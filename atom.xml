<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZombieBrand</title>
  
  <subtitle>前端</subtitle>
  <link href="/ZombieBrand.github.io/atom.xml" rel="self"/>
  
  <link href="https://zombrbrand.github.io/ZombieBrand.github.io/"/>
  <updated>2019-03-31T11:02:07.261Z</updated>
  <id>https://zombrbrand.github.io/ZombieBrand.github.io/</id>
  
  <author>
    <name>车勇志</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Grid布局</title>
    <link href="https://zombrbrand.github.io/ZombieBrand.github.io/2019/03/31/Grid%E5%B8%83%E5%B1%80/"/>
    <id>https://zombrbrand.github.io/ZombieBrand.github.io/2019/03/31/Grid布局/</id>
    <published>2019-03-31T10:53:53.000Z</published>
    <updated>2019-03-31T11:02:07.261Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html" target="_blank" rel="noopener">阮一峰博客转载</a></p></blockquote><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>网格布局（Grid）是最强大的 CSS 布局方案。</p><p>它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。以前，只能通过复杂的 CSS 框架达到的效果，现在浏览器内置了。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/1_bg2019032501.png" alt="img"></p><p>上图这样的布局，就是 Grid 布局的拿手好戏。</p><p>Grid 布局与 <a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">Flex 布局</a>有一定的相似性，都可以指定容器内部多个项目的位置。但是，它们也存在重大区别。</p><p>Flex 布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是<strong>一维布局</strong>。Grid 布局则是将容器划分成”行”和”列”，产生单元格，然后指定”项目所在”的单元格，可以看作是<strong>二维布局</strong>。Grid 布局远比 Flex 布局强大。</p><h2 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h2><p>学习 Grid 布局之前，需要了解一些基本概念。</p><h3 id="2-1-容器和项目"><a href="#2-1-容器和项目" class="headerlink" title="2.1 容器和项目"></a>2.1 容器和项目</h3><p>采用网格布局的区域，称为”容器”（container）。容器内部采用网格定位的子元素，称为”项目”（item）。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;div&gt;&lt;p&gt;1&lt;/p&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;&lt;p&gt;2&lt;/p&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;&lt;p&gt;3&lt;/p&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>上面代码中，最外层的<code>&lt;div&gt;</code>元素就是容器，内层的三个<code>&lt;div&gt;</code>元素就是项目。</p><p>注意：项目只能是容器的顶层子元素，不包含项目的子元素，比如上面代码的<code>&lt;p&gt;</code>元素就不是项目。Grid 布局只对项目生效。</p><h3 id="2-2-行和列"><a href="#2-2-行和列" class="headerlink" title="2.2 行和列"></a>2.2 行和列</h3><p>容器里面的水平区域称为”行”（row），垂直区域称为”列”（column）。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/1_bg2019032502.png" alt="img"></p><p>上图中，水平的深色区域就是”行”，垂直的深色区域就是”列”。</p><h3 id="2-3-单元格"><a href="#2-3-单元格" class="headerlink" title="2.3 单元格"></a>2.3 单元格</h3><p>行和列的交叉区域，称为”单元格”（cell）。</p><p>正常情况下，<code>n</code>行和<code>m</code>列会产生<code>n x m</code>个单元格。比如，3行3列会产生9个单元格。</p><h3 id="2-4-网格线"><a href="#2-4-网格线" class="headerlink" title="2.4 网格线"></a>2.4 网格线</h3><p>划分网格的线，称为”网格线”（grid line）。水平网格线划分出行，垂直网格线划分出列。</p><p>正常情况下，<code>n</code>行有<code>n + 1</code>根水平网格线，<code>m</code>列有<code>m + 1</code>根垂直网格线，比如三行就有四根水平网格线。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/1_bg2019032503.png" alt="img"></p><p>上图是一个 4 x 4 的网格，共有5根水平网格线和5根垂直网格线。</p><h2 id="三、容器属性"><a href="#三、容器属性" class="headerlink" title="三、容器属性"></a>三、容器属性</h2><p>Grid 布局的属性分成两类。一类定义在容器上面，称为容器属性；另一类定义在项目上面，称为项目属性。这部分先介绍容器属性。</p><h3 id="3-1-display-属性"><a href="#3-1-display-属性" class="headerlink" title="3.1 display 属性"></a>3.1 display 属性</h3><p><code>display: grid</code>指定一个容器采用网格布局。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032504.png" alt="img"></p><p>上图是<code>display: grid</code>的<a href="https://jsbin.com/guvivum/edit?html,css,output" target="_blank" rel="noopener">效果</a>。</p><p>默认情况下，容器元素都是块级元素，但也可以设成行内元素。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码指定<code>div</code>是一个行内元素，该元素内部采用网格布局。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032505.png" alt="img"></p><p>上图是<code>display: inline-grid</code>的<a href="https://jsbin.com/qatitav/edit?html,css,output" target="_blank" rel="noopener">效果</a>。</p><p> 注意，设为网格布局以后，容器的<code>float</code>、<code>display: inline-block</code>、<code>display: table-cell</code>、<code>vertical-align</code>和<code>column-*</code>等设置都将失效。</p><h3 id="3-2-grid-template-columns-属性，-grid-template-rows-属性"><a href="#3-2-grid-template-columns-属性，-grid-template-rows-属性" class="headerlink" title="3.2  grid-template-columns 属性， grid-template-rows 属性"></a>3.2  grid-template-columns 属性， grid-template-rows 属性</h3><p>容器指定了网格布局以后，接着就要划分行和列。<code>grid-template-columns</code>属性定义每一列的列宽，<code>grid-template-rows</code>属性定义每一行的行高。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://jsbin.com/qiginur/edit?css,output" target="_blank" rel="noopener">上面代码</a>指定了一个三行三列的网格，列宽和行高都是<code>100px</code>。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032506.png" alt="img"></p><p>除了使用绝对单位，也可以使用百分比。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">33.33%</span> <span class="number">33.33%</span> <span class="number">33.33%</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">33.33%</span> <span class="number">33.33%</span> <span class="number">33.33%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（1）repeat()</strong></p><p>有时候，重复写同样的值非常麻烦，尤其网格很多时。这时，可以使用<code>repeat()</code>函数，简化重复的值。上面的代码用<code>repeat()</code>改写如下。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(3, 33.33%);</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="built_in">repeat</span>(3, 33.33%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>repeat()</code>接受两个参数，第一个参数是重复的次数（上例是3），第二个参数是所要重复的值。</p><p><code>repeat()</code>重复某种模式也是可以的。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: <span class="selector-tag">repeat</span>(2, 100<span class="selector-tag">px</span> 20<span class="selector-tag">px</span> 80<span class="selector-tag">px</span>);</span><br></pre></td></tr></table></figure><p><a href="https://jsbin.com/cokohu/edit?css,output" target="_blank" rel="noopener">上面代码</a>定义了6列，第一列和第四列的宽度为<code>100px</code>，第二列和第五列为<code>20px</code>，第三列和第六列为<code>80px</code>。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032507.png" alt="img"></p><p><strong>（2）auto-fill 关键字</strong></p><p>有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用<code>auto-fill</code>关键字表示自动填充。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(auto-fill, 100px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://jsbin.com/himoku/edit?css,output" target="_blank" rel="noopener">上面代码</a>表示每列宽度<code>100px</code>，然后自动填充，直到容器不能放置更多的列。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032508.png" alt="img"></p><p><strong>（3）fr 关键字</strong></p><p>为了方便表示比例关系，网格布局提供了<code>fr</code>关键字（fraction 的缩写，意为”片段”）。如果两列的宽度分别为<code>1fr</code>和<code>2fr</code>，就表示后者是前者的两倍。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://jsbin.com/hadexek/edit?html,css,output" target="_blank" rel="noopener">上面代码</a>表示两个相同宽度的列。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/1_bg2019032509.png" alt="img"></p><p><code>fr</code>可以与绝对长度的单位结合使用，这时会非常方便。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">150px</span> <span class="number">1</span>fr <span class="number">2</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://jsbin.com/remowec/edit?html,css,output" target="_blank" rel="noopener">上面代码</a>表示，第一列的宽度为150像素，第二列的宽度是第三列的一半。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032510.png" alt="img"></p><p><strong>（4）minmax()</strong></p><p><code>minmax()</code>函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: 1<span class="selector-tag">fr</span> 1<span class="selector-tag">fr</span> <span class="selector-tag">minmax</span>(100<span class="selector-tag">px</span>, 1<span class="selector-tag">fr</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>minmax(100px, 1fr)</code>表示列宽不小于<code>100px</code>，不大于<code>1fr</code>。</p><p><strong>（5）auto 关键字</strong></p><p><code>auto</code>关键字表示由浏览器自己决定长度。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: 100<span class="selector-tag">px</span> <span class="selector-tag">auto</span> 100<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，第二列的宽度，基本上等于该列单元格的最大宽度，除非单元格内容设置了<code>min-width</code>，且这个值大于最大宽度。</p><p><strong>（6）网格线的名称</strong></p><p><code>grid-template-columns</code>属性和<code>grid-template-rows</code>属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: [c1] <span class="number">100px</span> [c2] <span class="number">100px</span> [c3] auto [c4];</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: [r1] <span class="number">100px</span> [r2] <span class="number">100px</span> [r3] auto [r4];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码指定网格布局为3行 x 3列，因此有4根垂直网格线和4根水平网格线。方括号里面依次是这八根线的名字。</p><p>网格布局允许同一根线有多个名字，比如<code>[fifth-line row-5]</code>。</p><p><strong>（7）布局实例</strong></p><p><code>grid-template-columns</code>属性对于网页布局非常有用。两栏式布局只需要一行代码。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">70%</span> <span class="number">30%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码将左边栏设为70%，右边栏设为30%。</p><p>传统的十二网格布局，写起来也很容易。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: <span class="selector-tag">repeat</span>(12, 1<span class="selector-tag">fr</span>);</span><br></pre></td></tr></table></figure><h3 id="3-3-grid-row-gap-属性，-grid-column-gap-属性，-grid-gap-属性"><a href="#3-3-grid-row-gap-属性，-grid-column-gap-属性，-grid-gap-属性" class="headerlink" title="3.3  grid-row-gap 属性， grid-column-gap 属性， grid-gap 属性"></a>3.3  grid-row-gap 属性， grid-column-gap 属性， grid-gap 属性</h3><p><code>grid-row-gap</code>属性设置行与行的间隔（行间距），<code>grid-column-gap</code>属性设置列与列的间隔（列间距）。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">grid-row-gap</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">grid-column-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://jsbin.com/mezufab/edit?css,output" target="_blank" rel="noopener">上面代码</a>中，<code>grid-row-gap</code>用于设置行间距，<code>grid-column-gap</code>用于设置列间距。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032511.png" alt="img"></p><p><code>grid-gap</code>属性是<code>grid-column-gap</code>和<code>grid-row-gap</code>的合并简写形式，语法如下。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-gap</span>: &lt;<span class="selector-tag">grid-row-gap</span>&gt; &lt;<span class="selector-tag">grid-column-gap</span>&gt;;</span><br></pre></td></tr></table></figure><p>因此，上面一段 CSS 代码等同于下面的代码。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">grid-gap</span>: <span class="number">20px</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>grid-gap</code>省略了第二个值，浏览器认为第二个值等于第一个值。</p><p> 根据最新标准，上面三个属性名的<code>grid-</code>前缀已经删除，<code>grid-column-gap</code>和<code>grid-row-gap</code>写成<code>column-gap</code>和<code>row-gap</code>，<code>grid-gap</code>写成<code>gap</code>。</p><h3 id="3-4-grid-template-areas-属性"><a href="#3-4-grid-template-areas-属性" class="headerlink" title="3.4 grid-template-areas 属性"></a>3.4 grid-template-areas 属性</h3><p>网格布局允许指定”区域”（area），一个区域由单个或多个单元格组成。<code>grid-template-areas</code>属性用于定义区域。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-template-areas</span>: <span class="string">'a b c'</span></span><br><span class="line">                       <span class="string">'d e f'</span></span><br><span class="line">                       <span class="string">'g h i'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码先划分出9个单元格，然后将其定名为<code>a</code>到<code>i</code>的九个区域，分别对应这九个单元格。</p><p>多个单元格合并成一个区域的写法如下。</p> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grid-template-areas: 'a a a'</span><br><span class="line">                     'b b b'</span><br><span class="line">                     'c c c';</span><br></pre></td></tr></table></figure><p>上面代码将9个单元格分成<code>a</code>、<code>b</code>、<code>c</code>三个区域。</p><p>下面是一个布局实例。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-areas</span>: "<span class="selector-tag">header</span> <span class="selector-tag">header</span> <span class="selector-tag">header</span>"</span><br><span class="line">                     "<span class="selector-tag">main</span> <span class="selector-tag">main</span> <span class="selector-tag">sidebar</span>"</span><br><span class="line">                     "<span class="selector-tag">footer</span> <span class="selector-tag">footer</span> <span class="selector-tag">footer</span>";</span><br></pre></td></tr></table></figure><p>上面代码中，顶部是页眉区域<code>header</code>，底部是页脚区域<code>footer</code>，中间部分则为<code>main</code>和<code>sidebar</code>。</p><p>如果某些区域不需要利用，则使用”点”（<code>.</code>）表示。</p> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grid-template-areas: 'a . c'</span><br><span class="line">                     'd . f'</span><br><span class="line">                     'g . i';</span><br></pre></td></tr></table></figure><p>上面代码中，中间一列为点，表示没有用到该单元格，或者该单元格不属于任何区域。</p><p> 注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为<code>区域名-start</code>，终止网格线自动命名为<code>区域名-end</code>。</p><p> 比如，区域名为<code>header</code>，则起始位置的水平网格线和垂直网格线叫做<code>header-start</code>，终止位置的水平网格线和垂直网格线叫做<code>header-end</code>。</p><h3 id="3-5-grid-auto-flow-属性"><a href="#3-5-grid-auto-flow-属性" class="headerlink" title="3.5 grid-auto-flow 属性"></a>3.5 grid-auto-flow 属性</h3><p>划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是”先行后列”，即先填满第一行，再开始放入第二行，即下图数字的顺序。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032506.png" alt="img"></p><p>这个顺序由<code>grid-auto-flow</code>属性决定，默认值是<code>row</code>，即”先行后列”。也可以将它设成<code>column</code>，变成”先列后行”。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-auto-flow</span>: <span class="selector-tag">column</span>;</span><br></pre></td></tr></table></figure><p><a href="https://jsbin.com/xutokec/edit?css,output" target="_blank" rel="noopener">上面代码</a>设置了<code>column</code>以后，放置顺序就变成了下图。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032512.png" alt="img"></p><p><code>grid-auto-flow</code>属性除了设置成<code>row</code>和<code>column</code>，还可以设成<code>row dense</code>和<code>column dense</code>。这两个值主要用于，某些项目指定位置以后，剩下的项目怎么自动放置。</p><p><a href="https://jsbin.com/wapejok/edit?css,output" target="_blank" rel="noopener">下面的例子</a>让1号项目和2号项目各占据两个单元格，然后在默认的<code>grid-auto-flow: row</code>情况下，会产生下面这样的布局。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032513.png" alt="img"></p><p>上图中，1号项目后面的位置是空的，这是因为3号项目默认跟着2号项目，所以会排在2号项目后面。</p><p>现在修改设置，设为<code>row dense</code>，表示”先行后列”，并且尽可能紧密填满，尽量不出现空格。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-auto-flow</span>: <span class="selector-tag">row</span> <span class="selector-tag">dense</span>;</span><br></pre></td></tr></table></figure><p><a href="https://jsbin.com/helewuy/edit?css,output" target="_blank" rel="noopener">上面代码</a>的效果如下。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032514.png" alt="img"></p><p>上图会先填满第一行，再填满第二行，所以3号项目就会紧跟在1号项目的后面。8号项目和9号项目就会排到第四行。</p><p>如果将设置改为<code>column dense</code>，表示”先列后行”，并且尽量填满空格。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-auto-flow</span>: <span class="selector-tag">column</span> <span class="selector-tag">dense</span>;</span><br></pre></td></tr></table></figure><p><a href="https://jsbin.com/pupoduc/1/edit?html,css,output" target="_blank" rel="noopener">上面代码</a>的效果如下。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032515.png" alt="img"></p><p>上图会先填满第一列，再填满第2列，所以3号项目在第一列，4号项目在第二列。8号项目和9号项目被挤到了第四列。</p><h3 id="3-6-justify-items-属性，-align-items-属性，-place-items-属性"><a href="#3-6-justify-items-属性，-align-items-属性，-place-items-属性" class="headerlink" title="3.6  justify-items 属性， align-items 属性， place-items 属性"></a>3.6  justify-items 属性， align-items 属性， place-items 属性</h3><p><code>justify-items</code>属性设置单元格内容的水平位置（左中右），<code>align-items</code>属性设置单元格内容的垂直位置（上中下）。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">justify-items</span>: start | end | center | stretch;</span><br><span class="line">  <span class="attribute">align-items</span>: start | end | center | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个属性的写法完全相同，都可以取下面这些值。</p><ul><li>start：对齐单元格的起始边缘。</li><li>end：对齐单元格的结束边缘。</li><li>center：单元格内部居中。</li><li><p>stretch：拉伸，占满单元格的整个宽度（默认值）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">justify-items</span>: start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><a href="https://jsbin.com/gijeqej/edit?css,output" target="_blank" rel="noopener">上面代码</a>表示，单元格的内容左对齐，效果如下图。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032516.png" alt="img"></p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">align-items</span>: start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://jsbin.com/tecawur/edit?css,output" target="_blank" rel="noopener">上面代码</a>表示，单元格的内容头部对齐，效果如下图。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032517.png" alt="img"></p><p><code>place-items</code>属性是<code>align-items</code>属性和<code>justify-items</code>属性的合并简写形式。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">place-items</span>: &lt;<span class="selector-tag">align-items</span>&gt; &lt;<span class="selector-tag">justify-items</span>&gt;;</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">place-items</span>: <span class="selector-tag">start</span> <span class="selector-tag">end</span>;</span><br></pre></td></tr></table></figure><p>如果省略第二个值，则浏览器认为与第一个值相等。</p><h3 id="3-7-justify-content-属性，-align-content-属性，-place-content-属性"><a href="#3-7-justify-content-属性，-align-content-属性，-place-content-属性" class="headerlink" title="3.7  justify-content 属性， align-content 属性， place-content 属性"></a>3.7  justify-content 属性， align-content 属性， place-content 属性</h3><p><code>justify-content</code>属性是整个内容区域在容器里面的水平位置（左中右），<code>align-content</code>属性是整个内容区域的垂直位置（上中下）。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">justify-content</span>: start | end | center | stretch | space-around | space-between | space-evenly;</span><br><span class="line">  <span class="attribute">align-content</span>: start | end | center | stretch | space-around | space-between | space-evenly;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个属性的写法完全相同，都可以取下面这些值。（下面的图都以<code>justify-content</code>属性为例，<code>align-content</code>属性的图完全一样，只是将水平方向改成垂直方向。）</p><ul><li>start - 对齐容器的起始边框。</li></ul><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032519.png" alt="img"></p><ul><li>end - 对齐容器的结束边框。</li></ul><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032518.png" alt="img"></p><ul><li>center - 容器内部居中。</li></ul><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032520.png" alt="img"></p><ul><li>stretch - 项目大小没有指定时，拉伸占据整个网格容器。</li></ul><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032521.png" alt="img"></p><ul><li>space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。</li></ul><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032522.png" alt="img"></p><ul><li>space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔。</li></ul><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032523.png" alt="img"></p><ul><li>space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。</li></ul><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032524.png" alt="img"></p><p><code>place-content</code>属性是<code>align-content</code>属性和<code>justify-content</code>属性的合并简写形式。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">place-content</span>: &lt;<span class="selector-tag">align-content</span>&gt; &lt;<span class="selector-tag">justify-content</span>&gt;</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">place-content</span>: <span class="selector-tag">space-around</span> <span class="selector-tag">space-evenly</span>;</span><br></pre></td></tr></table></figure><p>如果省略第二个值，浏览器就会假定第二个值等于第一个值。</p><h3 id="3-8-grid-auto-columns-属性，-grid-auto-rows-属性"><a href="#3-8-grid-auto-columns-属性，-grid-auto-rows-属性" class="headerlink" title="3.8  grid-auto-columns 属性， grid-auto-rows 属性"></a>3.8  grid-auto-columns 属性， grid-auto-rows 属性</h3><p>有时候，一些项目的指定位置，在现有网格的外部。比如网格只有3列，但是某一个项目指定在第5行。这时，浏览器会自动生成多余的网格，以便放置项目。</p><p><code>grid-auto-columns</code>属性和<code>grid-auto-rows</code>属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与<code>grid-template-columns</code>和<code>grid-template-rows</code>完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。</p><p><a href="https://jsbin.com/sayuric/edit?css,output" target="_blank" rel="noopener">下面的例子</a>里面，划分好的网格是3行 x 3列，但是，8号项目指定在第4行，9号项目指定在第5行。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-auto-rows</span>: <span class="number">50px</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码指定新增的行高统一为50px（原始的行高为100px）。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032525.png" alt="img"></p><h3 id="3-9-grid-template-属性，-grid-属性"><a href="#3-9-grid-template-属性，-grid-属性" class="headerlink" title="3.9  grid-template 属性， grid 属性"></a>3.9  grid-template 属性， grid 属性</h3><p><code>grid-template</code>属性是<code>grid-template-columns</code>、<code>grid-template-rows</code>和<code>grid-template-areas</code>这三个属性的合并简写形式。</p><p><code>grid</code>属性是<code>grid-template-rows</code>、<code>grid-template-columns</code>、<code>grid-template-areas</code>、 <code>grid-auto-rows</code>、<code>grid-auto-columns</code>、<code>grid-auto-flow</code>这六个属性的合并简写形式。</p><p>从易读易写的角度考虑，还是建议不要合并属性，所以这里就不详细介绍这两个属性了。</p><h2 id="四、项目属性"><a href="#四、项目属性" class="headerlink" title="四、项目属性"></a>四、项目属性</h2><p>下面这些属性定义在项目上面。</p><h3 id="4-1-grid-column-start-属性，-grid-column-end-属性，-grid-row-start-属性，-grid-row-end-属性"><a href="#4-1-grid-column-start-属性，-grid-column-end-属性，-grid-row-start-属性，-grid-row-end-属性" class="headerlink" title="4.1  grid-column-start 属性， grid-column-end 属性， grid-row-start 属性， grid-row-end 属性"></a>4.1  grid-column-start 属性， grid-column-end 属性， grid-row-start 属性， grid-row-end 属性</h3><p>项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。</p><ul><li><code>grid-column-start</code>属性：左边框所在的垂直网格线</li><li><code>grid-column-end</code>属性：右边框所在的垂直网格线</li><li><code>grid-row-start</code>属性：上边框所在的水平网格线</li><li><p><code>grid-row-end</code>属性：下边框所在的水平网格线</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column-start</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">grid-column-end</span>: <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><a href="https://jsbin.com/yukobuf/edit?css,output" target="_blank" rel="noopener">上面代码</a>指定，1号项目的左边框是第二根垂直网格线，右边框是第四根垂直网格线。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032526.png" alt="img"></p><p>上图中，只指定了1号项目的左右边框，没有指定上下边框，所以会采用默认位置，即上边框是第一根水平网格线，下边框是第二根水平网格线。</p><p>除了1号项目以外，其他项目都没有指定位置，由浏览器自动布局，这时它们的位置由容器的<code>grid-auto-flow</code>属性决定，这个属性的默认值是<code>row</code>，因此会”先行后列”进行排列。读者可以把这个属性的值分别改成<code>column</code>、<code>row dense</code>和<code>column dense</code>，看看其他项目的位置发生了怎样的变化。</p><p><a href="https://jsbin.com/nagobey/edit?html,css,output" target="_blank" rel="noopener">下面的例子</a>是指定四个边框位置的效果。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column-start</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">grid-column-end</span>: <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">grid-row-start</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">grid-row-end</span>: <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032527.png" alt="img"></p><p>这四个属性的值，除了指定为第几个网格线，还可以指定为网格线的名字。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column-start</span>: header-start;</span><br><span class="line">  <span class="attribute">grid-column-end</span>: header-end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，左边框和右边框的位置，都指定为网格线的名字。</p><p>这四个属性的值还可以使用<code>span</code>关键字，表示”跨越”，即左右边框（上下边框）之间跨越多少个网格。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column-start</span>: span <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://jsbin.com/hehumay/edit?html,css,output" target="_blank" rel="noopener">上面代码</a>表示，1号项目的左边框距离右边框跨越2个网格。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032528.png" alt="img"></p><p>这与<a href="https://jsbin.com/mujihib/edit?html,css,output" target="_blank" rel="noopener">下面的代码</a>效果完全一样。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column-end</span>: span <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这四个属性，如果产生了项目的重叠，则使用<code>z-index</code>属性指定项目的重叠顺序。</p><h3 id="4-2-grid-column-属性，-grid-row-属性"><a href="#4-2-grid-column-属性，-grid-row-属性" class="headerlink" title="4.2  grid-column 属性， grid-row 属性"></a>4.2  grid-column 属性， grid-row 属性</h3><p><code>grid-column</code>属性是<code>grid-column-start</code>和<code>grid-column-end</code>的合并简写形式，<code>grid-row</code>属性是<code>grid-row-start</code>属性和<code>grid-row-end</code>的合并简写形式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>:  / ;</span><br><span class="line">  <span class="attribute">grid-row</span>:  / ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">1</span> / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 等同于 */</span></span><br><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column-start</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">grid-column-end</span>: <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">grid-row-start</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">grid-row-end</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，项目<code>item-1</code>占据第一行，从第一根列线到第三根列线。</p><p>这两个属性之中，也可以使用<code>span</code>关键字，表示跨越多少个网格。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#b03532</span>;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 等同于 */</span></span><br><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#b03532</span>;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">1</span> / span <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">1</span> / span <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://jsbin.com/volugow/edit?html,css,output" target="_blank" rel="noopener">上面代码</a>中，项目<code>item-1</code>占据的区域，包括第一行 + 第二行、第一列 + 第二列。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032529.png" alt="img"></p><p>斜杠以及后面的部分可以省略，默认跨越一个网格。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，项目<code>item-1</code>占据左上角第一个网格。</p><h3 id="4-3-grid-area-属性"><a href="#4-3-grid-area-属性" class="headerlink" title="4.3 grid-area 属性"></a>4.3 grid-area 属性</h3><p><code>grid-area</code>属性指定项目放在哪一个区域。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://jsbin.com/qokexob/edit?css,output" target="_blank" rel="noopener">上面代码</a>中，1号项目位于<code>e</code>区域，效果如下图。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032530.png" alt="img"></p><p><code>grid-area</code>属性还可用作<code>grid-row-start</code>、<code>grid-column-start</code>、<code>grid-row-end</code>、<code>grid-column-end</code>的合并简写形式，直接指定项目的位置。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个<a href="https://jsbin.com/duyafez/edit?css,output" target="_blank" rel="noopener">例子</a>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: <span class="number">1</span> / <span class="number">1</span> / <span class="number">3</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-justify-self-属性，-align-self-属性，-place-self-属性"><a href="#4-4-justify-self-属性，-align-self-属性，-place-self-属性" class="headerlink" title="4.4  justify-self 属性， align-self 属性， place-self 属性"></a>4.4  justify-self 属性， align-self 属性， place-self 属性</h3><p><code>justify-self</code>属性设置单元格内容的水平位置（左中右），跟<code>justify-items</code>属性的用法完全一致，但只作用于单个项目。</p><p><code>align-self</code>属性设置单元格内容的垂直位置（上中下），跟<code>align-items</code>属性的用法完全一致，也是只作用于单个项目。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">justify-self</span>: start | end | center | stretch;</span><br><span class="line">  <span class="attribute">align-self</span>: start | end | center | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个属性都可以取下面四个值。</p><ul><li>start：对齐单元格的起始边缘。</li><li>end：对齐单元格的结束边缘。</li><li>center：单元格内部居中。</li><li>stretch：拉伸，占满单元格的整个宽度（默认值）。</li></ul><p>下面是<code>justify-self: start</code>的例子。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span>  &#123;</span><br><span class="line">  <span class="attribute">justify-self</span>: start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032532.png" alt="img"></p><p><code>place-self</code>属性是<code>align-self</code>属性和<code>justify-self</code>属性的合并简写形式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">place-self</span>: &lt;<span class="selector-tag">align-self</span>&gt; &lt;<span class="selector-tag">justify-self</span>&gt;;</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">place-self</span>: <span class="selector-tag">center</span> <span class="selector-tag">center</span>;</span><br></pre></td></tr></table></figure><p>如果省略第二个值，<code>place-self</code>属性会认为这两个值相等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阮一峰博客转载&lt;/a&gt;&lt;/p&gt;
&lt;/
      
    
    </summary>
    
      <category term="CSS" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/tags/CSS/"/>
    
      <category term="Grid" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/tags/Grid/"/>
    
  </entry>
  
  <entry>
    <title>http控制缓存</title>
    <link href="https://zombrbrand.github.io/ZombieBrand.github.io/2019/03/18/http%E6%8E%A7%E5%88%B6%E7%BC%93%E5%AD%98/"/>
    <id>https://zombrbrand.github.io/ZombieBrand.github.io/2019/03/18/http控制缓存/</id>
    <published>2019-03-18T03:42:21.000Z</published>
    <updated>2019-03-18T03:42:53.030Z</updated>
    
    <content type="html"><![CDATA[<h3 id="静态服务器（无缓存无更新请求数据）"><a href="#静态服务器（无缓存无更新请求数据）" class="headerlink" title="静态服务器（无缓存无更新请求数据）"></a>静态服务器（无缓存无更新请求数据）</h3><ul><li>优点：简单。</li><li>缺点：每次请求必须查找返回原始文件，浪费带宽。</li></ul><h3 id="有缓存-无更新请求数据"><a href="#有缓存-无更新请求数据" class="headerlink" title="有缓存-无更新请求数据"></a>有缓存-无更新请求数据</h3><ul><li>优点：节省资源，速度快。</li><li>缺点：服务器缓存中的数据变了，浏览器不知道数据是否发生改变。</li></ul><h3 id="缓存作用："><a href="#缓存作用：" class="headerlink" title="缓存作用："></a>缓存作用：</h3><p>缓存是指代理服务器或客户端本地磁盘内保存的资源副本，利用缓存可减少对源服务器的访问，可以节省通信流量和通信时间。</p><h3 id="有缓存有更新请求数据"><a href="#有缓存有更新请求数据" class="headerlink" title="有缓存有更新请求数据"></a>有缓存有更新请求数据</h3><ul><li>主要原理：请求被响应的时候，响应报文中有一个Expires ：Mon,10 Dec 1990 02:25:22GMT（过期时间），再一次进行请求的时候，用本地的时间与过期时间进行比较，如果本地时间小于过期时间，那么从缓存中获取，如果本地时间大于过期时间，重新向服务器发送请求获取，再一次发送新的过期时间。</li><li>优点：缓存可控制。</li><li>缺点：控制的功能太单一，这种格式的时间和容易写错。</li></ul><h3 id="有缓存-更新机制升级版"><a href="#有缓存-更新机制升级版" class="headerlink" title="有缓存+更新机制升级版"></a>有缓存+更新机制升级版</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age=300；</span><br></pre></td></tr></table></figure><p>以上代码代表时间间隔，如果再一次的请求在时间间隔300s之内，就在缓存中获取，否则从服务器获取。</p><ul><li>Cache-Control还有其他值： <ul><li><code>Public</code>表示响应可被任何中间节点缓存，如 Browser &lt;– proxy1 &lt;– proxy2 &lt;– Server，中间的proxy可以缓存资源，比如下次再请求同一资源proxy1直接把自己缓存的东西给 Browser 而不再向proxy2要。</li><li><code>Private</code>表示中间节点不允许缓存，对于Browser &lt;– proxy1 &lt;– proxy2 &lt;– Server，proxy 会老老实实把Server 返回的数据发送给proxy1,自己不缓存任何数据。当下次Browser再次请求时proxy会做好请求转发而不是自作主张给自己缓存的数据。</li><li><code>no-cache</code>表示不使用 Cache-Control的缓存控制方式做前置验证，而是使用 Etag 或者Last-Modified字段来控制缓存。不走缓存，响应报文，是服务器发给浏览器的。浏览器在一次发送请求时，发现这个字段，就不会再缓存中获取数据了，而是再一次向服务器发送请求。 缓存只是本地缓存，而不是服务器对应的缓存。报文会缓存，但是不会使用。</li><li><code>no-store</code> ，真正的不缓存任何东西。浏览器会直接向服务器请求原始文件，并且请求中不附带 Etag 参数(服务器认为是新请求)。不存，所有的流程都不进行缓存。连报文都不会进行缓存，啥都不缓存。</li><li><code>max-age</code>，表示当前资源的有效时间，单位为秒。</li></ul></li><li>优点： 缓存控制功能更强大</li><li>缺点： 不够完美，超过时间间隔再向服务器要文件的时候，服务器会再一次发送源文件，但如果文件未被改变，发送源文件太浪费带宽了，只要发送一个文件未被更改的短信息标示就好了。</li></ul><h3 id="缓存-更新终极版"><a href="#缓存-更新终极版" class="headerlink" title="缓存+更新终极版"></a>缓存+更新终极版</h3><p>服务器返回的文件以及额外信息，其中Etag 是 对请求文件的编码，如果请求文件在服务端未被修改，这个值就不会变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age=300；</span><br><span class="line">ETag:W/&quot;e-cbxLFQW5zapn79tQwb/g6Q&quot;</span><br></pre></td></tr></table></figure><p>当超过时间间隔的时候，重新发请求获取源文件的时候，在发送请求的时候附带刚刚保存的文件的ETag ( If-None-Match：W/“e-cbxLFQW5zapn79tQwb/g6Q”），之后于ETag进行比较，如果二者相等，则发送个短消息（响应头，不包含图片内容, 304），如果二者不等则发送新文件和新的 ETag，浏览器获取新文件并更新该文件的 Etag。（浏览器的默认行为。）</p><p>与 ETag 类似功能的是Last-Modified/If-Modified-Since。当资源过期时（max-age超时），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头 If-Modified-Since，表示上次服务器告知的文件修改的时间。web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（200）；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 ，告知浏览器继续使用所保存的cache。第一次去请求，响应头中存在Last-modified,刷新后第二次请求，请求头中有if-modified-since。</p><h3 id="html不会缓存-css和图片都会"><a href="#html不会缓存-css和图片都会" class="headerlink" title=".html不会缓存,.css和图片都会"></a>.html不会缓存,.css和图片都会</h3><p>原因：图片和CSS的请求都是HTML到达浏览器后，浏览器解析发出的，而HTML是直接输入URL解析出来的。报文也存在差异：</p><p><img src="https:////upload-images.jianshu.io/upload_images/5628037-f2997c3aa3cab988.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/603/format/webp" alt="img"></p><p>htmlq请求报文.PNG</p><p><img src="https:////upload-images.jianshu.io/upload_images/5628037-510b4da0bfeb8353.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/583/format/webp" alt="img"></p><p>css报文.PNG</p><ul><li>当浏览器检测到状态码是304的时候，就会在本地的缓存中拿数据，做一个展示。调试的时候以为是服务器发过来的，实际上并不是。</li><li>勾选开发者工具控制台Disable cache原理：浏览器自动在请求报文上添加：pragma:no-cache。</li></ul><h3 id="lastModified和cache-control"><a href="#lastModified和cache-control" class="headerlink" title="lastModified和cache-control"></a>lastModified和cache-control</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br><span class="line">LastModified：sXXX</span><br></pre></td></tr></table></figure><p>可以进行缓存，但是下一次请求之前，不可以直接在缓存中拿数据，要先问服务器是否可以在本地缓存中中拿，如果服务器返回304状态码，则表示可以在本地缓存中拿数据，否则，服务器返回数据。</p><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><ol><li><p>在互联网上，域名通过DNS服务映射到IP地址之后访问目标网站，也就是说，当请求到达服务器时，已经是已IP地址形式访问了。</p></li><li><p>代理：是一种具有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。代理不会改变请求URI。每次通过代理服务器转发请求或者响应的时候，会追加写入Via首部信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET/HTTP/1.1 Via:proxy1</span><br></pre></td></tr></table></figure><p>。 </p><ul><li>缓存代理（利用缓存技术）；</li><li>透明代理，不对报文做任何加工的代理叫透明代理。</li></ul></li><li><p>网关：是转发其他服务器通信数据的服务器，接收从客户端发来的请求时，它就像自己拥有资源的服务器一样，对请求进行处理。利用网关可以由HTTP请求转化为其他协议通信。</p></li><li><p>隧道：是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。隧道的目的是确保客户端能与服务器进行安全的通信，本身 不会去解析HTTP请求，请求保持原样中转给之后的服务器。隧道会在通信双方断开连接时结束。</p></li><li><p>需要兼容HTTP1.0的时候需要使用Expires，不然可以考虑直接使用Cache-Control</p></li><li><p>需要处理一秒内多次修改的情况，或者其他Last-Modified处理不了的情况，才使用ETag，否则使用Last-Modified。</p></li><li><p>对于所有可缓存资源，需要指定一个Expires或Cache-Control，同时指定Last-Modified或者Etag。</p></li><li><p>可以通过标识文件版本名、加长缓存时间的方式来减少304响应。</p></li></ol><p>作者：L_筱_Q</p><p>链接：<a href="https://www.jianshu.com/p/8f7e1d4fc3ba" target="_blank" rel="noopener">https://www.jianshu.com/p/8f7e1d4fc3ba</a></p><p>来源：简书</p><p>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;静态服务器（无缓存无更新请求数据）&quot;&gt;&lt;a href=&quot;#静态服务器（无缓存无更新请求数据）&quot; class=&quot;headerlink&quot; title=&quot;静态服务器（无缓存无更新请求数据）&quot;&gt;&lt;/a&gt;静态服务器（无缓存无更新请求数据）&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;优点：简
      
    
    </summary>
    
      <category term="HTTP" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/tags/HTTP/"/>
    
      <category term="缓存" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>flex布局</title>
    <link href="https://zombrbrand.github.io/ZombieBrand.github.io/2019/03/17/flex%E5%B8%83%E5%B1%80/"/>
    <id>https://zombrbrand.github.io/ZombieBrand.github.io/2019/03/17/flex布局/</id>
    <published>2019-03-17T10:29:21.733Z</published>
    <updated>2019-03-14T12:02:45.289Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见布局"><a href="#常见布局" class="headerlink" title="常见布局"></a>常见布局</h2><ul><li>normal flow（正常流）</li><li>float + clear（浮动+清楚浮动）</li><li>position relative + absolute （相对定位+绝对定位）</li><li>display inline-block （改变元素属性）</li><li>-margin（负外边距）</li></ul><h2 id="Flex布局特性"><a href="#Flex布局特性" class="headerlink" title="Flex布局特性"></a>Flex布局特性</h2><ol><li><p>块级布局侧重垂直方向、行内布局侧重水平方向，flex布局是<strong>与方向无关的</strong></p></li><li><p>flex布局可以实现<strong>空间自动分配</strong>、<strong>自动对齐</strong>（全称:the flexible box Module）</p></li><li><p>flex适用于<strong>简单的线性布局</strong>，更复杂的布局要交给grid布局（目前还没发布）</p><p>​    </p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><blockquote><p>display: flex;</p><p>display: inline-flex;</p><p>设为Flex布局后，子元素的<code>loat,clear</code>和<code>vertical-align</code>属性将失效。</p></blockquote></li></ol><h2 id="Flex基础概念"><a href="#Flex基础概念" class="headerlink" title="Flex基础概念"></a>Flex基础概念</h2><p><strong>采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。</strong></p><p><a href="https://camo.githubusercontent.com/c204f0894898f5a8feee7ec098a16fc94532a5fa/68747470733a2f2f6f6f6f2e306f302e6f6f6f2f323031372f30352f30392f353931313763336464623763662e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/c204f0894898f5a8feee7ec098a16fc94532a5fa/68747470733a2f2f6f6f6f2e306f302e6f6f6f2f323031372f30352f30392f353931313763336464623763662e706e67" alt="flex基础分解图"></a></p><ul><li><p>上图水平是主轴(main axis)垂直是侧轴(cross axis)。主轴的开始位置叫做<code>main start</code>，结束位置叫做<code>main end</code>；侧轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code> 。</p></li><li><p>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的侧轴空间叫做<code>cross size</code>。</p></li></ul><h2 id="Flex-container容器属性"><a href="#Flex-container容器属性" class="headerlink" title="Flex container容器属性"></a>Flex container容器属性</h2><h3 id="flex-direction-决定了主轴的方向（即项目的排列方向"><a href="#flex-direction-决定了主轴的方向（即项目的排列方向" class="headerlink" title="flex-direction: 决定了主轴的方向（即项目的排列方向)"></a>flex-direction: 决定了主轴的方向（即项目的排列方向)</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">     <span class="attribute">display</span>:flex;</span><br><span class="line">     <span class="attribute">flex-direction</span>:column-revers|column|row-reverse|row;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>row(默认)</td><td>主轴方向为水平，起点在左端</td></tr><tr><td>row- reverse</td><td>主轴方向为水平，起点在右端</td></tr><tr><td>column</td><td>主轴方向为垂直，起点在上端</td></tr><tr><td>column-reverse</td><td>主轴方向为垂直，起点在下端</td></tr></tbody></table><p>  <a href="https://camo.githubusercontent.com/bb8b00a8353d931a32a422edc2f8b525cc510f1a/687474703a2f2f7777772e7275616e796966656e672e636f6d2f626c6f67696d672f61737365742f323031352f6267323031353037313030352e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/bb8b00a8353d931a32a422edc2f8b525cc510f1a/687474703a2f2f7777772e7275616e796966656e672e636f6d2f626c6f67696d672f61737365742f323031352f6267323031353037313030352e706e67" alt="flex-direction排序图"></a></p><blockquote><p>单独添加flex-direction: row; //默认是不会换行</p></blockquote><hr><h3 id="flex-wrap-定义如果一条轴线排不下，如何换行"><a href="#flex-wrap-定义如果一条轴线排不下，如何换行" class="headerlink" title="flex-wrap: 定义如果一条轴线排不下，如何换行"></a>flex-wrap: 定义如果一条轴线排不下，如何换行</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">     <span class="attribute">display</span>:flex;</span><br><span class="line">     <span class="attribute">flex-direction</span>:now  </span><br><span class="line">     flex-wrap:wrap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>nowrap(默认)</td><td>不换行</td></tr><tr><td>wrap</td><td>换行</td></tr><tr><td>wrap-reverse</td><td>换行反转</td></tr></tbody></table><p>  <a href="https://camo.githubusercontent.com/ef9b8559067337e190b156db8ff369f199e7e477/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f353535363032362d353461626161306361653634323863652e6a70673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/ef9b8559067337e190b156db8ff369f199e7e477/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f353535363032362d353461626161306361653634323863652e6a70673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="img"></a></p><hr><h3 id="flex-flow（以上两个属性的简写）"><a href="#flex-flow（以上两个属性的简写）" class="headerlink" title="flex-flow（以上两个属性的简写）"></a>flex-flow（以上两个属性的简写）</h3><p>  <code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:flex;</span><br><span class="line">    <span class="attribute">flex-flow</span>: row nowrap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="justify-content-定义了项目在主轴上的对齐方式"><a href="#justify-content-定义了项目在主轴上的对齐方式" class="headerlink" title="justify-content:定义了项目在主轴上的对齐方式"></a>justify-content:定义了项目在主轴上的对齐方式</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:flex;</span><br><span class="line">    <span class="attribute">justify-content</span>:flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>flex-start(默认)</td><td>项目沿着主轴方向的起始位置靠齐</td></tr><tr><td>flex-end</td><td>项目沿着主轴方向的结束位置靠齐，和flex-start相反</td></tr><tr><td>space-between</td><td>项目在主轴方向上两端对齐，其中的间隔相等</td></tr><tr><td>space-around</td><td>每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍</td></tr></tbody></table><p>  <a href="https://camo.githubusercontent.com/8f5eaddc35a3f320262ee598998c8d038946d04c/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f353535363032362d636664303366343763313632663434382e6a70673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/8f5eaddc35a3f320262ee598998c8d038946d04c/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f353535363032362d636664303366343763313632663434382e6a70673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="img"></a></p><hr><h3 id="align-items定义项目在交叉轴上如何对齐"><a href="#align-items定义项目在交叉轴上如何对齐" class="headerlink" title="align-items定义项目在交叉轴上如何对齐"></a>align-items定义项目在交叉轴上如何对齐</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:flex;</span><br><span class="line">    <span class="attribute">align-items</span>:flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>flex-start</td><td>项目沿着侧轴上的起点对齐</td></tr><tr><td>flex-end</td><td>项目沿着侧轴上的终点对齐</td></tr><tr><td>center</td><td>项目在侧轴方向上居中对齐</td></tr><tr><td>stretch(默认)</td><td>如果项目未设置高度或高度为auto,将占满整个容器的高度。</td></tr></tbody></table><p><a href="https://camo.githubusercontent.com/e4492baad276d7c4ad526348c72addbbe0b7ff86/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f353535363032362d363362306666326638653362616136622e6a70673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/e4492baad276d7c4ad526348c72addbbe0b7ff86/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f353535363032362d363362306666326638653362616136622e6a70673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="img"></a></p><hr><h3 id="align-content多行多列内容对齐方式"><a href="#align-content多行多列内容对齐方式" class="headerlink" title="align-content多行多列内容对齐方式"></a>align-content多行多列内容对齐方式</h3><p><em>注意如果项目只有一行，属性不起作用</em></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:flex;</span><br><span class="line">    <span class="attribute">align-content</span>:flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>flex-start</td><td>项目与侧轴的起点对齐</td></tr><tr><td>flex-end</td><td>项目与侧轴的终点对齐</td></tr><tr><td>center</td><td>项目与侧轴的中点对齐</td></tr><tr><td>space-between</td><td>与侧轴两端对齐，轴线之间的间隔平均分布</td></tr><tr><td>space-around</td><td>每行轴线两侧的间隔都相等。所以轴线之间的间隔比轴线与边框的间隔大一倍</td></tr><tr><td>stretch（默认）</td><td>轴线占满整个测轴</td></tr></tbody></table><p><a href="https://camo.githubusercontent.com/d5d550de5ba40286e0d1d2a63dd709fdf4605e13/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f353535363032362d356562633339343136396339356566302e6a70673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/d5d550de5ba40286e0d1d2a63dd709fdf4605e13/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f353535363032362d356562633339343136396339356566302e6a70673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="img"></a></p><hr><h2 id="flex-item项目属性"><a href="#flex-item项目属性" class="headerlink" title="flex item项目属性"></a>flex item项目属性</h2><ul><li><h3 id="order属性：定义项目的排列顺序。数值越小，排列越靠前，默认为0"><a href="#order属性：定义项目的排列顺序。数值越小，排列越靠前，默认为0" class="headerlink" title="order属性：定义项目的排列顺序。数值越小，排列越靠前，默认为0"></a>order属性：定义项目的排列顺序。数值越小，排列越靠前，默认为0</h3></li></ul><p><code>.item{order: &lt;integer&gt;;}</code></p><ul><li><h3 id="flex-grow属性-定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大"><a href="#flex-grow属性-定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大" class="headerlink" title="flex-grow属性:定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大"></a>flex-grow属性:定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大</h3></li></ul><p><code>.item{flex-grow:&lt;number&gt;;}</code></p><p>flex-grow为零的话则不变化，不能为負值。如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项的2倍。</p><ul><li><h3 id="flex-shrink属性：定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小"><a href="#flex-shrink属性：定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小" class="headerlink" title="flex-shrink属性：定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小"></a>flex-shrink属性：定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小</h3></li></ul><p><code>.item{flex-shrink:&lt;number&gt;;}</code></p><p>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。</p><ul><li><h3 id="flex-basis属性-定义了在分配多余空间之前，项目占据的主轴空间（main-size）"><a href="#flex-basis属性-定义了在分配多余空间之前，项目占据的主轴空间（main-size）" class="headerlink" title="flex-basis属性:定义了在分配多余空间之前，项目占据的主轴空间（main size）"></a>flex-basis属性:定义了在分配多余空间之前，项目占据的主轴空间（main size）</h3></li></ul><p>浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。它可以设为跟width或height属性一样的值，则项目将占据固定空间</p><p><code>.item{flex-basis: &lt;length&gt;| auto;</code></p><ul><li><h3 id="flex属性：flex-grow-flex-shrink和flex-basis的简写"><a href="#flex属性：flex-grow-flex-shrink和flex-basis的简写" class="headerlink" title="flex属性：flex-grow,flex-shrink和flex-basis的简写"></a>flex属性：flex-grow,flex-shrink和flex-basis的简写</h3></li></ul><p>默认值为0 1 auto。后两个属性可选。该属性有两个<code>快捷值：auto(</code>1 1 <em>auto) 和 none</em> (0 0 auto)。</p><ul><li><h3 id="align-self属性：允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性"><a href="#align-self属性：允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性" class="headerlink" title="align-self属性：允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性"></a>align-self属性：允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性</h3></li></ul><p>默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p><p><code>.item{align-self:auto | flex-start | flex-end | center | baseline | stretch;}</code></p><p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p><blockquote><p><a href="https://www.w3cplus.com/css3/understanding-flexbox-everything-you-need-to-know.html" target="_blank" rel="noopener">最近发现一篇很详细关于flex box 布局的博客链接</a><br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="noopener">阮一峰flex实战布局教程</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常见布局&quot;&gt;&lt;a href=&quot;#常见布局&quot; class=&quot;headerlink&quot; title=&quot;常见布局&quot;&gt;&lt;/a&gt;常见布局&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;normal flow（正常流）&lt;/li&gt;
&lt;li&gt;float + clear（浮动+清楚浮动）&lt;/li&gt;
&lt;l
      
    
    </summary>
    
      <category term="CSS" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/tags/CSS/"/>
    
      <category term="布局" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/tags/%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>前端缓存</title>
    <link href="https://zombrbrand.github.io/ZombieBrand.github.io/2019/03/17/%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98/"/>
    <id>https://zombrbrand.github.io/ZombieBrand.github.io/2019/03/17/前端缓存/</id>
    <published>2019-03-17T08:36:48.000Z</published>
    <updated>2019-03-17T08:38:06.907Z</updated>
    
    <content type="html"><![CDATA[<h1 id="localStorage-还能这么用"><a href="#localStorage-还能这么用" class="headerlink" title="localStorage 还能这么用"></a>localStorage 还能这么用</h1><p><img src="http://self-storage.b0.upaiyun.com/2017/10/09/150756387698667375.png" alt="img"></p><p>HTML5中 Web Storage 的出现，主要是为了弥补使用 Cookie 作为本地存储的不足。Cookie 存储的数据量非常小，而且数据会自动携带到请求头里，但服务器端可能并不关心这些数据，所以会造成带宽的浪费。</p><p>Web Storage 提供了两个存储对象：localStorage 和 sessionStorage。</p><p>sessionStorage 存储的数据仅在本次会话有用，会话结束后会自动失效，而且数据仅在当前窗口有效，同一源下新窗口也访问不到其他窗口基于<br>sessionStorage 存储的数据。也是由于这些特性，导致 sessionStorage 的使用场景会比较少。</p><p>localStorage 可以永久存储，而且同源下数据多窗口也能共享，。看起来很美好，但 localStorage 也有短板，绝大多数浏览器有 5M 的大小限制。但是这不足以成为大家使用 localStorage 的障碍，要知道 Cookie 只有 4K 的大小，多了一千多倍，偷着乐吧。</p><h2 id="localStorage-的基本使用"><a href="#localStorage-的基本使用" class="headerlink" title="localStorage 的基本使用"></a>localStorage 的基本使用</h2><p>讲这个内容的文章网上太多了，现在再来讲有点老套了。这里就不做更多介绍了，不清楚的读者可以看<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API" target="_blank" rel="noopener">这里</a>。</p><p>有两点需要注意一下。在 <code>setItem</code> 时，可能会达到大小限制，最好加上错误捕捉 <a href="https://iammapping.com/the-other-ways-to-use-localstorage/#ref-error" target="_blank" rel="noopener">1</a>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  localStorage.setItem(key, value);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="keyword">if</span> (isQuotaExceeded(e)) &#123;</span><br><span class="line">    <span class="comment">// Storage full, maybe notify user or do some clean-up</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isQuotaExceeded</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> quotaExceeded = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.code) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (e.code) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">22</span>:</span><br><span class="line">          quotaExceeded = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1014</span>:</span><br><span class="line">          <span class="comment">// Firefox</span></span><br><span class="line">          <span class="keyword">if</span> (e.name === <span class="string">'NS_ERROR_DOM_QUOTA_REACHED'</span>) &#123;</span><br><span class="line">            quotaExceeded = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.number === <span class="number">-2147024882</span>) &#123;</span><br><span class="line">      <span class="comment">// Internet Explorer 8</span></span><br><span class="line">      quotaExceeded = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> quotaExceeded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外在存储容量快满时，会造成 <code>getItem</code> 性能急剧下降 <a href="https://iammapping.com/the-other-ways-to-use-localstorage/#ref-performance" target="_blank" rel="noopener">2</a>。</p><p>我们下面看看 localStorage 有哪些脑洞大开的用法。</p><h2 id="缓存静态文件"><a href="#缓存静态文件" class="headerlink" title="缓存静态文件"></a>缓存静态文件</h2><p>你不禁要问，HTTP 协议不是本来就支持缓存文件吗（之前写过一篇文章<a href="https://iammapping.com/the-http-guide-of-web-cache/" target="_blank" rel="noopener">《Web缓存之HTTP指南》</a>），为什么还要使用 localStorage 来缓存？为了可编程化，通俗一点说就是把命运握在自己手中。</p><p>HTTP 协议的缓存，可以由用户浏览器清除或禁用缓存，也可以由 Web 服务器设置过期时间或不缓存。对于前端工程师，这更像是一个黑盒，想要决定文件是访问缓存还是访问远程显得有些力不从心了。</p><p>使用 localStorage 控制文件缓存的方式有两种：</p><ol><li>使用 Loader 加载静态文件</li><li>借助服务器端将静态文件 inline 化</li></ol><p>这两种方式一般都会提前做好缓存过期策略，通常是使用版本号来控制，下面还会细讲。否则文件新版上线，用户客户端还是旧版，这就麻烦大了，而且这类问题，还不好调试不好重现。</p><h3 id="使用-Loader-加载静态文件"><a href="#使用-Loader-加载静态文件" class="headerlink" title="使用 Loader 加载静态文件"></a>使用 Loader 加载静态文件</h3><p>由于请求都是动态发出的，所以可以对请求拦截处理。大致流程如下：</p><ol><li>查看请求的文件 url 是否有缓存到 localStorage</li><li>如果没有，到第 2 大步</li><li>如果有，判断文件是否过期或版本号是否匹配<ol><li>过期或不匹配，到第 2 大步</li><li>文件内容有效，到第 4 大步</li></ol></li><li>请求远程文件</li><li>缓存最新文件内容</li><li>执行文件内容</li></ol><p>这个方式有个开源库：<a href="https://github.com/addyosmani/basket.js" target="_blank" rel="noopener">basket.js</a>。</p><h3 id="借助服务器端将静态文件-inline-化"><a href="#借助服务器端将静态文件-inline-化" class="headerlink" title="借助服务器端将静态文件 inline 化"></a>借助服务器端将静态文件 inline 化</h3><p>这个方式比上面那种更进一步，在第一次响应时把需要放入 localStorage 的文件都内联进 html 中，后面每次响应只要文件版本没有变化，都是渲染一段从 localStorage 加载该文件的代码。这样做的好处是可以有效减少请求次数，即使是第一次。</p><p>版本号不匹配（版本号可记在 Cookie 中，第一次访问没有版本号），服务端响应内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">script2ls</span>(<span class="params">id</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> script = <span class="built_in">document</span>.getElementById(id);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">if</span> (script) &#123;</span></span><br><span class="line"><span class="undefined">    localStorage[id] = script.innerHTML;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">id</span>=<span class="string">"jquery.js"</span>&gt;</span><span class="undefined">...jquery source code...</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">script2ls(<span class="string">'jquery.js'</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>版本号匹配，服务端响应内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">ls2script</span>(<span class="params">id</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span></span><br><span class="line"><span class="undefined">  script.text = localStorage[id];</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.head.appendChild(script);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">ls2script(<span class="string">'jquery.js'</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不过使用 localStorage 缓存文件会有 XSS 的风险，而且造成的伤害可能是永久的 <a href="https://iammapping.com/the-other-ways-to-use-localstorage/#ref-xss" target="_blank" rel="noopener">3</a>。</p><h2 id="同源窗口通信"><a href="#同源窗口通信" class="headerlink" title="同源窗口通信"></a>同源窗口通信</h2><p>你可能不禁又要问，不是有 postMessage 吗？没错 postMessage 确实可以用于窗口或 iframe 间通信，但是前提是你必须拿到打开新窗或 iframe 的句柄对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> popup = <span class="built_in">window</span>.open(...popup details...);</span><br><span class="line">popup.postMessage(<span class="string">"hello there!"</span>, <span class="string">"http://example.com"</span>);</span><br></pre></td></tr></table></figure><p>这样在新窗中再打开新窗，似乎就不好传递消息了。</p><p>你可能还想问，为什么要在窗口间通信？好问题，没有应用场景的技术都是耍流氓。像多窗口共用的一些组件，而且对数据实时同步都有较高要求的都会是这个技术的应用场景。比如通知中心上面的未读数量，两个窗口，A 窗口更新为 8，切到 B 窗口还是 9，这就造成了体验不一致，这个例子可能还觉得无关痛痒；再比如购物车，两个产品窗口，A 窗口添加到购物车，切到 B 窗口添加到购物车，发现没有 A 添加的产品，这样就比较严重了。这当然也可以通过每个窗口都与后台建立连接来更新，但用户如果开十几个窗口就开销大了。</p><p>有了同源窗口通信，我们就可以只有一个窗口与后台建立连接，收到更新后，广播给其他窗口就可以。说了这么多，实现原理是怎样的呢？</p><p><img src="http://self-storage.b0.upaiyun.com/2017/10/09/150756219537917384.png" alt="storage event"></p><p>其实原理也简单，每次 localStorage 中有任何变动都会触发一个 <code>storage</code> 事件，所有窗口都监听这个事件，一旦有窗口更新 localStorage，其他窗口都会收到通知，根据事件中的 <code>key</code> 把不关心的变动过滤掉。原理是很简单，但是要实现一套完整的广播机制还是有些复杂，你需要：</p><ul><li>管理好每个窗口的唯一 ID</li><li>防止消息重复</li><li>防止消息发给不关心的窗口</li><li>窗口心跳 keep alive</li><li>主窗口选举</li><li>…</li></ul><p>不用担心，已经有了不错的开源实现：<a href="https://github.com/diy/intercom.js" target="_blank" rel="noopener">diy/intercom.js</a>、<a href="https://github.com/tejacques/crosstab" target="_blank" rel="noopener">tejacques/crosstab</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="作为前端-DB-的存储介质"><a href="#作为前端-DB-的存储介质" class="headerlink" title="作为前端 DB 的存储介质"></a>作为前端 DB 的存储介质</h3><p>你可能不满足于用键值对保存数据，你还想保存更复杂的数据结构。</p><p>灵活存取 json 格式的数据：<a href="https://github.com/typicode/lowdb#install" target="_blank" rel="noopener">typicode/lowdb</a></p><p>通过 sql 对数据 CURD 操作：<a href="https://github.com/agershun/alasql#localstorage-and-dom-storage" target="_blank" rel="noopener">agershun/alasql</a></p><h3 id="表单自动持久化"><a href="#表单自动持久化" class="headerlink" title="表单自动持久化"></a>表单自动持久化</h3><p>在填写表单时，遇到浏览器奔溃或者误操作导致填写内容丢失，此刻用户的内心也应该是奔溃的。误操作还可以加一个 <code>beforeunload</code> 事件，在关闭浏览器或跳出当前页前提醒一下用户。那浏览器崩溃呢，将数据变更实时保存到后台，这样似乎开销很大，实时保存到 localStorage 是个不错的解决方案，真巧，也有一个开源实现：<a href="https://github.com/simsalabim/sisyphus" target="_blank" rel="noopener">simsalabim/sisyphus</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>文件缓存现在有更好的解决方案，没错，说的就是 Service Worker 的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage" target="_blank" rel="noopener">CacheStorage</a>。</p><p>不过多了解一些脑洞大开的想法，有利于拓展解决问题的思路。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;localStorage-还能这么用&quot;&gt;&lt;a href=&quot;#localStorage-还能这么用&quot; class=&quot;headerlink&quot; title=&quot;localStorage 还能这么用&quot;&gt;&lt;/a&gt;localStorage 还能这么用&lt;/h1&gt;&lt;p&gt;&lt;img s
      
    
    </summary>
    
      <category term="缓存" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/categories/%E7%BC%93%E5%AD%98/"/>
    
    
      <category term="缓存" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="localStorage" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/tags/localStorage/"/>
    
  </entry>
  
  <entry>
    <title>移动端入门常见适配问题</title>
    <link href="https://zombrbrand.github.io/ZombieBrand.github.io/2019/03/17/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%85%A5%E9%97%A8%E5%B8%B8%E8%A7%81%E9%80%82%E9%85%8D%E9%97%AE%E9%A2%98/"/>
    <id>https://zombrbrand.github.io/ZombieBrand.github.io/2019/03/17/移动端入门常见适配问题/</id>
    <published>2019-03-17T08:35:52.000Z</published>
    <updated>2019-03-17T08:37:14.525Z</updated>
    
    <content type="html"><![CDATA[<h3 id="移动端开发分为4类"><a href="#移动端开发分为4类" class="headerlink" title="移动端开发分为4类"></a>移动端开发分为4类</h3><hr><ul><li>Native（原生 APP）<br>使用 Java/Objective-C/Swift 开发</li><li>Webapp<br>在手机浏览器上展示的网页</li><li>Hybird（混合应用）<br>Native + Html</li><li>微信小程序<br><a href="https://www.zhihu.com/topic/20061410/hot" target="_blank" rel="noopener">https://www.zhihu.com/topic/20061410/hot</a></li></ul><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><hr><ul><li>开发成本<br>开发App成本比较大：android + ios+前端+后台<br>Webapp=微信小程序：前端</li><li>更新<br>Native：需要提示用户更新下载新版本<br>Webapp=Hybird=小程序： 不需要用户更新下载新版本</li><li>性能体验<br>Native：体验最佳，速度快，功能强大<br>Hybird：次之<br>Webapp：最差</li><li>安装方式<br>Native=Hybird：下载安装<br>Webapp：无需下载</li><li>跨平台<br>andriod平台<br>ios平台<br>Webapp：不需要考虑平台</li></ul><h3 id="移动端和-PC-的区别"><a href="#移动端和-PC-的区别" class="headerlink" title="移动端和 PC 的区别"></a>移动端和 PC 的区别</h3><hr><p>开发流程一样：psd稿子-&gt;切图-&gt;分析功能-&gt;&gt;写html-&gt;写css-&gt;写js</p><p><img src="https:////upload-images.jianshu.io/upload_images/6555104-2938ecae4e58d13c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p><p>移动端vsPC端，移动端的布局更简单</p><h4 id="1-触摸事件"><a href="#1-触摸事件" class="headerlink" title="1.触摸事件"></a>1.触摸事件</h4><p>touchstart, touchend, touchmove, touchcancel<br> touchcancel：系统取消touch事件的时候触发（不常用）<br> <a href="http://js.jirengu.com/pire/5/edit?html,js,output" target="_blank" rel="noopener">touchstart立即响应</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">node.addEventListener(&apos;touchstart&apos;, function()&#123;</span><br><span class="line">  console.log(&apos;start touch&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">node.addEventListener(&apos;touchend&apos;, function()&#123;</span><br><span class="line">  console.log(&apos;&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>JS没有滑动事件，我们可以<a href="http://www.zixuephp.net/article-201.html" target="_blank" rel="noopener">用触摸点的坐标来判断滑动方向</a>。</p><h4 id="2-移动端-300ms-延时"><a href="#2-移动端-300ms-延时" class="headerlink" title="2.移动端 300ms 延时"></a>2.移动端 300ms 延时</h4><p><a href="http://thx.github.io/mobile/300ms-click-delay" target="_blank" rel="noopener">300ms 延时的原因</a><br> 出于对手指触摸滑动的区分，移动端页面对于触摸事件会有 300 毫秒的延迟。</p><p>2007 年初，苹果公司在发布首款 iPhone 前夕，遇到一个问题 —— 当时的网站都是为大屏幕设备所设计的。于是苹果的工程师们做了一些约定，应对 iPhone 这种小屏幕浏览桌面端站点的问题。</p><p>这当中最出名的，当属双击缩放(double tap to zoom)，浏览PC页面时，默认缩小显示（980px的视窗宽度），用手指在屏幕上快速点击两次，Safari 浏览器会将网页缩放至原始比例。</p><p>假定用户在 iOS Safari 里边点击了一个链接。由于用户可以进行双击缩放或者双击滚动的操作，当用户一次点击屏幕之后，浏览器并不能立刻判断用户是确实要打开这个链接，还是想要进行双击操作。因此，iOS Safari 就等待 300 毫秒，以判断用户是否再次点击了屏幕。</p><h5 id="避免300ms延时的方法"><a href="#避免300ms延时的方法" class="headerlink" title="避免300ms延时的方法"></a>避免300ms延时的方法</h5><p><strong>方案一：禁止缩放，就无需等待300ms</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;user-scalable=no&quot;&gt; 禁止用户缩放</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1,maximum-scale=1&quot;&gt; 禁止浏览器缩放</span><br></pre></td></tr></table></figure><p><strong>方案二：更改默认的视口宽度</strong><br> 用 <meta> 标签配置width=device-width。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;将视口大小设为设备本身的尺寸</span><br></pre></td></tr></table></figure><p>Chrome 32对<a href="https://codereview.chromium.org/18850005/" target="_blank" rel="noopener">包含 width=device-width 或者置为比 viewport 值更小的页面上禁用双击缩放</a>。没有双击缩放就没有 300 毫秒点击延迟。<br> iOS 9.3 中：Safari 针对移动版的网页去掉了点击时的 300ms 延迟。对于网页开发者来说，不再需要引入类似 FastClick 这样的 Hack 了。双击放大的功能仍然可用，但是必须点击链接之外的地方才有效（否则就直接进入链接了）</p><p><strong>方案三：CSS touch-action: manipulation;</strong><br> CSS属性 touch-action 用于指定某个给定的区域是否允许用户操作，以及如何响应用户操作（比如浏览器自带的划动、缩放等）<br> 移动端300ms延迟，就可以使用<code>touch-action: manipulation;</code>来解决。<br> manipulation:<br> 浏览器只允许进行滚动和持续缩放操作，禁用其他非标准手势，例如双击以进行缩放，也就没有300 毫秒点击延迟啦。</p><p><strong>方案四：使用fastclick库</strong><br> <a href="https://github.com/ftlabs/fastclick" target="_blank" rel="noopener">FastClick</a> 是 <a href="http://labs.ft.com/" target="_blank" rel="noopener">FT Labs</a> 专门为解决移动端浏览器 300 毫秒点击延迟问题所开发的一个轻量级的库。简而言之，FastClick 在检测到 <code>touchend</code> 事件的时候，会通过 <a href="https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent" target="_blank" rel="noopener">DOM 自定义事件</a>立即触发一个模拟 <code>click</code> 事件，并把浏览器在 300 毫秒之后真正触发的 <code>click</code> 事件阻止掉。用法很简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//引入fastclick.js</span><br><span class="line">&lt;script type=&apos;application/javascript&apos; src=&apos;/path/to/fastclick.js&apos;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">//在body里面写</span><br><span class="line">if (&apos;addEventListener&apos; in document) &#123;</span><br><span class="line">    document.addEventListener(&apos;DOMContentLoaded&apos;, function() &#123;</span><br><span class="line">        FastClick.attach(document.body);</span><br><span class="line">    &#125;, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-常见手势"><a href="#3-常见手势" class="headerlink" title="3.常见手势"></a>3.常见手势</h4><p><img src="https:////upload-images.jianshu.io/upload_images/6555104-7edcad4fb0b58095.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/988" alt="img"></p><p>image</p><p> 但原生js只有touchstart, touchend, touchmove事件， </p><p>hammerjs</p><p> 为我们实现了一个手势库</p><h4 id="4-滚动"><a href="#4-滚动" class="headerlink" title="4.滚动"></a>4.滚动</h4><p>以往我们可以通过CSS的overflow:scroll或者overflow:auto实现滚动，但是在移动端这样效果不好。可以使用<a href="http://iscrolljs.com/" target="_blank" rel="noopener">iscroll</a></p><h4 id="5-需要设置viewport来控制屏幕全屏显示，禁止缩放"><a href="#5-需要设置viewport来控制屏幕全屏显示，禁止缩放" class="headerlink" title="5.需要设置viewport来控制屏幕全屏显示，禁止缩放"></a>5.需要设置viewport来控制屏幕全屏显示，禁止缩放</h4><p>inital-scale页面初始的放大倍数，maximum-scale最大放大倍数<br> user-scalable=no 页面不可以放大缩小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, height=device-height, inital-scale=1.0, maximum-scale=1.0, user-scalable=no;&quot; /&gt;</span><br></pre></td></tr></table></figure><h4 id="6-页面适配-动态-rem-（移动端方案，不是响应式）"><a href="#6-页面适配-动态-rem-（移动端方案，不是响应式）" class="headerlink" title="6.页面适配-动态 rem （移动端方案，不是响应式）"></a>6.页面适配-动态 rem （移动端方案，不是响应式）</h4><h5 id="响应式方案"><a href="#响应式方案" class="headerlink" title="响应式方案"></a>响应式方案</h5><p>目的是一份代码解决手机、平板、电脑的页面适配。</p><ol><li>meta:vp禁止缩放<br><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, height=device-height, inital-scale=1.0, maximum-scale=1.0, user-scalable=no;&quot; /&gt;</code> </li><li>尽量不要写width/height，该用max-width/max-height</li><li>多用flex布局</li><li>media query</li></ol><h5 id="动态-rem方案"><a href="#动态-rem方案" class="headerlink" title="动态 rem方案"></a>动态 rem方案</h5><p>而动态 rem是只针对移动端页面的适配方法。<a href="https://h5.m.taobao.com/" target="_blank" rel="noopener">例如手机淘宝</a> 在移动端宽度不适合再用固定宽度px，我们希望整体等比缩放。如果用媒体查询的响应式，那么对于宽度不同的手机，显示页面内容的宽度仍然一样，内容居中，只是两边留白宽度不同。</p><p>rem是CSS3新增的一个相对单位（root em，根em），相对的只是HTML根元素（1rem=html font size）。通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应（em也是相对长度单位，但会继承父级元素的字体大小）。</p><p>rem是相对于根节点html的font-size的倍数，浏览器对font-size值有限制，一般font-size最小值默认为12。</p><p><strong>动态 rem方案1</strong></p><ol><li>meta:vp禁止缩放<br><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, height=device-height, inital-scale=1.0, maximum-scale=1.0, user-scalable=no;&quot; /&gt;</code> </li><li>document.documentElement.clientWidth动态获取页面宽度</li><li>赋给html的font-size，即拼接成<code>html{font-size:&#39;+document.documentElement.clientWidth +&#39;px;}</code> </li><li>所有需要跟视觉稿一致的地方，按比例算出rem值<br><a href="http://js.jirengu.com/runakatoxe/1/edit" target="_blank" rel="noopener">示例1</a> </li></ol><p><strong>动态rem方案2</strong></p><ol><li>meta:vp禁止缩放<br><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, height=device-height, inital-scale=1.0, maximum-scale=1.0, user-scalable=no;&quot; /&gt;</code> </li><li>document.documentElement.clientWidth动态获取页面宽度width</li><li>赋给html的font-size，即拼接成<code>html{font-size:&#39;+ width/10 +&#39;px;}</code> </li><li>10rem==页面宽度width</li><li>所有单位都用rem == 所有长度都以页面的宽度为基准<br><a href="http://js.jirengu.com/zupeviquni/1/edit" target="_blank" rel="noopener">示例2</a> </li></ol><p><strong>动态rem方案3 + retina下，border: 1px问题</strong></p><ol><li>普通屏幕<br>CSS 1px == 设备的1px</li><li>在Retina<br>CSS 1px == 设备的2px<br>设计师要求 border-width == 设备的1px<br>所以我们让border-width ：0.5px== 设备的1px（兼容性有问题，不是所有的浏览器都支持0.5px）</li></ol><p>解决方案：<br> 1.获取设备 像素比window.devicePixelRatio<br> 2.<code>var sacle = 1/window.devicePixelRatio;</code><br> 3.让rem变为rem*像素比<br> 4.border-top:1px solid red;<br> <a href="http://jsbin.com/cojivi/1/edit?html,css,output" target="_blank" rel="noopener">示例3</a><br> <a href="http://www.aliued.com/?p=3166" target="_blank" rel="noopener">移动端高清、多屏适配方案-阿里</a><br> <a href="http://www.alloyteam.com/2016/03/mobile-web-adaptation-tool-rem/" target="_blank" rel="noopener">移动web适配-rem-腾讯</a></p><p><strong>动态rem方案可以被css3中相对长度单位vw 取代</strong><br> <a href="https://caniuse.com/#search=vm" target="_blank" rel="noopener">查看浏览器对vw的支持情况</a><br> vw  相对于视口的宽度。视口被均分为100单位的vw(即浏览器可视区) 100vw = 可视区宽度<br> vh  相对于视口的高度。视口被均分为100单位的vh(即浏览器可视区) 100vh  = 可视区高度</p><h4 id="7-开发调试"><a href="#7-开发调试" class="headerlink" title="7.开发调试"></a>7.开发调试</h4><p>PC端：采用本地编写，浏览器查看，dev-tools调试<br> 移动端：<code>npm install browser-sync</code> 用于在手机端验证和调试。手机通过连接局域网地址也可以访问页面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ browser-sync</span><br><span class="line">[Browsersync] Access URLs:</span><br><span class="line"> ---------------------------------------</span><br><span class="line">       Local: http://localhost:3000</span><br><span class="line">    External: http://192.168.10.101:3000</span><br><span class="line"> ---------------------------------------</span><br><span class="line">          UI: http://localhost:3001   (调试地址)</span><br><span class="line"> UI External: http://192.168.10.101:3001</span><br></pre></td></tr></table></figure><h4 id="8-移动端解决方法收集"><a href="#8-移动端解决方法收集" class="headerlink" title="8.移动端解决方法收集"></a>8.移动端解决方法收集</h4><p><a href="https://github.com/jtyjty99999/mobileTech/blob/master/README.md" target="_blank" rel="noopener">https://github.com/jtyjty99999/mobileTech/blob/master/README.md</a><br> <a href="https://placeholder.com/" target="_blank" rel="noopener">image place holder占位图片定制化</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;移动端开发分为4类&quot;&gt;&lt;a href=&quot;#移动端开发分为4类&quot; class=&quot;headerlink&quot; title=&quot;移动端开发分为4类&quot;&gt;&lt;/a&gt;移动端开发分为4类&lt;/h3&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;Native（原生 APP）&lt;br&gt;使用 Java/Objec
      
    
    </summary>
    
      <category term="移动端" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
      <category term="适配" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/%E9%80%82%E9%85%8D/"/>
    
    
      <category term="移动端" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
      <category term="适配" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/tags/%E9%80%82%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>移动端rem适配</title>
    <link href="https://zombrbrand.github.io/ZombieBrand.github.io/2019/03/17/%E7%A7%BB%E5%8A%A8%E7%AB%AFrem%E9%80%82%E9%85%8D/"/>
    <id>https://zombrbrand.github.io/ZombieBrand.github.io/2019/03/17/移动端rem适配/</id>
    <published>2019-03-17T08:31:59.000Z</published>
    <updated>2019-03-17T08:35:13.152Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于移动端-rem-布局的一些总结"><a href="#关于移动端-rem-布局的一些总结" class="headerlink" title="关于移动端 rem 布局的一些总结"></a>关于移动端 rem 布局的一些总结</h1><p><strong>先上一段代码原理下边</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">win, lib</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timer,</span><br><span class="line">        doc     = win.document,</span><br><span class="line">        docElem = doc.documentElement,</span><br><span class="line"></span><br><span class="line">        vpMeta   = doc.querySelector(<span class="string">'meta[name="viewport"]'</span>),</span><br><span class="line">        flexMeta = doc.querySelector(<span class="string">'meta[name="flexible"]'</span>),</span><br><span class="line"> </span><br><span class="line">        dpr   = <span class="number">0</span>,</span><br><span class="line">        scale = <span class="number">0</span>,</span><br><span class="line"> </span><br><span class="line">        flexible = lib.flexible || (lib.flexible = &#123;&#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 设置了 viewport meta</span></span><br><span class="line">    <span class="keyword">if</span> (vpMeta) &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">"将根据已有的meta标签来设置缩放比例"</span>);</span><br><span class="line">        <span class="keyword">var</span> initial = vpMeta.getAttribute(<span class="string">"content"</span>).match(<span class="regexp">/initial\-scale=([\d\.]+)/</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (initial) &#123;</span><br><span class="line">            scale = <span class="built_in">parseFloat</span>(initial[<span class="number">1</span>]); <span class="comment">// 已设置的 initialScale</span></span><br><span class="line">            dpr = <span class="built_in">parseInt</span>(<span class="number">1</span> / scale);      <span class="comment">// 设备像素比 devicePixelRatio</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置了 flexible Meta</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (flexMeta) &#123;</span><br><span class="line">        <span class="keyword">var</span> flexMetaContent = flexMeta.getAttribute(<span class="string">"content"</span>);</span><br><span class="line">        <span class="keyword">if</span> (flexMetaContent) &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">var</span> initial = flexMetaContent.match(<span class="regexp">/initial\-dpr=([\d\.]+)/</span>),</span><br><span class="line">                maximum = flexMetaContent.match(<span class="regexp">/maximum\-dpr=([\d\.]+)/</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (initial) &#123;</span><br><span class="line">                dpr = <span class="built_in">parseFloat</span>(initial[<span class="number">1</span>]);</span><br><span class="line">                scale = <span class="built_in">parseFloat</span>((<span class="number">1</span> / dpr).toFixed(<span class="number">2</span>));</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (maximum) &#123;</span><br><span class="line">                dpr = <span class="built_in">parseFloat</span>(maximum[<span class="number">1</span>]);</span><br><span class="line">                scale = <span class="built_in">parseFloat</span>((<span class="number">1</span> / dpr).toFixed(<span class="number">2</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// viewport 或 flexible</span></span><br><span class="line">    <span class="comment">// meta 均未设置</span></span><br><span class="line">    <span class="keyword">if</span> (!dpr &amp;&amp; !scale) &#123;</span><br><span class="line">        <span class="comment">// QST</span></span><br><span class="line">        <span class="comment">// 这里的 第一句有什么用 ?</span></span><br><span class="line">        <span class="comment">// 和 Android 有毛关系 ?</span></span><br><span class="line">        <span class="keyword">var</span> u = (win.navigator.appVersion.match(<span class="regexp">/android/gi</span>), win.navigator.appVersion.match(<span class="regexp">/iphone/gi</span>)),</span><br><span class="line">            _dpr = win.devicePixelRatio;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 所以这里似乎是将所有 Android 设备都设置为 1 了</span></span><br><span class="line">        dpr = u ? ( (_dpr &gt;= <span class="number">3</span> &amp;&amp; (!dpr || dpr &gt;= <span class="number">3</span>))</span><br><span class="line">                        ? <span class="number">3</span></span><br><span class="line">                        : (_dpr &gt;= <span class="number">2</span> &amp;&amp; (!dpr || dpr &gt;= <span class="number">2</span>))</span><br><span class="line">                            ? <span class="number">2</span></span><br><span class="line">                            : <span class="number">1</span></span><br><span class="line">                  )</span><br><span class="line">                : <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">        scale = <span class="number">1</span> / dpr;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    docElem.setAttribute(<span class="string">"data-dpr"</span>, dpr);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 插入 viewport meta</span></span><br><span class="line">    <span class="keyword">if</span> (!vpMeta) &#123;</span><br><span class="line">        vpMeta = doc.createElement(<span class="string">"meta"</span>);</span><br><span class="line">         </span><br><span class="line">        vpMeta.setAttribute(<span class="string">"name"</span>, <span class="string">"viewport"</span>);</span><br><span class="line">        vpMeta.setAttribute(<span class="string">"content"</span>,</span><br><span class="line">            <span class="string">"initial-scale="</span> + scale + <span class="string">", maximum-scale="</span> + scale + <span class="string">", minimum-scale="</span> + scale + <span class="string">", user-scalable=no"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (docElem.firstElementChild) &#123;</span><br><span class="line">            docElem.firstElementChild.appendChild(vpMeta)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> div = doc.createElement(<span class="string">"div"</span>);</span><br><span class="line">            div.appendChild(vpMeta);</span><br><span class="line">            doc.write(div.innerHTML);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setFontSize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> winWidth = docElem.getBoundingClientRect().width;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (winWidth / dpr &gt; <span class="number">540</span>) &#123;</span><br><span class="line">            (winWidth = <span class="number">540</span> * dpr);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 根节点 fontSize 根据宽度决定</span></span><br><span class="line">        <span class="keyword">var</span> baseSize = winWidth / <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">        docElem.style.fontSize = baseSize + <span class="string">"px"</span>;</span><br><span class="line">        flexible.rem = win.rem = baseSize;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 调整窗口时重置</span></span><br><span class="line">    win.addEventListener(<span class="string">"resize"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        timer = setTimeout(setFontSize, <span class="number">300</span>);</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 这一段是我自己加的</span></span><br><span class="line">    <span class="comment">// orientationchange 时也需要重算下吧</span></span><br><span class="line">    win.addEventListener(<span class="string">"orientationchange"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        timer = setTimeout(setFontSize, <span class="number">300</span>);</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// pageshow</span></span><br><span class="line">    <span class="comment">// keyword: 倒退 缓存相关</span></span><br><span class="line">    win.addEventListener(<span class="string">"pageshow"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e.persisted) &#123;</span><br><span class="line">            clearTimeout(timer);</span><br><span class="line">            timer = setTimeout(setFontSize, <span class="number">300</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 设置基准字体</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"complete"</span> === doc.readyState) &#123;</span><br><span class="line">        doc.body.style.fontSize = <span class="number">12</span> * dpr + <span class="string">"px"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        doc.addEventListener(<span class="string">"DOMContentLoaded"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            doc.body.style.fontSize = <span class="number">12</span> * dpr + <span class="string">"px"</span>;</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    setFontSize();</span><br><span class="line"> </span><br><span class="line">    flexible.dpr = win.dpr = dpr;</span><br><span class="line"> </span><br><span class="line">    flexible.refreshRem = setFontSize;</span><br><span class="line"> </span><br><span class="line">    flexible.rem2px = <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> c = <span class="built_in">parseFloat</span>(d) * <span class="keyword">this</span>.rem;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"string"</span> == <span class="keyword">typeof</span> d &amp;&amp; d.match(<span class="regexp">/rem$/</span>)) &#123;</span><br><span class="line">            c += <span class="string">"px"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    flexible.px2rem = <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> c = <span class="built_in">parseFloat</span>(d) / <span class="keyword">this</span>.rem;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"string"</span> == <span class="keyword">typeof</span> d &amp;&amp; d.match(<span class="regexp">/px$/</span>)) &#123;</span><br><span class="line">            c += <span class="string">"rem"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="built_in">window</span>, <span class="built_in">window</span>.lib || (<span class="built_in">window</span>.lib = &#123;&#125;));</span><br></pre></td></tr></table></figure><h2 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h2><p>在前一段时间，我曾经写过一篇关于viewport的文章。最近由于在接触移动端开发，对viewport有了新的理解。于是，打算重新写一篇文章，介绍移动端视口的相关概念。</p><p>关于这篇文章说到的所有知识，本质上离不开以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot; /&gt;</span><br><span class="line"></span><br><span class="line">@media all and (max-width: 320px) &#123;</span><br><span class="line">    // do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>了解过移动端开发的朋友，其实对以上的代码就不会陌生。上面的代码，主要涉及到meta视口标签与媒体查询。单单以上简短的代码就需要明白：</p><ul><li>像素(pixel)</li><li>视口(viewport)</li><li>分辨率(resolution)与设备像素比(device-pixel-ratio)</li><li>meta视口标签</li><li>媒体查询(media query)</li><li>JavaScript相关的属性和方法</li><li>如何实现移动端响应式适配的问题</li></ul><p>那就进入主题吧：）</p><h3 id="像素"><a href="#像素" class="headerlink" title="像素"></a>像素</h3><p>在移动端上，所谓的像素分为两种</p><ul><li>CSS像素：CSS像素就是我们在编写CSS代码时的像素。</li><li>设备像素：设备屏幕的物理像素，任何设备的物理像素的数量都是固定的。</li></ul><p>1个CSS像素等于多少个设备像素取决于屏幕特性(是否是高清屏)和用户缩放的比例。当用户将屏幕从100%放大到200%时，1个CSS像素等于2个设备像素，反之相反；当屏幕为Retina高清屏(如iPhone6，dpr=2)时，1个CSS像素就等于2个设备像素，反之相反。</p><p>需要明白一点的是，2个设备像素并不是说它扩大了两倍，而是说在<strong>页面上仍然显示的是1px(1个CSS像素)</strong>，但是这1px是由2个设备像素组成。像素点变多了，因此图像会变得更加清晰。下面这幅图大致说明了CSS像素和设备像素的区别。<br><img src="https://images2015.cnblogs.com/blog/896144/201707/896144-20170706233919628-231558146.png" alt="img"></p><h3 id="视口-1"><a href="#视口-1" class="headerlink" title="视口"></a>视口</h3><p>在移动端上，存在三种不同的视口。</p><ul><li>布局视口：在PC端上，布局视口等于浏览器窗口的宽度。而在移动端上，由于要使为PC端浏览器设计的网站能够完全显示在移动端的小屏幕里，此时的布局视口会远大于移动设备的屏幕。在移动端，默认情况下，布局视口等于浏览器窗口宽度。<strong>布局视口限制了CSS的布局。</strong>在<strong>JavaScirpt上获取布局视口的宽度</strong>可以通过<code>document.documentElement.clientWidth | document.body.clientWidth</code>得到。<br><img src="https://images2015.cnblogs.com/blog/896144/201707/896144-20170706233934425-712228411.png" alt="img"></li><li>视觉视口：视觉视口是用户正在看到的区域。用户可以缩放来操作视觉视口，而不影响视觉视口的宽度。<strong>视觉视口决定了用户看到了什么</strong>。在<strong>JavaScript上获取视觉视口的宽度</strong>可以通过`window.innerWidth得到。</li></ul><p>在PC端上，视觉视口等于布局视口的宽度，无论用户是放大屏幕还是缩小屏幕，这两个视口的宽度仍然相等。但是，在移动端上，并非如此。<strong>缩放屏幕的过程实质上就是CSS像素缩放的过程</strong>。当用户将屏幕放到到两倍时，视觉视口变小了(因为视觉视口中CSS像素变少了)，而每单位的CSS像素却变大了，因此1px(1个CSS像素)等于2个设备像素。同理，当为iPhone6(dpr=2)时，视觉视口中CSS像素变少了，但是1px等于2个设备像素。当用户缩小屏幕时也是同样的道理。<strong>缩放的过程并不会影响布局视口的大小。</strong></p><p>也就是说，高清屏(dpr&gt;=2)或屏幕放大时，视觉视口变小(CSS像素变少)，每单位的CSS像素等于更多的设备像素；非高清屏(dpr&lt;2)<br>或屏幕缩小时，视觉视口变大(CSS像素变多)，每单位的CSS像素等于更少的设备像素。<br>但是无论放大或缩小屏幕，布局视口的宽度仍然保持不变。</p><ul><li>理想视口：由于默认情况下布局视口等于浏览器窗口宽度，因此在移动端上需要通过放大或缩小视觉视口来查看页面内容，这当然体验糟糕啊！因此在移动端引入了理想视口的概念。理想视口的出现必须需要设置meta视口标签，此时布局视口等于理想视口的宽度。常见的，iPhone6的理想视口为375px <em> 667px，iPhon6 plus的理想视口为414px </em> 736px。在<strong>JavaScript上获取理想视口的宽度</strong><code>window.screen.width</code>得到。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot; /&gt;</span><br></pre></td></tr></table></figure><p>当设置了meta视口标签之后，iPhone6的布局视口宽度将等于375px，iPhone6plus布局视口的宽度等于414px。其他移动设备相似。</p><p>理想视口会随着屏幕的旋转而改变。当iPhone6为肖像模式时(即竖屏)，此时理想视口为375px <em> 667px；但为横屏模式时，此时理想视口为667px </em> 375px。</p><h3 id="分辨率与设备像素比"><a href="#分辨率与设备像素比" class="headerlink" title="分辨率与设备像素比"></a>分辨率与设备像素比</h3><p>分辨率是指每英寸内点的个数，单位是dpi或者dppx。设备像素比是指设备像素与理想视口宽度的比值，没有单位。</p><p>分辨率在CSS上可以通过<code>resolution</code>属性设置。一般情况下会使用dpi作为分辨率的单位，因为dppx并非所有浏览器都支持。</p><p>而设备像素比在CSS上可以通过<code>device-pixel-ratio</code>属性设置，而在JavaScript上可以通过<code>window.devicePixelRatio</code>属性获取。</p><p>同时，<strong>1dpr=96dpi</strong>。举个例子。在iPhon6下，理想视口宽度为375px，而设备像素为750px，因此此时设备像素比为2，分辨率为192dpi。因此如果为iPhon6以下的设备写某个特定样式，可以这样写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 注意，device-pixel-ratio需要带上-webkit-前缀，保证浏览器兼容性问题。</span><br><span class="line">@media all and (max-width: 375px) and (-webkit-max-device-pixel-ratio: 2) &#123;</span><br><span class="line">    body &#123;</span><br><span class="line">        background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line">@media all and (max-width: 375px) and (max-resolution: 192dpi) &#123;</span><br><span class="line">    body &#123;</span><br><span class="line">        background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="meta视口标签"><a href="#meta视口标签" class="headerlink" title="meta视口标签"></a>meta视口标签</h3><p>meta视口标签是是设置理想视口的重要元素，主要用于将布局视口的尺寸和理想视口的尺寸相匹配。meta视口标签存在5个指令</p><ol><li>width：设置布局视口的宽度，一般设为device-width。</li><li>initial-scale：初始缩放比例。1即100%，2即200%，以此类推</li><li>maximum=scale：最大缩放比例。</li><li>minimum-scale：最小缩放比例。</li><li>user-scalable：是否静止用户进行缩放，默认为no。</li></ol><p>需要注意的是，<strong>缩放是根据理想视口进行计算的。缩放程度与视觉视口的宽度是逆相关的。</strong>也就是说，当你将屏幕放到到2倍时，视觉视口为理想视口的一半，此时每单位的CSS像素等于2个设备像素。缩小时则相反。</p><h2 id="响应式适配问题"><a href="#响应式适配问题" class="headerlink" title="响应式适配问题"></a>响应式适配问题</h2><p>理解了一些基本概念之后，我们来看看如何实现响应式适配。</p><p>一般情况下，前端开发工程师会根据设计师给的设计稿进行开发。而设计稿一般是根据iPhon6手机进行页面的设计的。我们知道iPhone6的理想视口宽度为375px，同时iPhone6的设备像素比为2，设备像素为750px。我们需要在只有一份设计稿的情况下写出适应各种屏幕不一的终端设备，因此需要一些移动端响应式适配的方案。此时需要用到的一个单位是<code>REM</code>。简单的说，REM会根据HTML元素的<code>font-size</code>进行设置。当HTML元素的<code>font-size: 16px</code>时，<code>1rem = 16px, 1.5rem = 24px</code></p><p>个人总结出了两套响应式适配的方案(前提是设置meta视口标签)。两套方案由一个共同点：给定一个<strong>基准值</strong>。</p><p>假如现在拿到的设计稿是根据iPhone6进行设计的。</p><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>方案一是设计稿给什么尺寸，我们就将其缩小100倍，最后换算成rem单位。比如，设计稿上某个title的<code>font-size</code>为32px，此时写CSS样式时就直接缩小100倍，即<code>0.32rem</code>。</p><p>由于rem是根据根元素进行设置的，所以我们需要设置根元素的<code>font-size</code>。</p><p>给HTML设置<code>font-size</code>的基本思路：</p><ol><li>通过<code>window.screen.width</code>获取不同移动设备的理想视口宽度。</li><li>规定基准值为750px(此值为iPhon6的设备像素)。</li><li>(1) / (2) * 100即得到HTML元素的<code>font-size</code>。(乘于100是因为我们在前面将字体缩小了100倍，此时要乘回来)</li></ol><p>换算成公式即：<strong>设计稿尺寸 / 100 * (不同设备的理想视口宽度 / 基准值 * 100)</strong></p><p>举个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 根据不同设备的理想视口宽度动态设置根元素的`font-size`。</span><br><span class="line">let idealViewWidth = window.screen.width;</span><br><span class="line">const BASICVALUE = 750;</span><br><span class="line">document.documentElement.style.fontSize = (idealViewWidth / BASICVALUE) * 100 + &apos;px&apos;;</span><br></pre></td></tr></table></figure><p>因此，在不同设备下的HTML元素的<code>font-size</code>大小和实际像素如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iPhone5 : (320 / 750) * 100 = 42.667px</span><br><span class="line">iPhone6 : (375 / 750) * 100 = 50px</span><br><span class="line">iPhone6+: (414 / 750) * 100 = 55.2px</span><br><span class="line"></span><br><span class="line">假如设计稿上标注.title类上的字体为32px，此时有</span><br><span class="line">iPhone5上的某字体:  42.667 * 0.32rem = 13.653px</span><br><span class="line">iPhone6上的某字体： 50 * 0.32rem = 16px</span><br><span class="line">iPhone6+上的某字体: 55.2 * 0.32rem = 17.664px</span><br></pre></td></tr></table></figure><p>可以看出，在不同设备下，同一字号的字体使用rem单位可以实现不同设备的响应式适配。不单单在字体上可以使用，在移动端上的width、height等涉及单位的都可以使用。这样的话，就可以在不同设备下完美的复现设计稿的要求。</p><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>此方案使用了SASS预处理器。基本思路：</p><ol><li>设置根元素的<code>font-size</code>。通过获取不同设备的理想视口宽度，再除以10。(除以10是因为不想<code>font-size</code>太大。)</li><li>给定基准值，此时给的基准值为75px(此值为iPhone6的设备像素除以10)</li><li>写SASS Function</li></ol><p>代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">SASS</span><br><span class="line">@function px2rem ($value) &#123;</span><br><span class="line">    $para: 75px;</span><br><span class="line">    @return $value / $para + rem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JS</span><br><span class="line">let idealViewWidth = window.screen.width;</span><br><span class="line">document.documentElement.style.fontSize = idealViewWidth / 10 + &apos;px&apos;;</span><br><span class="line"></span><br><span class="line">在不同设备下根元素的`font-size`：</span><br><span class="line"></span><br><span class="line">iPhone5 : 320px / 10 = 32px</span><br><span class="line">iPhone6 : 375px / 10 = 37.5px</span><br><span class="line">iPhone6+: 414px / 10 = 41.4px</span><br><span class="line"></span><br><span class="line">根据以上，可以看一个例子。某设计稿下5个li，横向排布，每个的宽度为200px</span><br><span class="line">CSS</span><br><span class="line">@import (路径名)</span><br><span class="line">iPhone5: li &#123; width: px2rem(200px) &#125; =&gt; width: 85.333px</span><br><span class="line">// 此时(200px / 75px = 2.667rem) 2.667rem = 2.667 * (320 / 10) = 85.3333px</span><br><span class="line">iPhone6: li &#123; width: px2rem(200px) &#125; =&gt; width: 100px</span><br><span class="line">// 此时(200px / 75px = 2.667rem) 2.667rem = 2.667 * (375 / 10) = 100px</span><br><span class="line">iPhone6+: li &#123; width: px2rem(200px) &#125; =&gt; width: 4138px</span><br><span class="line">// 此时(200px / 75px = 2.667rem) 2.667rem = 2.667 * (414 / 10) = 110.4138px</span><br><span class="line"></span><br><span class="line">因此，一个200px的(实际只有100px)的li元素的宽度在不同设备下显示了不同的宽度，实现了响应式适配的问题。</span><br></pre></td></tr></table></figure><h3 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h3><p>方案三与前两个方案不相同，此方案并不需要给根元素设置<code>font-size</code>，不需要基准值。此方案是根据不同设备的dpr来实现页面的缩放的。</p><p>基本思路如下：</p><ol><li>通过window.devicePixelRatio获取设备的dpr</li><li>根据不同的dpr缩放页面，动态设置meta视口标签。(缩放是放大或缩小CSS的过程，根据理想视口进行缩放，与视觉视口方向相反)</li></ol><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let dpr = window.devicePixelRatio;</span><br><span class="line">let meta = document.createElement(&apos;meta&apos;);</span><br><span class="line">let initialScale = 1 / dpr;</span><br><span class="line">let maximumScale = 1 / dpr;</span><br><span class="line">let minimumScale = 1 / dpr;</span><br><span class="line">meta.setAttribute(&apos;name&apos;, &apos;viewport&apos;);</span><br><span class="line">meta.setAttribute(&apos;content&apos;, `width=device-width, user-scalable=no, initial-scale=$&#123;initialScale&#125;, maximum-scale=$&#123;maximumScale&#125;, minimum-scale=$&#123;minimumScale&#125;`);</span><br><span class="line">document.head.appendChild(meta);</span><br><span class="line"></span><br><span class="line">因此，可以直接根据设计稿的尺寸写CSS样式，如设计稿下有5个li元素，宽度为200px，此时不同设备下li的宽度</span><br><span class="line"></span><br><span class="line">iPhone5 : li &#123; width: 200px &#125; 实际宽度为：100px</span><br><span class="line">iPhone6 : li &#123; width: 200px &#125; 实际宽度为：100px</span><br><span class="line">iPhone6+: li &#123; width: 200px &#125; 实际宽度为：66.667px</span><br></pre></td></tr></table></figure><p>以上三种方法解决了大部分移动端响应式适配的问题，但是在1px问题上，使用以上的方法仍然(除了第三个方案)，都不能很好的解决1px的问题。有时间写一篇文章介绍如何解决1px的问题。</p><hr><h1 id="淘宝flexible适配方法"><a href="#淘宝flexible适配方法" class="headerlink" title="淘宝flexible适配方法"></a>淘宝flexible适配方法</h1><p><a href="https://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html" target="_blank" rel="noopener">原文来源</a></p><p>直接插入到HTML中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">! <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b = f.getBoundingClientRect().width;</span><br><span class="line">        b / i &gt; <span class="number">540</span> &amp;&amp; (b = <span class="number">540</span> * i);</span><br><span class="line">        <span class="keyword">var</span> c = b / <span class="number">10</span>;</span><br><span class="line">        f.style.fontSize = c + <span class="string">"px"</span>, k.rem = a.rem = c</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> d, e = a.document,</span><br><span class="line">        f = e.documentElement,</span><br><span class="line">        g = e.querySelector(<span class="string">'meta[name="viewport"]'</span>),</span><br><span class="line">        h = e.querySelector(<span class="string">'meta[name="flexible"]'</span>),</span><br><span class="line">        i = <span class="number">0</span>,</span><br><span class="line">        j = <span class="number">0</span>,</span><br><span class="line">        k = b.flexible || (b.flexible = &#123;&#125;);</span><br><span class="line">    <span class="keyword">if</span> (g) &#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">"将根据已有的meta标签来设置缩放比例"</span>);</span><br><span class="line">        <span class="keyword">var</span> l = g.getAttribute(<span class="string">"content"</span>).match(<span class="regexp">/initial\-scale=([\d\.]+)/</span>);</span><br><span class="line">        l &amp;&amp; (j = <span class="built_in">parseFloat</span>(l[<span class="number">1</span>]), i = <span class="built_in">parseInt</span>(<span class="number">1</span> / j))</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (h) &#123;</span><br><span class="line">        <span class="keyword">var</span> m = h.getAttribute(<span class="string">"content"</span>);</span><br><span class="line">        <span class="keyword">if</span> (m) &#123;</span><br><span class="line">            <span class="keyword">var</span> n = m.match(<span class="regexp">/initial\-dpr=([\d\.]+)/</span>),</span><br><span class="line">                o = m.match(<span class="regexp">/maximum\-dpr=([\d\.]+)/</span>);</span><br><span class="line">            n &amp;&amp; (i = <span class="built_in">parseFloat</span>(n[<span class="number">1</span>]), j = <span class="built_in">parseFloat</span>((<span class="number">1</span> / i).toFixed(<span class="number">2</span>))), o &amp;&amp; (i = <span class="built_in">parseFloat</span>(o[<span class="number">1</span>]), j = <span class="built_in">parseFloat</span>((<span class="number">1</span> / i).toFixed(<span class="number">2</span>)))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!i &amp;&amp; !j) &#123;</span><br><span class="line">        <span class="keyword">var</span> p = a.navigator.userAgent,</span><br><span class="line">            q = (!!p.match(<span class="regexp">/android/gi</span>), !!p.match(<span class="regexp">/iphone/gi</span>)),</span><br><span class="line">            r = q &amp;&amp; !!p.match(<span class="regexp">/OS 9_3/</span>),</span><br><span class="line">            s = a.devicePixelRatio;</span><br><span class="line">        i = q &amp;&amp; !r ? s &gt;= <span class="number">3</span> &amp;&amp; (!i || i &gt;= <span class="number">3</span>) ? <span class="number">3</span> : s &gt;= <span class="number">2</span> &amp;&amp; (!i || i &gt;= <span class="number">2</span>) ? <span class="number">2</span> : <span class="number">1</span> : <span class="number">1</span>, j = <span class="number">1</span> / i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (f.setAttribute(<span class="string">"data-dpr"</span>, i), !g)</span><br><span class="line">        <span class="keyword">if</span> (g = e.createElement(<span class="string">"meta"</span>), g.setAttribute(<span class="string">"name"</span>, <span class="string">"viewport"</span>), g.setAttribute(<span class="string">"content"</span>, <span class="string">"initial-scale="</span> + j + <span class="string">", maximum-scale="</span> + j + <span class="string">", minimum-scale="</span> + j + <span class="string">", user-scalable=no"</span>), f.firstElementChild) f.firstElementChild.appendChild(g);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> t = e.createElement(<span class="string">"div"</span>);</span><br><span class="line">            t.appendChild(g), e.write(t.innerHTML)</span><br><span class="line">        &#125; a.addEventListener(<span class="string">"resize"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        clearTimeout(d), d = setTimeout(c, <span class="number">300</span>)</span><br><span class="line">    &#125;, !<span class="number">1</span>), a.addEventListener(<span class="string">"pageshow"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">        a.persisted &amp;&amp; (clearTimeout(d), d = setTimeout(c, <span class="number">300</span>))</span><br><span class="line">    &#125;, !<span class="number">1</span>), <span class="string">"complete"</span> === e.readyState ? e.body.style.fontSize = <span class="number">12</span> * i + <span class="string">"px"</span> : e.addEventListener(<span class="string">"DOMContentLoaded"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        e.body.style.fontSize = <span class="number">12</span> * i + <span class="string">"px"</span></span><br><span class="line">    &#125;, !<span class="number">1</span>), c(), k.dpr = a.dpr = i, k.refreshRem = c, k.rem2px = <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="built_in">parseFloat</span>(a) * <span class="keyword">this</span>.rem;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"string"</span> == <span class="keyword">typeof</span> a &amp;&amp; a.match(<span class="regexp">/rem$/</span>) &amp;&amp; (b += <span class="string">"px"</span>), b</span><br><span class="line">    &#125;, k.px2rem = <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="built_in">parseFloat</span>(a) / <span class="keyword">this</span>.rem;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"string"</span> == <span class="keyword">typeof</span> a &amp;&amp; a.match(<span class="regexp">/px$/</span>) &amp;&amp; (b += <span class="string">"rem"</span>), b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="built_in">window</span>, <span class="built_in">window</span>.lib || (<span class="built_in">window</span>.lib = &#123;&#125;));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于移动端-rem-布局的一些总结&quot;&gt;&lt;a href=&quot;#关于移动端-rem-布局的一些总结&quot; class=&quot;headerlink&quot; title=&quot;关于移动端 rem 布局的一些总结&quot;&gt;&lt;/a&gt;关于移动端 rem 布局的一些总结&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;先上
      
    
    </summary>
    
      <category term="适配" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/categories/%E9%80%82%E9%85%8D/"/>
    
      <category term="移动端" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/categories/%E9%80%82%E9%85%8D/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
      <category term="rem" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/tags/rem/"/>
    
      <category term="移动端" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
      <category term="适配" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/tags/%E9%80%82%E9%85%8D/"/>
    
      <category term="Flexible" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/tags/Flexible/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式实例</title>
    <link href="https://zombrbrand.github.io/ZombieBrand.github.io/2019/03/17/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AE%9E%E4%BE%8B/"/>
    <id>https://zombrbrand.github.io/ZombieBrand.github.io/2019/03/17/正则表达式实例/</id>
    <published>2019-03-17T08:29:57.000Z</published>
    <updated>2019-03-17T08:30:30.310Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>收集在业务中经常使用的正则表达式实例，方便以后进行查找，减少工作量。</p></blockquote><ol><li><a href="https://segmentfault.com/a/1190000012806098#articleHeader0" target="_blank" rel="noopener">校验基本日期格式</a></li><li><a href="https://segmentfault.com/a/1190000012806098#articleHeader1" target="_blank" rel="noopener">校验密码强度</a></li><li><a href="https://segmentfault.com/a/1190000012806098#articleHeader2" target="_blank" rel="noopener">校验中文</a></li><li><a href="https://segmentfault.com/a/1190000012806098#articleHeader3" target="_blank" rel="noopener">由数字、26个英文字母或下划线组成的字符串</a></li><li><a href="https://segmentfault.com/a/1190000012806098#articleHeader4" target="_blank" rel="noopener">校验E-Mail 地址</a></li><li><a href="https://segmentfault.com/a/1190000012806098#articleHeader5" target="_blank" rel="noopener">校验身份证号码</a></li><li><a href="https://segmentfault.com/a/1190000012806098#articleHeader6" target="_blank" rel="noopener">校验日期</a></li><li><a href="https://segmentfault.com/a/1190000012806098#articleHeader7" target="_blank" rel="noopener">校验金额</a></li><li><a href="https://segmentfault.com/a/1190000012806098#articleHeader8" target="_blank" rel="noopener">校验手机号</a></li><li><a href="https://segmentfault.com/a/1190000012806098#articleHeader9" target="_blank" rel="noopener">判断IE的版本</a></li><li><a href="https://segmentfault.com/a/1190000012806098#articleHeader10" target="_blank" rel="noopener">校验IP-v4地址</a></li><li><a href="https://segmentfault.com/a/1190000012806098#articleHeader11" target="_blank" rel="noopener">校验IP-v6地址</a></li><li><a href="https://segmentfault.com/a/1190000012806098#articleHeader12" target="_blank" rel="noopener">检查URL的前缀</a></li><li><a href="https://segmentfault.com/a/1190000012806098#articleHeader13" target="_blank" rel="noopener">提取URL链接</a></li><li><a href="https://segmentfault.com/a/1190000012806098#articleHeader14" target="_blank" rel="noopener">文件路径及扩展名校验</a></li><li><a href="https://segmentfault.com/a/1190000012806098#articleHeader15" target="_blank" rel="noopener">提取Color Hex Codes</a></li><li><a href="https://segmentfault.com/a/1190000012806098#articleHeader16" target="_blank" rel="noopener">提取网页图片</a></li><li><a href="https://segmentfault.com/a/1190000012806098#articleHeader17" target="_blank" rel="noopener">提取页面超链接</a></li><li><a href="https://segmentfault.com/a/1190000012806098#articleHeader18" target="_blank" rel="noopener">查找CSS属性</a></li><li><a href="https://segmentfault.com/a/1190000012806098#articleHeader19" target="_blank" rel="noopener">抽取注释</a></li><li><a href="https://segmentfault.com/a/1190000012806098#articleHeader20" target="_blank" rel="noopener">转换千分位分隔符</a></li></ol><h2 id="1-校验基本日期格式"><a href="#1-校验基本日期格式" class="headerlink" title="1. 校验基本日期格式"></a>1. 校验基本日期格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var reg1 = /^\d&#123;4&#125;(\-|\/|\.)\d&#123;1,2&#125;\1\d&#123;1,2&#125;$/;</span><br><span class="line">var reg2 = /^(^(\d&#123;4&#125;|\d&#123;2&#125;)(\-|\/|\.)\d&#123;1,2&#125;\3\d&#123;1,2&#125;$)|(^\d&#123;4&#125;年\d&#123;1,2&#125;月\d&#123;1,2&#125;日$)$/;</span><br></pre></td></tr></table></figure><h2 id="2-校验密码强度"><a href="#2-校验密码强度" class="headerlink" title="2. 校验密码强度"></a>2. 校验密码强度</h2><p>密码的强度必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reg = /^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$/;</span><br></pre></td></tr></table></figure><p><strong>网友提供的解决检测特殊字符的方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reg = /^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$/;</span><br></pre></td></tr></table></figure><h2 id="3-校验中文"><a href="#3-校验中文" class="headerlink" title="3. 校验中文"></a>3. 校验中文</h2><p>字符串仅能是中文。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reg = /^[\\u4e00-\\u9fa5]&#123;0,&#125;$/;</span><br></pre></td></tr></table></figure><h2 id="4-由数字、26个英文字母或下划线组成的字符串"><a href="#4-由数字、26个英文字母或下划线组成的字符串" class="headerlink" title="4. 由数字、26个英文字母或下划线组成的字符串"></a>4. 由数字、26个英文字母或下划线组成的字符串</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reg = /^\\w+$/;</span><br></pre></td></tr></table></figure><h2 id="5-校验E-Mail-地址"><a href="#5-校验E-Mail-地址" class="headerlink" title="5. 校验E-Mail 地址"></a>5. 校验E-Mail 地址</h2><p>同密码一样，下面是E-mail地址合规性的正则检查语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reg = /[\\w!#$%&amp;&apos;*+/=?^_`&#123;|&#125;~-]+(?:\\.[\\w!#$%&amp;&apos;*+/=?^_`&#123;|&#125;~-]+)*@(?:[\\w](?:[\\w-]*[\\w])?\\.)+[\\w](?:[\\w-]*[\\w])?/;</span><br></pre></td></tr></table></figure><h2 id="6-校验身份证号码"><a href="#6-校验身份证号码" class="headerlink" title="6. 校验身份证号码"></a>6. 校验身份证号码</h2><p>下面是身份证号码的正则校验。15 或 18位。</p><p>15位：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reg = /^[1-9]\\d&#123;7&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d&#123;3&#125;$/;</span><br></pre></td></tr></table></figure><p>18位：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reg = /^[1-9]\\d&#123;5&#125;[1-9]\\d&#123;3&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d&#123;3&#125;([0-9]|X)$/;</span><br></pre></td></tr></table></figure><h2 id="7-校验日期"><a href="#7-校验日期" class="headerlink" title="7. 校验日期"></a>7. 校验日期</h2><p>“yyyy-mm-dd” 格式的日期校验，已考虑平闰年。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reg = /^(?:(?!0000)[0-9]&#123;4&#125;-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]&#123;2&#125;(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$/;</span><br></pre></td></tr></table></figure><h2 id="8-校验金额"><a href="#8-校验金额" class="headerlink" title="8. 校验金额"></a>8. 校验金额</h2><p>金额校验，精确到2位小数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reg = /^[0-9]+(.[0-9]&#123;2&#125;)?$/;</span><br></pre></td></tr></table></figure><h2 id="9-校验手机号"><a href="#9-校验手机号" class="headerlink" title="9. 校验手机号"></a>9. 校验手机号</h2><p>下面是国内 13、15、18开头的手机号正则表达式。（可根据目前国内收集号扩展前两位开头号码）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reg = /^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d&#123;8&#125;$/;</span><br></pre></td></tr></table></figure><h2 id="10-判断IE的版本"><a href="#10-判断IE的版本" class="headerlink" title="10. 判断IE的版本"></a>10. 判断IE的版本</h2><p>IE目前还没被完全取代，很多页面还是需要做版本兼容，下面是IE版本检查的表达式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reg = /^.*MSIE [5-8](?:\\.[0-9]+)?(?!.*Trident\\\/[5-9]\\.0).*$/;</span><br></pre></td></tr></table></figure><h2 id="11-校验IP-v4地址"><a href="#11-校验IP-v4地址" class="headerlink" title="11. 校验IP-v4地址"></a>11. 校验IP-v4地址</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reg = /\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b/;</span><br></pre></td></tr></table></figure><h2 id="12-校验IP-v6地址"><a href="#12-校验IP-v6地址" class="headerlink" title="12. 校验IP-v6地址"></a>12. 校验IP-v6地址</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reg = /(([0-9a-fA-F]&#123;1,4&#125;:)&#123;7,7&#125;[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,7&#125;:|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,6&#125;:[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,5&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,2&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,3&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,3&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,2&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,5&#125;|[0-9a-fA-F]&#123;1,4&#125;:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,6&#125;)|:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,7&#125;|:)|fe80:(:[0-9a-fA-F]&#123;0,4&#125;)&#123;0,4&#125;%[0-9a-zA-Z]&#123;1,&#125;|::(ffff(:0&#123;1,4&#125;)&#123;0,1&#125;:)&#123;0,1&#125;((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;:((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9]))/;</span><br></pre></td></tr></table></figure><h2 id="13-检查URL的前缀"><a href="#13-检查URL的前缀" class="headerlink" title="13. 检查URL的前缀"></a>13. 检查URL的前缀</h2><p>应用开发中很多时候需要区分请求是HTTPS还是HTTP，通过下面的表达式可以取出一个url的前缀然后再逻辑判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (!s.match(/^[a-zA-Z]+:\/\//)) &#123;</span><br><span class="line">    s = &apos;http://&apos; + s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-提取URL链接"><a href="#14-提取URL链接" class="headerlink" title="14. 提取URL链接"></a>14. 提取URL链接</h2><p>下面的这个表达式可以筛选出一段文本中的URL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reg = /^(f|ht)&#123;1&#125;(tp|tps):\/\/([\w-]+\.)+[\w-]+(\/[\w- ./?%&amp;=]*)?/;</span><br></pre></td></tr></table></figure><h2 id="15-文件路径及扩展名校验"><a href="#15-文件路径及扩展名校验" class="headerlink" title="15. 文件路径及扩展名校验"></a>15. 文件路径及扩展名校验</h2><p>验证windows下文件路径和扩展名（下面的例子中为.txt文件）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reg = /^([a-zA-Z]\\:|\\\\)\\\\([^\\]+\\)*[^\\/:*?&quot;&lt;&gt;|]+\\.txt(l)?$/;</span><br></pre></td></tr></table></figure><h2 id="16-提取Color-Hex-Codes"><a href="#16-提取Color-Hex-Codes" class="headerlink" title="16. 提取Color Hex Codes"></a>16. 提取Color Hex Codes</h2><p>有时需要抽取网页中的颜色代码，可以使用下面的表达式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reg = /^#([A-Fa-f0-9]&#123;6&#125;|[A-Fa-f0-9]&#123;3&#125;)$/;</span><br></pre></td></tr></table></figure><h2 id="17-提取网页图片"><a href="#17-提取网页图片" class="headerlink" title="17. 提取网页图片"></a>17. 提取网页图片</h2><p>假若你想提取网页中所有图片信息，可以利用下面的表达式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reg = /\\&lt; *[img][^\\&gt;]*[src] *= *[\\&quot;\&apos;]&#123;0,1&#125;([^\\&quot;\&apos;\ &gt;]*)/;</span><br></pre></td></tr></table></figure><h2 id="18-提取页面超链接"><a href="#18-提取页面超链接" class="headerlink" title="18. 提取页面超链接"></a>18. 提取页面超链接</h2><p>提取html中的超链接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reg = /(&lt;a\\s*(?!.*\\brel=)[^&gt;]*)(href=&quot;https?:\/\/)((?!(?:(?:www\\.)?&apos;.implode(&apos;|(?:www\\.)?&apos;, $follow_list).&apos;))[^&quot;]+)&quot;((?!.*\\brel=)[^&gt;]*)(?:[^&gt;]*)&gt;/;</span><br></pre></td></tr></table></figure><h2 id="19-查找CSS属性"><a href="#19-查找CSS属性" class="headerlink" title="19. 查找CSS属性"></a>19. 查找CSS属性</h2><p>通过下面的表达式，可以搜索到相匹配的CSS属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reg = /^\\s*[a-zA-Z\\-]+\\s*[:]&#123;1&#125;\\s[a-zA-Z0-9\\s.#]+[;]&#123;1&#125;/;</span><br></pre></td></tr></table></figure><h2 id="20-抽取注释"><a href="#20-抽取注释" class="headerlink" title="20. 抽取注释"></a>20. 抽取注释</h2><p>如果你需要移除HMTL中的注释，可以使用如下的表达式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reg = /&lt;!--(.*?)--&gt;/;</span><br></pre></td></tr></table></figure><h2 id="21-转换千分位分隔符"><a href="#21-转换千分位分隔符" class="headerlink" title="21. 转换千分位分隔符"></a>21. 转换千分位分隔符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return total.toString().replace(/\B(?=(\d&#123;3&#125;)+$)/g, &apos;,&apos;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;收集在业务中经常使用的正则表达式实例，方便以后进行查找，减少工作量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000012806098#articleHe
      
    
    </summary>
    
      <category term="正则" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/categories/%E6%AD%A3%E5%88%99/"/>
    
    
      <category term="正则" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>常用正则表达式</title>
    <link href="https://zombrbrand.github.io/ZombieBrand.github.io/2019/03/17/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://zombrbrand.github.io/ZombieBrand.github.io/2019/03/17/常用正则表达式/</id>
    <published>2019-03-17T08:28:35.000Z</published>
    <updated>2019-03-17T08:29:34.596Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="https://whjin.github.io/2018/10/31/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%89%8B%E5%86%8C/" target="_blank" rel="noopener">正则表达式手册</a></p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td><code>\</code></td><td>将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“<code>n</code>”匹配字符“<code>n</code>”。“<code>\n</code>”匹配一个换行符。串行“<code>\\</code>”匹配“<code>\</code>”而“<code>\(</code>”则匹配“<code>(</code>”。</td></tr><tr><td><code>^</code></td><td>匹配输入字符串的开始位置。如果设置了<code>RegExp</code>对象的<code>Multiline</code>属性，<code>^</code>也匹配“<code>\n</code>”或“<code>\r</code>”之后的位置。</td></tr><tr><td><code>$</code></td><td>匹配输入字符串的结束位置。如果设置了<code>RegExp</code>对象的<code>Multiline</code>属性，<code>$</code>也匹配“<code>\n</code>”或“<code>\r</code>”之前的位置。</td></tr><tr><td><code>*</code></td><td>匹配前面的子表达式零次或多次。例如，<code>zo*</code>能匹配“<code>z</code>”以及“<code>zoo</code>”。<code>*</code>等价于<code>{0,}</code>。</td></tr><tr><td><code>+</code></td><td>匹配前面的子表达式一次或多次。例如，“<code>zo+</code>”能匹配“<code>zo</code>”以及“<code>zoo</code>”，但不能匹配“<code>z</code>”。<code>+</code>等价于<code>{1,}</code>。</td></tr><tr><td><code>?</code></td><td>匹配前面的子表达式零次或一次。例如，“<code>do(es)?</code>”可以匹配“<code>does</code>”或“<code>does</code>”中的“<code>do</code>”。<code>?</code>等价于<code>{0,1}</code>。</td></tr><tr><td><code>{n}</code></td><td><code>n</code>是一个非负整数。匹配确定的<code>n</code>次。例如，“<code>o{2}</code>”不能匹配“<code>Bob</code>”中的“<code>o</code>”，但是能匹配“<code>food</code>”中的两个<code>o</code>。</td></tr><tr><td><code>{n,}</code></td><td><code>n</code>是一个非负整数。至少匹配<code>n</code>次。例如，“<code>o{2,}</code>”不能匹配“<code>Bob</code>”中的“<code>o</code>”，但能匹配“<code>foooood</code>”中的所有<code>o</code>。“<code>o{1,}</code>”等价于“<code>o+</code>”。“<code>o{0,}</code>”则等价于“<code>o*</code>”。</td></tr><tr><td><code>{n,m}</code></td><td><code>m</code>和<code>n</code>均为非负整数，其中<code>n&lt;=m</code>。最少匹配<code>n</code>次且最多匹配<code>m</code>次。例如，“<code>o{1,3}</code>”将匹配“<code>fooooood</code>”中的前三个<code>o</code>。“<code>o{0,1}</code>”等价于“<code>o?</code>”。请注意在逗号和两个数之间不能有空格。</td></tr><tr><td><code>?</code></td><td>当该字符紧跟在任何一个其他限制符（<code>*</code>,<code>+</code>,<code>?</code>，<code>{n}</code>，<code>{n,}</code>，<code>{n,m}</code>）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“<code>oooo</code>”，“<code>o+?</code>”将匹配单个“<code>o</code>”，而“<code>o+</code>”将匹配所有“<code>o</code>”。</td></tr><tr><td><code>.</code></td><td>匹配除“<code>\n</code>”之外的任何单个字符。要匹配包括“<code>\n</code>”在内的任何字符，请使用像“<code>(.\n)</code>”的模式。</td></tr><tr><td><code>(pattern)</code></td><td>匹配<code>pattern</code>并获取这一匹配。所获取的匹配可以从产生的<code>Matches</code>集合得到，在<code>VBScript</code>中使用<code>SubMatches</code>集合，在<code>JScript</code>中则使用<code>$0…$9</code>属性。要匹配圆括号字符，请使用“<code>\(</code>”或“`</td><td>”。`</td></tr><tr><td><code>(?:pattern)</code></td><td>匹配<code>pattern</code>但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“`(</td><td>)<code>”来组合一个模式的各个部分是很有用。例如“</code>industr(?:y</td><td>ies)<code>”就是一个比“</code>industry</td><td>industries`”更简略的表达式。</td></tr><tr><td><code>(?=pattern)</code></td><td>正向肯定预查，在任何匹配<code>pattern</code>的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“`Windows(?=95</td><td>98</td><td>NT</td><td>2000)<code>”能匹配“</code>Windows2000<code>”中的“</code>Windows<code>”，但不能匹配“</code>Windows3.1<code>”中的“</code>Windows`”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td></tr><tr><td><code>(?!pattern)</code></td><td>正向否定预查，在任何不匹配<code>pattern</code>的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“`Windows(?!95</td><td>98</td><td>NT</td><td>2000)<code>”能匹配“</code>Windows3.1<code>”中的“</code>Windows<code>”，但不能匹配“</code>Windows2000<code>”中的“</code>Windows`”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td></tr><tr><td><code>(?&lt;=pattern)</code></td><td>反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“`(?&lt;=95</td><td>98</td><td>NT</td><td>2000)Windows<code>”能匹配“</code>2000Windows<code>”中的“</code>Windows<code>”，但不能匹配“</code>3.1Windows<code>”中的“</code>Windows`”。</td></tr><tr><td><code>(?&lt;!pattern)</code></td><td>反向否定预查，与正向否定预查类拟，只是方向相反。例如“`(?&lt;!95</td><td>98</td><td>NT</td><td>2000)Windows<code>”能匹配“</code>3.1Windows<code>”中的“</code>Windows<code>”，但不能匹配“</code>2000Windows<code>”中的“</code>Windows`”。</td></tr><tr><td>`x</td><td>y`</td><td>匹配<code>x</code>或<code>y</code>。例如，“`z</td><td>food<code>”能匹配“</code>z<code>”或“</code>food<code>”。“</code>(z</td><td>f)ood<code>”则匹配“</code>zood<code>”或“</code>food`”。</td></tr><tr><td><code>[xyz]</code></td><td>字符集合。匹配所包含的任意一个字符。例如，“<code>[abc]</code>”可以匹配“<code>plain</code>”中的“<code>a</code>”。</td></tr><tr><td><code>[^xyz]</code></td><td>负值字符集合。匹配未包含的任意字符。例如，“<code>[^abc]</code>”可以匹配“<code>plain</code>”中的“<code>p</code>”。</td></tr><tr><td><code>[a-z]</code></td><td>字符范围。匹配指定范围内的任意字符。例如，“<code>[a-z]</code>”可以匹配“<code>a</code>”到“<code>z</code>”范围内的任意小写字母字符。</td></tr><tr><td><code>[^a-z]</code></td><td>负值字符范围。匹配任何不在指定范围内的任意字符。例如，“<code>[^a-z]</code>”可以匹配任何不在“<code>a</code>”到“<code>z</code>”范围内的任意字符。</td></tr><tr><td><code>\b</code></td><td>匹配一个单词边界，也就是指单词和空格间的位置。例如，“<code>er\b</code>”可以匹配“<code>never</code>”中的“<code>er</code>”，但不能匹配“<code>verb</code>”中的“<code>er</code>”。</td></tr><tr><td><code>\B</code></td><td>匹配非单词边界。“<code>er\B</code>”能匹配“<code>verb</code>”中的“<code>er</code>”，但不能匹配“<code>never</code>”中的“<code>er</code>”。</td></tr><tr><td><code>\cx</code></td><td>匹配由<code>x</code>指明的控制字符。例如，<code>\cM</code>匹配一个<code>Control-M</code>或回车符。<code>x</code>的值必须为<code>A-Z</code>或<code>a-z</code>之一。否则，将c视为一个原义的“<code>c</code>”字符。</td></tr><tr><td><code>\d</code></td><td>匹配一个数字字符。等价于<code>[0-9]</code>。</td></tr><tr><td><code>\D</code></td><td>匹配一个非数字字符。等价于<code>[^0-9]</code>。</td></tr><tr><td><code>\f</code></td><td>匹配一个换页符。等价于<code>\x0c</code>和<code>\cL</code>。</td></tr><tr><td><code>\n</code></td><td>匹配一个换行符。等价于<code>\x0a</code>和<code>\cJ</code>。</td></tr><tr><td><code>\r</code></td><td>匹配一个回车符。等价于<code>\x0d</code>和<code>\cM</code>。</td></tr><tr><td><code>\s</code></td><td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于<code>[\f\n\r\t\v]</code>。</td></tr><tr><td><code>\S</code></td><td>匹配任何非空白字符。等价于<code>[^\f\n\r\t\v]</code>。</td></tr><tr><td><code>\t</code></td><td>匹配一个制表符。等价于<code>\x09</code>和<code>\cI</code>。</td></tr><tr><td><code>\v</code></td><td>匹配一个垂直制表符。等价于<code>\x0b</code>和<code>\cK</code>。</td></tr><tr><td><code>\w</code></td><td>匹配包括下划线的任何单词字符。等价于“<code>[A-Za-z0-9_]</code>”。</td></tr><tr><td><code>\W</code></td><td>匹配任何非单词字符。等价于“<code>[^A-Za-z0-9_]</code>”。</td></tr><tr><td><code>\xn</code></td><td>匹配<code>n</code>，其中<code>n</code>为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“<code>\x41</code>”匹配“<code>A</code>”。“<code>\x041</code>”则等价于“<code>\x04&amp;1</code>”。正则表达式中可以使用<code>ASCII</code>编码。</td></tr><tr><td><code>\num</code></td><td>匹配<code>num</code>，其中<code>num</code>是一个正整数。对所获取的匹配的引用。例如，“<code>(.)\1</code>”匹配两个连续的相同字符。</td></tr><tr><td><code>\n</code></td><td>标识一个八进制转义值或一个向后引用。如果<code>\n</code>之前至少<code>n</code>个获取的子表达式，则<code>n</code>为向后引用。否则，如果<code>n</code>为八进制数字（<code>0-7</code>），则<code>n</code>为一个八进制转义值。</td></tr><tr><td><code>\nm</code></td><td>标识一个八进制转义值或一个向后引用。如果<code>\nm</code>之前至少有<code>nm</code>个获得子表达式，则<code>nm</code>为向后引用。如果<code>\nm</code>之前至少有<code>n</code>个获取，则<code>n</code>为一个后跟文字<code>m</code>的向后引用。如果前面的条件都不满足，若<code>n</code>和<code>m</code>均为八进制数字（<code>0-7</code>），则<code>\nm</code>将匹配八进制转义值<code>nm</code>。</td></tr><tr><td><code>\nml</code></td><td>如果<code>n</code>为八进制数字（<code>0-3</code>），且<code>m</code>和<code>l</code>均为八进制数字（<code>0-7</code>），则匹配八进制转义值<code>nml</code>。</td></tr><tr><td><code>\un</code></td><td>匹配<code>n</code>，其中<code>n</code>是一个用四个十六进制数字表示的<code>Unicode</code>字符。例如，<code>\u00A9</code>匹配版权符号（<code>©</code>）。</td></tr></tbody></table><h1 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h1><table><thead><tr><th>匹配内容</th><th>正则表达式</th></tr></thead><tbody><tr><td>用户名</td><td><code>/^[a-z0-9_-]{3,16}$/</code></td></tr><tr><td>密码</td><td><code>/^[a-z0-9_-]{6,18}$/</code></td></tr><tr><td>十六进制值</td><td>`/^#?([a-f0-9]{6}</td><td>[a-f0-9]{3})$/`</td></tr><tr><td>电子邮箱</td><td><code>/^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,6})$/</code> <code>/^[a-z\d]+(\.[a-z\d]+)*@([\da-z](-[\da-z])?)+(\.{1,2}[a-z]+)+$/</code></td></tr><tr><td>URL</td><td><code>/^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/</code></td></tr><tr><td>IP 地址</td><td>`/((2[0-4]d</td><td>25[0-5]</td><td>[01]?dd?).){3}(2[0-4]d</td><td>25[0-5]</td><td>[01]?dd?)/<code></code>/^(?:(?:25[0-5]</td><td>20-4</td><td>[01]?0-9?).){3}(?:25[0-5]</td><td>20-4</td><td>[01]?0-9?)$/`</td></tr><tr><td>HTML标签</td><td>`/^&lt;([a-z]+)([^&lt;]+)<em>(?:&gt;(.</em>)</td><td>s+/&gt;)$/`</td></tr><tr><td>删除代码\注释</td><td>`(?&lt;!http:</td><td>S)//.*$`</td></tr><tr><td><code>Unicode</code>编码中的汉字范围</td><td><code>/^[\u2E80-\u9FFF]+$/</code></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文链接：&lt;a href=&quot;https://whjin.github.io/2018/10/31/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%89%8B%E5%86%8C/&quot; target=&quot;_blank&quot; rel=&quot;n
      
    
    </summary>
    
      <category term="正则" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/categories/%E6%AD%A3%E5%88%99/"/>
    
    
      <category term="正则" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>摘抄面向对象实战之拖拽对象封装</title>
    <link href="https://zombrbrand.github.io/ZombieBrand.github.io/2019/03/17/%E6%91%98%E6%8A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%AE%9E%E6%88%98%E4%B9%8B%E6%8B%96%E6%8B%BD%E5%AF%B9%E8%B1%A1%E5%B0%81%E8%A3%85/"/>
    <id>https://zombrbrand.github.io/ZombieBrand.github.io/2019/03/17/摘抄面向对象实战之拖拽对象封装/</id>
    <published>2019-03-17T08:20:30.000Z</published>
    <updated>2019-03-17T14:13:22.207Z</updated>
    
    <content type="html"><![CDATA[<p>前面几篇文章，我跟大家分享了JavaScript的一些基础知识，这篇文章，将会进入第一个实战环节：利用前面几章的所涉及到的知识，封装一个拖拽对象。为了能够帮助大家了解更多的方式与进行对比，我会使用三种不同的方式来实现拖拽。</p><ul><li>不封装对象直接实现；</li><li>利用原生JavaScript封装拖拽对象；</li><li>通过扩展jQuery来实现拖拽对象。</li></ul><blockquote><p>本文的例子会放置于<a href="http://codepen.io/" target="_blank" rel="noopener">codepen.io</a>中，供大家在阅读时直接查看。如果对于codepen不了解的同学，可以花点时间稍微了解一下。</p></blockquote><p>拖拽的实现过程会涉及到非常多的实用小知识，因此为了巩固我自己的知识积累，也为了大家能够学到更多的知识，我会尽量详细的将一些细节分享出来，相信大家认真阅读之后，一定能学到一些东西。</p><h6 id="1、如何让一个DOM元素动起来"><a href="#1、如何让一个DOM元素动起来" class="headerlink" title="1、如何让一个DOM元素动起来"></a>1、如何让一个DOM元素动起来</h6><p>我们常常会通过修改元素的<code>top，left，translate</code>来其的位置发生改变。在下面的例子中，每点击一次按钮，对应的元素就会移动5px。大家可点击查看。</p><p><a href="http://codepen.io/yangbo5207/pen/YZxGpO" target="_blank" rel="noopener">点击查看一个让元素动起来的小例子</a></p><blockquote><p>由于修改一个元素top/left值会引起页面重绘，而translate不会，因此从性能优化上来判断，我们会优先使用translate属性。</p></blockquote><h6 id="2、如何获取当前浏览器支持的transform兼容写法"><a href="#2、如何获取当前浏览器支持的transform兼容写法" class="headerlink" title="2、如何获取当前浏览器支持的transform兼容写法"></a>2、如何获取当前浏览器支持的transform兼容写法</h6><p>transform是css3的属性，当我们使用它时就不得不面对兼容性的问题。不同版本浏览器的兼容写法大致有如下几种：</p><p><code>[&#39;transform&#39;, &#39;webkitTransform&#39;, &#39;MozTransform&#39;, &#39;msTransform&#39;, &#39;OTransform&#39;]</code></p><p>因此我们需要判断当前浏览器环境支持的transform属性是哪一种，方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前浏览器支持的transform兼容写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTransform</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> transform = <span class="string">''</span>,</span><br><span class="line">        divStyle = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>).style,</span><br><span class="line">        <span class="comment">// 可能涉及到的几种兼容性写法，通过循环找出浏览器识别的那一个</span></span><br><span class="line">        transformArr = [<span class="string">'transform'</span>, <span class="string">'webkitTransform'</span>, <span class="string">'MozTransform'</span>, <span class="string">'msTransform'</span>, <span class="string">'OTransform'</span>],</span><br><span class="line"></span><br><span class="line">        i = <span class="number">0</span>,</span><br><span class="line">        len = transformArr.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(; i &lt; len; i++)  &#123;</span><br><span class="line">        <span class="keyword">if</span>(transformArr[i] <span class="keyword">in</span> divStyle) &#123;</span><br><span class="line">            <span class="comment">// 找到之后立即返回，结束函数</span></span><br><span class="line">            <span class="keyword">return</span> transform = transformArr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有找到，就直接返回空字符串</span></span><br><span class="line">    <span class="keyword">return</span> transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法用于获取浏览器支持的transform属性。如果返回的为空字符串，则表示当前浏览器并不支持transform，这个时候我们就需要使用left，top值来改变元素的位置。如果支持，就改变transform的值。</p><h6 id="3、-如何获取元素的初始位置"><a href="#3、-如何获取元素的初始位置" class="headerlink" title="3、 如何获取元素的初始位置"></a>3、 如何获取元素的初始位置</h6><p>我们首先需要获取到目标元素的初始位置，因此这里我们需要一个专门用来获取元素样式的功能函数。</p><p>但是获取元素样式在IE浏览器与其他浏览器有一些不同，因此我们需要一个兼容性的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStyle</span>(<span class="params">elem, property</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ie通过currentStyle来获取元素的样式，其他浏览器通过getComputedStyle来获取</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.defaultView.getComputedStyle ? <span class="built_in">document</span>.defaultView.getComputedStyle(elem, <span class="literal">false</span>)[property] : elem.currentStyle[property];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个方法之后，就可以开始动手写获取目标元素初始位置的方法了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTargetPos</span>(<span class="params">elem</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pos = &#123;<span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">var</span> transform = getTransform();</span><br><span class="line">    <span class="keyword">if</span>(transform) &#123;</span><br><span class="line">        <span class="keyword">var</span> transformValue = getStyle(elem, transform);</span><br><span class="line">        <span class="keyword">if</span>(transformValue == <span class="string">'none'</span>) &#123;</span><br><span class="line">            elem.style[transform] = <span class="string">'translate(0, 0)'</span>;</span><br><span class="line">            <span class="keyword">return</span> pos;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> temp = transformValue.match(<span class="regexp">/-?\d+/g</span>);</span><br><span class="line">            <span class="keyword">return</span> pos = &#123;</span><br><span class="line">                x: <span class="built_in">parseInt</span>(temp[<span class="number">4</span>].trim()),</span><br><span class="line">                y: <span class="built_in">parseInt</span>(temp[<span class="number">5</span>].trim())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(getStyle(elem, <span class="string">'position'</span>) == <span class="string">'static'</span>) &#123;</span><br><span class="line">            elem.style.position = <span class="string">'relative'</span>;</span><br><span class="line">            <span class="keyword">return</span> pos;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> x = <span class="built_in">parseInt</span>(getStyle(elem, <span class="string">'left'</span>) ? getStyle(elem, <span class="string">'left'</span>) : <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">var</span> y = <span class="built_in">parseInt</span>(getStyle(elem, <span class="string">'top'</span>) ? getStyle(elem, <span class="string">'top'</span>) : <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> pos = &#123;</span><br><span class="line">                x: x,</span><br><span class="line">                y: y</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在拖拽过程中，我们需要不停的设置目标元素的新位置，这样它才会移动起来，因此我们需要一个设置目标元素位置的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pos = &#123; x: 200, y: 100 &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setTargetPos</span>(<span class="params">elem, pos</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> transform = getTransform();</span><br><span class="line">    <span class="keyword">if</span>(transform) &#123;</span><br><span class="line">        elem.style[transform] = <span class="string">'translate('</span>+ pos.x +<span class="string">'px, '</span>+ pos.y +<span class="string">'px)'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        elem.style.left = pos.x + <span class="string">'px'</span>;</span><br><span class="line">        elem.style.top = pos.y + <span class="string">'px'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> elem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="5、我们需要用到哪些事件？"><a href="#5、我们需要用到哪些事件？" class="headerlink" title="5、我们需要用到哪些事件？"></a>5、我们需要用到哪些事件？</h6><p>在pc上的浏览器中，结合<code>mousedown、mousemove、mouseup</code>这三个事件可以帮助我们实现拖拽。</p><ul><li><code>mousedown</code> 鼠标按下时触发</li><li><code>mousemove</code> 鼠标按下后拖动时触发</li><li><code>mouseup</code> 鼠标松开时触发</li></ul><blockquote><p>而在移动端，分别与之对应的则是<code>touchstart、touchmove、touchend</code>。</p></blockquote><p>当我们将元素绑定这些事件时，有一个事件对象将会作为参数传递给回调函数，通过事件对象，我们可以获取到当前鼠标的精确位置，鼠标位置信息是实现拖拽的关键。</p><blockquote><p>事件对象十分重要，其中包含了非常多的有用的信息，这里我就不扩展了，大家可以在函数中将事件对象打印出来查看其中的具体属性，这个方法对于记不清事件对象重要属性的童鞋非常有用。</p></blockquote><h6 id="6、拖拽的原理"><a href="#6、拖拽的原理" class="headerlink" title="6、拖拽的原理"></a>6、拖拽的原理</h6><p>当事件触发时，我们可以通过事件对象获取到鼠标的精切位置。这是实现拖拽的关键。当鼠标按下(mousedown触发)时，我们需要记住鼠标的初始位置与目标元素的初始位置，我们的目标就是实现当鼠标移动时，目标元素也跟着移动，根据常理我们可以得出如下关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">移动后的鼠标位置 - 鼠标初始位置 = 移动后的目标元素位置 - 目标元素的初始位置</span><br></pre></td></tr></table></figure><p>如果鼠标位置的差值我们用dis来表示，那么目标元素的位置就等于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">移动后目标元素的位置 = dis + 目标元素的初始位置</span><br></pre></td></tr></table></figure><p>通过事件对象，我们可以精确的知道鼠标的当前位置，因此当鼠标拖动(mousemove)时，我们可以不停的计算出鼠标移动的差值，以此来求出目标元素的当前位置。这个过程，就实现了拖拽。</p><p>而在鼠标松开(mouseup)结束拖拽时，我们需要处理一些收尾工作。详情见代码。</p><h6 id="7、-我又来推荐思维导图辅助写代码了"><a href="#7、-我又来推荐思维导图辅助写代码了" class="headerlink" title="7、 我又来推荐思维导图辅助写代码了"></a>7、 我又来推荐思维导图辅助写代码了</h6><p>常常有新人朋友跑来问我，如果逻辑思维能力不强，能不能写代码做前端。我的答案是：能。因为借助思维导图，可以很轻松的弥补逻辑的短板。而且比在自己头脑中脑补逻辑更加清晰明了，不易出错。</p><p>上面第六点我介绍了原理，因此如何做就显得不是那么难了，而具体的步骤，则在下面的思维导图中明确给出，我们只需要按照这个步骤来写代码即可，试试看，一定很轻松。</p><p><img src="/ZombieBrand.github.io/assets/599584-6137a359597879a5.png" alt="使用思维导图清晰的表达出整个拖拽过程我们需要干的事情"></p><h6 id="8、代码实现"><a href="#8、代码实现" class="headerlink" title="8、代码实现"></a>8、代码实现</h6><p><strong>part1、准备工作</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取目标元素对象</span></span><br><span class="line"><span class="keyword">var</span> oElem = <span class="built_in">document</span>.getElementById(<span class="string">'target'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明2个变量用来保存鼠标初始位置的x，y坐标</span></span><br><span class="line"><span class="keyword">var</span> startX = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> startY = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明2个变量用来保存目标元素初始位置的x，y坐标</span></span><br><span class="line"><span class="keyword">var</span> sourceX = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> sourceY = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><strong>part2、功能函数</strong></p><p>因为之前已经贴过代码，就不再重复</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前浏览器支持的transform兼容写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTransform</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取元素属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStyle</span>(<span class="params">elem, property</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取元素的初始位置</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTargetPos</span>(<span class="params">elem</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置元素的初始位置</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setTargetPos</span>(<span class="params">elem, potions</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>part3、声明三个事件的回调函数</strong></p><p>这三个方法就是实现拖拽的核心所在，我将严格按照上面思维导图中的步骤来完成我们的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定在mousedown上的回调，event为传入的事件对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取鼠标初始位置</span></span><br><span class="line">    startX = event.pageX;</span><br><span class="line">    startY = event.pageY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取元素初始位置</span></span><br><span class="line">    <span class="keyword">var</span> pos = getTargetPos(oElem);</span><br><span class="line"></span><br><span class="line">    sourceX = pos.x;</span><br><span class="line">    sourceY = pos.y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">'mousemove'</span>, move, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">'mouseup'</span>, end, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取鼠标当前位置</span></span><br><span class="line">    <span class="keyword">var</span> currentX = event.pageX;</span><br><span class="line">    <span class="keyword">var</span> currentY = event.pageY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算差值</span></span><br><span class="line">    <span class="keyword">var</span> distanceX = currentX - startX;</span><br><span class="line">    <span class="keyword">var</span> distanceY = currentY - startY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算并设置元素当前位置</span></span><br><span class="line">    setTargetPos(oElem, &#123;</span><br><span class="line">        x: (sourceX + distanceX).toFixed(),</span><br><span class="line">        y: (sourceY + distanceY).toFixed()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">end</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.removeEventListener(<span class="string">'mousemove'</span>, move);</span><br><span class="line">    <span class="built_in">document</span>.removeEventListener(<span class="string">'mouseup'</span>, end);</span><br><span class="line">    <span class="comment">// do other things</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，一个简单的拖拽，就这样愉快的实现了。点击下面的链接，可以在线查看该例子的demo。</p><p><a href="http://codepen.io/yangbo5207/pen/WpEoyd" target="_blank" rel="noopener">使用原生js实现拖拽</a></p><h6 id="9、封装拖拽对象"><a href="#9、封装拖拽对象" class="headerlink" title="9、封装拖拽对象"></a>9、封装拖拽对象</h6><p>在前面一章我给大家分享了面向对象如何实现，基于那些基础知识，我们来将上面实现的拖拽封装为一个拖拽对象。我们的目标是，只要我们声明一个拖拽实例，那么传入的目标元素将自动具备可以被拖拽的功能。</p><p>在实际开发中，一个对象我们常常会单独放在一个js文件中，这个js文件将单独作为一个模块，利用各种模块的方式组织起来使用。当然这里没有复杂的模块交互，因为这个例子，我们只需要一个模块即可。</p><p>为了避免变量污染，我们需要将模块放置于一个函数自执行方式模拟的块级作用域中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><blockquote><p>在普通的模块组织中，我们只是单纯的将许多js文件压缩成为一个js文件，因此此处的第一个分号则是为了防止上一个模块的结尾不用分号导致报错。必不可少。当然在通过require或者ES6模块等方式就不会出现这样的情况。</p></blockquote><p>我们知道，在封装一个对象的时候，我们可以将属性与方法放置于构造函数或者原型中，而在增加了自执行函数之后，我们又可以将属性和方法防止与模块的内部作用域。这是闭包的知识。</p><p><strong>那么我们面临的挑战就在于，如何合理的处理属性与方法的位置。</strong></p><p>当然，每一个对象的情况都不一样，不能一概而论，我们需要清晰的知道这三种位置的特性才能做出最适合的决定。</p><ul><li>构造函数中： 属性与方法为当前实例单独拥有，只能被当前实例访问，并且每声明一个实例，其中的方法都会被重新创建一次。</li><li>原型中： 属性与方法为所有实例共同拥有，可以被所有实例访问，新声明实例不会重复创建方法。</li><li>模块作用域中：属性和方法不能被任何实例访问，但是能被内部方法访问，新声明的实例，不会重复创建相同的方法。</li></ul><p>对于方法的判断比较简单。</p><p>因为在构造函数中的方法总会在声明一个新的实例时被重复创建，因此我们声明的方法都尽量避免出现在构造函数中。</p><p>而如果你的方法中需要用到构造函数中的变量，或者想要公开，那就需要放在原型中。</p><p>如果方法需要私有不被外界访问，那么就放置在模块作用域中。</p><p>对于属性放置于什么位置有的时候很难做出正确的判断，因此我很难给出一个准确的定义告诉你什么属性一定要放在什么位置，这需要在实际开发中不断的总结经验。但是总的来说，仍然要结合这三个位置的特性来做出最合适的判断。</p><p>如果属性值只能被实例单独拥有，比如person对象的name，只能属于某一个person实例，又比如这里拖拽对象中，某一个元素的初始位置，也仅仅只是这个元素的当前位置，这个属性，则适合放在构造函数中。</p><p>而如果一个属性仅仅供内部方法访问，这个属性就适合放在模块作用域中。</p><blockquote><p>关于面向对象，上面的几点思考我认为是这篇文章最值得认真思考的精华。如果在封装时没有思考清楚，很可能会遇到很多你意想不到的bug，所以建议大家结合自己的开发经验，多多思考，总结出自己的观点。</p></blockquote><p>根据这些思考，大家可以自己尝试封装一下。然后与我的做一些对比，看看我们的想法有什么不同，在下面例子的注释中，我将自己的想法表达出来。</p><p><a href="http://codepen.io/yangbo5207/pen/LWjWpe" target="_blank" rel="noopener">点击查看已经封装好的demo</a></p><p>js 源码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这是一个私有属性，不需要被实例访问</span></span><br><span class="line">    <span class="keyword">var</span> transform = getTransform();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Drag</span>(<span class="params">selector</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 放在构造函数中的属性，都是属于每一个实例单独拥有</span></span><br><span class="line">        <span class="keyword">this</span>.elem = <span class="keyword">typeof</span> selector == <span class="string">'Object'</span> ? selector : <span class="built_in">document</span>.getElementById(selector);</span><br><span class="line">        <span class="keyword">this</span>.startX = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.startY = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.sourceX = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.sourceY = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原型</span></span><br><span class="line">    Drag.prototype = &#123;</span><br><span class="line">        <span class="keyword">constructor</span>: Drag,</span><br><span class="line"></span><br><span class="line">        init: function() &#123;</span><br><span class="line">            <span class="comment">// 初始时需要做些什么事情</span></span><br><span class="line">            <span class="keyword">this</span>.setDrag();</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 稍作改造，仅用于获取当前元素的属性，类似于getName</span></span><br><span class="line">        getStyle: <span class="function"><span class="keyword">function</span>(<span class="params">property</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">document</span>.defaultView.getComputedStyle ? <span class="built_in">document</span>.defaultView.getComputedStyle(<span class="keyword">this</span>.elem, <span class="literal">false</span>)[property] : <span class="keyword">this</span>.elem.currentStyle[property];</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用来获取当前元素的位置信息，注意与之前的不同之处</span></span><br><span class="line">        getPosition: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> pos = &#123;<span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">if</span>(transform) &#123;</span><br><span class="line">                <span class="keyword">var</span> transformValue = <span class="keyword">this</span>.getStyle(transform);</span><br><span class="line">                <span class="keyword">if</span>(transformValue == <span class="string">'none'</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.elem.style[transform] = <span class="string">'translate(0, 0)'</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">var</span> temp = transformValue.match(<span class="regexp">/-?\d+/g</span>);</span><br><span class="line">                    pos = &#123;</span><br><span class="line">                        x: <span class="built_in">parseInt</span>(temp[<span class="number">4</span>].trim()),</span><br><span class="line">                        y: <span class="built_in">parseInt</span>(temp[<span class="number">5</span>].trim())</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.getStyle(<span class="string">'position'</span>) == <span class="string">'static'</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.elem.style.position = <span class="string">'relative'</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    pos = &#123;</span><br><span class="line">                        x: <span class="built_in">parseInt</span>(<span class="keyword">this</span>.getStyle(<span class="string">'left'</span>) ? <span class="keyword">this</span>.getStyle(<span class="string">'left'</span>) : <span class="number">0</span>),</span><br><span class="line">                        y: <span class="built_in">parseInt</span>(<span class="keyword">this</span>.getStyle(<span class="string">'top'</span>) ? <span class="keyword">this</span>.getStyle(<span class="string">'top'</span>) : <span class="number">0</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> pos;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用来设置当前元素的位置</span></span><br><span class="line">        setPostion: <span class="function"><span class="keyword">function</span>(<span class="params">pos</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(transform) &#123;</span><br><span class="line">                <span class="keyword">this</span>.elem.style[transform] = <span class="string">'translate('</span>+ pos.x +<span class="string">'px, '</span>+ pos.y +<span class="string">'px)'</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.elem.style.left = pos.x + <span class="string">'px'</span>;</span><br><span class="line">                <span class="keyword">this</span>.elem.style.top = pos.y + <span class="string">'px'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该方法用来绑定事件</span></span><br><span class="line">        setDrag: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">this</span>.elem.addEventListener(<span class="string">'mousedown'</span>, start, <span class="literal">false</span>);</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">                self.startX = event.pageX;</span><br><span class="line">                self.startY = event.pageY;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> pos = self.getPosition();</span><br><span class="line"></span><br><span class="line">                self.sourceX = pos.x;</span><br><span class="line">                self.sourceY = pos.y;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">document</span>.addEventListener(<span class="string">'mousemove'</span>, move, <span class="literal">false</span>);</span><br><span class="line">                <span class="built_in">document</span>.addEventListener(<span class="string">'mouseup'</span>, end, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> currentX = event.pageX;</span><br><span class="line">                <span class="keyword">var</span> currentY = event.pageY;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> distanceX = currentX - self.startX;</span><br><span class="line">                <span class="keyword">var</span> distanceY = currentY - self.startY;</span><br><span class="line"></span><br><span class="line">                self.setPostion(&#123;</span><br><span class="line">                    x: (self.sourceX + distanceX).toFixed(),</span><br><span class="line">                    y: (self.sourceY + distanceY).toFixed()</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">end</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">document</span>.removeEventListener(<span class="string">'mousemove'</span>, move);</span><br><span class="line">                <span class="built_in">document</span>.removeEventListener(<span class="string">'mouseup'</span>, end);</span><br><span class="line">                <span class="comment">// do other things</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有方法，仅仅用来获取transform的兼容写法</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getTransform</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> transform = <span class="string">''</span>,</span><br><span class="line">            divStyle = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>).style,</span><br><span class="line">            transformArr = [<span class="string">'transform'</span>, <span class="string">'webkitTransform'</span>, <span class="string">'MozTransform'</span>, <span class="string">'msTransform'</span>, <span class="string">'OTransform'</span>],</span><br><span class="line"></span><br><span class="line">            i = <span class="number">0</span>,</span><br><span class="line">            len = transformArr.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(; i &lt; len; i++)  &#123;</span><br><span class="line">            <span class="keyword">if</span>(transformArr[i] <span class="keyword">in</span> divStyle) &#123;</span><br><span class="line">                <span class="keyword">return</span> transform = transformArr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> transform;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一种对外暴露的方式</span></span><br><span class="line">    <span class="built_in">window</span>.Drag = Drag;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用：声明2个拖拽实例</span></span><br><span class="line"><span class="keyword">new</span> Drag(<span class="string">'target'</span>);</span><br><span class="line"><span class="keyword">new</span> Drag(<span class="string">'target2'</span>);</span><br></pre></td></tr></table></figure><p>这样一个拖拽对象就封装完毕了。</p><p>建议大家根据我提供的思维方式，多多尝试封装一些组件。比如封装一个弹窗，封装一个循环轮播等。练得多了，面向对象就不再是问题了。这种思维方式，在未来任何时候都是能够用到的。</p><p>下一章分析jQuery对象的实现，与如何将我们这里封装的拖拽对象扩展为jQuery插件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面几篇文章，我跟大家分享了JavaScript的一些基础知识，这篇文章，将会进入第一个实战环节：利用前面几章的所涉及到的知识，封装一个拖拽对象。为了能够帮助大家了解更多的方式与进行对比，我会使用三种不同的方式来实现拖拽。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不封装对象直接实现；&lt;/
      
    
    </summary>
    
      <category term="面向对象" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
      <category term="拖拽对象" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/tags/%E6%8B%96%E6%8B%BD%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="面向对象" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>摘抄面向对象</title>
    <link href="https://zombrbrand.github.io/ZombieBrand.github.io/2019/03/17/%E6%91%98%E6%8A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://zombrbrand.github.io/ZombieBrand.github.io/2019/03/17/摘抄面向对象/</id>
    <published>2019-03-17T08:20:09.000Z</published>
    <updated>2019-03-17T14:13:17.916Z</updated>
    
    <content type="html"><![CDATA[<p>如果要我总结一下学习前端以来我遇到了哪些瓶颈，那么面向对象一定是第一个毫不犹豫想到的。尽管我现在对于面向对象有了一些的了解，但是当初的那种似懂非懂的痛苦，依然历历在目。</p><p>为了帮助大家能够更加直观的学习和了解面向对象，我会用尽量简单易懂的描述来展示面向对象的相关知识。并且也准备了一些实用的例子帮助大家更加快速的掌握面向对象的真谛。</p><ul><li>jQuery的面向对象实现</li><li>封装拖拽</li><li>简易版运动框架封装</li></ul><p>这可能会花一点时间，但是却值得期待。所以如果有兴趣的朋友可以来简书和公众号关注我。</p><p>而这篇文章主要来聊一聊关于面向对象的一些重要的基本功。</p><h5 id="一、对象的定义"><a href="#一、对象的定义" class="headerlink" title="一、对象的定义"></a>一、对象的定义</h5><p>在ECMAScript-262中，对象被定义为<strong>“无序属性的集合，其属性可以包含基本值，对象或者函数”</strong>。</p><p>也就是说，在JavaScript中，对象无非就是由一些列无序的<code>key-value</code>对组成。其中value可以是基本值，对象或者函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的person就是一个对象</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    parent: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h6><p>我们可以通过new的方式创建一个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure><p>也可以通过对象字面量的形式创建一个简单的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>当我们想要给我们创建的简单对象添加方法时，可以这样表示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以这样</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line">person.name = <span class="string">"TOM"</span>;</span><br><span class="line">person.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以这样</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"TOM"</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="访问对象的属性和方法"><a href="#访问对象的属性和方法" class="headerlink" title="访问对象的属性和方法"></a>访问对象的属性和方法</h6><p>假如我们有一个简单的对象如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'TOM'</span>,</span><br><span class="line">    age: <span class="string">'20'</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们想要访问他的name属性时，可以用如下两种方式访问。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person.name</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">person[<span class="string">'name'</span>]</span><br></pre></td></tr></table></figure><p>如果我们想要访问的属性名是一个变量时，常常会使用第二种方式。例如我们要同时访问person的name与age，可以这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'name'</span>, <span class="string">'age'</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(person[item]);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>这种方式一定要重视，记住它以后在我们处理复杂数据的时候会有很大的帮助。</p></blockquote><h5 id="二、工厂模式"><a href="#二、工厂模式" class="headerlink" title="二、工厂模式"></a>二、工厂模式</h5><p>使用上面的方式创建对象很简单，但是在很多时候并不能满足我们的需求。就以person对象为例。假如我们在实际开发中，不仅仅需要一个名字叫做TOM的person对象，同时还需要另外一个名为Jake的person对象，虽然他们有很多相似之处，但是我们不得不重复写两次。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> perTom = &#123;</span><br><span class="line">    name: <span class="string">'TOM'</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> perJake = &#123;</span><br><span class="line">    name: <span class="string">'Jake'</span>,</span><br><span class="line">    age: <span class="number">22</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然这并不是合理的方式，当相似对象太多时，大家都会崩溃掉。</p><p>我们可以使用工厂模式的方式解决这个问题。顾名思义，工厂模式就是我们提供一个模子，然后通过这个模子复制出我们需要的对象。我们需要多少个，就复制多少个。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> createPerson = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个中间对象，该对象就是工厂模式的模子</span></span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次添加我们需要的属性与方法</span></span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建两个实例</span></span><br><span class="line"><span class="keyword">var</span> perTom = createPerson(<span class="string">'TOM'</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">var</span> PerJake = createPerson(<span class="string">'Jake'</span>, <span class="number">22</span>);</span><br></pre></td></tr></table></figure><p>相信上面的代码并不难理解，也不用把工厂模式看得太过高大上。很显然，工厂模式帮助我们解决了重复代码上的麻烦，让我们可以写很少的代码，就能够创建很多个person对象。但是这里还有两个麻烦，需要我们注意。</p><p>第一个麻烦就是这样处理，我们没有办法识别对象实例的类型。使用instanceof可以识别对象的类型，如下例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(foo <span class="keyword">instanceof</span> <span class="built_in">Function</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>因此在工厂模式的基础上，我们需要使用构造函数的方式来解决这个麻烦。</p><h5 id="三、构造函数"><a href="#三、构造函数" class="headerlink" title="三、构造函数"></a>三、构造函数</h5><p>在JavaScript中，new关键字可以让一个函数变得与众不同。通过下面的例子，我们来一探new关键字的神奇之处。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">demo();  <span class="comment">// window</span></span><br><span class="line"><span class="keyword">new</span> demo();  <span class="comment">// demo</span></span><br></pre></td></tr></table></figure><p>为了能够直观的感受他们不同，建议大家动手实践观察一下。很显然，使用new之后，函数内部发生了一些变化，让this指向改变。那么new关键字到底做了什么事情呢。嗯，其实我之前在文章里用文字大概表达了一下new到底干了什么，但是一些同学好奇心很足，总期望用代码实现一下，我就大概以我的理解来表达一下吧。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先一本正经的创建一个构造函数，其实该函数与普通函数并无区别</span></span><br><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将构造函数以参数形式传入</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">New</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个中间对象，该对象为最终返回的实例</span></span><br><span class="line">    <span class="keyword">var</span> res = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (func.prototype !== <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将实例的原型指向构造函数的原型</span></span><br><span class="line">        res.__proto__ = func.prototype;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ret为构造函数执行的结果，这里通过apply，将构造函数内部的this指向修改为指向res，即为实例对象</span></span><br><span class="line">    <span class="keyword">var</span> ret = func.apply(res, <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当我们在构造函数中明确指定了返回对象时，那么new的执行结果就是该返回对象</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">typeof</span> ret === <span class="string">"object"</span> || <span class="keyword">typeof</span> ret === <span class="string">"function"</span>) &amp;&amp; ret !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有明确指定返回对象，则默认返回res，这个res就是实例对象</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过new声明创建实例，这里的p1，实际接收的正是new中返回的res</span></span><br><span class="line"><span class="keyword">var</span> p1 = New(Person, <span class="string">'tom'</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1.getName());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然，这里也可以判断出实例的类型了</span></span><br><span class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>JavaScript内部再通过其他的一些特殊处理，将<code>var p1 = New(Person, &#39;tom&#39;, 20);</code> 等效于<code>var p1 = new Person(&#39;tom&#39;, 20);</code>。就是我们认识的new关键字了。具体怎么处理的，我也不知道，别刨根问底了，一直回答下去太难 - -！</p></blockquote><p>老实讲，你可能很难在其他地方看到有如此明确的告诉你new关键字到底对构造函数干了什么的文章了。理解了这段代码，你对JavaScript的理解又比别人深刻了一分，所以，一本正经厚颜无耻求个赞可好？</p><p>当然，很多朋友由于对于前面几篇文章的知识理解不够到位，会对new的实现表示非常困惑。但是老实讲，如果你读了我的前面几篇文章，一定会对这里new的实现有似曾相识的感觉。而且我这里已经尽力做了详细的注解，剩下的只能靠你自己了。</p><p>但是只要你花点时间，理解了他的原理，那么困扰了无数人的构造函数中this到底指向谁就变得非常简单了。</p><p>所以，为了能够判断实例与对象的关系，我们就使用构造函数来搞定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'Ness'</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1.getName());  <span class="comment">// Ness</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>关于构造函数，如果你暂时不能够理解new的具体实现，就先记住下面这几个结论吧。</p><ul><li>与普通函数相比，构造函数并没有任何特别的地方，首字母大写只是我们约定的小规定，用于区分普通函数；</li><li>new关键字让构造函数具有了与普通函数不同的许多特点，而new的过程中，执行了如下过程：<ol><li>声明一个中间对象；</li><li>将该中间对象的原型指向构造函数的原型；</li><li>将构造函数的this，指向该中间对象；</li><li>返回该中间对象，即返回实例对象。</li></ol></li></ul><h5 id="四、原型"><a href="#四、原型" class="headerlink" title="四、原型"></a>四、原型</h5><p>虽然构造函数解决了判断实例类型的问题，但是，说到底，还是一个对象的复制过程。跟工厂模式颇有相似之处。也就是说，当我们声明了100个person对象，那么就有100个getName方法被重新生成。</p><p>这里的每一个getName方法实现的功能其实是一模一样的，但是由于分别属于不同的实例，就不得不一直不停的为getName分配空间。这就是工厂模式存在的第二个麻烦。</p><p>显然这是不合理的。我们期望的是，既然都是实现同一个功能，那么能不能就让每一个实例对象都访问同一个方法？</p><p>当然能，这就是原型对象要帮我们解决的问题了。</p><p>我们创建的每一个函数，都可以有一个prototype属性，该属性指向一个对象。这个对象，就是我们这里说的原型。</p><p>当我们在创建对象时，可以根据自己的需求，选择性的将一些属性和方法通过prototype属性，挂载在原型对象上。而每一个new出来的实例，都有一个<code>__proto__</code>属性，该属性指向构造函数的原型对象，通过这个属性，让实例对象也能够访问原型对象上的方法。因此，当所有的实例都能够通过<code>__proto__</code>访问到原型对象时，原型对象的方法与属性就变成了共有方法与属性。</p><p>我们通过一个简单的例子与图示，来了解构造函数，实例与原型三者之间的关系。</p><blockquote><p>由于每个函数都可以是构造函数，每个对象都可以是原型对象，因此如果在理解原型之初就想的太多太复杂的话，反而会阻碍你的理解，这里我们要学会先简化它们。就单纯的剖析这三者的关系。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过prototye属性，将方法挂载到原型对象上</span></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'tim'</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">'jak'</span>, <span class="number">22</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1.getName === p2.getName); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><img src="/ZombieBrand.github.io/assets/599584-2fc7dad23d112791.png" alt="图示"></p><p>通过图示我们可以看出，构造函数的prototype与所有实例对象的<code>__proto__</code>都指向原型对象。而原型对象的constructor指向构造函数。</p><p>除此之外，还可以从图中看出，实例对象实际上对前面我们所说的中间对象的复制，而中间对象中的属性与方法都在构造函数中添加。于是根据构造函数与原型的特性，我们就可以将在构造函数中，通过this声明的属性与方法称为私有变量与方法，它们被当前被某一个实例对象所独有。而通过原型声明的属性与方法，我们可以称之为共有属性与方法，它们可以被所有的实例对象访问。</p><p><strong>当我们访问实例对象中的属性或者方法时，会优先访问实例对象自身的属性和方法。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'this is constructor.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'tim'</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">p1.getName(); <span class="comment">// this is constructor.</span></span><br></pre></td></tr></table></figure><p>在这个例子中，我们同时在原型与构造函数中都声明了一个getName函数，运行代码的结果表示原型中的访问并没有被访问。</p><p>我们还可以通过in来判断，一个对象是否拥有某一个属性/方法，无论是该属性/方法存在与实例对象还是原型对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'tim'</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'name'</span> <span class="keyword">in</span> p1); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>in的这种特性最常用的场景之一，就是判断当前页面是否在移动端打开。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">isMobile = <span class="string">'ontouchstart'</span> <span class="keyword">in</span> <span class="built_in">document</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 很多人喜欢用浏览器UA的方式来判断，但并不是很好的方式</span></span><br></pre></td></tr></table></figure><p><strong> 更简单的原型写法 </strong></p><p>根据前面例子的写法，如果我们要在原型上添加更多的方法，可以这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure><p>除此之外，我还可以使用更为简单的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    getName: function() &#123;&#125;,</span><br><span class="line">    getAge: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    sayHello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种字面量的写法看上去简单很多，但是有一个需要特别注意的地方。<code>Person.prototype = {}</code>实际上是重新创建了一个<code>{}</code>对象并赋值给Person.prototype，这里的<code>{}</code>并不是最初的那个原型对象。因此它里面并不包含<code>constructor</code>属性。为了保证正确性，我们必须在新创建的<code>{}</code>对象中显示的设置<code>constructor</code>的指向。即上面的<code>constructor: Person</code>。</p><h5 id="五、原型链"><a href="#五、原型链" class="headerlink" title="五、原型链"></a>五、原型链</h5><p>原型对象其实也是普通的对象。几乎所有的对象都可能是原型对象，也可能是实例对象，而且还可以同时是原型对象与实例对象。这样的一个对象，正是构成原型链的一个节点。因此理解了原型，那么原型链并不是一个多么复杂的概念。</p><p>我们知道所有的函数都有一个叫做toString的方法。那么这个方法到底是在哪里的呢？</p><p>先随意声明一个函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>那么我们可以用如下的图来表示这个函数的原型链。</p><p><img src="/ZombieBrand.github.io/assets/599584-f4ca22c5db668eaf.png" alt="原型链"></p><p>其中add是Function对象的实例。而Function的原型对象同时又是Object原型的实例。这样就构成了一条原型链。原型链的访问，其实跟作用域链有很大的相似之处，他们都是一次单向的查找过程。因此实例对象能够通过原型链，访问到处于原型链上对象的所有属性与方法。这也是foo最终能够访问到处于Object原型对象上的toString方法的原因。</p><p>基于原型链的特性，我们可以很轻松的实现<strong>继承</strong>。</p><h5 id="六、继承"><a href="#六、继承" class="headerlink" title="六、继承"></a>六、继承</h5><p>我们常常结合构造函数与原型来创建一个对象。因为构造函数与原型的不同特性，分别解决了我们不同的困扰。因此当我们想要实现继承时，就必须得根据构造函数与原型的不同而采取不同的策略。</p><p>我们声明一个Person对象，该对象将作为父级，而子级cPerson将要继承Person的所有属性与方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们来看构造函数的继承。在上面我们已经理解了构造函数的本质，它其实是在new内部实现的一个复制过程。而我们在继承时想要的，就是想父级构造函数中的操作在子级的构造函数中重现一遍即可。我们可以通过call方法来达到目的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数的继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>, name, age);</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而原型的继承，则只需要将子级的原型对象设置为父级的一个实例，加入到原型链中即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承原型</span></span><br><span class="line">cPerson.prototype = <span class="keyword">new</span> Person(name, age);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加更多方法</span></span><br><span class="line">cPerson.prototype.getLive = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><img src="/ZombieBrand.github.io/assets/599584-c77eb714f66b8185.png" alt="原型链"></p><p>当然关于继承还有更好的方式。</p><h5 id="七、更好的继承"><a href="#七、更好的继承" class="headerlink" title="七、更好的继承"></a>七、更好的继承</h5><p>假设原型链的终点<code>Object.prototype</code>为原型链的E(end)端，原型链的起点为S(start)端。</p><p>通过前面原型链的学习我们知道，处于S端的对象，可以通过S -&gt; E的单向查找，访问到原型链上的所有方法与属性。因此这给继承提供了理论基础。我们只需要在S端添加新的对象，那么新对象就能够通过原型链访问到父级的方法与属性。因此想要实现继承，是一件非常简单的事情。</p><p>因为封装一个对象由构造函数与原型共同组成，因此继承也会分别有构造函数的继承与原型的继承。</p><p>假设我们已经封装好了一个父类对象Person。如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数的继承比较简单，我们可以借助call/apply来实现。假设我们要通过继承封装一个Student的子类对象。那么构造函数可以如下实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Student = <span class="function"><span class="keyword">function</span>(<span class="params">name, age, grade</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通过call方法还原Person构造函数中的所有处理逻辑</span></span><br><span class="line">    Student.call(Person, name, age);</span><br><span class="line">    <span class="keyword">this</span>.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> Student = <span class="function"><span class="keyword">function</span>(<span class="params">name, age, grade</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.grade = grade;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原型的继承则稍微需要一点思考。首先我们应该考虑，如何将子类对象的原型加入到原型链中？我们只需要让子类对象的原型，成为父类对象的一个实例，然后通过<code>__proto__</code>就可以访问父类对象的原型。这样就继承了父类原型中的方法与属性了。</p><p>因此我们可以先封装一个方法，该方法根据父类对象的原型创建一个实例，该实例将会作为子类对象的原型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">proto, options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空对象</span></span><br><span class="line">    <span class="keyword">var</span> tmp = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让这个新的空对象成为父类对象的实例</span></span><br><span class="line">    tmp.__proto__ = proto;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入的方法都挂载到新对象上，新的对象将作为子类对象的原型</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperties(tmp, options);</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单封装了<code>create</code>对象之后，我们就可以使用该方法来实现原型的继承了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Student.prototype = create(Person.prototype, &#123;</span><br><span class="line">    <span class="comment">// 不要忘了重新指定构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>: &#123;</span><br><span class="line">        value: Student</span><br><span class="line">    &#125;</span><br><span class="line">    getGrade: &#123;</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.grade</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>那么我们来验证一下我们这里实现的继承是否正确。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> Student(<span class="string">'ming'</span>, <span class="number">22</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s1.getName());  <span class="comment">// ming</span></span><br><span class="line"><span class="built_in">console</span>.log(s1.getAge());   <span class="comment">// 22</span></span><br><span class="line"><span class="built_in">console</span>.log(s1.getGrade()); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>全部都能正常访问，没问题。在ECMAScript5中直接提供了一个<code>Object.create</code>方法来完成我们上面自己封装的<code>create</code>的功能。因此我们可以直接使用<code>Object.create</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Student.prototype = create(Person.prototype, &#123;</span><br><span class="line">    <span class="comment">// 不要忘了重新指定构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>: &#123;</span><br><span class="line">        value: Student</span><br><span class="line">    &#125;</span><br><span class="line">    getGrade: &#123;</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.grade</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, grade</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数继承</span></span><br><span class="line">    Person.call(<span class="keyword">this</span>, name, age);</span><br><span class="line">    <span class="keyword">this</span>.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型继承</span></span><br><span class="line">Student.prototype = <span class="built_in">Object</span>.create(Person.prototype, &#123;</span><br><span class="line">    <span class="comment">// 不要忘了重新指定构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>: &#123;</span><br><span class="line">        value: Student</span><br><span class="line">    &#125;</span><br><span class="line">    getGrade: &#123;</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.grade</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> Student(<span class="string">'ming'</span>, <span class="number">22</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s1.getName());  <span class="comment">// ming</span></span><br><span class="line"><span class="built_in">console</span>.log(s1.getAge());   <span class="comment">// 22</span></span><br><span class="line"><span class="built_in">console</span>.log(s1.getGrade()); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h5 id="八、属性类型"><a href="#八、属性类型" class="headerlink" title="八、属性类型"></a>八、属性类型</h5><p>在上面的继承实现中，使用了一个大家可能不太熟悉的方法<code>defineProperties</code>。并且在定义<code>getGrade</code>时使用了一个很奇怪的方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getGrade: &#123;</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.grade</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其实是对象中的属性类型。在我们平常的使用中，给对象添加一个属性时，直接使用<code>object.param</code>的方式就可以了，或者直接在对象中挂载。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'TOM'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ECMAScript5中，对每个属性都添加了几个属性类型，来描述这些属性的特点。他们分别是</p><ul><li><strong><code>configurable</code></strong>: 表示该属性是否能被delete删除。当其值为false时，其他的特性也不能被改变。默认值为true</li><li><strong><code>enumerable</code></strong>: 是否能枚举。也就是是否能被for-in遍历。默认值为true</li><li><strong><code>writable</code></strong>: 是否能修改值。默认为true</li><li><strong><code>value</code></strong>: 该属性的具体值是多少。默认为undefined</li><li><strong><code>get</code></strong>: 当我们通过<code>person.name</code>访问name的值时，get将被调用。该方法可以自定义返回的具体值时多少。get默认值为undefined</li><li><strong><code>set</code></strong>: 当我们通过<code>person.name = &#39;Jake&#39;</code>设置name的值时，set方法将被调用。该方法可以自定义设置值的具体方式。set默认值为undefined</li></ul><blockquote><p>需要注意的是，不能同时设置value、writable 与 get、set的值。</p></blockquote><p>我们可以通过<code>Object.defineProperty</code>方法来修改这些属性类型。</p><p>下面我们用一些简单的例子来演示一下这些属性类型的具体表现。</p><p><strong>configurable</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用普通的方式给person对象添加一个name属性，值为TOM</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'TOM'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用delete删除该属性</span></span><br><span class="line"><span class="keyword">delete</span> person.name;  <span class="comment">// 返回true 表示删除成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过Object.defineProperty重新添加name属性</span></span><br><span class="line"><span class="comment">// 并设置name的属性类型的configurable为false，表示不能再用delete删除</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">'name'</span>, &#123;</span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="string">'Jake'</span>  <span class="comment">// 设置name属性的值</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次delete，已经不能删除了</span></span><br><span class="line"><span class="keyword">delete</span> person.name   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name)    <span class="comment">// 值为Jake</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 试图改变value</span></span><br><span class="line">person.name = <span class="string">"alex"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// Jake 改变失败</span></span><br></pre></td></tr></table></figure><p><strong>enumerable</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'TOM'</span>,</span><br><span class="line">    age: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用for-in枚举person的属性</span></span><br><span class="line"><span class="keyword">var</span> params = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> person) &#123;</span><br><span class="line">    params.push(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看枚举结果</span></span><br><span class="line"><span class="built_in">console</span>.log(params);  <span class="comment">// ['name', 'age']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新设置name属性的类型，让其不可被枚举</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">'name'</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> params_ = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> person) &#123;</span><br><span class="line">    params_.push(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次查看枚举结果</span></span><br><span class="line"><span class="built_in">console</span>.log(params_); <span class="comment">// ['age']</span></span><br></pre></td></tr></table></figure><p><strong>writable</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'TOM'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改name的值</span></span><br><span class="line">person.name = <span class="string">'Jake'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看修改结果</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// Jake 修改成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置name的值不能被修改</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">'name'</span>, &#123;</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次试图修改name的值</span></span><br><span class="line">person.name = <span class="string">'alex'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// Jake 修改失败</span></span><br></pre></td></tr></table></figure><p><strong>value</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个name属性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">'name'</span>, &#123;</span><br><span class="line">    value: <span class="string">'TOM'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name)  <span class="comment">// TOM</span></span><br></pre></td></tr></table></figure><p><strong>get/set</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过get与set自定义访问与设置name属性的方式</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">'name'</span>, &#123;</span><br><span class="line">    <span class="keyword">get</span>: function() &#123;</span><br><span class="line">        <span class="comment">// 一直返回TOM</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'TOM'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function(value) &#123;</span><br><span class="line">        <span class="comment">// 设置name属性时，返回该字符串，value为新值</span></span><br><span class="line">        <span class="built_in">console</span>.log(value + <span class="string">' in set'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次访问name，调用get</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name)   <span class="comment">// TOM</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试修改name值，此时set方法被调用</span></span><br><span class="line">person.name = <span class="string">'alex'</span>   <span class="comment">// alex in set</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次访问name，还是调用get</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// TOM</span></span><br></pre></td></tr></table></figure><blockquote><p>请尽量同时设置get、set。如果仅仅只设置了get，那么我们将无法设置该属性值。如果仅仅只设置了set，我们也无法读取该属性的值。</p></blockquote><p><code>Object.defineProperty</code>只能设置一个属性的属性特性。当我们想要同时设置多个属性的特性时，需要使用我们之前提到过的<code>Object.defineProperties</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(person, &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        value: <span class="string">'Jake'</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    age: &#123;</span><br><span class="line">        <span class="keyword">get</span>: function() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.value || <span class="number">22</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>: function(value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">person.name   <span class="comment">// Jake</span></span><br><span class="line">person.age    <span class="comment">// 22</span></span><br></pre></td></tr></table></figure><h6 id="读取属性的特性值"><a href="#读取属性的特性值" class="headerlink" title="读取属性的特性值"></a>读取属性的特性值</h6><p>我们可以使用<code>Object.getOwnPropertyDescriptor</code>方法读取某一个属性的特性值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">'name'</span>, &#123;</span><br><span class="line">    value: <span class="string">'alex'</span>,</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> descripter = <span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">'name'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(descripter);  <span class="comment">// 返回结果如下</span></span><br><span class="line"></span><br><span class="line">descripter = &#123;</span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="string">'alex'</span>,</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h5><p> 关于面向对象的基础知识大概就是这些了。我从最简单的创建一个对象开始，解释了为什么我们需要构造函数与原型，理解了这其中的细节，有助于我们在实际开发中灵活的组织自己的对象。因为我们并不是所有的场景都会使用构造函数或者原型来创建对象，也许我们需要的对象并不会声明多个实例，或者不用区分对象的类型，那么我们就可以选择更简单的方式。</p><p>我们还需要关注构造函数与原型的各自特性，有助于我们在创建对象时准确的判断我们的属性与方法到底是放在构造函数中还是放在原型中。如果没有理解清楚，这会给我们在实际开发中造成非常大的困扰。</p><p>最后接下来的几篇文章，我会挑几个面向对象的例子，继续帮助大家掌握面向对象的实际运用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果要我总结一下学习前端以来我遇到了哪些瓶颈，那么面向对象一定是第一个毫不犹豫想到的。尽管我现在对于面向对象有了一些的了解，但是当初的那种似懂非懂的痛苦，依然历历在目。&lt;/p&gt;
&lt;p&gt;为了帮助大家能够更加直观的学习和了解面向对象，我会用尽量简单易懂的描述来展示面向对象的相关
      
    
    </summary>
    
      <category term="面向对象" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
      <category term="面向对象" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>摘抄详解ES6</title>
    <link href="https://zombrbrand.github.io/ZombieBrand.github.io/2019/03/17/%E6%91%98%E6%8A%84%E8%AF%A6%E8%A7%A3ES6/"/>
    <id>https://zombrbrand.github.io/ZombieBrand.github.io/2019/03/17/摘抄详解ES6/</id>
    <published>2019-03-17T08:19:56.000Z</published>
    <updated>2019-03-17T14:13:17.916Z</updated>
    
    <content type="html"><![CDATA[<p>对于新人朋友来说，想要自己去搞定一个ES6开发环境并不是一件容易的事情，因为构建工具的学习本身又是一个非常大的方向，我们需要花费不少的时间才能掌握它。</p><p>好在慢慢的开始有大神提供了一些非常简单易懂，学习成本非常低的解决方案来帮助大家学习。<code>create-react-app</code>就是这些解决方案中，个人认为最简单易懂的一种方式。</p><p>所以在学习ES6 modules之前，先跟大家介绍一下<code>create-react-app</code>的安装与使用。</p><blockquote><p>尽管<code>create-react-app</code>的目的是用于开发react程序，但是我们仅仅只用来学习ES6是再合适不过了。当然你也可以借助<code>vue-cli</code>来学习，同样十分简单。</p></blockquote><h5 id="1、确保自己的本地环境已经安装了node与npm"><a href="#1、确保自己的本地环境已经安装了node与npm" class="headerlink" title="1、确保自己的本地环境已经安装了node与npm"></a>1、确保自己的本地环境已经安装了node与npm</h5><p>通常安装的方式就是去node的官方网站下载安装，在安装node的时候，npm也会一起被安装。</p><p>下载地址： <a href="http://nodejs.cn/download/" target="_blank" rel="noopener">http://nodejs.cn/download/</a></p><h5 id="2、安装一个好用的命令行工具"><a href="#2、安装一个好用的命令行工具" class="headerlink" title="2、安装一个好用的命令行工具"></a>2、安装一个好用的命令行工具</h5><p>在windows环境下，系统默认的cmd非常难用，所以我个人比较推荐大家使用git.bash 或者 cmder。</p><p>git 下载地址： <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a><br>在git安装目录下会有一个bash工具，找到安装目录直接使用即可。</p><p>cmder下载地址： <a href="http://cmder.net/" target="_blank" rel="noopener">http://cmder.net/</a></p><p>在mac上就方便很多了，你可以直接使用系统自带的terminal工具，就非常好用。但是一般我推荐大家使用iterm2，并安装oh my zsh插件。具体的配置大家可以自己去折腾，网上的教程应该足够帮助你搞定这一切了。</p><ul><li>iterm2 下载地址 <a href="http://www.iterm2.com/downloads.html" target="_blank" rel="noopener">http://www.iterm2.com/downloads.html</a></li><li>oh my zsh 主题选择 <a href="https://github.com/robbyrussell/oh-my-zsh/wiki/External-themes" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh/wiki/External-themes</a></li></ul><p><img src="/ZombieBrand.github.io/assets/599584-76079222df7b34f7.png" alt></p><p>另外还强烈推荐一款超高颜值的终端工具 <code>hyperTerm</code>。</p><p>这款工具的特色就是颜值高，第一感觉就是惊艳，大家不妨一试。</p><p><img src="/ZombieBrand.github.io/assets/599584-6e8534894dfb4e4d.png" alt></p><ul><li>hyperTerm 下载地址 <a href="https://hyper.is/" target="_blank" rel="noopener">https://hyper.is/</a></li></ul><h5 id="3、安装create-react-app"><a href="#3、安装create-react-app" class="headerlink" title="3、安装create-react-app"></a>3、安装create-react-app</h5><p>在命令行工具中使用查看版本的方式确保node与npm都安装好之后，我们就可以安装<code>create-react-app</code>了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; node -v</span><br><span class="line"><span class="comment">// 输出node版本号</span></span><br><span class="line"></span><br><span class="line">&gt; npm -v</span><br><span class="line"><span class="comment">// 输出npm版本号</span></span><br></pre></td></tr></table></figure><p>使用npm全局安装create-react-app</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; npm install create-react-app -g</span><br></pre></td></tr></table></figure><p>然后我们就可以使用<code>create-react-app</code>来创建我们的第一个项目。</p><p>找到一个你要存放项目的根目录，假设叫做<code>develop</code>，运行以下指令。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; create-react-app es6app</span><br></pre></td></tr></table></figure><p>create-react-app会自动帮助我们在develop目录下创建一个叫做es6app的文件夹，这就是我们新创建的项目。</p><p>当项目创建完成之后，在命令行工具中，我们会看到如图所示的提示。这些提示告诉了我们如何运行项目<code>npm start</code> ，如何打包项目<code>npm run build</code>等，这里我就不再赘述。</p><p><img src="/ZombieBrand.github.io/assets/599584-368f0d2ad8cafb5c.png" alt></p><p>项目创建完毕之后，进入该文件夹。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; cd es6app</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看文件夹里的内容</span></span><br><span class="line">&gt; ls</span><br></pre></td></tr></table></figure><p>我们会发现里面有一个叫做<code>package.json</code>的文件，这个文件里包含了项目所需要的所有依赖。当我们第一次运行项目之前，还需要安装该文件里的依赖包。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; npm install</span><br></pre></td></tr></table></figure><p>安装完毕之后，我们就可以启动该项目了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; npm start</span><br></pre></td></tr></table></figure><p><img src="/ZombieBrand.github.io/assets/599584-105e41643f770f96.png" alt="项目启动之后"></p><p>一般来说，启动之后会自动在浏览器中打开。</p><p><img src="/ZombieBrand.github.io/assets/599584-f91ae7637fa70ed9.png" alt="项目首次启动的页面"></p><blockquote><p><code>create-react-app</code>已经自动帮助我们实现了热更新，因此当我们修改代码时，浏览器会自动更新。当然，如果我们仅仅只是修改页面样式时，热更新将会非常方便，但是如果你正在进行单页面的组件开发，可能热更新能够提供的帮助非常有限。</p></blockquote><h5 id="4、认识项目"><a href="#4、认识项目" class="headerlink" title="4、认识项目"></a>4、认识项目</h5><p>只要我们按照构建工具的规则进行开发，那么构建工具会自动帮助我们将代码进行整合，因此在该项目中开发时，我们并不需要自己来使用script或者link标签来引入js与css，所以认识create-react-app的规则就变得很重要。</p><p>初次创建的项目下，会有3个文件夹。</p><ul><li>node_modules<br>项目依赖包存放位置。当我们运行<code>npm install</code>安装<code>package.json</code>中的依赖包时，该文件夹会自动创建，所有的依赖包会安装到该文件夹里。</li><li>public<br>主要的作用是html入口文件的存放。当然我们也可以存放其他公用的静态资源，如图片，css等。其中的<code>index.html</code>就是我们项目的入口html文件</li><li>src<br>组件的存放目录。在create-react-app创建的项目中，每一个单独的文件都可以被看成一个单独的模块，单独的image，单独的css，单独js等，而所有的组件都存放于src目录中，其中<code>index.js</code>则是js的入口文件。虽然我们并没有在<code>index.html</code>中使用script标签引入他，但是他的作用就和此一样。</li></ul><p>当然，如果我们要进一步进行react的学习，那么肯定需要了解多一点的规则，但是在学习react之前，我们还是先把ES6 modules的知识搞定在说吧，所以，接下来你要做的事情就是，删掉src目录里的除了index.js之外的所有文件，并清空index.js，我们从0开始学习ES6 modules。</p><p>为了确保程序仍然能够正常运行，我们在index.js中随便写点代码测试一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="built_in">document</span>.querySelector(<span class="string">'#root'</span>)</span><br><span class="line">app.innerHTML = <span class="string">'啊，全部被清空啦，准备工作终于做完了，可以开始学习ES6啦'</span></span><br></pre></td></tr></table></figure><p><img src="/ZombieBrand.github.io/assets/599584-2524e23338728b89.png" alt="一切正常，程序变得普通了，我们更容易理解"></p><p>那么我们就可以在这个环境下学习ES6的所有知识了，当然也包括ES6 modules。</p><h4 id="ES6-modules"><a href="#ES6-modules" class="headerlink" title="ES6 modules"></a>ES6 modules</h4><h5 id="1-引入模块"><a href="#1-引入模块" class="headerlink" title="1. 引入模块"></a>1. 引入模块</h5><p>首先在<code>src</code>目录下创建一个<code>test.js</code>，在<code>test.js</code>中我们随便干点什么简单的事情即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/test.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'your first module'</span>);</span><br></pre></td></tr></table></figure><p>在index.js中通过<code>import</code>引入test.js，这是我们要学会的第一个语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.js</span></span><br><span class="line"><span class="keyword">import</span> test <span class="keyword">from</span> <span class="string">'./test'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(test);</span><br></pre></td></tr></table></figure><ul><li><code>import</code>表示引入一个模块，</li><li>test 我们暂时理解为引入模块的名字，</li><li>from表示从哪里引入</li><li><code>./test</code>为<code>./test.js</code>的简写，表示将要引入模块的路径</li></ul><p><img src="/ZombieBrand.github.io/assets/599584-258a86fe0e06b5f9.png" alt="结果是test中的代码执行，index.js中模块test为一个空对象"></p><p>引入这个动作执行时，test.js中的代码也执行了。由于在<code>test.js</code>中并没有对外暴露任何接口，因此<code>index.js</code>中的<code>test</code>为一个空对象，那么对外暴露接口的方式，则是我们要学习的第二个语法。</p><h5 id="2-对外提供接口"><a href="#2-对外提供接口" class="headerlink" title="2. 对外提供接口"></a>2. 对外提供接口</h5><p>ES6 modules使用<code>export</code>关键字对外提供接口，在我们刚才创建的<code>test.js</code>中，我们添加如下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="keyword">const</span> num = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    a: <span class="number">0</span>,</span><br><span class="line">    b: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    num,</span><br><span class="line">    arr,</span><br><span class="line">    obj,</span><br><span class="line">    foo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/ZombieBrand.github.io/assets/599584-783481a63855b461.png" alt="运行结果"></p><p>在<code>test.js</code>中，我们使用<code>export default</code>对包暴露了一个对象。他的意思就是当我们使用<code>import test from &#39;./test&#39;</code>时，这个test对象就默认等于<code>export default</code>暴露的对象。</p><p>我们还可以在test.js中，仅仅通过<code>export</code>暴露几个方法与属性，我们来看看index.js中test会变成什么样子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/test.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> bar = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> zcar = <span class="number">12345</span>;</span><br></pre></td></tr></table></figure><p>保存运行后，我们发现，index.js中的test对象并没有变化，因为它仅仅等于<code>export default</code>抛出的对象，因此，为了获得模块<code>test.js</code>暴露的所有接口，我们得通过如下的方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> test <span class="keyword">from</span> <span class="string">'./test'</span>;</span><br></pre></td></tr></table></figure><p>其中的 <code>*</code> 表示所有，这是比较常用的通配符，as表示别名，<code>* as test</code>的意思是将test.js暴露的所有接口组成的对象，命名为test。那么我们在index.js中log出test，结果就如下。</p><p><img src="/ZombieBrand.github.io/assets/599584-682a3aa05a20aad6.png" alt="看到结果，我们就很容易清楚的知道export与export default的区别与作用了，并且如何使用他们就变得很简单了"></p><p>如果大家还记得前面一篇文章里，我所讲的ES6解析结构的语法，那么对于如下的用法相信就不难理解。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.js</span></span><br><span class="line"><span class="keyword">import</span> test, &#123; bar, zcar &#125; <span class="keyword">from</span> <span class="string">'./test'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(test);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'bar:'</span>, bar);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'zcar:'</span>, zcar);</span><br></pre></td></tr></table></figure><p>test，仍然表示为<code>export default</code>暴露的对象，而 <code>{ bar, zcar }</code>则表示利用解析结构的语法，从整个返回对象中去取得对应的接口。输出结果也就很清晰了。</p><p><img src="/ZombieBrand.github.io/assets/599584-5f1b2cb69be63173.png" alt="result"></p><p>这种方式还是比较常见，比如我们在使用react时，常常这样使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br></pre></td></tr></table></figure><p>它其实暗示了React的封装方式，也暗示了我们应该如何去封装我们的模块。</p><blockquote><p>这里我们能够直接引入<code>react</code>的原因，是因为我们将它安装到了文件夹<code>node_modules</code>中，该文件夹中安装的所有模块都可以这样直接引用。例如我们安装一个jquery。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安装jquery</span></span><br><span class="line">&gt; npm install jquery</span><br></pre></td></tr></table></figure><p>然后在其他模块中就可以直接引入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span></span><br></pre></td></tr></table></figure><p>这样，我们可以和往常一样使用jquery。<br>通过这样方式，我们还可以扩展更多的库，这就使得我们这个开发环境不仅仅能够用于react的开发，怎么用，完全取决与你自己。</p><p>OK，ES6 模块的基础语法大概就这些吧，他告诉了我们在ES6中，一个模块应该如何对外暴露接口与如何引入其他模块暴露的接口，这个知识点在实际开发中非常常用，因此虽然简单，但是不得不掌握，这也是大家进一步学习react或者vue的基础，主要的难点大概在于本地开发环境的折腾，如果你是初次折腾这些，可能会遇到一些小问题，所以一定要有一点耐心。</p><blockquote><p>通常来说，一个知识点，在完全理解之前还是有点难度的，但是理解之后就变得非常简单，所以如果你在学习这个知识点时感觉有点困难，也不要过于担心，多多动手尝试，并在实践中运用起来，相信很快就能掌握。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于新人朋友来说，想要自己去搞定一个ES6开发环境并不是一件容易的事情，因为构建工具的学习本身又是一个非常大的方向，我们需要花费不少的时间才能掌握它。&lt;/p&gt;
&lt;p&gt;好在慢慢的开始有大神提供了一些非常简单易懂，学习成本非常低的解决方案来帮助大家学习。&lt;code&gt;create
      
    
    </summary>
    
      <category term="ES6" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/categories/ES6/"/>
    
    
      <category term="ES6" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>摘抄浅析jQuery</title>
    <link href="https://zombrbrand.github.io/ZombieBrand.github.io/2019/03/17/%E6%91%98%E6%8A%84%E6%B5%85%E6%9E%90jQuery/"/>
    <id>https://zombrbrand.github.io/ZombieBrand.github.io/2019/03/17/摘抄浅析jQuery/</id>
    <published>2019-03-17T08:19:30.000Z</published>
    <updated>2019-03-17T14:13:17.917Z</updated>
    
    <content type="html"><![CDATA[<p>早几年学习前端，大家都非常热衷于研究jQuery源码。我还记得当初从jQuery源码中学到一星半点应用技巧的时候常会有一种发自内心的惊叹，“原来JavaScript居然可以这样用！”</p><p>虽然随着前端的发展，另外几种前端框架的崛起，jQuery慢慢变得不再是必须。因此大家对于jQuery的热情低了很多。但是许多从jQuery中学到的技巧用在实际开发中仍然非常好用。简单的了解它也有助于我们更加深入的理解JavaScript。</p><p>这篇文章的主要目的就是跟大家分享一下，jquery对象是如何封装的。算是对于大家进一步学习jQuery源码的一个抛砖引玉。</p><p>使用jQuery对象时，我们这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个jQuery对象</span></span><br><span class="line">$(<span class="string">'.target'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取元素的css属性</span></span><br><span class="line">$(<span class="string">'.target'</span>).css(<span class="string">'width'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取元素的位置信息</span></span><br><span class="line">$(<span class="string">'.target'</span>).offset()</span><br></pre></td></tr></table></figure><p>在使用之初可能会有许多疑问，比如$是怎么回事？为什么不用new就可以直接声明一个对象等等。后来了解之后，才知道原来这正是jQuery对象创建的巧妙之处。</p><p>先直接用代码展示出来，再用图跟大家解释是怎么回事。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">ROOT</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">var</span> jQuery = <span class="function"><span class="keyword">function</span>(<span class="params">selector</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在jQuery中直接返回new过的实例，这里的init是jQuery的真正构造函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init(selector)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jQuery.fn = jQuery.prototype = &#123;</span><br><span class="line">        <span class="keyword">constructor</span>: jQuery,</span><br><span class="line"></span><br><span class="line">        version: '1.0.0',</span><br><span class="line"></span><br><span class="line">        init: function(selector) &#123;</span><br><span class="line">            <span class="comment">// 在jquery中这里有一个复杂的判断，但是这里我做了简化</span></span><br><span class="line">            <span class="keyword">var</span> elem, selector;</span><br><span class="line">             elem = <span class="built_in">document</span>.querySelector(selector);</span><br><span class="line">            <span class="keyword">this</span>[<span class="number">0</span>] = elem;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在jquery中返回一个由所有原型属性方法组成的数组，我们这里简化，直接返回this即可</span></span><br><span class="line">            <span class="comment">// return jQuery.makeArray(selector, this);</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在原型上添加一堆方法</span></span><br><span class="line">        toArray: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        <span class="keyword">get</span>: function() &#123;&#125;,</span><br><span class="line">        each: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        ready: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        first: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        slice: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">        <span class="comment">// ... ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jQuery.fn.init.prototype = jQuery.fn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现jQuery的两种扩展方式</span></span><br><span class="line">    jQuery.extend = jQuery.fn.extend = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在jquery源码中会根据参数不同进行很多判断，我们这里就直接走一种方式，所以就不用判断了</span></span><br><span class="line">        <span class="keyword">var</span> target = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> copy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(name <span class="keyword">in</span> options) &#123;</span><br><span class="line">            copy = options[name];</span><br><span class="line">            target[name] = copy;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// jQuery中利用上面实现的扩展机制，添加了许多方法，其中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接添加在构造函数上，被称为工具方法</span></span><br><span class="line">    jQuery.extend(&#123;</span><br><span class="line">        isFunction: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        type: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        parseHTML: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        parseJSON: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        ajax: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加到原型上</span></span><br><span class="line">    jQuery.fn.extend(&#123;</span><br><span class="line">        queue: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        promise: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        attr: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        prop: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        addClass: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        removeClass: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        val: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        css: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// $符号的由来，实际上它就是jQuery，一个简化的写法，在这里我们还可以替换成其他可用字符</span></span><br><span class="line">    ROOT.jQuery = ROOT.$ = jQuery;</span><br><span class="line"></span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure><p>在上面的代码中，我封装了一个简化版的jQuery对象。它向大家简单展示了jQuery的整体框架情况。如果了解了整体框架，那么大家去读jQuery源码，就会变得非常轻松。</p><p>我们在代码中可以看到，jQuery自身对于原型的处理使用了一些巧妙的语法，比如<code>jQuery.fn = jQuery.prototype</code>，<code>jQuery.fn.init.prototype = jQuery.fn;</code>等，这几句正式jQuery对象的关键所在，下面我用图给大家展示一下这中间的逻辑是怎么回事。</p><p><img src="/ZombieBrand.github.io/assets/599584-181a154ebc9ec559.png" alt="jQuery对象核心图"></p><p><strong> 对象封装分析 </strong></p><p>在上面的实现中，代码首先在jQuery构造函数中声明了一个fn属性，并将其指向了原型<code>jQuery.prototype</code>。并在原型中添加了init方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jQuery.fn = jQuery.prototype = &#123;</span><br><span class="line">    init: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后又将init的原型，指向了jQuery.prototype。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery.fn.init.prototype = jQuery.fn;</span><br></pre></td></tr></table></figure><p>而在构造函数jQuery中，返回了init的实例对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jQuery = <span class="function"><span class="keyword">function</span>(<span class="params">selector</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在jQuery中直接返回new过的实例，这里的init是jQuery的真正构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init(selector)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后对外暴露入口时，将字符<code>$</code>与<code>jQuery</code>对等起来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROOT.jQuery = ROOT.$ = jQuery;</span><br></pre></td></tr></table></figure><p>因此当我们直接使用<code>$(&#39;#test&#39;)</code>创建一个对象时，实际上是创建了一个init的实例，这里的正真构造函数是原型中的init方法。</p><p><strong>注意：</strong>许多对jQuery内部实现不太了解的盆友，在使用jQuery时常常会毫无节制使用<code>$()</code>，比如对于同一个元素的不同操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> width = <span class="built_in">parseInt</span>($(<span class="string">'#test'</span>).css(<span class="string">'width'</span>));</span><br><span class="line"><span class="keyword">if</span>(width &gt; <span class="number">20</span>) &#123;</span><br><span class="line">    $(<span class="string">'#test'</span>).css(<span class="string">'backgroundColor'</span>, <span class="string">'red'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过我们上面的一系列分析，我们知道每当我们执行<code>$()</code>时，就会重新生成一个init的实例对象，因此当我们这样没有节制的使用jQuery时是非常不正确的，虽然看上去方便了一些，但是对于内存的消耗是非常大的。正确的做法是既然是同一个对象，那么就用一个变量保存起来后续使用即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $test = $(<span class="string">'#test'</span>);</span><br><span class="line"><span class="keyword">var</span> width = <span class="built_in">parseInt</span>($test.css(<span class="string">'width'</span>));</span><br><span class="line"><span class="keyword">if</span>(width &gt; <span class="number">20</span>) &#123;</span><br><span class="line">    $test.css(<span class="string">'backgroundColor'</span>, <span class="string">'red'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>扩展方法分析</strong></p><p>在上面的代码实现中，我还简单实现了两个扩展方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">jQuery.extend = jQuery.fn.extend = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在jquery源码中会根据参数不同进行很多判断，我们这里就直接走一种方式，所以就不用判断了</span></span><br><span class="line">    <span class="keyword">var</span> target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> copy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(name <span class="keyword">in</span> options) &#123;</span><br><span class="line">        copy = options[name];</span><br><span class="line">        target[name] = copy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要理解它的实现，我们首先要明确的知道this的指向。如果你搞不清楚，可以回头去看看我们之前关于this指向的讲解。传入的参数options对象为一个<code>key: value</code>模式的对象，我通过<code>for in</code>遍历options，将key作为jQuery的新属性，value作为该新属性所对应的新方法，分别添加到jQuery方法和jQuery.fn中。</p><p>也就是说，当我们通过<code>jQuery.extend</code>扩展jQuery时，方法被添加到了jQuery构造函数中，而当我们通过<code>jQuery.fn.extend</code>扩展jQuery时，方法被添加到了jQuery原型中。</p><p>上面的例子中，我也简单展示了在jQuery内部，许多方法的实现都是通过这两个扩展方法来完成的。</p><blockquote><p>当我们通过上面的知识了解了jQuery的大体框架之后，那么我们对于jQuery的学习就可以具体到诸如css/val/attr等方法是如何实现这样的程度，那么源码学习起来就会轻松很多，也会节约更多的时间。也给一些对于源码敬而远之的朋友提供了一个学习的可能。</p></blockquote><p>有一个朋友留言给我，说她被静态方法，工具方法和实例方法这几个概念困扰了很久，到底他们有什么区别？</p><p>其实在上一篇文章中，关于封装一个对象，我跟大家分享了一个非常非常干货，但是却只有少数几个读者老爷get到的知识，那就是在封装对象时，属性和方法可以具体放置的三个位置，并且对于这三个位置的不同做了一个详细的解读。</p><p>而在实现jQuery扩展方法的想法中，一部分方法需要扩展到jQuery构造函数中，一部分方法需要扩展到原型中，当我们通读jQuery源码，还发现有一些方法放在了模块作用域中，至于为什么会有这样的区别，建议大家回过头去读读前一篇文章。</p><p>而放在构造函数中的方法，因为我们在使用时，不需要声明一个实例对象就可以直接使用，因此这样的方法常常被叫做工具方法，或者所谓的静态方法。工具方法在使用时因为不用创建新的实例，因此相对而言效率会高很多，但是并不节省内存。</p><p>而工具方法的特性也和工具一词非常贴近，他们与实例的自身属性毫无关联，仅仅只是实现一些通用的功能，我们可以通过<code>$.each</code>与<code>$(&#39;div&#39;).each</code>这2个方法来体会工具方法与实例方法的不同之处。</p><p>在实际开发中，我们运用得非常多的一个工具库就是<code>lodash.js</code>，大家如果时间充裕一定要去学习一下他的使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.ajax()</span><br><span class="line">$.isFunction()</span><br><span class="line">$.each()</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure><p>而放在原型中的方法，在使用时必须创建了一个新的实例对象才能访问，因此这样的方法叫做实例方法。也正是由于必须创建了一个实例之后才能访问，所以他的使用成本会比工具方法高很多。但是节省了内存。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#test'</span>).css()</span><br><span class="line">$(<span class="string">'#test'</span>).attr()</span><br><span class="line">$(<span class="string">'div'</span>).each()</span><br></pre></td></tr></table></figure><p>这样，那位同学的疑问就很简单的被搞定了。我们在学习的时候，一定不要过分去纠结一些概念，而要明白具体怎么回事儿，那么学习这件事情就不会在一些奇奇怪怪的地方卡住了。</p><p>所以通过<code>$.extend</code>扩展的方法，其实就是对工具方法的扩展，而通过<code>$.fn.extend</code>扩展的方法，就是对于实例方法的扩展。那么我们在使用的时候就知道如何准确的去使用自己扩展的方法了。</p><p><strong>jQuery插件的实现</strong></p><p>我在初级阶段的时候，觉得要自己编写一个jQuery插件是一件高大上的事情，可望不可即。但是通过对于上面的理解，我就知道扩展jQuery插件其实是一件我们自己也可以完成的事情。</p><p>在前面我跟大家分享了jQuery如何实现，以及他们的方法如何扩展，并且前一篇文章分享了拖拽对象的具体实现。所以建议大家暂时不要阅读下去，自己动手尝试将拖拽扩展成为jQuery的一个实例方法，那么这就是一个jQuery插件了。</p><p>具体也没有什么可多说的了，大家看了代码就可以明白一切。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Drag对象简化代码，完整源码可在上一篇文章中查看</span></span><br><span class="line">;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Drag</span>(<span class="params">selector</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原型</span></span><br><span class="line">    Drag.prototype = &#123;</span><br><span class="line">        <span class="keyword">constructor</span>: Drag,</span><br><span class="line"></span><br><span class="line">        init: function() &#123;</span><br><span class="line">            <span class="comment">// 初始时需要做些什么事情</span></span><br><span class="line">            <span class="keyword">this</span>.setDrag();</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 稍作改造，仅用于获取当前元素的属性，类似于getName</span></span><br><span class="line">        getStyle: <span class="function"><span class="keyword">function</span>(<span class="params">property</span>) </span>&#123;&#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用来获取当前元素的位置信息，注意与之前的不同之处</span></span><br><span class="line">        getPosition: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用来设置当前元素的位置</span></span><br><span class="line">        setPostion: <span class="function"><span class="keyword">function</span>(<span class="params">pos</span>) </span>&#123;&#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该方法用来绑定事件</span></span><br><span class="line">        setDrag: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一种对外暴露的方式</span></span><br><span class="line">    <span class="built_in">window</span>.Drag = Drag;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过扩展方法将拖拽扩展为jQuery的一个实例方法</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">$</span>) </span>&#123;</span><br><span class="line">  $.fn.extend(&#123;</span><br><span class="line">    becomeDrag: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">new</span> Drag(<span class="keyword">this</span>[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;   <span class="comment">// 注意：为了保证jQuery所有的方法都能够链式访问，每一个方法的最后都需要返回this，即返回jQuery实例</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)(jQuery);</span><br></pre></td></tr></table></figure><p><strong>后续文章内容一个大概预想</strong></p><p>去年年末的时候就有了想要将JavaScript基础知识总结一下的这样一个想法，可是JavaScript基础知识确实并非全部是层层递进的关系，有很多碎片化的东西，所以之前一直没有找到一个合适的整理方法。</p><p>直到在segmentfault中我在给题主建议如何快速学习一门诸如react/vue这样的流行框架时，找到了一个好一点的思路，于是就有了这样一系列文章，虽然它并不全面，很多知识没有涉及到，但是其实我是围绕最终通过模块化来构建自己代码这样一个思路来总结的，因此这系列文章能够解决大家最核心的问题。</p><p>也正因为如此，这系列的文章的终点将会是在ES6环境下掌握react的使用。虽然前面我多多少少都涉及到了模块的一些概念，但是还差一个实践。因此最终我会以ES6的模块跟大家分享如何使用。</p><p>那么后续的文章应该会涉及的内容，就大概包括：</p><ul><li>事件循环机制</li><li>Promise</li><li>ES6的基础语法</li><li>ES6下的常用设计模式</li><li>ES6模块</li><li>结合ES6的实例</li><li>React基础语法</li><li>React组件</li><li>React高阶组件</li><li>React实例</li><li>Redux</li></ul><p>这系列文章，算是对于大家学习方向的一个具体的，切实可行的一个指引，而非简单的通过鸡汤的方式告诉你应该如何学习。所以，想要学习这些知识的朋友，赶紧来简书关注我吧！！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;早几年学习前端，大家都非常热衷于研究jQuery源码。我还记得当初从jQuery源码中学到一星半点应用技巧的时候常会有一种发自内心的惊叹，“原来JavaScript居然可以这样用！”&lt;/p&gt;
&lt;p&gt;虽然随着前端的发展，另外几种前端框架的崛起，jQuery慢慢变得不再是必须。
      
    
    </summary>
    
      <category term="jQuery" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/categories/jQuery/"/>
    
    
      <category term="jQuery" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>摘抄柯里化</title>
    <link href="https://zombrbrand.github.io/ZombieBrand.github.io/2019/03/17/%E6%91%98%E6%8A%84%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    <id>https://zombrbrand.github.io/ZombieBrand.github.io/2019/03/17/摘抄柯里化/</id>
    <published>2019-03-17T08:19:08.000Z</published>
    <updated>2019-03-17T08:25:47.522Z</updated>
    
    <content type="html"><![CDATA[<p>柯里化是函数的一个比较高级的应用，想要理解它并不简单。因此我一直在思考应该如何更加表达才能让大家理解起来更加容易。</p><blockquote><p>以下是新版本讲解。高阶函数章节由于一些原因并未公开，大家可以自行搜索学习</p></blockquote><p>通过上一个章节的学习我们知道，接收函数作为参数的函数，都可以叫做高阶函数。我们常常利用高阶函数来封装一些公共的逻辑。</p><p>这一章我们要学习的柯里化，其实就是高阶函数的一种特殊用法。</p><p><strong>柯里化是指这样一个函数(假设叫做createCurry)，他接收函数A作为参数，运行后能够返回一个新的函数。并且这个新的函数能够处理函数A的剩余参数。</strong></p><p>这样的定义可能不太好理解，我们可以通过下面的例子配合理解。</p><p>假如有一个接收三个参数的函数A。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又假如我们有一个已经封装好了的柯里化通用函数createCurry。他接收bar作为参数，能够将A转化为柯里化函数，返回结果就是这个被转化之后的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _A = createCurry(A);</span><br></pre></td></tr></table></figure><p>那么_A作为createCurry运行的返回函数，他能够处理A的剩余参数。因此下面的运行结果都是等价的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_A(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">_A(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>);</span><br><span class="line">_A(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">_A(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>);</span><br><span class="line">A(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>函数A被createCurry转化之后得到柯里化函数_A，_A能够处理A的所有剩余参数。因此柯里化也被称为部分求值。</p><p>在简单的场景下，我们可以不用借助柯里化通用式来转化得到柯里化函数，我们可以凭借眼力自己封装。</p><p>例如有一个简单的加法函数，他能够将自身的三个参数加起来并返回计算结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么add函数的柯里化函数_add则可以如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_add</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a + b + c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此下面的运算方式是等价的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">_add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>当然，柯里化通用式具备更加强大的能力，我们靠眼力自己封装的柯里化函数则自由度偏低。因此我们仍然需要知道自己如何去封装这样一个柯里化的通用式。</p><p>首先通过_add可以看出，柯里化函数的运行过程其实是一个参数的收集过程，我们将每一次传入的参数收集起来，并在最里层里面处理。因此我们在实现createCurry时，可以借助这个思路来进行封装。</p><p>封装如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单实现，参数只能从右到左传递</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCurry</span>(<span class="params">func, args</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> arity = func.length;</span><br><span class="line">    <span class="keyword">var</span> args = args || [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> _args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        [].push.apply(_args, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果参数个数小于最初的func.length，则递归调用，继续收集参数</span></span><br><span class="line">        <span class="keyword">if</span> (_args.length &lt; arity) &#123;</span><br><span class="line">            <span class="keyword">return</span> createCurry.call(<span class="keyword">this</span>, func, _args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 参数收集完毕，则执行func</span></span><br><span class="line">        <span class="keyword">return</span> func.apply(<span class="keyword">this</span>, _args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管我已经做了足够详细的注解，但是我想理解起来也并不是那么容易，因此建议大家用点耐心多阅读几遍。这个createCurry函数的封装借助闭包与递归，实现了一个参数收集，并在收集完毕之后执行所有参数的一个过程。</p><p>因此聪明的读者可能已经发现，把函数经过createCurry转化为一个柯里化函数，最后执行的结果，不是正好相当于执行函数自身吗？柯里化是不是把简单的问题复杂化了？</p><p>如果你能够提出这样的问题，那么说明你确实已经对柯里化有了一定的了解。柯里化确实是把简答的问题复杂化了，但是复杂化的同时，我们在使用函数时拥有了更加多的自由度。而这里对于函数参数的自由处理，正是柯里化的核心所在。</p><p>我们来举一个非常常见的例子。</p><p>如果我们想要验证一串数字是否是正确的手机号，那么按照普通的思路来做，大家可能是这样封装，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkPhone</span>(<span class="params">phoneNumber</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/^1[34578]\d&#123;9&#125;$/</span>.test(phoneNumber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而如果我们想要验证是否是邮箱呢？这么封装：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkEmail</span>(<span class="params">email</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/</span>.test(email);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还可能会遇到验证身份证号，验证密码等各种验证信息，因此在实践中，为了统一逻辑，，我们就会封装一个更为通用的函数，将用于验证的正则与将要被验证的字符串作为参数传入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">targetString, reg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> reg.test(targetString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样封装之后，在使用时又会稍微麻烦一点，因为会总是输入一串正则，这样就导致了使用时的效率低下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">check(<span class="regexp">/^1[34578]\d&#123;9&#125;$/</span>, <span class="string">'14900000088'</span>);</span><br><span class="line">check(<span class="regexp">/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/</span>, <span class="string">'test@163.com'</span>);</span><br></pre></td></tr></table></figure><p>那么这个时候，我们就可以借助柯里化，在check的基础上再做一层封装，以简化使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _check = createCurry(check);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> checkPhone = _check(<span class="regexp">/^1[34578]\d&#123;9&#125;$/</span>);</span><br><span class="line"><span class="keyword">var</span> checkEmail = _check(<span class="regexp">/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/</span>);</span><br></pre></td></tr></table></figure><p>最后在使用的时候就会变得更加直观与简洁了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">checkPhone(<span class="string">'183888888'</span>);</span><br><span class="line">checkEmail(<span class="string">'xxxxx@test.com'</span>);</span><br></pre></td></tr></table></figure><p>经过这个过程我们发现，柯里化能够应对更加复杂的逻辑封装。当情况变得多变，柯里化依然能够应付自如。</p><p>虽然柯里化确实在一定程度上将问题复杂化了，也让代码更加不容易理解，但是柯里化在面对复杂情况下的灵活性却让我们不得不爱。</p><p>当然这个案例本身情况还算简单，所以还不能够特别明显的凸显柯里化的优势，我们的主要目的在于借助这个案例帮助大家了解柯里化在实践中的用途。</p><p>我们继续来思考一个例子。这个例子与map有关。在高阶函数的章节中，我们分析了封装map方法的思考过程。由于我们没有办法确认一个数组在遍历时会执行什么操作，因此我们只能将调用for循环的这个统一逻辑封装起来，而具体的操作则通过参数传入的形式让使用者自定义。这就是map函数。</p><p>但是，这是针对了所有的情况我们才会这样想。</p><p>实践中我们常常会发现，在我们的某个项目中，针对于某一个数组的操作其实是固定的，也就是说，同样的操作，可能会在项目的不同地方调用很多次。</p><p>于是，这个时候，我们就可以在map函数的基础上，进行二次封装，以简化我们在项目中的使用。假如这个在我们项目中会调用多次的操作是将数组的每一项都转化为百分比 1 –&gt; 100%。</p><p>普通思维下我们可以这样来封装。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNewArray</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item * <span class="number">100</span> + <span class="string">'%'</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getNewArray([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0.12</span>]);   <span class="comment">// ['100%', '200%', '300%', '12%'];</span></span><br></pre></td></tr></table></figure><p>而如果借助柯里化来二次封装这样的逻辑，则会如下实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_map</span>(<span class="params">func, array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.map(func);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _getNewArray = createCurry(_map);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getNewArray = _getNewArray(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item * <span class="number">100</span> + <span class="string">'%'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">getNewArray([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0.12</span>]);   <span class="comment">// ['100%', '200%', '300%', '12%'];</span></span><br><span class="line">getNewArray([<span class="number">0.01</span>, <span class="number">1</span>]); <span class="comment">// ['1%', '100%']</span></span><br></pre></td></tr></table></figure><p>如果我们的项目中的固定操作是希望对数组进行一个过滤，找出数组中的所有Number类型的数据。借助柯里化思维我们可以这样做。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_filter</span>(<span class="params">func, array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.filter(func);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _find = createCurry(_filter);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> findNumber = _find(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> item == <span class="string">'number'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">findNumber([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="number">4</span>]); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当我们继续封装另外的过滤操作时就会变得非常简单</span></span><br><span class="line"><span class="comment">// 找出数字为20的子项</span></span><br><span class="line"><span class="keyword">var</span> find20 = _find(<span class="function"><span class="keyword">function</span>(<span class="params">item, i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> item === <span class="number">20</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">find20([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">100</span>]);  <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找出数组中大于100的所有数据</span></span><br><span class="line"><span class="keyword">var</span> findGreater100 = _find(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (item &gt; <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">findGreater100([<span class="number">1</span>, <span class="number">2</span>, <span class="number">101</span>, <span class="number">300</span>, <span class="number">2</span>, <span class="number">122</span>]); <span class="comment">// [101, 300, 122]</span></span><br></pre></td></tr></table></figure><p>我采用了与check例子不一样的思维方向来想大家展示我们在使用柯里化时的想法。目的是想告诉大家，柯里化能够帮助我们应对更多更复杂的场景。</p><p>当然不得不承认，这些例子都太简单了，简单到如果使用柯里化的思维来处理他们显得有一点多此一举，而且变得难以理解。因此我想读者朋友们也很难从这些例子中感受到柯里化的魅力。不过没关系，如果我们能够通过这些例子掌握到柯里化的思维，那就是最好的结果了。在未来你的实践中，如果你发现用普通的思维封装一些逻辑慢慢变得困难，不妨想一想在这里学到的柯里化思维，应用起来，柯里化足够强大的自由度一定能给你一个惊喜。</p><p>当然也并不建议在任何情况下以炫技为目的的去使用柯里化，在柯里化的实现中，我们知道柯里化虽然具有了更多的自由度，但同时柯里化通用式里调用了arguments对象，使用了递归与闭包，因此柯里化的自由度是以牺牲了一定的性能为代价换来的。只有在情况变得复杂时，才是柯里化大显身手的时候。</p><h5 id="额外知识补充"><a href="#额外知识补充" class="headerlink" title="额外知识补充"></a>额外知识补充</h5><p>无限参数的柯里化。</p><blockquote><p>该部分内容可忽略</p></blockquote><p>在前端面试中，你可能会遇到这样一个涉及到柯里化的题目。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现一个add方法，使计算结果能够满足如下预期：</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>) = <span class="number">6</span>;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)(<span class="number">4</span>) = <span class="number">10</span>;</span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>) = <span class="number">15</span>;</span><br></pre></td></tr></table></figure><p>这个题目的目的是想让add执行之后返回一个函数能够继续执行，最终运算的结果是所有出现过的参数之和。而这个题目的难点则在于参数的不固定。我们不知道函数会执行几次。因此我们不能使用上面我们封装的createCurry的通用公式来转换一个柯里化函数。只能自己封装，那么怎么办呢？在此之前，补充2个非常重要的知识点。</p><p>一个是ES6函数的不定参数。假如我们有一个数组，希望把这个数组中所有的子项展开传递给一个函数作为参数。那么我们应该怎么做？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大家可以思考一下，如果将args数组的子项展开作为add的参数传入</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, c, d</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c + d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">100</span>, <span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>在ES5中，我们可以借助之前学过的apply来达到我们的目的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add.apply(<span class="literal">null</span>, args);  <span class="comment">// 105</span></span><br></pre></td></tr></table></figure><p>而在ES6中，提供了一种新的语法来解决这个问题，那就是不定参。写法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(...args);  <span class="comment">// 105</span></span><br></pre></td></tr></table></figure><p>这两种写法是等效的。OK，先记在这里。在接下的实现中，我们会用到不定参数的特性。</p><p>第二个要补充的知识点是函数的隐式转换。当我们直接将函数参与其他的计算时，函数会默认调用toString方法，直接将函数体转换为字符串参与计算。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">20</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn + <span class="number">10</span>);     <span class="comment">// 输出结果 function fn() &#123; return 20 &#125;10</span></span><br></pre></td></tr></table></figure><p>但是我们可以重写函数的toString方法，让函数参与计算时，输出我们想要的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">20</span>; &#125;</span><br><span class="line">fn.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">30</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fn + <span class="number">10</span>); <span class="comment">// 40</span></span><br></pre></td></tr></table></figure><p>除此之外，当我们重写函数的valueOf方法也能够改变函数的隐式转换结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">20</span>; &#125;</span><br><span class="line">fn.valueOf = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">60</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fn + <span class="number">10</span>); <span class="comment">// 70</span></span><br></pre></td></tr></table></figure><p>当我们同时重写函数的toString方法与valueOf方法时，最终的结果会取valueOf方法的返回结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">20</span>; &#125;</span><br><span class="line">fn.valueOf = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">50</span> &#125;</span><br><span class="line">fn.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">30</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fn + <span class="number">10</span>); <span class="comment">// 60</span></span><br></pre></td></tr></table></figure><p>补充了这两个知识点之后，我们可以来尝试完成之前的题目了。add方法的实现仍然会是一个参数的收集过程。当add函数执行到最后时，仍然返回的是一个函数，但是我们可以通过定义toString/valueOf的方式，让这个函数可以直接参与计算，并且转换的结果是我们想要的。而且它本身也仍然可以继续执行接收新的参数。实现方式如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 第一次执行时，定义一个数组专门用来存储所有的参数</span></span><br><span class="line">    <span class="keyword">var</span> _args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值</span></span><br><span class="line">    <span class="keyword">var</span> adder = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> _adder = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// [].push.apply(_args, [].slice.call(arguments));</span></span><br><span class="line">            _args.push(...arguments);</span><br><span class="line">            <span class="keyword">return</span> _adder;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回</span></span><br><span class="line">        _adder.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _args.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a + b;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> _adder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return adder.apply(null, _args);</span></span><br><span class="line">    <span class="keyword">return</span> adder(..._args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>);   <span class="comment">// f 10</span></span><br><span class="line"><span class="keyword">var</span> b = add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);   <span class="comment">// f 10</span></span><br><span class="line"><span class="keyword">var</span> c = add(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>);   <span class="comment">// f 10</span></span><br><span class="line"><span class="keyword">var</span> d = add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)(<span class="number">4</span>);   <span class="comment">// f 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以利用隐式转换的特性参与计算</span></span><br><span class="line"><span class="built_in">console</span>.log(a + <span class="number">10</span>); <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(b + <span class="number">20</span>); <span class="comment">// 30</span></span><br><span class="line"><span class="built_in">console</span>.log(c + <span class="number">30</span>); <span class="comment">// 40</span></span><br><span class="line"><span class="built_in">console</span>.log(d + <span class="number">40</span>); <span class="comment">// 50</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以继续传入参数，得到的结果再次利用隐式转换参与计算</span></span><br><span class="line"><span class="built_in">console</span>.log(a(<span class="number">10</span>) + <span class="number">100</span>);  <span class="comment">// 120</span></span><br><span class="line"><span class="built_in">console</span>.log(b(<span class="number">10</span>) + <span class="number">100</span>);  <span class="comment">// 120</span></span><br><span class="line"><span class="built_in">console</span>.log(c(<span class="number">10</span>) + <span class="number">100</span>);  <span class="comment">// 120</span></span><br><span class="line"><span class="built_in">console</span>.log(d(<span class="number">10</span>) + <span class="number">100</span>);  <span class="comment">// 120</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其实上栗中的add方法，就是下面这个函数的柯里化函数，只不过我们并没有使用通用式来转化，而是自己封装</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> args.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以下为老版本讲解，请勿阅读学习，因为部分思维并不完全正确。</p></blockquote><h5 id="一、补充知识点之函数的隐式转换"><a href="#一、补充知识点之函数的隐式转换" class="headerlink" title="一、补充知识点之函数的隐式转换"></a>一、补充知识点之函数的隐式转换</h5><p>JavaScript作为一种弱类型语言，它的隐式转换是非常灵活有趣的。当我们没有深入了解隐式转换的时候可能会对一些运算的结果会感动困惑，比如<code>4 + true = 5</code>。当然，如果对隐式转换了解足够深刻，肯定是能够很大程度上提高对js的使用能力。只是我没有打算将所有的隐式转换规则分享给大家，这里暂时只分享一下，函数在隐式转换中的一些规则。</p><p>来一个简单的思考题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function fn() &#123;</span><br><span class="line">    return 20;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(fn + 10); // 输出结果是多少？</span><br></pre></td></tr></table></figure><p>稍微修改一下，再想想输出结果会是什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function fn() &#123;</span><br><span class="line">return 20;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.toString = function() &#123;</span><br><span class="line">return 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(fn + 10);  // 输出结果是多少？</span><br></pre></td></tr></table></figure><p>还可以继续修改一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function fn() &#123;</span><br><span class="line">return 20;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.toString = function() &#123;</span><br><span class="line">return 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.valueOf = function() &#123;</span><br><span class="line">return 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(fn + 10); // 输出结果是多少？</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 输出结果分别为</span><br><span class="line">function fn() &#123;</span><br><span class="line">return 20;</span><br><span class="line">&#125;10</span><br><span class="line"></span><br><span class="line">20</span><br><span class="line"></span><br><span class="line">15</span><br></pre></td></tr></table></figure><p>当使用console.log，或者进行运算时，隐式转换就可能会发生。从上面三个例子中我们可以得出一些关于函数隐式转换的结论。</p><blockquote><p>当我们没有重新定义toString与valueOf时，函数的隐式转换会调用默认的toString方法，它会将函数的定义内容作为字符串返回。而当我们主动定义了toString/vauleOf方法时，那么隐式转换的返回结果则由我们自己控制了。其中valueOf会比toString后执行</p></blockquote><p>因此上面例子的结论就很容易理解了。建议大家动手尝试一下。</p><h5 id="二、补充知识点之利用call-apply封数组的map方法"><a href="#二、补充知识点之利用call-apply封数组的map方法" class="headerlink" title="二、补充知识点之利用call/apply封数组的map方法"></a>二、补充知识点之利用call/apply封数组的map方法</h5><blockquote><p>map(): 对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</p></blockquote><p>通俗来说，就是遍历数组的每一项元素，并且在map的第一个参数（回调函数）中进行运算处理后返回计算结果。返回一个由所有计算结果组成的新数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 回调函数中有三个参数</span><br><span class="line">// 第一个参数表示newArr的每一项，第二个参数表示该项在数组中的索引值</span><br><span class="line">// 第三个表示数组本身</span><br><span class="line">// 除此之外，回调函数中的this，当map不存在第二参数时，this指向丢失，当存在第二个参数时，指向改参数所设定的对象</span><br><span class="line">var newArr = [1, 2, 3, 4].map(function(item, i, arr) &#123;</span><br><span class="line">    console.log(item, i, arr, this);  // 可运行试试看</span><br><span class="line">    return item + 1;  // 每一项加1</span><br><span class="line">&#125;, &#123; a: 1 &#125;)</span><br><span class="line"></span><br><span class="line">console.log(newArr); // [2, 3, 4, 5]</span><br></pre></td></tr></table></figure><p>在上面例子的注释中详细阐述了map方法的细节。现在要面临一个难题，就是如何封装map。</p><p>可以先想想for循环。我们可以使用for循环来实现一个map，但是在封装的时候，我们会考虑一些问题。我们在使用for循环的时候，一个循环过程确实很好封装，但是我们在for循环里面要对每一项做的事情却很难用一个固定的东西去把它封装起来。因为每一个场景，for循环里对数据的处理肯定都是不一样的。</p><p>于是大家就想了一个很好的办法，将这些不一样的操作单独用一个函数来处理，让这个函数成为map方法的第一个参数，具体这个回调函数中会是什么样的操作，则由我们自己在使用时决定。因此，根据这个思路的封装实现如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype._map = function(fn, context) &#123;</span><br><span class="line">    var temp = [];</span><br><span class="line">    if(typeof fn == &apos;function&apos;) &#123;</span><br><span class="line">        var k = 0;</span><br><span class="line">        var len = this.length;</span><br><span class="line">        // 封装for循环过程</span><br><span class="line">        for(; k &lt; len; k++) &#123;</span><br><span class="line">            // 将每一项的运算操作丢进fn里，利用call方法指定fn的this指向与具体参数</span><br><span class="line">            temp.push(fn.call(context, this[k], k, this))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.error(&apos;TypeError: &apos;+ fn +&apos; is not a function.&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 返回每一项运算结果组成的新数组</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var newArr = [1, 2, 3, 4]._map(function(item) &#123;</span><br><span class="line">    return item + 1;</span><br><span class="line">&#125;)</span><br><span class="line">// [2, 3, 4, 5]</span><br></pre></td></tr></table></figure><p>在上面的封装中，我首先定义了一个空的temp数组，该数组用来存储最终的返回结果。在for循环中，每循环一次，就执行一次参数fn函数，fn的参数则使用call方法传入。</p><blockquote><p>在理解了map的封装过程之后，我们就能够明白为什么我们在使用map时，总是期望能够在第一个回调函数中有一个返回值了。在eslint的规则中，如果我们在使用map时没有设置一个返回值，就会被判定为错误。</p></blockquote><p>ok，明白了函数的隐式转换规则与call/apply在这种场景的使用方式，我们就可以尝试通过简单的例子来了解一下柯里化了。</p><h5 id="三、由浅入深的柯里化"><a href="#三、由浅入深的柯里化" class="headerlink" title="三、由浅入深的柯里化"></a>三、由浅入深的柯里化</h5><p>在前端面试中有一个关于柯里化的面试题，流传甚广。</p><blockquote><p>实现一个add方法，使计算结果能够满足如下预期：<br><code>add(1)(2)(3) = 6</code><br><code>add(1, 2, 3)(4) = 10</code><br><code>add(1)(2)(3)(4)(5) = 15</code></p></blockquote><p>很明显，计算结果正是所有参数的和，add方法每运行一次，肯定返回了一个同样的函数，继续计算剩下的参数。</p><p>我们可以从最简单的例子一步一步寻找解决方案。</p><p>当我们只调用两次时，可以这样封装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function add(a) &#123;</span><br><span class="line">return function(b) &#123;</span><br><span class="line">return a + b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(add(1)(2));  // 3</span><br></pre></td></tr></table></figure><p>如果只调用三次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function add(a) &#123;</span><br><span class="line">return function(b) &#123;</span><br><span class="line">return function (c) &#123;</span><br><span class="line">return a + b + c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(add(1)(2)(3)); // 6</span><br></pre></td></tr></table></figure><p>上面的封装看上去跟我们想要的结果有点类似，但是参数的使用被限制得很死，因此并不是我们想要的最终结果，我们需要通用的封装。应该怎么办？总结一下上面2个例子，其实我们是利用闭包的特性，将所有的参数，集中到最后返回的函数里进行计算并返回结果。因此我们在封装时，主要的目的，就是将参数集中起来计算。</p><p>来看看具体实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function add() &#123;</span><br><span class="line">// 第一次执行时，定义一个数组专门用来存储所有的参数</span><br><span class="line">var _args = [].slice.call(arguments);</span><br><span class="line"></span><br><span class="line">// 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值</span><br><span class="line">    var adder = function () &#123;</span><br><span class="line">        var _adder = function() &#123;</span><br><span class="line">            [].push.apply(_args, [].slice.call(arguments));</span><br><span class="line">            return _adder;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">// 利用隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回</span><br><span class="line">        _adder.toString = function () &#123;</span><br><span class="line">            return _args.reduce(function (a, b) &#123;</span><br><span class="line">                return a + b;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return _adder;</span><br><span class="line">    &#125;</span><br><span class="line">    return adder.apply(null, [].slice.call(arguments));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出结果，可自由组合的参数</span><br><span class="line">console.log(add(1, 2, 3, 4, 5));  // 15</span><br><span class="line">console.log(add(1, 2, 3, 4)(5));  // 15</span><br><span class="line">console.log(add(1)(2)(3)(4)(5));  // 15</span><br></pre></td></tr></table></figure><p>上面的实现，利用闭包的特性，主要目的是想通过一些巧妙的方法将所有的参数收集在一个数组里，并在最终隐式转换时将数组里的所有项加起来。因此我们在调用add方法的时候，参数就显得非常灵活。当然，也就很轻松的满足了我们的需求。</p><p>那么读懂了上面的demo，然后我们再来看看柯里化的定义，相信大家就会更加容易理解了。</p><blockquote><p>柯里化（英语：Currying），又称为部分求值，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回一个新的函数的技术，新函数接受余下参数并返回运算结果。</p></blockquote><ul><li>接收单一参数，因为要携带不少信息，因此常常以回调函数的理由来解决。</li><li>将部分参数通过回调函数等方式传入函数中</li><li>返回一个新函数，用于处理所有的想要传入的参数</li></ul><p>在上面的例子中，我们可以将<code>add(1, 2, 3, 4)</code>转换为<code>add(1)(2)(3)(4)</code>。这就是部分求值。每次传入的参数都只是我们想要传入的所有参数中的一部分。当然实际应用中，并不会常常这么复杂的去处理参数，很多时候也仅仅只是分成两部分而已。</p><p>咱们再来一起思考一个与柯里化相关的问题。</p><blockquote><p>假如有一个计算要求，需要我们将数组里面的每一项用我们自己想要的字符给连起来。我们应该怎么做？想到使用join方法，就很简单。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">// 实际开发中并不建议直接给Array扩展新的方法</span><br><span class="line">// 只是用这种方式演示能够更加清晰一点</span><br><span class="line">Array.prototype.merge = function(chars) &#123;</span><br><span class="line">return this.join(chars);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var string = arr.merge(&apos;-&apos;)</span><br><span class="line"></span><br><span class="line">console.log(string);  // 1-2-3-4-5</span><br></pre></td></tr></table></figure><p>增加难度，将每一项加一个数后再连起来。那么这里就需要map来帮助我们对每一项进行特殊的运算处理，生成新的数组然后用字符连接起来了。实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">Array.prototype.merge = function(chars, number) &#123;</span><br><span class="line">return this.map(function(item) &#123;</span><br><span class="line">return item + number;</span><br><span class="line">&#125;).join(chars);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var string = arr.merge(&apos;-&apos;, 1);</span><br><span class="line"></span><br><span class="line">console.log(string); // 2-3-4-5-6</span><br></pre></td></tr></table></figure><p>但是如果我们又想要让数组每一项都减去一个数之后再连起来呢？当然和上面的加法操作一样的实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">Array.prototype.merge = function(chars, number) &#123;</span><br><span class="line">return this.map(function(item) &#123;</span><br><span class="line">return item - number;</span><br><span class="line">&#125;).join(chars);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var string = arr.merge(&apos;~&apos;, 1);</span><br><span class="line"></span><br><span class="line">console.log(string); // 0~1~2~3~4</span><br></pre></td></tr></table></figure><p>机智的小伙伴肯定发现困惑所在了。我们期望封装一个函数，能同时处理不同的运算过程，但是我们并不能使用一个固定的套路将对每一项的操作都封装起来。于是问题就变成了和封装map的时候所面临的问题一样了。我们可以借助柯里化来搞定。</p><p>与map封装同样的道理，既然我们事先并不确定我们将要对每一项数据进行怎么样的处理，我只是知道我们需要将他们处理之后然后用字符连起来，所以不妨将处理内容保存在一个函数里。而仅仅固定封装连起来的这一部分需求。</p><p>于是我们就有了以下的封装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 封装很简单，一句话搞定</span><br><span class="line">Array.prototype.merge = function(fn, chars) &#123;</span><br><span class="line">return this.map(fn).join(chars);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr = [1, 2, 3, 4];</span><br><span class="line"></span><br><span class="line">// 难点在于，在实际使用的时候，操作怎么来定义，利用闭包保存于传递num参数</span><br><span class="line">var add = function(num) &#123;</span><br><span class="line">return function(item) &#123;</span><br><span class="line">return item + num;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var red = function(num) &#123;</span><br><span class="line">return function(item) &#123;</span><br><span class="line">return item - num;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 每一项加2后合并</span><br><span class="line">var res1 = arr.merge(add(2), &apos;-&apos;);</span><br><span class="line"></span><br><span class="line">// 每一项减2后合并</span><br><span class="line">var res2 = arr.merge(red(1), &apos;-&apos;);</span><br><span class="line"></span><br><span class="line">// 也可以直接使用回调函数，每一项乘2后合并</span><br><span class="line">var res3 = arr.merge((function(num) &#123;</span><br><span class="line">return function(item) &#123;</span><br><span class="line">return item * num</span><br><span class="line">&#125;</span><br><span class="line">&#125;)(2), &apos;-&apos;)</span><br><span class="line"></span><br><span class="line">console.log(res1); // 3-4-5-6</span><br><span class="line">console.log(res2); // 0-1-2-3</span><br><span class="line">console.log(res3); // 2-4-6-8</span><br></pre></td></tr></table></figure><p>大家能从上面的例子，发现柯里化的特征吗？</p><h5 id="四、柯里化通用式"><a href="#四、柯里化通用式" class="headerlink" title="四、柯里化通用式"></a>四、柯里化通用式</h5><p>通用的柯里化写法其实比我们上边封装的add方法要简单许多。   </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> currying = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 主要还是收集所有需要的参数到一个数组中，便于统一计算</span></span><br><span class="line"><span class="keyword">var</span> _args = args.concat([].slice.call(<span class="built_in">arguments</span>));</span><br><span class="line"><span class="keyword">return</span> fn.apply(<span class="literal">null</span>, _args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = currying(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"><span class="keyword">return</span> args.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">20</span>, <span class="number">10</span>));  <span class="comment">// 40</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">10</span>, <span class="number">5</span>));   <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><h5 id="五、柯里化与bind"><a href="#五、柯里化与bind" class="headerlink" title="五、柯里化与bind"></a>五、柯里化与bind</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.bind = function(context) &#123;</span><br><span class="line">var _this = this;</span><br><span class="line">var args = [].slice.call(arguments, 1);</span><br><span class="line"></span><br><span class="line">return function() &#123;</span><br><span class="line">return _this.apply(context, args)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子利用call与apply的灵活运用，实现了bind的功能。</p><p>在前面的几个例子中，我们可以总结一下柯里化的特点：</p><ul><li>接收单一参数，将更多的参数通过回调函数来搞定？</li><li>返回一个新函数，用于处理所有的想要传入的参数；</li><li>需要利用call/apply与arguments对象收集参数；</li><li>返回的这个函数正是用来处理收集起来的参数。</li></ul><p>希望大家读完之后都能够大概明白柯里化的概念，如果想要熟练使用它，就需要我们掌握更多的实际经验才行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;柯里化是函数的一个比较高级的应用，想要理解它并不简单。因此我一直在思考应该如何更加表达才能让大家理解起来更加容易。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以下是新版本讲解。高阶函数章节由于一些原因并未公开，大家可以自行搜索学习&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/categories/JavaScript/"/>
    
    
      <category term="柯里化" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/tags/%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>摘抄执行上下文</title>
    <link href="https://zombrbrand.github.io/ZombieBrand.github.io/2019/03/17/%E6%91%98%E6%8A%84%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <id>https://zombrbrand.github.io/ZombieBrand.github.io/2019/03/17/摘抄执行上下文/</id>
    <published>2019-03-17T08:18:35.000Z</published>
    <updated>2019-03-17T14:13:17.916Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/ZombieBrand.github.io/assets/599584-58d31e5b80737ca0.png" alt="先随便放张图"><br>我们在JS学习初期或者面试的时候常常会遇到考核变量提升的思考题。比如先来一个简单一点的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">// 这里会打印出什么？</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>暂时先不管这个例子，我们先引入一个JavaScript中最基础，但同时也是最重要的一个概念<strong>执行上下文（Execution Context）</strong>。</p><p>每次当控制器转到可执行代码的时候，就会进入一个执行上下文。执行上下文可以理解为当前代码的执行环境，它会形成一个作用域。JavaScript中的运行环境大概包括三种情况。</p><ul><li>全局环境：JavaScript代码运行起来会首先进入该环境</li><li>函数环境：当函数被调用执行时，会进入当前函数中执行代码</li><li>eval（不建议使用，可忽略）</li></ul><p>因此在一个JavaScript程序中，必定会产生多个执行上下文，在我的上一篇文章中也有提到，JavaScript引擎会以栈的方式来处理它们，这个栈，我们称其为函数调用栈(call stack)。栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。</p><p>当代码在执行过程中，遇到以上三种情况，都会生成一个执行上下文，放入栈中，而处于栈顶的上下文执行完毕之后，就会自动出栈。为了更加清晰的理解这个过程，根据下面的例子，结合图示给大家展示。</p><blockquote><p>执行上下文可以理解为函数执行的环境，每一个函数执行时，都会给对应的函数创建这样一个执行环境。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">'blue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> anotherColor = <span class="string">'red'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swapColors</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> tempColor = anotherColor;</span><br><span class="line">        anotherColor = color;</span><br><span class="line">        color = tempColor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    swapColors();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">changeColor();</span><br></pre></td></tr></table></figure><p>我们用ECStack来表示处理执行上下文组的堆栈。我们很容易知道，第一步，首先是全局上下文入栈。</p><p><img src="/ZombieBrand.github.io/assets/599584-bb2d5907b658c456.png" alt="第一步：全局上下文入栈"></p><p>全局上下文入栈之后，其中的可执行代码开始执行，直到遇到了<code>changeColor()</code>，这一句激活函数<code>changeColor</code>创建它自己的执行上下文，因此第二步就是changeColor的执行上下文入栈。</p><p><img src="/ZombieBrand.github.io/assets/599584-bbc841d4908c05cb.png" alt="第二步：changeColor的执行上下文入栈"></p><p>changeColor的上下文入栈之后，控制器开始执行其中的可执行代码，遇到<code>swapColors()</code>之后又激活了一个执行上下文。因此第三步是swapColors的执行上下文入栈。</p><p><img src="/ZombieBrand.github.io/assets/599584-8bc0424ffcb2507b.png" alt="第三步：swapColors的执行上下文入栈"></p><p>在swapColors的可执行代码中，再没有遇到其他能生成执行上下文的情况，因此这段代码顺利执行完毕，swapColors的上下文从栈中弹出。</p><p><img src="http://upload-images.jianshu.io/upload_images/599584-bbc841d4908c05cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第四步：swapColors的执行上下文出栈"></p><p>swapColors的执行上下文弹出之后，继续执行changeColor的可执行代码，也没有再遇到其他执行上下文，顺利执行完毕之后弹出。这样，ECStack中就只身下全局上下文了。</p><p><img src="http://upload-images.jianshu.io/upload_images/599584-bb2d5907b658c456.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第五步：changeColor的执行上下文出栈"></p><p>全局上下文在浏览器窗口关闭后出栈。</p><blockquote><p>注意：函数中，遇到return能直接终止可执行代码的执行，因此会直接将当前上下文弹出栈。</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/599584-58d31e5b80737ca0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="整个过程"></p><p>详细了解了这个过程之后，我们就可以对执行上下文总结一些结论了。</p><ul><li>单线程</li><li>同步执行，只有栈顶的上下文处于执行中，其他上下文需要等待</li><li>全局上下文只有唯一的一个，它在浏览器关闭时出栈</li><li>函数的执行上下文的个数没有限制</li><li>每次某个函数被调用，就会有个新的执行上下文为其创建，即使是调用的自身函数，也是如此。</li></ul><p>为了巩固一下执行上下文的理解，我们再来绘制一个例子的演变过程，这是一个简单的闭包例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n=<span class="number">999</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result=f1();</span><br><span class="line">result(); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure><p>因为f1中的函数f2在f1的可执行代码中，并没有被调用执行，因此执行f1时，f2不会创建新的上下文，而直到result执行时，才创建了一个新的。具体演变过程如下。</p><p><img src="/ZombieBrand.github.io/assets/599584-bb9829780f50c07e.png" alt="上例演变过程"></p><blockquote><p>如果你在某公众号看到我的文章，然后发现下面的评论说最后一个例子错了，请不要管他们，他们把函数调用栈和作用域链没有分清楚就跑出来质疑，真的很有问题。建议大家读一读这系列的第六篇文章，教你如何自己拥有判断对错的能力。</p></blockquote><p>最后留一个简单的例子，大家可以自己脑补一下这个例子在执行过程中执行上下文的变化情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"window"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = &#123;</span><br><span class="line">  name: <span class="string">'Perter'</span>,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用变量保存的方式保证其访问的是p对象</span></span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> self.name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getName = p.getName();</span><br><span class="line"><span class="keyword">var</span> _name = getName();</span><br><span class="line"><span class="built_in">console</span>.log(_name);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/ZombieBrand.github.io/assets/599584-58d31e5b80737ca0.png&quot; alt=&quot;先随便放张图&quot;&gt;&lt;br&gt;我们在JS学习初期或者面试的时候常常会遇到考核变量提升的思考题。比如先来一个简单一点的。&lt;/p&gt;
&lt;f
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/categories/JavaScript/"/>
    
    
      <category term="执行上下文" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/tags/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>摘抄在chrome中观察函数调用</title>
    <link href="https://zombrbrand.github.io/ZombieBrand.github.io/2019/03/17/%E6%91%98%E6%8A%84%E5%9C%A8chrome%E4%B8%AD%E8%A7%82%E5%AF%9F%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/"/>
    <id>https://zombrbrand.github.io/ZombieBrand.github.io/2019/03/17/摘抄在chrome中观察函数调用/</id>
    <published>2019-03-17T08:18:21.000Z</published>
    <updated>2019-03-17T14:13:17.915Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/ZombieBrand.github.io/assets/599584-64a8168e053e721f.png" alt="配图与本文无关"></p><p>在前端开发中，有一个非常重要的技能，叫做<strong>断点调试</strong>。</p><p>在chrome的开发者工具中，通过断点调试，我们能够非常方便的一步一步的观察JavaScript的执行过程，直观感知函数调用栈，作用域链，变量对象，闭包，this等关键信息的变化。因此，断点调试对于快速定位代码错误，快速了解代码的执行过程有着非常重要的作用，这也是我们前端开发者必不可少的一个高级技能。</p><p>当然如果你对JavaScript的这些基础概念（执行上下文，变量对象，闭包，this等）了解还不够的话，想要透彻掌握断点调试可能会有一些困难。但是好在在前面几篇文章，我都对这些概念进行了详细的概述，因此要掌握这个技能，对大家来说，应该是比较轻松的。</p><p>这篇文章的主要目的在于借助对于断点调试的学习，来进一步加深对闭包的理解。</p><h5 id="一、基础概念回顾"><a href="#一、基础概念回顾" class="headerlink" title="一、基础概念回顾"></a>一、基础概念回顾</h5><p>函数在被调用执行时，会创建一个当前函数的执行上下文。在该执行上下文的创建阶段，变量对象、作用域链、闭包、this指向会分别被确定。而一个JavaScript程序中一般来说会有多个函数，JavaScript引擎使用函数调用栈来管理这些函数的调用顺序。函数调用栈的调用顺序与栈数据结构一致。</p><h5 id="二、认识断点调试工具"><a href="#二、认识断点调试工具" class="headerlink" title="二、认识断点调试工具"></a>二、认识断点调试工具</h5><p>在尽量新版本的chrome浏览器中（不确定你用的老版本与我的一致），调出chrome浏览器的开发者工具。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">浏览器右上角竖着的三点 -&gt; 更多工具 -&gt; 开发者工具 -&gt; Sources</span><br></pre></td></tr></table></figure><p>界面如图。</p><p><img src="/ZombieBrand.github.io/assets/599584-56f0737789bb3c36.png" alt="断点调试界面"></p><p>在我的demo中，我把代码放在app.js中，在index.html中引入。我们暂时只需要关注截图中红色箭头的地方。在最右侧上方，有一排图标。我们可以通过使用他们来控制函数的执行顺序。从左到右他们依次是：</p><ul><li>resume/pause script execution<br>恢复/暂停脚本执行</li><li><strong>step over next function call</strong><br>跨过，实际表现是不遇到函数时，执行下一步。遇到函数时，不进入函数直接执行下一步。</li><li><strong>step into next function call</strong><br>跨入，实际表现是不遇到函数时，执行下一步。遇到到函数时，进入函数执行上下文。</li><li><strong>step out of current function</strong><br>跳出当前函数</li><li>deactivate breakpoints<br>停用断点</li><li>don‘t pause on exceptions<br>不暂停异常捕获</li></ul><p>其中跨过，跨入，跳出是我使用最多的三个操作。</p><p>上图右侧第二个红色箭头指向的是函数调用栈（call Stack），这里会显示代码执行过程中，调用栈的变化。</p><p>右侧第三个红色箭头指向的是作用域链（Scope），这里会显示当前函数的作用域链。其中Local表示当前的局部变量对象，Closure表示当前作用域链中的闭包。借助此处的作用域链展示，我们可以很直观的判断出一个例子中，到底谁是闭包，对于闭包的深入了解具有非常重要的帮助作用。</p><h5 id="三、断点设置"><a href="#三、断点设置" class="headerlink" title="三、断点设置"></a>三、断点设置</h5><p>在显示代码行数的地方点击，即可设置一个断点。断点设置有以下几个特点：</p><ul><li>在单独的变量声明(如果没有赋值)，函数声明的那一行，无法设置断点。</li><li>设置断点后刷新页面，JavaScript代码会执行到断点位置处暂停执行，然后我们就可以使用上边介绍过的几个操作开始调试了。</li><li>当你设置多个断点时，chrome工具会自动判断从最早执行的那个断点开始执行，因此我一般都是设置一个断点就行了。</li></ul><h5 id="四、实例"><a href="#四、实例" class="headerlink" title="四、实例"></a>四、实例</h5><p>接下来，我们借助一些实例，来使用断点调试工具，看一看，我们的demo函数，在执行过程中的具体表现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo01</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( a );</span><br><span class="line">    &#125;</span><br><span class="line">    fn = baz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line">bar(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>在向下阅读之前，我们可以停下来思考一下，这个例子中，谁是闭包？</p><p>这是来自《你不知道的js》中的一个例子。由于在使用断点调试过程中，发现chrome浏览器理解的闭包与该例子中所理解的闭包不太一致，因此专门挑出来，供大家参考。我个人更加倾向于chrome中的理解。</p><ul><li>第一步：设置断点，然后刷新页面。</li></ul><p><img src="/ZombieBrand.github.io/assets/599584-ed677cf1c64e39e7.png" alt="设置断点"></p><ul><li>第二步：点击上图红色箭头指向的按钮（step into），该按钮的作用会根据代码执行顺序，一步一步向下执行。在点击的过程中，我们要注意观察下方call stack 与 scope的变化，以及函数执行位置的变化。</li></ul><p>一步一步执行，当函数执行到上例子中<br><img src="/ZombieBrand.github.io/assets/599584-1b8e8f6a6cee5b88.png" alt="baz函数被调用执行，foo形成了闭包"></p><p>我们可以看到，在chrome工具的理解中，由于在foo内部声明的baz函数在调用时访问了它的变量a，因此foo成为了闭包。这好像和我们学习到的知识不太一样。我们来看看在《你不知道的js》这本书中的例子中的理解。</p><p><img src="/ZombieBrand.github.io/assets/599584-7a72e8a1b8fdd764.png" alt="你不知道的js中的例子"></p><p>书中的注释可以明显的看出，作者认为fn为闭包。即baz，这和chrome工具中明显是不一样的。</p><p>而在备受大家推崇的《JavaScript高级编程》一书中，是这样定义闭包。</p><p><img src="/ZombieBrand.github.io/assets/599584-b30c0aee7668c183.png" alt="JavaScript高级编程中闭包的定义"></p><p><img src="/ZombieBrand.github.io/assets/599584-ee0c3051f02ec5d8.png" alt="书中作者将自己理解的闭包与包含函数所区分"></p><p>这里chrome中理解的闭包，与我所阅读的这几本书中的理解的闭包不一样。其实在之前对于闭包分析的文章中，我已经有对这种情况做了一个解读。<a href="http://www.jianshu.com/p/21a16d44f150" target="_blank" rel="noopener">闭包详解</a></p><p>闭包是一个特殊对象，它由执行上下文(代号A)与在该执行上下文中创建的函数(代号B)共同组成。</p><p>当B执行时，如果访问了A中变量对象中的值，那么闭包就会产生。</p><p>那么在大多数理解中，包括许多著名的书籍，文章里都以函数B的名字代指这里生成的闭包。而在chrome中，则以执行上下文A的函数名代指闭包。</p><p>我们修改一下demo01中的例子，来看看一个非常有意思的变化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo02</span></span><br><span class="line"><span class="keyword">var</span> fn;</span><br><span class="line"><span class="keyword">var</span> m = <span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    fn = baz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fn(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line">bar(); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>这个例子在demo01的基础上，我在baz函数中传入一个参数，并打印出来。在调用时，我将全局的变量m传入。输出结果变为20。在使用断点调试看看作用域链。</p><p><img src="/ZombieBrand.github.io/assets/599584-f74b68b5f041ca9e.png" alt="闭包没了，作用域链中没有包含foo了。"></p><p>是不是结果有点意外，闭包没了，作用域链中没有包含foo了。我靠，跟我们理解的好像又有点不一样。所以通过这个对比，我们可以确定闭包的形成需要两个条件。</p><ul><li>在函数内部创建新的函数；</li><li>新的函数在执行时，访问了函数的变量对象；</li></ul><p>还有更有意思的。</p><p>我们继续来看看一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo03</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo();</span><br><span class="line"><span class="keyword">var</span> fn = bar();</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><p>在这个例子中，fn只访问了foo中的a变量，因此它的闭包只有foo。</p><p><img src="/ZombieBrand.github.io/assets/599584-6e98041bfd2f719f.png" alt="闭包只有foo"></p><p>修改一下demo03，我们在fn中也访问bar中b变量试试看。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo04</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo();</span><br><span class="line"><span class="keyword">var</span> fn = bar();</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><p><img src="/ZombieBrand.github.io/assets/599584-431d16611cac1243.png" alt="这个时候闭包变成了两个"></p><p>这个时候，闭包变成了两个。分别是bar，foo。</p><p>我们知道，闭包在模块中的应用非常重要。因此，我们来一个模块的例子，也用断点工具来观察一下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo05</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> test = &#123;</span><br><span class="line">        m: <span class="number">20</span>,</span><br><span class="line">        add: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a + x;</span><br><span class="line">        &#125;,</span><br><span class="line">        sum: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a + b + <span class="keyword">this</span>.m;</span><br><span class="line">        &#125;,</span><br><span class="line">        mark: <span class="function"><span class="keyword">function</span>(<span class="params">k, j</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> k + j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">window</span>.test = test;</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">test.add(<span class="number">100</span>);</span><br><span class="line">test.sum();</span><br><span class="line">test.mark();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _mark = test.mark;</span><br><span class="line">_mark();</span><br></pre></td></tr></table></figure><p><img src="/ZombieBrand.github.io/assets/599584-662ec3ce1cf33206.png" alt="add执行时，闭包为外层的自执行函数，this指向test"></p><p><img src="/ZombieBrand.github.io/assets/599584-24572d8b5dd381b6.png" alt="sum执行时，同上"></p><p><img src="/ZombieBrand.github.io/assets/599584-77888095edb980a7.png" alt="mark执行时，闭包为外层的自执行函数，this指向test"></p><p><img src="/ZombieBrand.github.io/assets/599584-fedeee99354936a9.png" alt="\_mark执行时，闭包为外层的自执行函数，this指向window"></p><blockquote><p>注意：这里的this指向显示为Object或者Window，大写开头，他们表示的是实例的构造函数，实际上this是指向的具体实例</p><p>test.mark能形成闭包，跟下面的补充例子（demo07）情况是一样的。</p></blockquote><p>我们还可以结合点断调试的方式，来理解那些困扰我们很久的this指向。随时观察this的指向，在实际开发调试中非常有用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo06</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.call(obj); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p><img src="/ZombieBrand.github.io/assets/599584-ab511b394be82692.png" alt="this指向obj"></p><p>最后继续补充一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo07</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>这个例子，和其他例子不太一样。虽然fn2并没有访问到foo的变量，但是foo执行时仍然变成了闭包。而当我将fn1的声明去掉时，闭包便不会出现了。</p><p>那么结合这个特殊的例子，我们可以这样这样定义闭包。</p><p><strong>闭包是指这样的作用域(foo)，它包含有一个函数(fn1)，这个函数(fn1)可以调用被这个作用域所封闭的变量(a)、函数、或者闭包等内容。通常我们通过闭包所对应的函数来获得对闭包的访问。</strong></p><p>更多的例子，大家可以自行尝试，总之，学会了使用断点调试之后，我们就能够很轻松的了解一段代码的执行过程了。这对快速定位错误，快速了解他人的代码都有非常巨大的帮助。大家一定要动手实践，把它给学会。</p><p>最后，根据以上的摸索情况，再次总结一下闭包：</p><ul><li>闭包是在函数被调用执行的时候才被确认创建的。</li><li>闭包的形成，与作用域链的访问顺序有直接关系。</li><li>只有内部函数访问了上层作用域链中的变量对象时，才会形成闭包，因此，我们可以利用闭包来访问函数内部的变量。</li></ul><blockquote><p>大家也可以根据我提供的这个方法，对其他的例子进行更多的测试，如果发现我的结论有不对的地方，欢迎指出，大家相互学习进步，谢谢大家。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/ZombieBrand.github.io/assets/599584-64a8168e053e721f.png&quot; alt=&quot;配图与本文无关&quot;&gt;&lt;/p&gt;
&lt;p&gt;在前端开发中，有一个非常重要的技能，叫做&lt;strong&gt;断点调试&lt;/strong&gt;。&lt;/p&gt;
      
    
    </summary>
    
      <category term="chrome" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/categories/chrome/"/>
    
    
      <category term="chrome" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/tags/chrome/"/>
    
  </entry>
  
  <entry>
    <title>摘抄变量对象</title>
    <link href="https://zombrbrand.github.io/ZombieBrand.github.io/2019/03/17/%E6%91%98%E6%8A%84%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/"/>
    <id>https://zombrbrand.github.io/ZombieBrand.github.io/2019/03/17/摘抄变量对象/</id>
    <published>2019-03-17T08:18:04.000Z</published>
    <updated>2019-03-17T14:13:17.916Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/ZombieBrand.github.io/assets/599584-ab88faf1cbf625b6.png" alt></p><p>开年之后工作热情一直不是很高，这几天一直处于消极怠工状态。早上不想起床，起床了不想上班。明明放假之前工作热情还一直很高，一直心心念念的想把小程序项目怼出来，结果休假回来之后画风完全不一样了。我感觉自己得了严重了节后综合征。还好撸了几篇文章，勉强表示这一周的时间没有完全浪费。这篇文章要给大家介绍的是变量对象。</p><p>在JavaScript中，我们肯定不可避免的需要声明变量和函数，可是JS解析器是如何找到这些变量的呢？我们还得对执行上下文有一个进一步的了解。</p><p>在上一篇文章中，我们已经知道，当调用一个函数时（激活），一个新的执行上下文就会被创建。而一个执行上下文的生命周期可以分为两个阶段。</p><ul><li><strong>创建阶段</strong><br>在这个阶段中，执行上下文会分别创建变量对象，建立作用域链，以及确定this的指向。</li><li><strong>代码执行阶段</strong><br>创建完成之后，就会开始执行代码，这个时候，会完成变量赋值，函数引用，以及执行其他代码。</li></ul><p><img src="/ZombieBrand.github.io/assets/599584-391af3aad043c028.png" alt="执行上下文生命周期"></p><p>从这里我们就可以看出详细了解执行上下文极为重要，因为其中涉及到了变量对象，作用域链，this等很多人没有怎么弄明白，但是却极为重要的概念，它关系到我们能不能真正理解JavaScript。在后面的文章中我们会一一详细总结，这里我们先重点了解变量对象。</p><h5 id="变量对象（Variable-Object）"><a href="#变量对象（Variable-Object）" class="headerlink" title="变量对象（Variable Object）"></a>变量对象（Variable Object）</h5><p>变量对象的创建，依次经历了以下几个过程。</p><ol><li>建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。</li><li>检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。</li><li>检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。</li></ol><p>许多读者在阅读到这的时候会因为下面的这样场景对于“跳过”一词产生疑问。既然变量声明的foo遇到函数声明的foo会跳过，可是为什么最后foo的输出结果仍然是被覆盖了？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'function foo'</span>) &#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>其实只是大家在阅读的时候不够仔细，因为上面的三条规则仅仅适用于变量对象的创建过程。也就是执行上下文的创建过程。而<code>foo = 20</code>是在执行上下文的执行过程中运行的，输出结果自然会是20。对比下例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// function foo</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'function foo'</span>) &#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上栗的执行顺序为</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先将所有函数声明放入变量对象中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'function foo'</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其次将所有变量声明放入变量对象中，但是因为foo已经存在同名函数，因此此时会跳过undefined的赋值</span></span><br><span class="line"><span class="comment">// var foo = undefined;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后开始执行阶段代码的执行</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// function foo</span></span><br><span class="line">foo = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p><img src="/ZombieBrand.github.io/assets/599584-7d131cfe82a20d37.png" alt="我知道有的人不喜欢看文字"></p><p>根据这个规则，理解变量提升就变得十分简单了。在很多文章中虽然提到了变量提升，但是具体是怎么回事还真的很多人都说不出来，以后在面试中用变量对象的创建过程跟面试官解释变量提升，保证瞬间提升逼格。</p><p>在上面的规则中我们看出，function声明会比var声明优先级更高一点。为了帮助大家更好的理解变量对象，我们结合一些简单的例子来进行探讨。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo01</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="built_in">console</span>.log(foo());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>在上例中，我们直接从test()的执行上下文开始理解。全局作用域中运行<code>test()</code>时，test()的执行上下文开始创建。为了便于理解，我们用如下的形式来表示</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建过程</span></span><br><span class="line">testEC = &#123;</span><br><span class="line">    <span class="comment">// 变量对象</span></span><br><span class="line">    VO: &#123;&#125;,</span><br><span class="line">    scopeChain: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为本文暂时不详细解释作用域链，所以把变量对象专门提出来说明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// VO 为 Variable Object的缩写，即变量对象</span></span><br><span class="line">VO = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;...&#125;,  <span class="comment">//注：在浏览器的展示中，函数的参数可能并不是放在arguments对象中，这里为了方便理解，我做了这样的处理</span></span><br><span class="line">    foo: <span class="xml"><span class="tag">&lt;<span class="name">foo</span> <span class="attr">reference</span>&gt;</span>  // 表示foo的地址引用</span></span><br><span class="line"><span class="xml">    a: undefined</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>未进入执行阶段之前，变量对象中的属性都不能访问！但是进入执行阶段之后，变量对象转变为了活动对象，里面的属性都能被访问了，然后开始进行执行阶段的操作。</p><blockquote><p>这样，如果再面试的时候被问到变量对象和活动对象有什么区别，就又可以自如的应答了，他们其实都是同一个对象，只是处于执行上下文的不同生命周期。不过只有处于函数调用栈栈顶的执行上下文中的变量对象，才会变成活动对象。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行阶段</span></span><br><span class="line">VO -&gt;  AO   <span class="comment">// Active Object</span></span><br><span class="line">AO = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;...&#125;,</span><br><span class="line">    foo: <span class="xml"><span class="tag">&lt;<span class="name">foo</span> <span class="attr">reference</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">    a: 1,</span></span><br><span class="line"><span class="xml">    this: Window</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>因此，上面的例子demo1，执行顺序就变成了这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> a;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="built_in">console</span>.log(foo());</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>再来一个例子，巩固一下我们的理解。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(foo);</span><br><span class="line">    <span class="built_in">console</span>.log(bar);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> foo = <span class="string">'Hello'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(foo);</span><br><span class="line">    <span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'world'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建阶段</span></span><br><span class="line">VO = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;...&#125;,</span><br><span class="line">    foo: <span class="xml"><span class="tag">&lt;<span class="name">foo</span> <span class="attr">reference</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">    bar: undefined</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">// 这里有一个需要注意的地方，因为var声明的变量当遇到同名的属性时，会跳过而不会覆盖</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行阶段</span></span><br><span class="line">VO -&gt; AO</span><br><span class="line">VO = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;...&#125;,</span><br><span class="line">    foo: <span class="string">'Hello'</span>,</span><br><span class="line">    bar: <span class="xml"><span class="tag">&lt;<span class="name">bar</span> <span class="attr">reference</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">    this: Window</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>需要结合上面的知识，仔细对比这个例子中变量对象从创建阶段到执行阶段的变化，如果你已经理解了，说明变量对象相关的东西都已经难不倒你了。</p><h5 id="全局上下文的变量对象"><a href="#全局上下文的变量对象" class="headerlink" title="全局上下文的变量对象"></a>全局上下文的变量对象</h5><p>以浏览器中为例，全局对象为window。<br>全局上下文有一个特殊的地方，它的变量对象，就是window对象。而这个特殊，在this指向上也同样适用，this也是指向window。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以浏览器中为例，全局对象为window</span></span><br><span class="line"><span class="comment">// 全局上下文</span></span><br><span class="line">windowEC = &#123;</span><br><span class="line">    VO: Window,</span><br><span class="line">    scopeChain: &#123;&#125;,</span><br><span class="line">    <span class="keyword">this</span>: Window</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，全局上下文的生命周期，与程序的生命周期一致，只要程序运行不结束，比如关掉浏览器窗口，全局上下文就会一直存在。其他所有的上下文环境，都能直接访问全局上下文的属性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/ZombieBrand.github.io/assets/599584-ab88faf1cbf625b6.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;开年之后工作热情一直不是很高，这几天一直处于消极怠工状态。早上不想起床，起床了不想上班。明明放假之前工作热情还一
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/tags/JavaScript/"/>
    
      <category term="变量对象" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/tags/%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>摘抄函数与函数式编程</title>
    <link href="https://zombrbrand.github.io/ZombieBrand.github.io/2019/03/17/%E6%91%98%E6%8A%84%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>https://zombrbrand.github.io/ZombieBrand.github.io/2019/03/17/摘抄函数与函数式编程/</id>
    <published>2019-03-17T08:17:52.000Z</published>
    <updated>2019-03-17T08:22:59.536Z</updated>
    
    <content type="html"><![CDATA[<p>纵观JavaScript中所有必须需要掌握的重点知识中，函数是我们在初学的时候最容易忽视的一个知识点。在学习的过程中，可能会有很多人、很多文章告诉你面向对象很重要，原型很重要，可是却很少有人告诉你，面向对象中所有的重点难点，几乎都与函数息息相关。</p><p>包括我之前几篇文章介绍的执行上下文，变量对象，闭包，this等，都是围绕函数的细节来展开。</p><p>我知道很多人在学习中，很急切的希望自己快一点开始学习面向对象，学习模块，学习流行框架，然后迅速成为高手。但是我可以很负责的告诉你，关于函数的这些基础东西没理解到一定程度，那么你的学习进展一定是举步维艰的。</p><p>所以，大家一定要重视函数！</p><p>当然，关于函数的重点，难点在前面几篇文章都已经说得差不多了，这篇文章主要总结一下函数的基础知识，并初步学习函数式编程的思维。</p><h5 id="一、函数声明、函数表达式、匿名函数与自执行函数"><a href="#一、函数声明、函数表达式、匿名函数与自执行函数" class="headerlink" title="一、函数声明、函数表达式、匿名函数与自执行函数"></a>一、函数声明、函数表达式、匿名函数与自执行函数</h5><p>关于函数在实际开发中的应用，大体可以总结为函数声明、函数表达式、匿名函数、自执行函数。</p><p><strong>函数声明</strong></p><p>我们知道，JavaScript中，有两种声明方式，一个是使用<code>var</code>的变量声明，另一个是使用<code>function</code>的函数声明。</p><p>在<a href="http://www.jianshu.com/p/330b1505e41d" target="_blank" rel="noopener">前端基础进阶（三）：变量对象详解</a>中我有提到过，变量对象的创建过程中，函数声明比变量声明具有更为优先的执行顺序，即我们常常提到的函数声明提前。因此我们在执行上下文中，无论在什么位置声明了函数，我们都可以在同一个执行上下文中直接使用该函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn();  <span class="comment">// function</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'function'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong> 函数表达式 </strong></p><p>与函数声明不同，函数表达式使用了var进行声明，那么我们在确认他是否可以正确使用的时候就必须依照var的规则进行判断，即变量声明。我们知道使用var进行变量声明，其实是进行了两步操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量声明</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际执行顺序</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="literal">undefined</span>;  <span class="comment">// 变量声明，初始值undefined，变量提升，提升顺序次于function声明</span></span><br><span class="line">a = <span class="number">20</span>;  <span class="comment">// 变量赋值，该操作不会提升</span></span><br></pre></td></tr></table></figure><p>同样的道理，当我们使用变量声明的方式来声明函数时，就是我们常常说的函数表达式。函数表达的提升方式与变量声明一致。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn(); <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'function'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例子的执行顺序为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="literal">undefined</span>;   <span class="comment">// 变量声明提升</span></span><br><span class="line">fn();    <span class="comment">// 执行报错</span></span><br><span class="line">fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;   <span class="comment">// 赋值操作，此时将后边函数的引用赋值给fn</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'function'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因此，由于声明方式的不同，导致了函数声明与函数表达式在使用上的一些差异需要我们注意，除此之外，这两种形式的函数在使用上并无不同。</p></blockquote><p>关于上面例子中，函数表达式中的赋值操作，在其他一些地方也会被经常使用，我们清楚其中的关系即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">在构造函数中添加方法</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="comment">// 在构造函数内部中添加方法</span></span><br><span class="line">    <span class="keyword">this</span>.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给原型添加方法</span></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在对象中添加方法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    m: <span class="number">20</span>,</span><br><span class="line">    getM: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>匿名函数</strong></p><p>在上面我们大概讲述了函数表达式中的赋值操作。而匿名函数，顾名思义，就是指的没有被显示进行赋值操作的函数。它的使用场景，多作为一个参数传入另一个函数中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params">bar, num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bar() + num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;, <span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>在上面的例子中，fn的第一个参数传入了一个匿名函数。虽然该匿名函数没有显示的进行赋值操作，我们没有办法在外部执行上下文中引用到它，但是在fn函数内部，我们将该匿名函数赋值给了变量bar，保存在了fn变量对象的arguments对象中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量对象在fn上下文执行过程中的创建阶段</span></span><br><span class="line">VO(fn) = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        bar: <span class="literal">undefined</span>,</span><br><span class="line">        num: <span class="literal">undefined</span>,</span><br><span class="line">        length: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量对象在fn上下文执行过程中的执行阶段</span></span><br><span class="line"><span class="comment">// 变量对象变为活动对象，并完成赋值操作与执行可执行代码</span></span><br><span class="line">VO -&gt; AO</span><br><span class="line"></span><br><span class="line">AO(fn) = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        bar: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> a &#125;,</span><br><span class="line">        num: <span class="number">20</span>,</span><br><span class="line">        length: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于匿名函数传入另一个函数之后，最终会在另一个函数中执行，因此我们也常常称这个匿名函数为<strong>回调函数</strong>。关于匿名函数更多的内容，我会在下一篇深入探讨柯里化的文章中进行更加详细讲解。</p><p><strong>匿名函数的这个应用场景几乎承担了函数的所有难以理解的知识点</strong>，因此我们一定要对它的这些细节了解的足够清楚，如果对于变量对象的演变过程你还看不太明白，一定要回过头去看这篇文章：<a href="http://www.jianshu.com/p/330b1505e41d" target="_blank" rel="noopener">前端基础进阶（三）：变量对象详解</a></p><p><strong>函数自执行与块级作用域</strong></p><p>在ES5中，没有块级作用域，因此我们常常使用函数自执行的方式来模仿块级作用域，这样就提供了一个独立的执行上下文，结合闭包，就为模块化提供了基础。而函数自执行，其实是匿名函数的一种应用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>一个模块往往可以包括：私有变量、私有方法、公有变量、公有方法。</p><p>根据作用域链的单向访问，外面可能很容易知道在这个独立的模块中，外部执行环境是无法访问内部的任何变量与方法的，因此我们可以很容易的创建属于这个模块的私有变量与私有方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 私有变量</span></span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'Tom'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有方法</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`your name is `</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>但是共有方法和变量应该怎么办？大家还记得我们前面讲到过的<strong>闭包</strong>的特性吗？没错，利用闭包，我们可以访问到执行上下文内部的变量和方法，因此，我们只需要根据闭包的定义，创建一个闭包，将你认为需要公开的变量和方法开放出来即可。</p><blockquote><p>如果你对闭包了解不够，<a href="http://www.jianshu.com/p/21a16d44f150" target="_blank" rel="noopener">前端基础进阶（四）：详细图解作用域链与闭包</a>应该可以帮到你。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 私有变量</span></span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'Tom'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有方法</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`your name is `</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共有方法</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将引用保存在外部执行环境的变量中，形成闭包，防止该执行环境被垃圾回收</span></span><br><span class="line">    <span class="built_in">window</span>.getAge = getAge;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>当然，闭包在模块中的重要作用，我们也在讲解闭包的时候已经强调过，但是这个知识点真的太重要，需要我们反复理解并且彻底掌握，因此为了帮助大家进一步理解闭包，我们来看看jQuery中，是如何利用我们模块与闭包的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用函数自执行的方式创建模块</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window, undefined</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明jQuery构造函数</span></span><br><span class="line">     <span class="keyword">var</span> jQuery = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主动在构造函数中，返回一个jQuery实例</span></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init(name);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加原型方法</span></span><br><span class="line">     jQuery.prototype = jQuery.fn = &#123;</span><br><span class="line">         <span class="keyword">constructor</span>: jQuery,</span><br><span class="line">         init:function() &#123; ... &#125;,</span><br><span class="line">         css: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     jQuery.fn.init.prototype = jQuery.fn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将jQuery改名为$，并将引用保存在window上，形成闭包，对外开发jQuery构造函数，这样我们就可以访问所有挂载在jQuery原型上的方法了</span></span><br><span class="line">     <span class="built_in">window</span>.jQuery = <span class="built_in">window</span>.$ = jQuery;</span><br><span class="line"> &#125;)(<span class="built_in">window</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在使用时，我们直接执行了构造函数，因为在jQuery的构造函数中通过一些手段，返回的是jQuery的实例，所以我们就不用再每次用的时候在自己new了</span></span><br><span class="line">$(<span class="string">'#div1'</span>);</span><br></pre></td></tr></table></figure><p>在这里，我们只需要看懂闭包与模块的部分就行了，至于内部的原型链是如何绕的，为什么会这样写，我在讲面向对象的时候会为大家慢慢分析。举这个例子的目的所在，就是希望大家能够重视函数，因为在实际开发中，它无处不在。</p><p>接下来我要分享一个高级的，非常有用的模块的应用。当我们的项目越来越大，那么需要保存的数据与状态就越来越多，因此，我们需要一个专门的模块来维护这些数据，这个时候，有一个叫做状态管理器的东西就应运而生。对于状态管理器，最出名的，我想非redux莫属了。虽然对于还在学习中的大家来说，redux是一个有点高深莫测的东西，但是在我们学习之前，可以先通过简单的方式，让大家大致了解状态管理器的实现原理，为我们未来的学习奠定坚实的基础。</p><p>先来直接看代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自执行创建模块</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// states 结构预览</span></span><br><span class="line">    <span class="comment">// states = &#123;</span></span><br><span class="line">    <span class="comment">//     a: 1,</span></span><br><span class="line">    <span class="comment">//     b: 2,</span></span><br><span class="line">    <span class="comment">//     m: 30,  </span></span><br><span class="line">    <span class="comment">//     o: &#123;&#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">var</span> states = &#123;&#125;;  <span class="comment">// 私有变量，用来存储状态与数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断数据类型</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">type</span>(<span class="params">elem</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(elem == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> elem + <span class="string">''</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> toString.call(elem).replace(<span class="regexp">/[\[\]]/g</span>, <span class="string">''</span>).split(<span class="string">' '</span>)[<span class="number">1</span>].toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @Param name 属性名</span></span><br><span class="line"><span class="comment">     * @Description 通过属性名获取保存在states中的值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> states[name] ? states[name] : <span class="string">''</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getStates</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> states;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * @param options &#123;object&#125; 键值对</span></span><br><span class="line"><span class="comment">    * @param target &#123;object&#125; 属性值为对象的属性，只在函数实现时递归中传入</span></span><br><span class="line"><span class="comment">    * @desc 通过传入键值对的方式修改state树，使用方式与小程序的data或者react中的setStates类似</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">options, target</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(options);</span><br><span class="line">        <span class="keyword">var</span> o = target ? target : states;</span><br><span class="line"></span><br><span class="line">        keys.map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> o[item] == <span class="string">'undefined'</span>) &#123;</span><br><span class="line">                o[item] = options[item];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                type(o[item]) == <span class="string">'object'</span> ? <span class="keyword">set</span>(options[item], o[item]) : o[item] = options[item];</span><br><span class="line">            &#125;</span><br><span class="line">            return item;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 对外提供接口</span><br><span class="line">    window.<span class="keyword">get</span> = <span class="keyword">get</span>;</span><br><span class="line">    window.<span class="keyword">set</span> = <span class="keyword">set</span>;</span><br><span class="line">    window.getStates = getStates;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">// 具体使用如下</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(&#123; a: <span class="number">20</span> &#125;);     <span class="comment">// 保存 属性a</span></span><br><span class="line"><span class="keyword">set</span>(&#123; b: <span class="number">100</span> &#125;);    <span class="comment">// 保存属性b</span></span><br><span class="line"><span class="keyword">set</span>(&#123; c: <span class="number">10</span> &#125;);     <span class="comment">// 保存属性c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存属性o, 它的值为一个对象</span></span><br><span class="line"><span class="keyword">set</span>(&#123;</span><br><span class="line">    o: &#123;</span><br><span class="line">        m: <span class="number">10</span>,</span><br><span class="line">        n: <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改对象o 的m值</span></span><br><span class="line"><span class="keyword">set</span>(&#123;</span><br><span class="line">    o: &#123;</span><br><span class="line">        m: <span class="number">1000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给对象o中增加一个c属性</span></span><br><span class="line"><span class="keyword">set</span>(&#123;</span><br><span class="line">    o: &#123;</span><br><span class="line">        c: <span class="number">100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(getStates())</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/yangbo5207/pen/EZzEbY?editors=1111" target="_blank" rel="noopener">demo实例在线地址</a></p><p>我之所以说这是一个高级应用，是因为在单页应用中，我们很可能会用到这样的思路。根据我们提到过的知识，理解这个例子其实很简单，其中的难点估计就在于set方法的处理上，因为为了具有更多的适用性，因此做了很多适配，用到了递归等知识。如果你暂时看不懂，没有关系，知道如何使用就行了，上面的代码可以直接运用于实际开发。记住，当你需要保存的状态太多的时候，你就想到这一段代码就行了。</p><blockquote><p>函数自执行的方式另外还有其他几种写法，诸如<code>!function(){}()</code>，<code>+function(){}()</code></p></blockquote><h5 id="二、函数参数传递方式：按值传递"><a href="#二、函数参数传递方式：按值传递" class="headerlink" title="二、函数参数传递方式：按值传递"></a>二、函数参数传递方式：按值传递</h5><p>还记得基本数据类型与引用数据类型在复制上的差异吗？基本数据类型复制，是直接值发生了复制，因此改变后，各自相互不影响。但是引用数据类型的复制，是保存在变量对象中的引用发生了复制，因此复制之后的这两个引用实际访问的实际是同一个堆内存中的值。当改变其中一个时，另外一个自然也被改变。如下例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">b = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">var</span> n = m;</span><br><span class="line">n.a = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(m.a) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>当值作为函数的参数传递进入函数内部时，也有同样的差异。我们知道，函数的参数在进入函数后，实际是被保存在了函数的变量对象中，因此，这个时候相当于发生了一次复制。如下例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    a = a + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">fn(a);</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">m</span>: <span class="number">10</span>, <span class="attr">n</span>: <span class="number">20</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    a.m = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(a);</span><br><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">// &#123; m: 20, n: 20 &#125;</span></span><br></pre></td></tr></table></figure><p>正是由于这样的不同，导致了许多人在理解函数参数的传递方式时，就有许多困惑。到底是按值传递还是按引用传递？实际上结论仍然是按值传递，只不过当我们期望传递一个引用类型时，真正传递的，只是这个引用类型保存在变量对象中的引用而已。为了说明这个问题，我们看看下面这个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name: <span class="string">'Nicholas'</span>,</span><br><span class="line">age: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;  <span class="comment">// 传入一个引用</span></span><br><span class="line">obj = &#123;&#125;;   <span class="comment">// 将传入的引用指向另外的值</span></span><br><span class="line">obj.name = <span class="string">'Greg'</span>;  <span class="comment">// 修改引用的name属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setName(person);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);  <span class="comment">// Nicholas 未被改变</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，如果person是按引用传递，那么person就会自动被修改为指向其name属性值为Gerg的新对象。但是我们从结果中看到，person对象并未发生任何改变，因此只是在函数内部引用被修改而已。</p><h5 id="四、函数式编程"><a href="#四、函数式编程" class="headerlink" title="四、函数式编程"></a>四、函数式编程</h5><p>虽然JavaScript并不是一门纯函数式编程的语言，但是它使用了许多函数式编程的特性。因此了解这些特性可以让我们更加了解自己写的代码。</p><p>当我们想要使用一个函数时，通常情况下其实就是想要将一些功能，逻辑等封装起来。相信大家对于封装这个概念并不陌生。</p><p>我们通常通过函数封装来完成一件事情。例如，我想要计算任意三个数的和，我们就可以将这三个数作为参数，封装一个简单的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们想要计算三个数的和时，直接调用该方法即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>当然，当我们想要做的事情比较简单的时候，可能还看不出来封装成为函数之后带来的便利。如果我们想要做的事情稍微复杂一点呢。例如我想要计算一个数组中的所有子项目的和。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeArr</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123; result  += arr[i] &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们不通过函数封装的方式，那么再每次想要实现这个功能时，就不得不重新使用一次for循环，这样的后果就是我们的代码中充斥着越来越多的重复代码。而封装之后，当我们想要再次做这件事情的时候，只需要一句话就可以了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mergeArr([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br></pre></td></tr></table></figure><p>当然，我相信大家对于函数封装的意义都应该有非常明确的认知，但是我们要面临的问题是，当我们想要去封装一个函数时，如何做才是最佳实践呢？</p><p>函数式编程能给我们答案。</p><p>我们在初学时，往往会不由自主的使用命令式编程的风格来完成我们想要干的事情。因为命令式编程更加的简单，直白。例如我们现在有一个数组，<code>array = [1, 3, &#39;h&#39;, 5, &#39;m&#39;, &#39;4&#39;]</code>，现在想要找出这个数组中的所有类型为number的子项。当我们使用命令式编程思维时，可能就会直接这样做。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">3</span>, <span class="string">'h'</span>, <span class="number">5</span>, <span class="string">'m'</span>, <span class="string">'4'</span>];</span><br><span class="line"><span class="keyword">var</span> res = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i ++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> array[i] === <span class="string">'number'</span>) &#123;</span><br><span class="line">        res.push(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种实现方式中，我们平铺直叙的实现了我们的目的。这样做的问题在于，当我们在另外的时刻，想要找出另外一个数组中所有的子项时，我们不得不把同样的逻辑再写一次。当出现次数变多时，我们的代码也变得更加糟糕且难以维护。</p><p>而函数式编程的思维则建议我们将这种会多次出现的功能封装起来以备调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNumbers</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = [];</span><br><span class="line">    array.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> item === <span class="string">'number'</span>) &#123;</span><br><span class="line">            res.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上是我们的封装，以下是功能实现</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">3</span>, <span class="string">'h'</span>, <span class="number">5</span>, <span class="string">'m'</span>, <span class="string">'4'</span>];</span><br><span class="line"><span class="keyword">var</span> res = getNumbers(array);</span><br></pre></td></tr></table></figure><p>因此当我们将功能封装之后，我们实现同样的功能时，只需要写一行代码。而如果未来需求变动，或者稍作修改，我们只需要对getNumbers方法进行调整就可以了。而且我们在使用时，只需要关心这个方法能做什么，而不用关心他具体是怎么实现的。这也是函数式编程思维与命令式不同的地方之一。</p><p>函数式编程思维还具有以下几个特征。</p><p><strong>函数是第一等公民</strong></p><p>所谓”第一等公民”（first class），指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。这些场景，我们应该见过很多。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;  <span class="comment">// 赋值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">function(</span>) </span>&#123;&#125;, num) &#123;&#125;   <span class="comment">// 函数作为参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数作为返回值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">var</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        ... ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这都是JavaScript的基本概念。但是我想很多人，甚至包括正在阅读的你自己都可能会无视这些概念。可以用一个简单的例子来验证一下。</p><p>我们先自定义这样一个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'5000ms之后执行该方法.'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在要做的是，如果要求你结合setTimeout方法，让delay方法延迟5000ms执行，应该怎么做？</p><p>其实很简单，对不对，直接这样就可以了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    delay();</span><br><span class="line">&#125;, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure><p>那么现在问题来了，如果你对函数是一等公民有一个深刻的认知，我想你会发现上面这种写法其实是有一些问题的。所以思考一下，问题出在哪里？</p><p>函数既然能够作为一个参数传入另外一个函数，那么我们是不是可以直接将delay作为setTimeout的第一个参数，而不用额外的多加一层匿名函数呢？</p><p>因此，其实最正确的解法应该这样写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timer = setTimeout(delay, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure><p>当然，如果你已经提前想到这样做了，那么恭喜你，说明你在JavaScript上比普通人更有天赋。其实第一种糟糕的方式很多人都在用，包括有多年工作经验的人也没有完全避免。而他们甚至还不知道自己问题出在什么地方。</p><p>在未来的实践中，你还会遇到更多类似的场景。为了验证读者朋友们的理解，我们不妨来思考一下如何优化下面的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUser</span>(<span class="params">path, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $.<span class="keyword">get</span>(path, function(info) &#123;</span><br><span class="line">        <span class="keyword">return</span> callback(info);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getUser(<span class="string">'/api/user'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">resp</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// resp为成功请求之后返回的数据</span></span><br><span class="line">    <span class="built_in">console</span>.log(resp);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>优化的原理和setTimeout的例子一模一样，我这里卖个关子，不打算告诉大家结论，仅提示一句，getUser优化之后，仅有一句代码。考验大家学习成果的时候到了 ^ ^。</p><p><strong>只用”表达式”，不用”语句”</strong></p><p>“表达式”（expression）是一个单纯的运算过程，总是有返回值；”语句”（statement）是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。</p><p>假如我们的项目中，多处需要改变某个元素的背景色。因此我们可以这样封装一下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ele = <span class="built_in">document</span>.querySelector(<span class="string">'.test'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setBackgroundColor</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">    ele.style.backgroundColor = color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多处使用</span></span><br><span class="line">setBackgroundColor(<span class="string">'red'</span>);</span><br><span class="line">setBackgroundColor(<span class="string">'#ccc'</span>);</span><br></pre></td></tr></table></figure><p>我们可以很明显的感受到，setBackgroundColor封装的仅仅只是一条语句。这并不是理想的效果。函数式编程期望一个函数有输入，也有输出。因此良好的习惯应该如下做。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setBackgroundColor</span>(<span class="params">ele, color</span>) </span>&#123;</span><br><span class="line">    ele.style.backgroundColor = color;</span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多处使用</span></span><br><span class="line"><span class="keyword">var</span> ele = <span class="built_in">document</span>.querySelector(<span class="string">'.test'</span>);</span><br><span class="line">setBackgroundColor(ele, <span class="string">'red'</span>);</span><br><span class="line">setBackgroundColor(ele, <span class="string">'#ccc'</span>);</span><br></pre></td></tr></table></figure><p>了解这一点，可以让我们自己在封装函数的时候养成良好的习惯。</p><p><strong>纯函数</strong></p><p>相同的输入总会得到相同的输出，并且不会产生副作用的函数，就是纯函数。</p><p>所谓”副作用”（side effect），指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。</p><p>函数式编程强调没有”副作用”，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。</p><p>即所谓的只要是同样的参数传入，返回的结果一定是相等的。</p><p>例如我们期望封装一个函数，能够得到传入数组的最后一项。那么可以通过下面两种方式来实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLast</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr[arr.length];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLast_</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> source = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> last = getLast(source); <span class="comment">// 返回结果4 原数组不变</span></span><br><span class="line"><span class="keyword">var</span> last_ = getLast_(source); <span class="comment">// 返回结果4 原数据最后一项被删除</span></span><br></pre></td></tr></table></figure><p>getLast与getLast_虽然同样能够获得数组的最后一项值，但是getLast_改变了原数组。而当原始数组被改变，那么当我们再次调用该方法时，得到的结果就会变得不一样。这样不可预测的封装方式，在我们看来是非常糟糕的。它会把我们的数据搞得非常混乱。在JavaScript原生支持的数据方法中，也有许多不纯的方法，我们在使用时需要非常警惕，我们要清晰的知道原始数据的改变是否会留下隐患。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">source.slice(<span class="number">1</span>, <span class="number">3</span>); <span class="comment">// 纯函数 返回[2, 3] source不变</span></span><br><span class="line">source.splice(<span class="number">1</span>, <span class="number">3</span>); <span class="comment">// 不纯的 返回[2, 3, 4] source被改变</span></span><br><span class="line"></span><br><span class="line">source.pop(); <span class="comment">// 不纯的</span></span><br><span class="line">source.push(<span class="number">6</span>); <span class="comment">// 不纯的</span></span><br><span class="line">source.shift(); <span class="comment">// 不纯的</span></span><br><span class="line">source.unshift(<span class="number">1</span>); <span class="comment">// 不纯的</span></span><br><span class="line">source.reverse(); <span class="comment">// 不纯的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我也不能短时间知道现在source被改变成了什么样子，干脆重新约定一下</span></span><br><span class="line">source = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">source.concat([<span class="number">6</span>, <span class="number">7</span>]); <span class="comment">// 纯函数 返回[1, 2, 3, 4, 5, 6, 7] source不变</span></span><br><span class="line">source.join(<span class="string">'-'</span>); <span class="comment">// 纯函数 返回1-2-3-4-5 source不变</span></span><br></pre></td></tr></table></figure><p><strong>闭包</strong></p><p>闭包是函数式编程语言的重要特性，我也在前面几篇文章中说了很多关于闭包的内容。这里不再赘述。</p><p><strong>柯里化</strong></p><p>略</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;纵观JavaScript中所有必须需要掌握的重点知识中，函数是我们在初学的时候最容易忽视的一个知识点。在学习的过程中，可能会有很多人、很多文章告诉你面向对象很重要，原型很重要，可是却很少有人告诉你，面向对象中所有的重点难点，几乎都与函数息息相关。&lt;/p&gt;
&lt;p&gt;包括我之前几
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/categories/JavaScript/"/>
    
    
      <category term="function" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/tags/function/"/>
    
      <category term="函数式编程" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>摘抄内存空间详解</title>
    <link href="https://zombrbrand.github.io/ZombieBrand.github.io/2019/03/17/%E6%91%98%E6%8A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E8%AF%A6%E8%A7%A3/"/>
    <id>https://zombrbrand.github.io/ZombieBrand.github.io/2019/03/17/摘抄内存空间详解/</id>
    <published>2019-03-17T08:17:41.000Z</published>
    <updated>2019-03-17T14:13:17.916Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/ZombieBrand.github.io/assets/599584-cce8e155e19593fb-1552810047786.png" alt="变量对象与堆内存"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">'abc'</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> d = &#123; <span class="attr">m</span>: <span class="number">20</span> &#125;</span><br></pre></td></tr></table></figure><p>因为JavaScript具有自动垃圾回收机制，所以对于前端开发来说，内存空间并不是一个经常被提及的概念，很容易被大家忽视。特别是很多不是计算机专业的朋友在进入到前端之后，会对内存空间的认知比较模糊，甚至有些人干脆就是一无所知。</p><p>当然也包括我自己。在很长一段时间里认为内存空间的概念在JS的学习中并不是那么重要。可是后我当我回过头来重新整理JS基础时，发现由于对它们的模糊认知，导致了很多东西我都理解得并不明白。比如最基本的引用数据类型和引用传递到底是怎么回事儿？比如浅复制与深复制有什么不同？还有闭包，原型等等。</p><p>因此后来我才渐渐明白，想要对JS的理解更加深刻，就必须对内存空间有一个清晰的认知。</p><p>在学习内存空间之前，我们需要对三种数据结构有一个直观的认知。他们分别是<strong>堆(heap)，栈(stack)与队列(queue)</strong>。</p><h5 id="一、栈数据结构"><a href="#一、栈数据结构" class="headerlink" title="一、栈数据结构"></a>一、栈数据结构</h5><p>与C/C++不同，JavaScript中并没有严格意义上区分栈内存与堆内存。因此我们可以简单粗暴的理解为JavaScript的所有数据都保存在堆内存中。但是在某些场景，我们仍然需要基于堆栈数据结构的思维来实现一些功能，比如JavaScript的执行上下文（关于执行上下文我会在下一篇文章中总结）。执行上下文的执行顺序借用了栈数据结构的存取方式。(也就是后面我们会经常提到的函数调用栈)。因此理解栈数据结构的原理与特点十分重要。   </p><p>要简单理解栈的存取方式，我们可以通过类比乒乓球盒子来分析。如下图左侧。</p><p><img src="/ZombieBrand.github.io/assets/599584-b12fef30803a0c53-1552810047719.png" alt="乒乓球盒子与栈类比"></p><p>这种乒乓球的存放方式与栈中存取数据的方式如出一辙。处于盒子中最顶层的乒乓球5，它一定是最后被放进去，但可以最先被使用。而我们想要使用底层的乒乓球1，就必须将上面的4个乒乓球取出来，让乒乓球1处于盒子顶层。这就是栈空间<strong>先进后出，后进先出</strong>的特点。图中已经详细的表明了栈空间的存储原理。</p><h5 id="二、堆数据结构"><a href="#二、堆数据结构" class="headerlink" title="二、堆数据结构"></a>二、堆数据结构</h5><p>堆数据结构是一种树状结构。它的存取数据的方式，则与书架与书非常相似。</p><p>书虽然也整齐的存放在书架上，但是我们只要知道书的名字，我们就可以很方便的取出我们想要的书，而不用像从乒乓球盒子里取乒乓一样，非得将上面的所有乒乓球拿出来才能取到中间的某一个乒乓球。好比在JSON格式的数据中，我们存储的<code>key-value</code>是可以无序的，因为顺序的不同并不影响我们的使用，我们只需要关心书的名字。</p><h4 id="三、队列"><a href="#三、队列" class="headerlink" title="三、队列"></a>三、队列</h4><p>在JavaScript中，理解队列数据结构的目的主要是为了清晰的明白事件循环（Event Loop）的机制到底是怎么回事。在后续的章节中我会详细分析事件循环机制。</p><p>队列是一种先进先出（FIFO）的数据结构。正如排队过安检一样，排在队伍前面的人一定是最先过检的人。用以下的图示可以清楚的理解队列的原理。</p><p><img src="/ZombieBrand.github.io/assets/599584-7ca4b641daf48c57-1552810047744.png" alt></p><h5 id="四、变量对象与基础数据类型"><a href="#四、变量对象与基础数据类型" class="headerlink" title="四、变量对象与基础数据类型"></a>四、变量对象与基础数据类型</h5><p>JavaScript的执行上下文生成之后，会创建一个叫做变量对象的特殊对象（具体会在下一篇文章与执行上下文一起总结），JavaScript的基础数据类型往往都会保存在变量对象中。</p><blockquote><p>严格意义上来说，变量对象也是存放于堆内存中，但是由于变量对象的特殊职能，我们在理解时仍然需要将其于堆内存区分开来。</p></blockquote><p>基础数据类型都是一些简单的数据段，JavaScript中有5中基础数据类型，分别是<code>Undefined、Null、Boolean、Number、String</code>。基础数据类型都是按值访问，因为我们可以直接操作保存在变量中的实际的值。</p><blockquote><p>ES6中新加了一种基础数据类型Symbol，可以先不用考虑他</p></blockquote><h5 id="五、引用数据类型与堆内存"><a href="#五、引用数据类型与堆内存" class="headerlink" title="五、引用数据类型与堆内存"></a>五、引用数据类型与堆内存</h5><p>与其他语言不同，JS的引用数据类型，比如数组Array，它们值的大小是不固定的。引用数据类型的值是保存在堆内存中的对象。JavaScript不允许直接访问堆内存中的位置，因此我们不能直接操作对象的堆内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。因此，引用类型的值都是按引用访问的。这里的引用，我们可以理解为保存在变量对象中的一个地址，该地址与堆内存的实际值相关联。</p><p>为了更好的搞懂变量对象与堆内存，我们可以结合以下例子与图解进行理解。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a1 = <span class="number">0</span>;   <span class="comment">// 变量对象</span></span><br><span class="line"><span class="keyword">var</span> a2 = <span class="string">'this is string'</span>; <span class="comment">// 变量对象</span></span><br><span class="line"><span class="keyword">var</span> a3 = <span class="literal">null</span>; <span class="comment">// 变量对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = &#123; <span class="attr">m</span>: <span class="number">20</span> &#125;; <span class="comment">// 变量b存在于变量对象中，&#123;m: 20&#125; 作为对象存在于堆内存中</span></span><br><span class="line"><span class="keyword">var</span> c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// 变量c存在于变量对象中，[1, 2, 3] 作为对象存在于堆内存中</span></span><br></pre></td></tr></table></figure><p><img src="/ZombieBrand.github.io/assets/599584-8e93616d7afcf811-1552810047730.png" alt="上例图解"></p><p>因此当我们要访问堆内存中的引用数据类型时，实际上我们首先是从变量对象中获取了该对象的地址引用（或者地址指针），然后再从堆内存中取得我们需要的数据。</p><p>理解了JS的内存空间，我们就可以借助内存空间的特性来验证一下引用类型的一些特点了。</p><p>在前端面试中我们常常会遇到这样一个类似的题目</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo01.js</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">b = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这时a的值是多少？</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo02.js</span></span><br><span class="line"><span class="keyword">var</span> m = &#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span> &#125;</span><br><span class="line"><span class="keyword">var</span> n = m;</span><br><span class="line">n.a = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这时m.a的值是多少</span></span><br></pre></td></tr></table></figure><p>在变量对象中的数据发生复制行为时，系统会自动为新的变量分配一个新值。<code>var b = a</code>执行之后，a与b虽然值都等于20，但是他们其实已经是相互独立互不影响的值了。具体如图。所以我们修改了b的值以后，a的值并不会发生变化。</p><p><img src="/ZombieBrand.github.io/assets/599584-959cc758fb313a03-1552810047742.png" alt="demo01图解"></p><p>在demo02中，我们通过<code>var n = m</code>执行一次复制引用类型的操作。引用类型的复制同样也会为新的变量自动分配一个新的值保存在变量对象中，但不同的是，这个新的值，仅仅只是引用类型的一个地址指针。当地址指针相同时，尽管他们相互独立，但是在变量对象中访问到的具体对象实际上是同一个。如图所示。</p><p>因此当我改变n时，m也发生了变化。这就是引用类型的特性。</p><p><img src="/ZombieBrand.github.io/assets/599584-c269c4c5cae7d537-1552810047751.png" alt="demo02图解"></p><p>通过内存的角度来理解，是不是感觉要轻松很多？除此之外，我们还可以以此为基础，一步一步的理解JavaScript的执行上下文，作用域链，闭包，原型链等重要概念。其他的我会在以后的文章慢慢总结，敬请期待。</p><h5 id="六、内存空间管理"><a href="#六、内存空间管理" class="headerlink" title="六、内存空间管理"></a>六、内存空间管理</h5><p>因为JavaScript具有自动垃圾收集机制，所以我们在开发时好像不用关心内存的使用问题，内存的分配与回收都完全实现了自动管理。但是根据我自己的开发经验，了解内存机制有助于自己清晰的认识到自己写的代码在执行过程中发生过什么，从而写出性能更加优秀的代码。因此关心内存是一件非常重要的事情。</p><p>JavaScript的内存生命周期</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 分配你所需要的内存</span><br><span class="line"><span class="number">2.</span> 使用分配到的内存（读、写）</span><br><span class="line"><span class="number">3.</span> 不需要时将其释放、归还</span><br></pre></td></tr></table></figure><p>为了便于理解，我们使用一个简单的例子来解释这个周期。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;  <span class="comment">// 在内存中给数值变量分配空间</span></span><br><span class="line">alert(a + <span class="number">100</span>);  <span class="comment">// 使用内存</span></span><br><span class="line">a = <span class="literal">null</span>; <span class="comment">// 使用完毕之后，释放内存空间</span></span><br></pre></td></tr></table></figure><p>第一步和第二步我们都很好理解，JavaScript在定义变量时就完成了内存分配。第三步释放内存空间则是我们需要重点理解的一个点。</p><p>JavaScript有自动垃圾收集机制，那么这个自动垃圾收集机制的原理是什么呢？其实很简单，就是找出那些不再继续使用的值，然后释放其占用的内存。垃圾收集器会每隔固定的时间段就执行一次释放操作。</p><p>在JavaScript中，最常用的是通过<strong>标记清除</strong>的算法来找到哪些对象是不再继续使用的，因此<code>a = null</code>其实仅仅只是做了一个释放引用的操作，让 a 原本对应的值失去引用，脱离执行环境，这个值会在下一次垃圾收集器执行操作时被找到并释放。而在适当的时候解除引用，是为页面获得更好性能的一个重要方式。</p><blockquote><ul><li>在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。但是全局变量什么时候需要自动释放内存空间则很难判断，因此在我们的开发中，需要尽量避免使用全局变量。  </li></ul></blockquote><blockquote><ul><li>要详细了解垃圾收集机制，建议阅读《JavaScript高级编程》中的4.3节</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/ZombieBrand.github.io/assets/599584-cce8e155e19593fb-1552810047786.png&quot; alt=&quot;变量对象与堆内存&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight javascrip
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/categories/JavaScript/"/>
    
    
      <category term="内存空间" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/tags/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>摘抄作用域链与闭包</title>
    <link href="https://zombrbrand.github.io/ZombieBrand.github.io/2019/03/17/%E6%91%98%E6%8A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E4%B8%8E%E9%97%AD%E5%8C%85/"/>
    <id>https://zombrbrand.github.io/ZombieBrand.github.io/2019/03/17/摘抄作用域链与闭包/</id>
    <published>2019-03-17T08:17:27.000Z</published>
    <updated>2019-03-17T14:13:17.916Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/ZombieBrand.github.io/assets/599584-aacdb7b7ba2468da.png" alt="攻克闭包难题"><br>初学JavaScript的时候，我在学习闭包上，走了很多弯路。而这次重新回过头来对基础知识进行梳理，要讲清楚闭包，也是一个非常大的挑战。</p><p>闭包有多重要？如果你是初入前端的朋友，我没有办法直观的告诉你闭包在实际开发中的无处不在，但是我可以告诉你，<strong>前端面试，必问闭包</strong>。面试官们常常用对闭包的了解程度来判定面试者的基础水平，保守估计，10个前端面试者，至少5个都死在闭包上。</p><p>可是为什么，闭包如此重要，还是有那么多人没有搞清楚呢？是因为大家不愿意学习吗？还真不是，而是我们通过搜索找到的大部分讲解闭包的中文文章，都没有清晰明了的把闭包讲解清楚。要么浅尝辄止，要么高深莫测，要么干脆就直接乱说一通。包括我自己曾经也写过一篇关于闭包的总结，回头一看，不忍直视[捂脸]。</p><p>因此本文的目的就在于，能够清晰明了得把闭包说清楚，让读者朋友们看了之后，就把闭包给彻底学会了，而不是似懂非懂。</p><h5 id="一、作用域与作用域链"><a href="#一、作用域与作用域链" class="headerlink" title="一、作用域与作用域链"></a>一、作用域与作用域链</h5><p>在详细讲解作用域链之前，我默认你已经大概明白了JavaScript中的下面这些重要概念。这些概念将会非常有帮助。</p><ul><li>基础数据类型与引用数据类型</li><li>内存空间</li><li>垃圾回收机制</li><li>执行上下文</li><li>变量对象与活动对象</li></ul><p>如果你暂时还没有明白，可以去看本系列的前三篇文章，本文文末有<a href="http://www.jianshu.com/p/cd3fee40ef59" target="_blank" rel="noopener">目录链接</a>。为了讲解闭包，已经为大家做好了基础知识的铺垫哦。</p><p><strong>作用域</strong></p><ul><li>在JavaScript中，我们可以将作用域定义为一套规则,这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。</li></ul><blockquote><p>这里的标识符，指的是变量名或者函数名</p></blockquote><ul><li>JavaScript中只有全局作用域与函数作用域(因为eval我们平时开发中几乎不会用到它，这里不讨论)。</li><li>作用域与执行上下文是完全不同的两个概念。我知道很多人会混淆他们，但是一定要仔细区分。</li></ul><blockquote><p>JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建。</p></blockquote><p><img src="/ZombieBrand.github.io/assets/599584-c850e91b12e88831.png" alt="过程"></p><p><strong>作用域链</strong></p><p>回顾一下上一篇文章我们分析的执行上下文的生命周期，如下图。<br><img src="/ZombieBrand.github.io/assets/599584-391af3aad043c028-1552810015061.png" alt="执行上下文生命周期"></p><p>我们知道函数在调用激活时，会开始创建对应的执行上下文，在执行上下文生成的过程中，变量对象，作用域链，以及this的值会分别被确定。之前一篇文章我们详细说明了变量对象，而这里，我们将详细说明作用域链。</p><p><strong>作用域链，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。</strong></p><p>为了帮助大家理解作用域链，我我们先结合一个例子，以及相应的图示来说明。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = a + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">innerTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> c = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> b + c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> innerTest();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>在上面的例子中，全局，函数test，函数innerTest的执行上下文先后创建。我们设定他们的变量对象分别为VO(global)，VO(test), VO(innerTest)。而innerTest的作用域链，则同时包含了这三个变量对象，所以innerTest的执行上下文可如下表示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">innerTestEC = &#123;</span><br><span class="line">    VO: &#123;...&#125;,  <span class="comment">// 变量对象</span></span><br><span class="line">    scopeChain: [VO(innerTest), VO(test), VO(global)], <span class="comment">// 作用域链</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以直接用一个数组来表示作用域链，数组的第一项scopeChain[0]为作用域链的最前端，而数组的最后一项，为作用域链的最末端，所有的最末端都为全局变量对象。</p><p>很多人会误解为当前作用域与上层作用域为包含关系，但其实并不是。以最前端为起点，最末端为终点的单方向通道我认为是更加贴切的形容。如图。</p><p><img src="/ZombieBrand.github.io/assets/599584-b5e7e00de7c9213a.png" alt="作用域链图示"></p><blockquote><p>注意，因为变量对象在执行上下文进入执行阶段时，就变成了活动对象，这一点在上一篇文章中已经讲过，因此图中使用了AO来表示。Active Object</p></blockquote><p>是的，作用域链是由一系列变量对象组成，我们可以在这个单向通道中，查询变量对象中的标识符，这样就可以访问到上一层作用域中的变量了。</p><h5 id="二、闭包"><a href="#二、闭包" class="headerlink" title="二、闭包"></a>二、闭包</h5><p>对于那些有一点 JavaScript 使用经验但从未真正理解闭包概念的人来说，理解闭包可以看作是某种意义上的重生，突破闭包的瓶颈可以使你功力大增。</p><p><strong>闭包是一种特殊的对象。</strong></p><p><strong>它由两部分组成。执行上下文(代号A)，以及在该执行上下文中创建的函数（代号B）。</strong></p><p><strong>当B执行时，如果访问了A中变量对象中的值，那么闭包就会产生。</strong></p><p><strong>在大多数理解中，包括许多著名的书籍，文章里都以函数B的名字代指这里生成的闭包。而在chrome中，则以执行上下文A的函数名代指闭包。</strong></p><p>因此我们只需要知道，一个闭包对象，由A、B共同组成，在以后的篇幅中，我将以chrome的标准来称呼。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo01</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo();</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure><p>上面的例子，首先有执行上下文foo，在foo中定义了函数bar，而通过对外返回bar的方式让bar得以执行。当bar执行时，访问了foo内部的变量a，b。因此这个时候闭包产生。</p><p>在<a href="http://www.jianshu.com/p/996671d4dcc4" target="_blank" rel="noopener">基础进阶（一）</a>中，我总结了JavaScript的垃圾回收机制。JavaScript拥有自动的垃圾回收机制，关于垃圾回收机制，有一个重要的行为，那就是，当一个值，在内存中失去引用时，垃圾回收机制会根据特殊的算法找到它，并将其回收，释放内存。</p><p>而我们知道，函数的执行上下文，在执行完毕之后，生命周期结束，那么该函数的执行上下文就会失去引用。其占用的内存空间很快就会被垃圾回收器释放。可是闭包的存在，会阻止这一过程。</p><p>先来一个简单的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="literal">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">innnerFoo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    fn = innnerFoo; <span class="comment">// 将 innnerFoo的引用，赋值给全局变量中的fn</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fn(); <span class="comment">// 此处的保留的innerFoo的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line">bar(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>foo()</code>执行完毕之后，按照常理，其执行环境生命周期会结束，所占内存被垃圾收集器释放。但是通过<code>fn = innerFoo</code>，函数innerFoo的引用被保留了下来，复制给了全局变量fn。这个行为，导致了foo的变量对象，也被保留了下来。于是，函数fn在函数bar内部执行时，依然可以访问这个被保留下来的变量对象。所以此刻仍然能够访问到变量a的值。</p><p>这样，我们就可以称foo为闭包。</p><p>下图展示了闭包foo的作用域链。</p><p><img src="http://upload-images.jianshu.io/upload_images/599584-aacdb7b7ba2468da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="闭包foo的作用域链，图中标题写错了，请无视"></p><p>我们可以在chrome浏览器的开发者工具中查看这段代码运行时产生的函数调用栈与作用域链的生成情况。如下图。</p><blockquote><p>关于如何在chrome中观察闭包，以及更多闭包的例子，请阅读基础系列（六）</p></blockquote><p><img src="/ZombieBrand.github.io/assets/599584-75ba724cb9e19b51.png" alt="从图中可以看出，chrome浏览器认为闭包是foo，而不是通常我们认为的innerFoo"></p><p>在上面的图中，红色箭头所指的正是闭包。其中Call Stack为当前的函数调用栈，Scope为当前正在被执行的函数的作用域链，Local为当前的局部变量。</p><p><strong>所以，通过闭包，我们可以在其他的执行上下文中，访问到函数的内部变量。</strong>比如在上面的例子中，我们在函数bar的执行环境中访问到了函数foo的a变量。个人认为，从应用层面，这是闭包最重要的特性。利用这个特性，我们可以实现很多有意思的东西。</p><p>不过读者朋友们需要注意的是，虽然例子中的闭包被保存在了全局变量中，但是闭包的作用域链并不会发生任何改变。在闭包中，能访问到的变量，仍然是作用域链上能够查询到的变量。</p><p>对上面的例子稍作修改，如果我们在函数bar中声明一个变量c，并在闭包fn中试图访问该变量，运行结果会抛出错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="literal">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">innnerFoo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(c); <span class="comment">// 在这里，试图访问函数bar中的c变量，会抛出错误</span></span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    fn = innnerFoo; <span class="comment">// 将 innnerFoo的引用，赋值给全局变量中的fn</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="number">100</span>;</span><br><span class="line">    fn(); <span class="comment">// 此处的保留的innerFoo的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure><blockquote><p>关于这一点，很多同学把函数调用栈与作用域链没有分清楚，所以有的大神看了我关于介绍执行上下文的文章时就义正言辞的说我的例子有问题，而这些评论有很大的误导作用，为了帮助大家自己拥有能够辨别的能力，所以我写了基础（六），教大家如何在chrome中观察闭包，作用域链，this等。当然我也不敢100%保证我文中的例子就一定正确，所以教大家如何去辨认我认为才是最重要的。</p></blockquote><p><strong>闭包的应用场景</strong></p><p>除了面试，在实践中，闭包有两个非常重要的应用场景。分别是模块化与柯里化。</p><ul><li>柯里化</li></ul><p>在函数式编程中，利用闭包能够实现很多炫酷的功能，柯里化便是其中很重要的一种。<a href="http://www.jianshu.com/p/5e1899fe7d6b" target="_blank" rel="noopener">点击了解更多关于柯里化的知识</a></p><ul><li>模块</li></ul><p>在我看来，模块是闭包最强大的一个应用场景。如果你是初学者，对于模块的了解可以暂时不用放在心上，因为理解模块需要更多的基础知识。但是如果你已经有了很多JavaScript的使用经验，在彻底了解了闭包之后，不妨借助本文介绍的作用域链与闭包的思路，重新理一理关于模块的知识。这对于我们理解各种各样的设计模式具有莫大的帮助。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> num1 = !!num1 ? num1 : a;</span><br><span class="line">        <span class="keyword">var</span> num2 = !!num2 ? num2 : b;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">window</span>.add = add;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">add(<span class="number">10</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>在上面的例子中，我使用函数自执行的方式，创建了一个模块。add是模块对外暴露的一个公共方法。而变量a，b被作为私有变量。在面向对象的开发中，我们常常需要考虑是将变量作为私有变量，还是放在构造函数中的this中，因此理解闭包，以及原型链是一个非常重要的事情。模块十分重要，因此我会在以后的文章专门介绍，这里就暂时不多说啦。</p><p><img src="/ZombieBrand.github.io/assets/599584-147ebb03cacc6609.png" alt="此图中可以观看到当代码执行到add方法时的调用栈与作用域链，此刻的闭包为外层的自执行函数"></p><p>为了验证自己有没有搞懂作用域链与闭包，这里留下一个经典的思考题，常常也会在面试中被问到。</p><p>利用闭包，修改下面的代码，让循环输出的结果依次为1， 2， 3， 4， 5</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">    setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, i*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.jianshu.com/p/9b4a54a98660" target="_blank" rel="noopener">点此查看关于此题的详细解读</a></p><p>关于作用域链的与闭包我就总结完了，虽然我自认为我是说得非常清晰了，但是我知道理解闭包并不是一件简单的事情，所以如果你有什么问题，可以在评论中问我。你也可以带着从别的地方没有看懂的例子在评论中留言。大家一起学习进步。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/ZombieBrand.github.io/assets/599584-aacdb7b7ba2468da.png&quot; alt=&quot;攻克闭包难题&quot;&gt;&lt;br&gt;初学JavaScript的时候，我在学习闭包上，走了很多弯路。而这次重新回过头来对基础知识进行梳理，要
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/categories/JavaScript/"/>
    
    
      <category term="闭包" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/tags/%E9%97%AD%E5%8C%85/"/>
    
      <category term="作用域链" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>摘抄事件循环机制</title>
    <link href="https://zombrbrand.github.io/ZombieBrand.github.io/2019/03/17/%E6%91%98%E6%8A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/"/>
    <id>https://zombrbrand.github.io/ZombieBrand.github.io/2019/03/17/摘抄事件循环机制/</id>
    <published>2019-03-17T08:17:10.000Z</published>
    <updated>2019-03-17T14:13:17.915Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript的学习零散而庞杂，因此很多时候我们学到了一些东西，但是却没办法感受到自己的进步，甚至过了不久，就把学到的东西给忘了。为了解决自己的这个困扰，在学习的过程中，我一直试图在寻找一条核心的线索，只要我根据这条线索，我就能够一点一点的进步。</p><p>前端基础进阶正是围绕这条线索慢慢展开，而事件循环机制(Event Loop)，则是这条线索的最关键的知识点。所以，我就马不停蹄的去深入的学习了事件循环机制，并总结出了这篇文章跟大家分享。</p><p>事件循环机制从整体上的告诉了我们所写的JavaScript代码的执行顺序。但是在我学习的过程中，找到的许多国内博客文章对于它的讲解浅尝辄止，不得其法，很多文章在图中画个圈就表示循环了，看了之后也没感觉明白了多少。但是他又如此重要，以致于当我们想要面试中高级岗位时，事件循环机制总是绕不开的话题。特别是ES6中正式加入了Promise对象之后，对于新标准中事件循环机制的理解就变得更加重要。这就很尴尬了。</p><blockquote><p>最近有两篇比较火的文章也表达了这个问题的重要性。</p></blockquote><blockquote><p><a href="https://zhuanlan.zhihu.com/p/25407758" target="_blank" rel="noopener">这个前端面试在搞事</a><br><a href="https://juejin.im/post/58cf180b0ce4630057d6727c" target="_blank" rel="noopener">80% 应聘者都不及格的 JS 面试题</a></p></blockquote><blockquote><p>但是很遗憾的是，大神们告诉了大家这个知识点很重要，却并没有告诉大家为什么会这样。所以当我们在面试时遇到这样的问题时，就算你知道了结果，面试官再进一步问一下，我们依然懵逼。</p></blockquote><p>在学习事件循环机制之前，我默认你已经懂得了如下概念，如果仍然有疑问，可以回过头去看看我以前的文章。</p><ul><li>执行上下文(Execution context)</li><li>函数调用栈(call stack)</li><li>队列数据结构(queue)</li><li>Promise(我会在下一篇文章专门总结Promise的详细使用)</li></ul><blockquote><p>因为chrome浏览器中新标准中的事件循环机制与nodejs类似，因此此处就整合nodejs一起来理解，其中会介绍到几个nodejs有，但是浏览器中没有的API，大家只需要了解就好，不一定非要知道她是如何使用。比如process.nextTick，setImmediate</p></blockquote><p>OK，那我就先抛出结论，然后以例子与图示详细给大家演示事件循环机制。</p><ul><li>我们知道JavaScript的一大特点就是单线程，而这个线程中拥有唯一的一个事件循环。</li></ul><blockquote><p>当然新标准中的web worker涉及到了多线程，我对它了解也不多，这里就不讨论了。</p></blockquote><ul><li>JavaScript代码的执行过程中，除了依靠函数调用栈来搞定函数的执行顺序外，还依靠任务队列(task queue)来搞定另外一些代码的执行。</li></ul><p><img src="/ZombieBrand.github.io/assets/599584-15f617d44cdb990d.png" alt="队列数据结构"></p><ul><li>一个线程中，事件循环是唯一的，但是任务队列可以拥有多个。</li><li>任务队列又分为macro-task（宏任务）与micro-task（微任务），在最新标准中，它们被分别称为task与jobs。</li><li>macro-task大概包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。</li><li>micro-task大概包括: process.nextTick, Promise, Object.observe(已废弃), MutationObserver(html5新特性)</li><li>setTimeout/Promise等我们称之为任务源。而进入任务队列的是他们指定的具体执行任务。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setTimeout中的回调函数才是进入任务队列的任务</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'xxxx'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 非常多的同学对于setTimeout的理解存在偏差。所以大概说一下误解：</span></span><br><span class="line"><span class="comment">// setTimeout作为一个任务分发器，这个函数会立即执行，而它所要分发的任务，也就是它的第一个参数，才是延迟执行</span></span><br></pre></td></tr></table></figure><ul><li>来自不同任务源的任务会进入到不同的任务队列。其中setTimeout与setInterval是同源的。</li><li>事件循环的顺序，决定了JavaScript代码的执行顺序。它从script(整体代码)开始第一次循环。之后全局上下文进入函数调用栈。直到调用栈清空(只剩全局)，然后执行所有的micro-task。当所有可执行的micro-task执行完毕之后。循环再次从macro-task开始，找到其中一个任务队列执行完毕，然后再执行所有的micro-task，这样一直循环下去。</li><li>其中每一个任务的执行，无论是macro-task还是micro-task，都是借助函数调用栈来完成。</li></ul><p>纯文字表述确实有点干涩，因此，这里我们通过2个例子，来逐步理解事件循环的具体顺序。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo01  出自于上面我引用文章的一个例子，我们来根据上面的结论，一步一步分析具体的执行过程。</span></span><br><span class="line"><span class="comment">// 为了方便理解，我以打印出来的字符作为当前的任务名称</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'timeout1'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">     i == <span class="number">99</span> &amp;&amp; resolve();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'then1'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'global1'</span>);</span><br></pre></td></tr></table></figure><p>首先，事件循环从宏任务队列开始，这个时候，宏任务队列中，只有一个script(整体代码)任务。每一个任务的执行顺序，都依靠函数调用栈来搞定，而当遇到任务源时，则会先分发任务到对应的队列中去，所以，上面例子的第一步执行如下图所示。</p><p><img src="/ZombieBrand.github.io/assets/599584-92fc0827aa39e325.png" alt="首先script任务开始执行，全局上下文入栈"></p><p>第二步：script任务执行时首先遇到了setTimeout，setTimeout为一个宏任务源，那么他的作用就是将任务分发到它对应的队列中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'timeout1'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="/ZombieBrand.github.io/assets/599584-2a99131c2572f898.png" alt="宏任务timeout1进入setTimeout队列"></p><p>第三步：script执行时遇到Promise实例。Promise构造函数中的第一个参数，是在new的时候执行，因此不会进入任何其他的队列，而是直接在当前任务直接执行了，而后续的.then则会被分发到micro-task的Promise队列中去。</p><p>因此，构造函数执行时，里面的参数进入函数调用栈执行。for循环不会进入任何队列，因此代码会依次执行，所以这里的promise1和promise2会依次输出。</p><p><img src="/ZombieBrand.github.io/assets/599584-774ec33de48c1d41.png" alt="promise1入栈执行，这时promise1被最先输出"></p><p><img src="/ZombieBrand.github.io/assets/599584-8b5e93798f6c9d52.png" alt="resolve在for循环中入栈执行"></p><p><img src="/ZombieBrand.github.io/assets/599584-521c5da565a35a45.png" alt="构造函数执行完毕的过程中，resolve执行完毕出栈，promise2输出，promise1页出栈，then执行时，Promise任务then1进入对应队列"></p><p>script任务继续往下执行，最后只有一句输出了globa1，然后，全局任务就执行完毕了。</p><p>第四步：第一个宏任务script执行完毕之后，就开始执行所有的可执行的微任务。这个时候，微任务中，只有Promise队列中的一个任务then1，因此直接执行就行了，执行结果输出then1，当然，他的执行，也是进入函数调用栈中执行的。</p><p><img src="/ZombieBrand.github.io/assets/599584-dd7673edbbe5e687.png" alt="执行所有的微任务"></p><p>第五步：当所有的micro-tast执行完毕之后，表示第一轮的循环就结束了。这个时候就得开始第二轮的循环。第二轮循环仍然从宏任务macro-task开始。</p><p><img src="/ZombieBrand.github.io/assets/599584-881e739c134cb6c9.png" alt="微任务被清空"></p><p>这个时候，我们发现宏任务中，只有在setTimeout队列中还要一个timeout1的任务等待执行。因此就直接执行即可。</p><p><img src="/ZombieBrand.github.io/assets/599584-c4ea234b27c5f2f2.png" alt="timeout1入栈执行"></p><p>这个时候宏任务队列与微任务队列中都没有任务了，所以代码就不会再输出其他东西了。</p><p>那么上面这个例子的输出结果就显而易见。大家可以自行尝试体会。</p><p>这个例子比较简答，涉及到的队列任务并不多，因此读懂了它还不能全面的了解到事件循环机制的全貌。所以我下面弄了一个复杂一点的例子，再给大家解析一番，相信读懂之后，事件循环这个问题，再面试中再次被问到就难不倒大家了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo02</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'golb1'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'timeout1'</span>);</span><br><span class="line"> process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'timeout1_nextTick'</span>);</span><br><span class="line"> &#125;)</span><br><span class="line"> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'timeout1_promise'</span>);</span><br><span class="line">     resolve();</span><br><span class="line"> &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'timeout1_then'</span>)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'immediate1'</span>);</span><br><span class="line"> process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'immediate1_nextTick'</span>);</span><br><span class="line"> &#125;)</span><br><span class="line"> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'immediate1_promise'</span>);</span><br><span class="line">     resolve();</span><br><span class="line"> &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'immediate1_then'</span>)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'glob1_nextTick'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'glob1_promise'</span>);</span><br><span class="line"> resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'glob1_then'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'timeout2'</span>);</span><br><span class="line"> process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'timeout2_nextTick'</span>);</span><br><span class="line"> &#125;)</span><br><span class="line"> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'timeout2_promise'</span>);</span><br><span class="line">     resolve();</span><br><span class="line"> &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'timeout2_then'</span>)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'glob2_nextTick'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'glob2_promise'</span>);</span><br><span class="line"> resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'glob2_then'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'immediate2'</span>);</span><br><span class="line"> process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'immediate2_nextTick'</span>);</span><br><span class="line"> &#125;)</span><br><span class="line"> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'immediate2_promise'</span>);</span><br><span class="line">     resolve();</span><br><span class="line"> &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'immediate2_then'</span>)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这个例子看上去有点复杂，乱七八糟的代码一大堆，不过不用担心，我们一步一步来分析一下。</p><p>第一步：宏任务script首先执行。全局入栈。glob1输出。</p><p><img src="/ZombieBrand.github.io/assets/599584-5ae0b593167e499b.png" alt="script首先执行"></p><p>第二步，执行过程遇到setTimeout。setTimeout作为任务分发器，将任务分发到对应的宏任务队列中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'timeout1'</span>);</span><br><span class="line"> process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'timeout1_nextTick'</span>);</span><br><span class="line"> &#125;)</span><br><span class="line"> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'timeout1_promise'</span>);</span><br><span class="line">     resolve();</span><br><span class="line"> &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'timeout1_then'</span>)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="/ZombieBrand.github.io/assets/599584-afded6f26c106326.png" alt="timeout1进入对应队列"></p><p>第三步：执行过程遇到setImmediate。setImmediate也是一个宏任务分发器，将任务分发到对应的任务队列中。setImmediate的任务队列会在setTimeout队列的后面执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'immediate1'</span>);</span><br><span class="line"> process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'immediate1_nextTick'</span>);</span><br><span class="line"> &#125;)</span><br><span class="line"> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'immediate1_promise'</span>);</span><br><span class="line">     resolve();</span><br><span class="line"> &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'immediate1_then'</span>)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="/ZombieBrand.github.io/assets/599584-c22a5e6567ec25d3.png" alt="进入setImmediate队列"></p><p>第四步：执行遇到nextTick，process.nextTick是一个微任务分发器，它会将任务分发到对应的微任务队列中去。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'glob1_nextTick'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="/ZombieBrand.github.io/assets/599584-8d16de95f6a12b25.png" alt="nextTick"></p><p>第五步：执行遇到Promise。Promise的then方法会将任务分发到对应的微任务队列中，但是它构造函数中的方法会直接执行。因此，glob1_promise会第二个输出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'glob1_promise'</span>);</span><br><span class="line"> resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'glob1_then'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="/ZombieBrand.github.io/assets/599584-792877853f338494.png" alt="先是函数调用栈的变化"></p><p><img src="/ZombieBrand.github.io/assets/599584-b5c548ec48521c87.png" alt="然后glob1_then任务进入队列"></p><p>第六步：执行遇到第二个setTimeout。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'timeout2'</span>);</span><br><span class="line"> process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'timeout2_nextTick'</span>);</span><br><span class="line"> &#125;)</span><br><span class="line"> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'timeout2_promise'</span>);</span><br><span class="line">     resolve();</span><br><span class="line"> &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'timeout2_then'</span>)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="/ZombieBrand.github.io/assets/599584-0392b96fd8fd2281.png" alt="timeout2进入对应队列"></p><p>第七步：先后遇到nextTick与Promise</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'glob2_nextTick'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'glob2_promise'</span>);</span><br><span class="line"> resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'glob2_then'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="/ZombieBrand.github.io/assets/599584-7001e3438df47eb0.png" alt="glob2_nextTick与Promise任务分别进入各自的队列"></p><p>第八步：再次遇到setImmediate。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'immediate2'</span>);</span><br><span class="line"> process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'immediate2_nextTick'</span>);</span><br><span class="line"> &#125;)</span><br><span class="line"> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'immediate2_promise'</span>);</span><br><span class="line">     resolve();</span><br><span class="line"> &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'immediate2_then'</span>)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="/ZombieBrand.github.io/assets/599584-eb6742e93ff577cd.png" alt="nextTick"></p><p>这个时候，script中的代码就执行完毕了，执行过程中，遇到不同的任务分发器，就将任务分发到各自对应的队列中去。接下来，将会执行所有的微任务队列中的任务。</p><p>其中，nextTick队列会比Promie先执行。nextTick中的可执行任务执行完毕之后，才会开始执行Promise队列中的任务。</p><p>当所有可执行的微任务执行完毕之后，这一轮循环就表示结束了。下一轮循环继续从宏任务队列开始执行。</p><p>这个时候，script已经执行完毕，所以就从setTimeout队列开始执行。</p><p><img src="/ZombieBrand.github.io/assets/599584-48cfccebbff92e97.png" alt="第二轮循环初始状态"></p><p>setTimeout任务的执行，也依然是借助函数调用栈来完成，并且遇到任务分发器的时候也会将任务分发到对应的队列中去。</p><p>只有当setTimeout中所有的任务执行完毕之后，才会再次开始执行微任务队列。并且清空所有的可执行微任务。</p><p>setTiemout队列产生的微任务执行完毕之后，循环则回过头来开始执行setImmediate队列。仍然是先将setImmediate队列中的任务执行完毕，再执行所产生的微任务。</p><p>当setImmediate队列执行产生的微任务全部执行之后，第二轮循环也就结束了。</p><blockquote><p>大家需要注意这里的循环结束的时间节点。</p></blockquote><blockquote><p>当我们在执行setTimeout任务中遇到setTimeout时，它仍然会将对应的任务分发到setTimeout队列中去，但是该任务就得等到下一轮事件循环执行了。例子中没有涉及到这么复杂的嵌套，大家可以动手添加或者修改他们的位置来感受一下循环的变化。</p></blockquote><p>OK，到这里，事件循环我想我已经表述得很清楚了，能不能理解就看读者老爷们有没有耐心了。我估计很多人会理解不了循环结束的节点。</p><p>当然，这些顺序都是v8的一些实现。我们也可以根据上面的规则，来尝试实现一下事件循环的机制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用数组模拟一个队列</span></span><br><span class="line"><span class="keyword">var</span> tasks = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟一个事件分发器</span></span><br><span class="line"><span class="keyword">var</span> addFn1 = <span class="function"><span class="keyword">function</span>(<span class="params">task</span>) </span>&#123;</span><br><span class="line"> tasks.push(task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行所有的任务</span></span><br><span class="line"><span class="keyword">var</span> flush = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> tasks.map(<span class="function"><span class="keyword">function</span>(<span class="params">task</span>) </span>&#123;</span><br><span class="line">     task();</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后利用setTimeout/或者其他你认为合适的方式丢入事件循环中</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> flush();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然，也可以不用丢进事件循环，而是我们自己手动在适当的时机去执行对应的某一个方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dispatch = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"> tasks.map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(item.name == name) &#123;</span><br><span class="line">         item.handler();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然，我们把任务丢进去的时候，多保存一个name即可。</span></span><br><span class="line"><span class="comment">// 这时候，task的格式就如下</span></span><br><span class="line">demoTask =  &#123;</span><br><span class="line"> name: <span class="string">'demo'</span>,</span><br><span class="line"> handler: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 于是，一个订阅-通知的设计模式就这样轻松的被实现了</span></span><br></pre></td></tr></table></figure><p>这样，我们就模拟了一个任务队列。我们还可以定义另外一个队列，利用上面的各种方式来规定他们的优先级。</p><blockquote><p>需要注意的是，这里的执行顺序，或者执行的优先级在不同的场景里由于实现的不同会导致不同的结果，包括node的不同版本，不同浏览器等都有不同的结果。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JavaScript的学习零散而庞杂，因此很多时候我们学到了一些东西，但是却没办法感受到自己的进步，甚至过了不久，就把学到的东西给忘了。为了解决自己的这个困扰，在学习的过程中，我一直试图在寻找一条核心的线索，只要我根据这条线索，我就能够一点一点的进步。&lt;/p&gt;
&lt;p&gt;前端基
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/categories/JavaScript/"/>
    
    
      <category term="事件循环机制" scheme="https://zombrbrand.github.io/ZombieBrand.github.io/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
</feed>
