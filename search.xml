<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[完美实现一个“回到顶部”]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2F%E5%AE%8C%E7%BE%8E%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E2%80%9C%E5%9B%9E%E5%88%B0%E9%A1%B6%E9%83%A8%E2%80%9D%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[实现点击button滚动返回顶部动画]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2F%E5%AE%9E%E7%8E%B0%E7%82%B9%E5%87%BBbutton%E6%BB%9A%E5%8A%A8%E8%BF%94%E5%9B%9E%E9%A1%B6%E9%83%A8%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[绘制虚线并且能够设置虚线宽度方法]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2F%E7%BB%98%E5%88%B6%E8%99%9A%E7%BA%BF%E5%B9%B6%E4%B8%94%E8%83%BD%E5%A4%9F%E8%AE%BE%E7%BD%AE%E8%99%9A%E7%BA%BF%E5%AE%BD%E5%BA%A6%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[HTML5CSS3]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2FHTML5CSS3%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[media用法总结]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2Fmedia%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[CSS基础知识]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2FCSS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[CSS的全称是什么? Cascading Style Sheets 叠层样式表一种用来表现HTML或XML等文件样式的计算机语言。 CSS有几种引入方式? link 和@import 有什么区别? 内联样式内联方式指的是直接在HTML标签中的style属性中添加CSS。&lt;h1 style=&quot;color:red&quot;&gt; &lt;/h1&gt; 内部样式内部样式指的是在HTML头部中的标签中写CSS代码。 12345&lt;style type="text/css"&gt; h1&#123; color:red;&#125;&lt;/style&gt; 外部样式。分为链接和导入 链接方式链接方式指的是使用HTML头部的标签引入外部的CSS文件。 123&lt;head&gt;&lt;link rel="stylesheet" type="text/css" href="style.css"&gt;&lt;/head&gt; 导入方式导入方式指的是使用CSS规则引入外部CSS文件。 123&lt;style&gt; @import url(style.css);&lt;/style&gt; 比较link和@import区别link 属于 HTML，通过 标签中的 href 属性来引入外部文件，而 @import 属于 CSS，所以导入语句应写在 CSS 中，要注意的是导入语句应写在样式表的开头，否则无法正确导入外部文件；使用链接方式时，会在装置页面主体部分之前装载CSS文件，这样显示出来的网页从一开始就是带有样式的效果，而使用导入式时，会在整个页面装载完成后再装载CSS文件，对于有的浏览器来说，在一些情况下，如果网页文件的体积比较大，则会出现先显示无样式的页面，闪烁一下之后再出现样式设置后的效果。从浏览者的感受来说，这是使用导入式的一个缺陷。兼容性的差别。@import是CSS2.1提出，在IE5上才能识别。link无此问题。link支持使用Javascript控制DOM去改变样式；而@import不支持 以下这几种文件路径分别用在什么地方，代表什么意思? css/a.css：相对路径：代表当前目录下css文件夹中的a.css文件 ./css/a.css相对路径：代表当前目录下css文件夹中的a.css文件（加单个点与不加相同） b.css相对路径：代表当前目录下b.css文件 ../imgs/a.png相对路径：代表上级目录下imgs文件夹中的a.png文件 /Users/hunger/project/css/a.css/static/css/a.css绝对路径：代表本地绝对路径a.css文件 http://cdn.xxxx.com/kejian1/8-1.png网络路径：代表网站的图片路径 /static/css/a.css网站相对路径：代表网站服务器根目录static文件夹中的css文件夹中的a.css文件 如果我想在网页上展示一个图片，需要怎么操作? 将本地图片发到服务器上，或者直接从别的网站复制图片地址。使用&lt;img src=&quot;地址&quot;&gt; 列出5条以上html和 css 的书写规范 在每个 HTML 页面的第一行添加声明 添加标签 属性名 与之后的 :之间不允许包含空格，:与属性值之间必须包含空格。 使用英文小写 +、&gt;、~ 选择器的两边各保留一个空格。 RGB颜色值必须使用十六进制记号形式 #rrggbb。不允许使用 rgb()。 需要在 Windows 平台显示的中文内容，其字号应不小于 12px。 使用 4 个空格做为一个缩进层级，不允许使用 2 个空格 或 tab 字符别忘记结束符 使用外联式css样式 选择器 与 { 之间必须包含空格。 使用注释，方便以后或其他人理解]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS常见样式2]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2FCSS%E5%B8%B8%E8%A7%81%E6%A0%B7%E5%BC%8F2%2F</url>
    <content type="text"><![CDATA[CSS常见样式背景样式 属性 描述 background 简写属性，作用是将背景属性设置在一个声明中 background-attachment 背景图像是否固定或者随着页面的其余部分滚动 background-color 设置元素的背景颜色 background-image 把图像设置为背景 background-position 设置背景图像的起始位置 background-repeat 设置背景图像是否及如何重复 background-size 设置背景的大小(兼容性) background-position：默认左上角x yx% y%[top | center | bottom] [left | center | right] background-repeatno-repeat：背景图片在规定位置repeat-x：图片横向重复repeat-y：图片纵向重复repeat：全部重复 background-size100px 100pxcontaincover 12345background-color: #F00;background-image: url(background.gif);background-repeat: no-repeat;background-attachment: fixed;background-position: 0 0; 可以缩写为一句： background: #f00 url(background.gif) no-repeat fixed 0 0; 提醒： 要显示出background-img:容器需有 窗口，要被撑开。 text-align: center的作用是什么，作用在什么元素上？能让什么元素水平居中作用是让行内元素（包括inline-block）水平居中作用在要水平居中的行内元素的父元素上 IE 盒模型和W3C盒模型有什么区别?区别W3C标准盒模型中padding、border所占的空间不在width、height范围内，大家俗称的IE的盒模型width包括content尺寸＋padding＋border。 ie678怪异模式（不添加 doctype）使用 ie 盒模型，宽度=边框+padding+内容宽度。chrome， ie9+, ie678(添加 doctype) 使用标准盒模型， 宽度= 内容宽度。 { box-sizing: border-box;}的作用是什么？css3新样式box-sizing：允许以特定的方式定义匹配某个区域的特定元素值：box-sizing: content-box：w3c标准盒模型box-sizing: border-box：“IE盒模型” line-height: 2和line-height: 200%有什么区别?计算方法的区别。 数值：继承的时候，浏览器会先将line-height这个属性继承给子元素，再由子元素计算。根据自身元素font-size的2倍计算。 百分数：继承的时候，浏览器会先将行高对应的具体的数值计算出来以后再继承。根据父元素的font-size的200%计算。 另外 height = line-heihgt 可以用来 垂直居中单行文本 inline-block有什么特性？如何去除缝隙？高度不一样的inline-block元素如何顶端对齐? inline-block 内联块级元素，既能放在一行（内联元素特性），又能设置宽高及padding margin（块级元素特性）。 inline-block 元素间的空白/回车换行会产生缝隙，去除缝隙可以使html标签连续（无空白/折行），还可以设置其父元素font-size:0; 然后在inline-block元素内恢复font-size。 在父元素中使用vertical-align:top; 可以让高度不一样的inline-block 元素顶端对齐。（值还有更多） 行内元素和inline-block元素水平方向上默认情况下是按基线对齐 CSS sprite 是什么?CSS精灵图（雪碧图）CSS Sprites在国内很多人叫css精灵是一种网页图片应用处理方式。它允许你将一个页面涉及到的所有零星图片都包含到一张大图中去，这样一来，当访问该页面时，载入的图片就不会像以前那样一幅一幅地慢慢显示出来了。对于当前网络流行的速度而言，不高于200KB的单张图片的所需载入时间基本是差不多的，所以无需顾忌这个问题。加速的关键，不是降低重量，而是减少个数。传统切图讲究精细，图片规格越小越好，重量越小越好，其实规格大小无所谓，计算机统一都按byte计算。客户端每显示一张图片都会向服务器发送请求。所以，图片越多请求次数越多，造成延迟的可能性也就越大。 简单来说：指将不同的图片/图标合并在一张图上。使用CSS Sprite 可以减少网络请求，提高网页加载性能。 让一个元素”看不见”有几种方式？有什么区别?隐藏or透明 opacity: 0 ; 透明度为0，占据文档空间，元素绑定的事件还是会触发事件。 visibility: hidden ; 类似于 opacity:0，但绑定的事件不会触发。 background-color: rgba(0，0，0，0); 只是背景色透明 display:none; 消失，不占用位置，浏览器不会去绘制它，但存在于DOM树，绑定的事件不会触发。 前三种方法仅仅是改变其透明度，让其”假消失”，看不见，但存在。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS常见样式1]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2FCSS%E5%B8%B8%E8%A7%81%E6%A0%B7%E5%BC%8F1%2F</url>
    <content type="text"><![CDATA[CSS常见样式块级元素和行内元素分别有哪些？动手测试并列出4条以上的特性区别块级元素行内元素块级(block-level); 行内(内联、inline-level) 块级元素 VS 行内元素区别1：块级元素宽度占据整行，行内元素占据自身宽度的空间，能多个并列排序，直到一行排列不下，换下一行。区别2：块级元素可以包含块级元素和行内元素；行内元素内只能包含行内元素和文本区别3：块级元素可以设置宽高；行内元素则不能设置宽高（行内元素的高度是由line-height来决定，宽度由具体的内容来决定）区别4：块级元素可以设置上下左右的margin、padding 边距；行内元素只对左右方向的margin、padding生效，上下无效（行内元素对于上下padding，可以看到背景色和边框的影响，但高度还是无法撑开）区别5：块级元素，默认为display: block；行内元素表示为display:inline.区别6：行内元素可以”感受”到浮动元素的存在。 block-leveldiv h1 h2 h3 h4 h5 h6 p hrform ul dl ol pre tableli dd dt tr td th inline-levelem strong span a br imgbutton input label select textareacode script 什么是 CSS 继承? 哪些属性能继承，哪些不能？ css继承：继承就是子标签继承了上级标签的CSS样式的属性。 不可继承的：display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-bread-before和unicode-bidi。 所有元素可继承：visibility和cursor。 内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction。 终端块状元素可继承：text-indent和text-align。 列表元素可继承：list-style、list-style-type、list-style-position、list-style-image。 表格元素可继承：border-collapse。 如何让块级元素水平居中？如何让行内元素水平居中?水平居中 内联元素：在其父元素身上加 text-align:center； 块级元素： 固定宽度的div margin-left: auto margin-right: auto 不固定宽度的 div（有这种无脑需求？） margin: 0 100px; 用 CSS 实现一个三角形1234567 &lt;div class="box"&gt;&lt;/div&gt;.box &#123; width: 0; height: 0; border: 50px solid transparent; border-bottom: 50px solid #ccc;&#125; 设置块级元素的宽高都为0px，上下左右border设置实线solid，留一个设置为有颜色，其他三个为transparent透明，调整4个border的px可实现不同形状三角形(见最后任务4) 单行文本溢出加 …如何实现?首先设置不换行：white-space:nowrap;其次设置超出隐藏：overflow:hidden;再设置文本溢出显示为省略号：text-overflow:ellipsis; px, em, rem vw有什么区别 px 是绝对长度单位。em、rem 是相对长度单位 em如果用于font-size属性本身，则相对于父元素的font-size。若用于其它属性，则相对于元素本身的font-size当没有设置font-size时，chrome浏览器会有一个默认的 em 设置：1em = 16px缺点：容易混乱 remrem 是相对于根元素html的font-size属性的计算值，比较好计算当没有设置 font-size 时，浏览器会有一个默认的 rem 设置：1rem = 16px，这点与 em 是一致的兼容性：IE8-不支持 vw vh: 相对单位，1vw 为屏幕宽度的1% 兼容性 解释下面代码的作用?为什么要加引号? 字体里\5b8b\4f53代表什么?123body&#123; font: 12px/1.5 tahoma,arial,'Hiragino Sans GB','\5b8b\4f53',sans-serif;&#125; 设置body的字样为大小12px，1.5倍行高，字体选择依次为 tahoma,arial,’Hiragino Sans GB’,’\5b8b\4f53’,sans-serif有空格的内容要加引号，才会被认为是一个整体。不然会被认为是两个字体里\5b8b\4f53代表的是黑体的unicode码。文字先转化为相应的unicode码，再通过不同的字体库依据这个编码来转化为相应的字体(直接写成中文，浏览器有可能不能识别，所以要写成Unicode编码。) 去除元素默认 margin padding ：*{margin:0;padding:0} 颜色单词: red, blue, pink, yellow, white, black十六进制: #000000, #fff, #eee, #ccc, #666, #333, #f00, #0f0, #00frgb: rgb(255, 255, 255), rgb(0, 255, 0)rgba: rgba(0,0,0,0.5)更多 隐藏or透明opacity: 0 ; 透明度为0，整体visibility: hidden ; 和opacity:0 类似display:none; 消失，不占用位置background-color: rgba(0，0，0，0.2) 只是背景色透明 inline-block既呈现 inline 特性(不占据一整行，宽度由内容宽度决定)又呈现 block 特性 (可设置宽高，内外边距)缝隙问题 line-heightline-height: 2line-height: 100%height = line-heihgt 来垂直居中单行文本]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS选择器]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2FCSS%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[浮动]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2F%E6%B5%AE%E5%8A%A8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[BFC]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2FBFC%2F</url>
    <content type="text"><![CDATA[BFC 已经是一个耳听熟闻的词语了，网上有许多关于 BFC 的文章，介绍了如何触发 BFC 以及 BFC 的一些用处（如清除浮动，防止 margin 重叠等）。 一、BFC是什么？ 在解释 BFC 是什么之前，需要先介绍 Box、Formatting Context的概念。 Box: CSS布局的基本单位Box 是 CSS 布局的对象和基本单位， 直观点来说，就是一个页面是由很多个 Box 组成的。元素的类型和 display 属性，决定了这个 Box 的类型。 不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染。让我们看看有哪些盒子： block-level box: display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context； inline-level box: display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context； run-in box: css3 中才有， 这儿先不讲了。 Formatting context Formatting context 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)。 CSS2.1 中只有 BFC 和 IFC, CSS3 中还增加了 GFC 和 FFC。 BFC 定义 BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。 BFC布局规则： 内部的Box会在垂直方向，一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算 二、哪些元素会生成BFC? 根元素 float属性不为none position为absolute或fixed display为inline-block, table-cell, table-caption, flex, inline-flex overflow不为visible 三、BFC的作用及原理1. 自适应两栏布局代码： 12345678910111213141516171819202122&lt;style&gt; body &#123; width: 300px; position: relative; &#125; .aside &#123; width: 100px; height: 150px; float: left; background: #f66; &#125; .main &#123; height: 200px; background: #fcc; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="aside"&gt;&lt;/div&gt; &lt;div class="main"&gt;&lt;/div&gt;&lt;/body&gt; 根据BFC布局规则第3条： 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 因此，虽然存在浮动的元素aside，但main的左边依然会与包含块的左边相接触。 根据BFC布局规则第四条： BFC的区域不会与float box重叠。 我们可以通过触发main生成BFC， 来实现自适应两栏布局。 123.main &#123; overflow: hidden;&#125; 当触发main生成BFC后，这个新的BFC为了不与浮动的aside重叠。因此会根据包含块的宽度，和aside的宽度，自动变窄。效果如下：： 2. 清除内部浮动代码： 12345678910111213141516171819 &lt;style&gt; .par &#123; border: 5px solid #fcc; width: 300px; &#125; .child &#123; border: 5px solid #f66; width:100px; height: 100px; float: left; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="par"&gt; &lt;div class="child"&gt;&lt;/div&gt; &lt;div class="child"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 根据BFC布局规则第六条： 计算BFC的高度时，浮动元素也参与计算 解决方案一般有两种1). 利用 clear属性，清除浮动 123对父元素加一个class:floatfix添加如下CSS 12345678.floatfix&#123; *zoom:1;&#125;.floatfix:after&#123; content:""; display:table; clear:both;&#125; 2). 使父容器形成BFC 为达到清除内部浮动，我们可以触发par生成BFC，那么par在计算高度时，par内部的浮动元素child也会参与计算。 代码： 123 .par &#123; overflow: hidden;&#125; 效果如下： 3. 防止垂直 margin 重叠代码： 1234567891011121314 &lt;style&gt; p &#123; color: #f55; background: #fcc; width: 200px; line-height: 100px; text-align:center; margin: 100px; &#125;&lt;/style&gt;&lt;body&gt; &lt;p&gt;Haha&lt;/p&gt; &lt;p&gt;Hehe&lt;/p&gt;&lt;/body&gt; 页面： 两个p之间的距离为100px，发送了margin重叠。 根据BFC布局规则第二条： Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 折叠的结果： 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。 两个外边距一正一负时，折叠结果是两者的相加的和。 我们可以在p外面包裹一层容器，并触发该容器生成一个BFC。那么两个P便不属于同一个BFC，就不会发生margin重叠了。 代码： 12345678910111213141516171819&lt;style&gt; .wrap &#123; overflow: hidden; &#125; p &#123; color: #f55; background: #fcc; width: 200px; line-height: 100px; text-align:center; margin: 100px; &#125;&lt;/style&gt;&lt;body&gt; &lt;p&gt;Haha&lt;/p&gt; &lt;div class="wrap"&gt; &lt;p&gt;Hehe&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 效果如下: 浮动和绝对定位不与任何元素产生 margin 折叠原因： 浮动元素和绝对定位元素不与其他盒子产生外边距折叠是因为元素会脱离当前的文档流，违反了上面所述的两个margin是邻接的条件同时，又因为浮动和绝对定位会使元素为它的内容创建新的BFC，因此该元素和子元素所处的BFC是不相同的，因此也不会产生margin的折叠。 自己经验添加父子元素margin合并可以给父元素添加border或者padding解决 高级解决父子元素margin合并问题: 1.no-collapse::before&#123;content:'';display:table;&#125;,.no-collapse::after&#123;content:'';display:table;&#125; 总结 其实以上的几个例子都体现了BFC布局规则第五条： BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 因为BFC内部的元素和外部的元素绝对不会互相影响，因此， 当BFC外部存在浮动时，它不应该影响BFC内部Box的布局，BFC会通过变窄，而不与浮动有重叠。同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文本溢出加..如何实现]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2F%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E5%8A%A0-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[常见布局居中]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2F%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[两栏布局左侧固定宽度右边自适应负margin方法：1234567891011121314151617181920&lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt;.left&#123; width:200px; height:300px; margin-right:10px; background:red; float:left;&#125;.right&#123; width:100%; height:400px; float:right; margin-right:-210px; background:blue;&#125;&lt;/style&gt; overflow方法:123456789101112131415161718&lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt;.left&#123; width:200px; height:300px; margin-right:10px; background:red; float:left;&#125;.right&#123; height:400px; background:blue; overflow:hidden;&#125;&lt;/style&gt; position方法:12345678910111213141516171819202122232425&lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt;.container&#123; position:relative;&#125;.left&#123; position:absolute; top:0; left:0; width:200px; height:300px; background:red;&#125;.right&#123; position:absolute; top:0; left:210px; right:0; height:400px; background:blue;&#125;&lt;/style&gt; flex方法:1234567891011121314151617181920&lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt;.container&#123; display:flex;&#125;.left&#123; width:200px; height:300px; background:red; margin-right:10px;&#125;.right&#123; flex:1; height:400px; background:blue;&#125;&lt;/style&gt; 三栏布局margin方法1234567891011121314151617181920212223242526&lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;div class="center"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt;.left&#123; width:200px; height:300px; background:red; margin:0 10px; float:left;&#125;.center&#123; height:400px; background:pink; overflow:auto;&#125;.right&#123; width:200px; height:300px; background:blue; float:right; margin:0 10px;&#125;&lt;/style&gt; overflow方法1234567891011121314151617181920212223242526&lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;div class="center"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt;.left&#123; width:200px; height:300px; background:red; margin:0 10px; float:left;&#125;.center&#123; height:400px; background:pink; overflow:auto;&#125;.right&#123; width:200px; height:300px; background:blue; float:right; margin:0 10px;&#125;&lt;/style&gt; position方法12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt;&lt;style&gt;*&#123; box-sizing:border-box; margin:0; padding:0;&#125;.container&#123; position:relative;&#125;.left&#123; width:200px; height:300px; background:red; margin:0 10px; position:absolute; top:0; left:0;&#125;.center&#123; width:calc(100% - 440px); height:400px; background:pink; position:absolute; top:0; left:50%; transform:translateX(-50%);&#125;.right&#123; width:200px; height:300px; background:blue; position:absolute; top:0; right:0; margin:0 10px;&#125;&lt;/style&gt; flex方法123456789101112131415161718192021222324252627282930313233&lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt;*&#123; box-sizing:border-box; padding:0; margin:0;&#125;.container&#123; display:flex;&#125;.left&#123; width:200px; height:300px; background:red; margin:0 10px; &#125;.center&#123; height:400px; background:pink; flex:1;&#125;.right&#123; width:200px; height:300px; background:blue; margin:0 10px;&#125;&lt;/style&gt; 块级元素居中margin方法123456789.container&#123; background:grey;&#125;.item&#123; width:300px; height:200px; background:red; margin:0 auto;&#125; position方法12345678910111213.container&#123; background:grey; position:relative;&#125;.item&#123; width:300px; height:200px; background:red; position:absolute; top:0; left:50%; transform:translateX(-50%)&#125; display:flex12345678910.container&#123; background:grey; display:flex; justify-content:center;&#125;.item&#123; width:300px; height:200px; background:red;&#125; text-align:center 12345678910.container&#123; background:grey; text-align:center;&#125;.item&#123; width:300px; height:200px; background:red; display:inline-block;&#125; 多行文字水平垂直居中123456789101112131415161718192021&lt;section&gt; &lt;div class="container"&gt; &lt;h1 class="title"&gt;这是标题&lt;/h1&gt; &lt;p class="content"&gt;这是一大段文字内容这是一大段文字内容这是一大段文字内容这是一大段文字内容这是一大段文字内容这是一大段文字内容&lt;/p&gt; &lt;/div&gt;&lt;/section&gt;&lt;style&gt;section&#123; margin:0 auto; width:600px;&#125;.container&#123; padding:0 100px; width:600px; height:600px; background:grey; text-align:center; display:table-cell; vertical-align:middle;&#125;&lt;/style&gt; image水平垂直居中123456789101112131415161718 &lt;div class="container"&gt; &lt;img src="" alt="图片"&gt; &lt;/div&gt;.container&#123; width:300px; height:300px; border:1px solid red; text-align:center;&#125;.container::after&#123; content:''; height:100%; display:inline-block; vertical-align:middle;&#125;img&#123; vertical-align:middle;&#125; 浏览器固定水平垂直居中12345678.box&#123; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:#ccc; text-align:center;&#125; 水平居中SVG和font/img1234567svg&#123;vertical-align:middle&#125;span&#123;vertical-align:middle&#125;img&#123; vertical-align:middle&#125; 经典文章:https://www.zhangxinxu.com/wordpress/2015/08/css-deep-understand-vertical-align-and-line-height/]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex布局]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2Fflex%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[常见布局 normal flow（正常流） float + clear（浮动+清楚浮动） position relative + absolute （相对定位+绝对定位） display inline-block （改变元素属性） -margin（负外边距） Flex布局特性 块级布局侧重垂直方向、行内布局侧重水平方向，flex布局是与方向无关的 flex布局可以实现空间自动分配、自动对齐（全称:the flexible box Module） flex适用于简单的线性布局，更复杂的布局要交给grid布局（目前还没发布） 语法 display: flex; display: inline-flex; 设为Flex布局后，子元素的loat,clear和vertical-align属性将失效。 Flex基础概念采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。 上图水平是主轴(main axis)垂直是侧轴(cross axis)。主轴的开始位置叫做main start，结束位置叫做main end；侧轴的开始位置叫做cross start，结束位置叫做cross end 。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的侧轴空间叫做cross size。 Flex container容器属性flex-direction: 决定了主轴的方向（即项目的排列方向)1234.box&#123; display:flex; flex-direction:column-revers|column|row-reverse|row; &#125; 属性名 说明 row(默认) 主轴方向为水平，起点在左端 row- reverse 主轴方向为水平，起点在右端 column 主轴方向为垂直，起点在上端 column-reverse 主轴方向为垂直，起点在下端 单独添加flex-direction: row; //默认是不会换行 flex-wrap: 定义如果一条轴线排不下，如何换行12345.box&#123; display:flex; flex-direction:now flex-wrap:wrap; &#125; 属性名 说明 nowrap(默认) 不换行 wrap 换行 wrap-reverse 换行反转 flex-flow（以上两个属性的简写） flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 1234.box&#123; display:flex; flex-flow: row nowrap; &#125; justify-content:定义了项目在主轴上的对齐方式1234.box&#123; display:flex; justify-content:flex-start | flex-end | center | space-between | space-around;&#125; 属性名 说明 flex-start(默认) 项目沿着主轴方向的起始位置靠齐 flex-end 项目沿着主轴方向的结束位置靠齐，和flex-start相反 space-between 项目在主轴方向上两端对齐，其中的间隔相等 space-around 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍 align-items定义项目在交叉轴上如何对齐1234.box&#123; display:flex; align-items:flex-start | flex-end | center | baseline | stretch;&#125; 属性名 说明 flex-start 项目沿着侧轴上的起点对齐 flex-end 项目沿着侧轴上的终点对齐 center 项目在侧轴方向上居中对齐 stretch(默认) 如果项目未设置高度或高度为auto,将占满整个容器的高度。 align-content多行多列内容对齐方式注意如果项目只有一行，属性不起作用 1234.box&#123; display:flex; align-content:flex-start | flex-end | center | space-between | space-around | stretch;&#125; 属性名 说明 flex-start 项目与侧轴的起点对齐 flex-end 项目与侧轴的终点对齐 center 项目与侧轴的中点对齐 space-between 与侧轴两端对齐，轴线之间的间隔平均分布 space-around 每行轴线两侧的间隔都相等。所以轴线之间的间隔比轴线与边框的间隔大一倍 stretch（默认） 轴线占满整个测轴 flex item项目属性 order属性：定义项目的排列顺序。数值越小，排列越靠前，默认为0 .item{order: &lt;integer&gt;;} flex-grow属性:定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大 .item{flex-grow:&lt;number&gt;;} flex-grow为零的话则不变化，不能为負值。如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项的2倍。 flex-shrink属性：定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小 .item{flex-shrink:&lt;number&gt;;} 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。 flex-basis属性:定义了在分配多余空间之前，项目占据的主轴空间（main size） 浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。它可以设为跟width或height属性一样的值，则项目将占据固定空间 .item{flex-basis: &lt;length&gt;| auto; flex属性：flex-grow,flex-shrink和flex-basis的简写 默认值为0 1 auto。后两个属性可选。该属性有两个快捷值：auto(1 1 auto) 和 none (0 0 auto)。 align-self属性：允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性 默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 .item{align-self:auto | flex-start | flex-end | center | baseline | stretch;} 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 最近发现一篇很详细关于flex box 布局的博客链接阮一峰flex实战布局教程]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
