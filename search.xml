<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ES6 async]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F14%2FES6%20async%2F</url>
    <content type="text"><![CDATA[含义ES2017 标准引入了 async 函数，使得异步操作变得更加方便。async 函数是什么？一句话，它就是 Generator 函数的语法糖。前文有一个 Generator 函数，依次读取两个文件。 1234567891011121314151617const fs = require('fs');const readFile = function (fileName) &#123; return new Promise(function (resolve, reject) &#123; fs.readFile(fileName, function(error, data) &#123; if (error) return reject(error); resolve(data); &#125;); &#125;);&#125;;const gen = function* () &#123; const f1 = yield readFile('/etc/fstab'); const f2 = yield readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;; 写成async函数，就是下面这样。 123456const asyncReadFile = async function () &#123; const f1 = await readFile('/etc/fstab'); const f2 = await readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;; 一比较就会发现，async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。 async函数对 Generator 函数的改进，体现在以下四点。1. 内置执行器。Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。 asyncReadFile();上面的代码调用了asyncReadFile函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用next方法，或者用co模块，才能真正执行，得到最后结果。 2. 更好的语义。async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。 3. 更广的适用性。co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。 4. 返回值是 Promise。async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。 进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。基本用法async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。下面是一个例子。 123456789async function getStockPriceByName(name) &#123; const symbol = await getStockSymbol(name); const stockPrice = await getStockPrice(symbol); return stockPrice;&#125;getStockPriceByName('goog').then(function (result) &#123; console.log(result);&#125;); 上面代码是一个获取股票报价的函数，函数前面的async关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个Promise对象。 下面是另一个例子，指定多少毫秒后输出一个值。 123456789101112function timeout(ms) &#123; return new Promise((resolve) =&gt; &#123; setTimeout(resolve, ms); &#125;);&#125;async function asyncPrint(value, ms) &#123; await timeout(ms); console.log(value);&#125;asyncPrint('hello world', 50); 上面代码指定50毫秒以后，输出hello world。 由于async函数返回的是 Promise 对象，可以作为await命令的参数。所以，上面的例子也可以写成下面的形式。 123456789101112async function timeout(ms) &#123; await new Promise((resolve) =&gt; &#123; setTimeout(resolve, ms); &#125;);&#125;async function asyncPrint(value, ms) &#123; await timeout(ms); console.log(value);&#125;asyncPrint('hello world', 50); async 函数有多种使用形式。123456789101112131415161718192021222324252627// 函数声明async function foo() &#123;&#125;// 函数表达式const foo = async function () &#123;&#125;;// 对象的方法let obj = &#123; async foo() &#123;&#125; &#125;;obj.foo().then(...)// Class 的方法class Storage &#123; constructor() &#123; this.cachePromise = caches.open('avatars'); &#125; async getAvatar(name) &#123; const cache = await this.cachePromise; return cache.match(`/avatars/$&#123;name&#125;.jpg`); &#125;&#125;const storage = new Storage();storage.getAvatar('jake').then(…);// 箭头函数const foo = async () =&gt; &#123;&#125;; 语法async函数的语法规则总体上比较简单，难点是错误处理机制。 返回 Promise 对象async函数返回一个 Promise 对象。async函数内部return语句返回的值，会成为then方法回调函数的参数。123456async function f() &#123; return 'hello world';&#125;f().then(v =&gt; console.log(v))// "hello world" 上面代码中，函数f内部return命令返回的值，会被then方法回调函数接收到。 async函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。123456789async function f() &#123; throw new Error('出错了');&#125;f().then( v =&gt; console.log(v), e =&gt; console.log(e))// Error: 出错了 Promise 对象的状态变化async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。 下面是一个例子。 1234567async function getTitle(url) &#123; let response = await fetch(url); let html = await response.text(); return html.match(/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i)[1];&#125;getTitle('https://tc39.github.io/ecma262/').then(console.log)// "ECMAScript 2017 Language Specification" 上面代码中，函数getTitle内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行then方法里面的console.log。 await 命令正常情况下，await命令后面是一个 Promise 对象。如果不是，会被转成一个立即resolve的 Promise 对象。123456async function f() &#123; return await 123;&#125;f().then(v =&gt; console.log(v))// 123 上面代码中，await命令的参数是数值123，它被转成 Promise 对象，并立即resolve。 await命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。12345678async function f() &#123; await Promise.reject('出错了');&#125;f().then(v =&gt; console.log(v)).catch(e =&gt; console.log(e))// 出错了 注意，上面代码中，await语句前面没有return，但是reject方法的参数依然传入了catch方法的回调函数。这里如果在await前面加上return，效果是一样的。 只要一个await语句后面的 Promise 变为reject，那么整个async函数都会中断执行。1234async function f() &#123; await Promise.reject('出错了'); await Promise.resolve('hello world'); // 不会执行&#125; 上面代码中，第二个await语句是不会执行的，因为第一个await语句状态变成了reject。 有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个await放在try…catch结构里面，这样不管这个异步操作是否成功，第二个await都会执行。 1234567891011async function f() &#123; try &#123; await Promise.reject('出错了'); &#125; catch(e) &#123; &#125; return await Promise.resolve('hello world');&#125;f().then(v =&gt; console.log(v))// hello world 另一种方法是await后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误。12345678910async function f() &#123; await Promise.reject('出错了') .catch(e =&gt; console.log(e)); return await Promise.resolve('hello world');&#125;f().then(v =&gt; console.log(v))// 出错了// hello world 错误处理如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject。12345678910async function f() &#123; await new Promise(function (resolve, reject) &#123; throw new Error('出错了'); &#125;);&#125;f().then(v =&gt; console.log(v)).catch(e =&gt; console.log(e))// Error：出错了 上面代码中，async函数f执行后，await后面的 Promise 对象会抛出一个错误对象，导致catch方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制，可以参考后文的“async 函数的实现原理”。 防止出错的方法，也是将其放在try…catch代码块之中。123456789async function f() &#123; try &#123; await new Promise(function (resolve, reject) &#123; throw new Error('出错了'); &#125;); &#125; catch(e) &#123; &#125; return await('hello world');&#125; 如果有多个await命令，可以统一放在try…catch结构中。 123456789101112async function main() &#123; try &#123; const val1 = await firstStep(); const val2 = await secondStep(val1); const val3 = await thirdStep(val1, val2); console.log('Final: ', val3); &#125; catch (err) &#123; console.error(err); &#125;&#125; 下面的例子使用try…catch结构，实现多次重复尝试。 123456789101112131415const superagent = require('superagent');const NUM_RETRIES = 3;async function test() &#123; let i; for (i = 0; i &lt; NUM_RETRIES; ++i) &#123; try &#123; await superagent.get('http://google.com/this-throws-an-error'); break; &#125; catch(err) &#123;&#125; &#125; console.log(i); // 3&#125;test(); 上面代码中，如果await操作成功，就会使用break语句退出循环；如果失败，会被catch语句捕捉，然后进入下一轮循环。 使用注意点第一点，前面已经说过，await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try…catch代码块中。12345678910111213141516async function myFunction() &#123; try &#123; await somethingThatReturnsAPromise(); &#125; catch (err) &#123; console.log(err); &#125;&#125;// 另一种写法async function myFunction() &#123; await somethingThatReturnsAPromise() .catch(function (err) &#123; console.log(err); &#125;);&#125; 第二点，多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。12let foo = await getFoo();let bar = await getBar(); 上面代码中，getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发。 12345678// 写法一let [foo, bar] = await Promise.all([getFoo(), getBar()]);// 写法二let fooPromise = getFoo();let barPromise = getBar();let foo = await fooPromise;let bar = await barPromise; 上面两种写法，getFoo和getBar都是同时触发，这样就会缩短程序的执行时间。 第三点，await命令只能用在async函数之中，如果用在普通函数，就会报错。12345678async function dbFuc(db) &#123; let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; // 报错 docs.forEach(function (doc) &#123; await db.post(doc); &#125;);&#125; 上面代码会报错，因为await用在普通函数之中了。但是，如果将forEach方法的参数改成async函数，也有问题。 12345678function dbFuc(db) &#123; //这里不需要 async let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; // 可能得到错误结果 docs.forEach(async function (doc) &#123; await db.post(doc); &#125;);&#125; 上面代码可能不会正常工作，原因是这时三个db.post操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用for循环。 1234567async function dbFuc(db) &#123; let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; for (let doc of docs) &#123; await db.post(doc); &#125;&#125; 如果确实希望多个请求并发执行，可以使用Promise.all方法。当三个请求都会resolved时，下面两种写法效果相同。 1234567891011121314151617181920async function dbFuc(db) &#123; let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; let promises = docs.map((doc) =&gt; db.post(doc)); let results = await Promise.all(promises); console.log(results);&#125;// 或者使用下面的写法async function dbFuc(db) &#123; let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; let promises = docs.map((doc) =&gt; db.post(doc)); let results = []; for (let promise of promises) &#123; results.push(await promise); &#125; console.log(results);&#125; 目前，@std/esm模块加载器支持顶层await，即await命令可以不放在 async 函数里面，直接使用。 1234567891011// async 函数的写法const start = async () =&gt; &#123; const res = await fetch('google.com'); return res.text();&#125;;start().then(console.log);// 顶层 await 的写法const res = await fetch('google.com');console.log(await res.text()); 上面代码中，第二种写法的脚本必须使用@std/esm加载器，才会生效。 async 函数的实现原理async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。1234567891011async function fn(args) &#123; // ...&#125;// 等同于function fn(args) &#123; return spawn(function* () &#123; // ... &#125;);&#125; 所有的async函数都可以写成上面的第二种形式，其中的spawn函数就是自动执行器。 下面给出spawn函数的实现，基本就是前文自动执行器的翻版。 12345678910111213141516171819202122function spawn(genF) &#123; return new Promise(function(resolve, reject) &#123; const gen = genF(); function step(nextF) &#123; let next; try &#123; next = nextF(); &#125; catch(e) &#123; return reject(e); &#125; if(next.done) &#123; return resolve(next.value); &#125; Promise.resolve(next.value).then(function(v) &#123; step(function() &#123; return gen.next(v); &#125;); &#125;, function(e) &#123; step(function() &#123; return gen.throw(e); &#125;); &#125;); &#125; step(function() &#123; return gen.next(undefined); &#125;); &#125;);&#125; 与其他异步处理方法的比较我们通过一个例子，来看 async 函数与 Promise、Generator 函数的比较。 假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。 首先是 Promise 的写法。123456789101112131415161718192021222324function chainAnimationsPromise(elem, animations) &#123; // 变量ret用来保存上一个动画的返回值 let ret = null; // 新建一个空的Promise let p = Promise.resolve(); // 使用then方法，添加所有动画 for(let anim of animations) &#123; p = p.then(function(val) &#123; ret = val; return anim(elem); &#125;); &#125; // 返回一个部署了错误捕捉机制的Promise return p.catch(function(e) &#123; /* 忽略错误，继续执行 */ &#125;).then(function() &#123; return ret; &#125;);&#125; 虽然 Promise 的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是 Promise 的 API（then、catch等等），操作本身的语义反而不容易看出来。 接着是 Generator 函数的写法。123456789101112131415function chainAnimationsGenerator(elem, animations) &#123; return spawn(function*() &#123; let ret = null; try &#123; for(let anim of animations) &#123; ret = yield anim(elem); &#125; &#125; catch(e) &#123; /* 忽略错误，继续执行 */ &#125; return ret; &#125;);&#125; 上面代码使用 Generator 函数遍历了每个动画，语义比 Promise 写法更清晰，用户定义的操作全部都出现在spawn函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行 Generator 函数，上面代码的spawn函数就是自动执行器，它返回一个 Promise 对象，而且必须保证yield语句后面的表达式，必须返回一个 Promise。 最后是 async 函数的写法。1234567891011async function chainAnimationsAsync(elem, animations) &#123; let ret = null; try &#123; for(let anim of animations) &#123; ret = await anim(elem); &#125; &#125; catch(e) &#123; /* 忽略错误，继续执行 */ &#125; return ret;&#125; 可以看到Async函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将Generator写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用Generator写法，自动执行器需要用户自己提供。 实例：按顺序完成异步操作实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组 URL，然后按照读取的顺序输出结果。 Promise 的写法如下。 123456789101112function logInOrder(urls) &#123; // 远程读取所有URL const textPromises = urls.map(url =&gt; &#123; return fetch(url).then(response =&gt; response.text()); &#125;); // 按次序输出 textPromises.reduce((chain, textPromise) =&gt; &#123; return chain.then(() =&gt; textPromise) .then(text =&gt; console.log(text)); &#125;, Promise.resolve());&#125; 上面代码使用fetch方法，同时远程读取一组 URL。每个fetch操作都返回一个 Promise 对象，放入textPromises数组。然后，reduce方法依次处理每个 Promise 对象，然后使用then，将所有 Promise 对象连起来，因此就可以依次输出结果。 这种写法不太直观，可读性比较差。下面是 async 函数实现。 123456async function logInOrder(urls) &#123; for (const url of urls) &#123; const response = await fetch(url); console.log(await response.text()); &#125;&#125; 上面代码确实大大简化，问题是所有远程操作都是继发。只有前一个URL返回结果，才会去读取下一个URL，这样做效率很差，非常浪费时间。我们需要的是并发发出远程请求。 123456789101112async function logInOrder(urls) &#123; // 并发读取远程URL const textPromises = urls.map(async url =&gt; &#123; const response = await fetch(url); return response.text(); &#125;); // 按次序输出 for (const textPromise of textPromises) &#123; console.log(await textPromise); &#125;&#125; 上面代码中，虽然map方法的参数是async函数，但它是并发执行的，因为只有async函数内部是继发执行，外部不受影响。后面的for..of循环内部使用了await，因此实现了按顺序输出。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>async</tag>
      </tags>
  </entry>
</search>
