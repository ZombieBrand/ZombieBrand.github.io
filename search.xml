<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[标签模版过滤防止恶意代码嵌入]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F14%2F%E6%A0%87%E7%AD%BE%E6%A8%A1%E7%89%88%E8%BF%87%E6%BB%A4%E9%98%B2%E6%AD%A2%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%B5%8C%E5%85%A5%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920function SaferHTML(templateData) &#123; let s = templateData[0]; for (let i = 1; i &lt; arguments.length; i++) &#123; let arg = String(arguments[i]); // Escape special characters in the substitution. s += arg.replace(/&amp;/g, "&amp;amp;") .replace(/&lt;/g, "&amp;lt;") .replace(/&gt;/g, "&amp;gt;"); // Don't escape special characters in the template. s += templateData[i]; &#125; return s;&#125;let sender = '&lt;script&gt;alert("abc")&lt;/script&gt;'; // 恶意代码let message = SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;message"&lt;p&gt;&amp;lt;script&amp;gt;alert("abc")&amp;lt;/script&amp;gt; has sent you a message.&lt;/p&gt;"]]></content>
      <categories>
        <category>JavaScript</category>
        <category>安全</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[let和const命令]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F14%2Flet%E5%92%8Cconst%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ES6中对JS的扩展]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F14%2FES6%E4%B8%AD%E5%AF%B9JS%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ES6-异步]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F14%2FES6-%E5%BC%82%E6%AD%A5%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ES6-Symbol]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F14%2FES6-Symbol%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ES6-Set-Map]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F14%2FES6-Set-Map%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ES6 Proxy&Reflect]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F14%2FES6-Proxy-Reflect%2F</url>
    <content type="text"><![CDATA[Proxy概述Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。 Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。 Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。 ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。 1var proxy = new Proxy(target, handler); Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。 1234567891011下面是另一个拦截读取属性行为的例子。var proxy = new Proxy(&#123;&#125;, &#123; get: function(target, property) &#123; return 35; &#125;&#125;);proxy.time // 35proxy.name // 35proxy.title // 35 上面代码中，作为构造函数，Proxy接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有Proxy的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个get方法，用来拦截对目标对象属性的访问请求。get方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回35，所以访问任何属性都得到35。 注意，要使得Proxy起作用，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。 如果handler没有设置任何拦截，那就等同于直接通向原对象。 一个技巧是将 Proxy 对象，设置到object.proxy属性，从而可以在object对象上调用。 1var object = &#123; proxy: new Proxy(target, handler) &#125;; Proxy 实例也可以作为其他对象的原型对象。 12345678var proxy = new Proxy(&#123;&#125;, &#123; get: function(target, property) &#123; return 35; &#125;&#125;);let obj = Object.create(proxy);obj.time // 35 同一个拦截器函数，可以设置拦截多个操作。 Proxy 支持的拦截操作一览。对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。 （1）get(target, propKey, receiver) 拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]。 最后一个参数receiver是一个对象，可选，参见下面Reflect.get的部分。 （2）set(target, propKey, value, receiver) 拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值。 （3）has(target, propKey) 拦截propKey in proxy的操作，返回一个布尔值。 （4）deleteProperty(target, propKey) 拦截delete proxy[propKey]的操作，返回一个布尔值。 （5）ownKeys(target) 拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。 （6）getOwnPropertyDescriptor(target, propKey) 拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。 （7）defineProperty(target, propKey, propDesc) 拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。 （8）preventExtensions(target) 拦截Object.preventExtensions(proxy)，返回一个布尔值。 （9）getPrototypeOf(target) 拦截Object.getPrototypeOf(proxy)，返回一个对象。 （10）isExtensible(target) 拦截Object.isExtensible(proxy)，返回一个布尔值。 （11）setPrototypeOf(target, proto) 拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。 如果目标对象是函数，那么还有两种额外操作可以拦截。 （12）apply(target, object, args) 拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。 （13）construct(target, args) 拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。 Proxy 实例的方法下面是上面这些拦截方法的详细介绍。 get()get方法用于拦截某个属性的读取操作。上文已经有一个例子，下面是另一个拦截读取操作的例子。 12345678910111213141516var person = &#123; name: "张三"&#125;;var proxy = new Proxy(person, &#123; get: function(target, property) &#123; if (property in target) &#123; return target[property]; &#125; else &#123; throw new ReferenceError("Property \"" + property + "\" does not exist."); &#125; &#125;&#125;);proxy.name // "张三"proxy.age // 抛出一个错误 上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回undefined。 get方法可以继承。 123456789let proto = new Proxy(&#123;&#125;, &#123; get(target, propertyKey, receiver) &#123; console.log('GET '+propertyKey); return target[propertyKey]; &#125;&#125;);let obj = Object.create(proto);obj.xxx // "GET xxx" 上面代码中，拦截操作定义在Prototype对象上面，所以如果读取obj对象继承的属性时，拦截会生效。 如果一个属性不可配置（configurable）和不可写（writable），则该属性不能被代理，通过 Proxy 对象访问该属性会报错。 set()set方法用来拦截某个属性的赋值操作。 假定Person对象有一个age属性，该属性应该是一个不大于200的整数，那么可以使用Proxy保证age的属性值符合要求。 1234567891011121314151617181920212223let validator = &#123; set: function(obj, prop, value) &#123; if (prop === 'age') &#123; if (!Number.isInteger(value)) &#123; throw new TypeError('The age is not an integer'); &#125; if (value &gt; 200) &#123; throw new RangeError('The age seems invalid'); &#125; &#125; // 对于age以外的属性，直接保存 obj[prop] = value; &#125;&#125;;let person = new Proxy(&#123;&#125;, validator);person.age = 100;person.age // 100person.age = 'young' // 报错person.age = 300 // 报错 上面代码中，由于设置了存值函数set，任何不符合要求的age属性赋值，都会抛出一个错误，这是数据验证的一种实现方法。利用set方法，还可以数据绑定，即每当对象发生变化时，会自动更新 DOM。 有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合get和set方法，就可以做到防止这些内部属性被外部读写。 12345678910111213141516171819202122var handler = &#123; get (target, key) &#123; invariant(key, 'get'); return target[key]; &#125;, set (target, key, value) &#123; invariant(key, 'set'); target[key] = value; return true; &#125;&#125;;function invariant (key, action) &#123; if (key[0] === '_') &#123; throw new Error(`Invalid attempt to $&#123;action&#125; private "$&#123;key&#125;" property`); &#125;&#125;var target = &#123;&#125;;var proxy = new Proxy(target, handler);proxy._prop// Error: Invalid attempt to get private "_prop" propertyproxy._prop = 'c'// Error: Invalid attempt to set private "_prop" property 上面代码中，只要读写的属性名的第一个字符是下划线，一律抛错，从而达到禁止读写内部属性的目的。 注意，如果目标对象自身的某个属性，不可写也不可配置，那么set不得改变这个属性的值，只能返回同样的值，否则报错。 apply()apply方法拦截函数的调用、call和apply操作。 apply方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组。 12345var handler = &#123; apply (target, ctx, args) &#123; return Reflect.apply(...arguments); &#125;&#125;; 另外，直接调用Reflect.apply方法，也会被拦截。 1Reflect.apply(proxy, null, [9, 10]) // 38 has()has方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符。 下面的例子使用has方法隐藏某些属性，不被in运算符发现。 1234567891011var handler = &#123; has (target, key) &#123; if (key[0] === '_') &#123; return false; &#125; return key in target; &#125;&#125;;var target = &#123; _prop: 'foo', prop: 'foo' &#125;;var proxy = new Proxy(target, handler);'_prop' in proxy // false 如果原对象不可配置或者禁止扩展，这时has拦截会报错。 值得注意的是，has方法拦截的是HasProperty操作，而不是HasOwnProperty操作，即has方法不判断一个属性是对象自身的属性，还是继承的属性。 另外，虽然for…in循环也用到了in运算符，但是has拦截对for…in循环不生效。 construct()construct方法用于拦截new命令，下面是拦截对象的写法。 12345var handler = &#123; construct (target, args, newTarget) &#123; return new target(...args); &#125;&#125;; construct方法可以接受两个参数。 target: 目标对象 args：构建函数的参数对象 construct方法返回的必须是一个对象，否则会报错。 deleteProperty()deleteProperty方法用于拦截delete操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除。 注意，目标对象自身的不可配置（configurable）的属性，不能被deleteProperty方法删除，否则报错 defineProperty()defineProperty方法拦截了Object.defineProperty操作。 getOwnPropertyDescriptor()getOwnPropertyDescriptor方法拦截Object.getOwnPropertyDescriptor()，返回一个属性描述对象或者undefined。 getPrototypeOf()getPrototypeOf方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作。 Object.prototype.[object Object] Object.prototype.isPrototypeOf() Object.getPrototypeOf() Reflect.getPrototypeOf() instanceof 注意，getPrototypeOf方法的返回值必须是对象或者null，否则报错。另外，如果目标对象不可扩展（extensible）， getPrototypeOf方法必须返回目标对象的原型对象。 isExtensible()isExtensible方法拦截Object.isExtensible操作。 12345678910var p = new Proxy(&#123;&#125;, &#123; isExtensible: function(target) &#123; console.log("called"); return true; &#125;&#125;);Object.isExtensible(p)// "called"// true 上面代码设置了isExtensible方法，在调用Object.isExtensible时会输出called。 注意，该方法只能返回布尔值，否则返回值会被自动转为布尔值。 这个方法有一个强限制，它的返回值必须与目标对象的isExtensible属性保持一致，否则就会抛出错误。 ownKeys()ownKeys方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。 Object.getOwnPropertyNames() Object.getOwnPropertySymbols() Object.keys() 注意，使用Object.keys方法时，有三类属性会被ownKeys方法自动过滤，不会返回。 目标对象上不存在的属性 属性名为 Symbol 值 不可遍历（enumerable）的属性 preventExtensions()preventExtensions方法拦截Object.preventExtensions()。该方法必须返回一个布尔值，否则会被自动转为布尔值。 这个方法有一个限制，只有目标对象不可扩展时（即Object.isExtensible(proxy)为false），proxy.preventExtensions才能返回true，否则会报错。 1234567var p = new Proxy(&#123;&#125;, &#123; preventExtensions: function(target) &#123; return true; &#125;&#125;);Object.preventExtensions(p) // 报错 上面代码中，proxy.preventExtensions方法返回true，但这时Object.isExtensible(proxy)会返回true，因此报错。 为了防止出现这个问题，通常要在proxy.preventExtensions方法里面，调用一次Object.preventExtensions。 setPrototypeOf()setPrototypeOf方法主要用来拦截Object.setPrototypeOf方法。 注意，该方法只能返回布尔值，否则会被自动转为布尔值。另外，如果目标对象不可扩展（extensible），setPrototypeOf方法不得改变目标对象的原型。 Proxy.revocable()Proxy.revocable方法返回一个可取消的 Proxy 实例。 12345678910let target = &#123;&#125;;let handler = &#123;&#125;;let &#123;proxy, revoke&#125; = Proxy.revocable(target, handler);proxy.foo = 123;proxy.foo // 123revoke();proxy.foo // TypeError: Revoked Proxy.revocable方法返回一个对象，该对象的proxy属性是Proxy实例，revoke属性是一个函数，可以取消Proxy实例。上面代码中，当执行revoke函数之后，再访问Proxy实例，就会抛出一个错误。 Proxy.revocable的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。 this 问题虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理。 1234567891011const target = &#123; m: function () &#123; console.log(this === proxy); &#125;&#125;;const handler = &#123;&#125;;const proxy = new Proxy(target, handler);target.m() // falseproxy.m() // true 上面代码中，一旦proxy代理target.m，后者内部的this就是指向proxy，而不是target。 由于this指向的变化，有些情况会导致 Proxy 无法代理目标对象。 此外，有些原生对象的内部属性，只有通过正确的this才能拿到，所以 Proxy 也无法代理这些原生对象的属性。 实例：Web 服务的客户端Proxy 对象可以拦截目标对象的任意属性，这使得它很合适用来写 Web 服务的客户端。 123456const service = createWebService('http://example.com/data');service.employees().then(json =&gt; &#123; const employees = JSON.parse(json); // ···&#125;); 上面代码新建了一个 Web 服务的接口，这个接口返回各种数据。Proxy 可以拦截这个对象的任意属性，所以不用为每一种数据写一个适配方法，只要写一个 Proxy 拦截就可以了。 1234567function createWebService(baseUrl) &#123; return new Proxy(&#123;&#125;, &#123; get(target, propKey, receiver) &#123; return () =&gt; httpGet(baseUrl+'/' + propKey); &#125; &#125;);&#125; 同理，Proxy 也可以用来实现数据库的 ORM 层。 Reflect概述Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect对象的设计目的有这样几个。 （1） 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。 （2） 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。 1234567891011121314// 老写法try &#123; Object.defineProperty(target, property, attributes); // success&#125; catch (e) &#123; // failure&#125;// 新写法if (Reflect.defineProperty(target, property, attributes)) &#123; // success&#125; else &#123; // failure&#125; （3） 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。 12345// 老写法'assign' in Object // true// 新写法Reflect.has(Object, 'assign') // true （4）Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。 123456789Proxy(target, &#123; set: function(target, name, value, receiver) &#123; var success = Reflect.set(target,name, value, receiver); if (success) &#123; log('property ' + name + ' on ' + target + ' set to ' + value); &#125; return success; &#125;&#125;); 上面代码中，Proxy方法拦截target对象的属性赋值行为。它采用Reflect.set方法将值赋值给对象的属性，确保完成原有的行为，然后再部署额外的功能。 下面是另一个例子。 1234567891011121314var loggedObj = new Proxy(obj, &#123; get(target, name) &#123; console.log('get', target, name); return Reflect.get(target, name); &#125;, deleteProperty(target, name) &#123; console.log('delete' + name); return Reflect.deleteProperty(target, name); &#125;, has(target, name) &#123; console.log('has' + name); return Reflect.has(target, name); &#125;&#125;); 上面代码中，每一个Proxy对象的拦截操作（get、delete、has），内部都调用对应的Reflect方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。 有了Reflect对象以后，很多操作会更易读。 12345// 老写法Function.prototype.apply.call(Math.floor, undefined, [1.75]) // 1// 新写法Reflect.apply(Math.floor, undefined, [1.75]) // 1 静态方法Reflect对象一共有13个静态方法。 Reflect.apply(target,thisArg,args) Reflect.construct(target,args) Reflect.get(target,name,receiver) Reflect.set(target,name,value,receiver) Reflect.defineProperty(target,name,desc) Reflect.deleteProperty(target,name) Reflect.has(target,name) Reflect.ownKeys(target) Reflect.isExtensible(target) Reflect.preventExtensions(target) Reflect.getOwnPropertyDescriptor(target, name) Reflect.getPrototypeOf(target) Reflect.setPrototypeOf(target, prototype) 上面这些方法的作用，大部分与Object对象的同名方法的作用都是相同的，而且它与Proxy对象的方法是一一对应的。下面是对它们的解释。 Reflect.get(target, name, receiver)Reflect.get方法查找并返回target对象的name属性，如果没有该属性，则返回undefined。 1234567891011var myObject = &#123; foo: 1, bar: 2, get baz() &#123; return this.foo + this.bar; &#125;,&#125;Reflect.get(myObject, 'foo') // 1Reflect.get(myObject, 'bar') // 2Reflect.get(myObject, 'baz') // 3 如果name属性部署了读取函数（getter），则读取函数的this绑定receiver。 1234567891011121314var myObject = &#123; foo: 1, bar: 2, get baz() &#123; return this.foo + this.bar; &#125;,&#125;;var myReceiverObject = &#123; foo: 4, bar: 4,&#125;;Reflect.get(myObject, 'baz', myReceiverObject) // 8 如果第一个参数不是对象，Reflect.get方法会报错。 12Reflect.get(1, 'foo') // 报错Reflect.get(false, 'foo') // 报错 Reflect.set(target, name, value, receiver)Reflect.set方法设置target对象的name属性等于value。 如果name属性设置了赋值函数，则赋值函数的this绑定receiver。 1234567891011121314var myObject = &#123; foo: 4, set bar(value) &#123; return this.foo = value; &#125;,&#125;;var myReceiverObject = &#123; foo: 0,&#125;;Reflect.set(myObject, 'bar', 1, myReceiverObject);myObject.foo // 4myReceiverObject.foo // 1 如果第一个参数不是对象，Reflect.set会报错。 注意，Reflect.set会触发Proxy.defineProperty拦截 Reflect.has(obj, name)Reflect.has方法对应name in obj里面的in运算符。 123456789var myObject = &#123; foo: 1,&#125;;// 旧写法'foo' in myObject // true// 新写法Reflect.has(myObject, 'foo') // true 如果第一个参数不是对象，Reflect.has和in运算符都会报错。 Reflect.deleteProperty(obj, name)Reflect.deleteProperty方法等同于delete obj[name]，用于删除对象的属性。 1234567const myObj = &#123; foo: 'bar' &#125;;// 旧写法delete myObj.foo;// 新写法Reflect.deleteProperty(myObj, 'foo'); 该方法返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回true；删除失败，被删除的属性依然存在，返回false。 Reflect.construct(target, args)Reflect.construct方法等同于new target(…args)，这提供了一种不使用new，来调用构造函数的方法。 123456789function Greeting(name) &#123; this.name = name;&#125;// new 的写法const instance = new Greeting('张三');// Reflect.construct 的写法const instance = Reflect.construct(Greeting, ['张三']); Reflect.getPrototypeOf(obj)Reflect.getPrototypeOf方法用于读取对象的[object Object]属性，对应Object.getPrototypeOf(obj)。 1234567const myObj = new FancyThing();// 旧写法Object.getPrototypeOf(myObj) === FancyThing.prototype;// 新写法Reflect.getPrototypeOf(myObj) === FancyThing.prototype; Reflect.getPrototypeOf和Object.getPrototypeOf的一个区别是： 如果参数不是对象，Object.getPrototypeOf会将这个参数转为对象，然后再运行，而Reflect.getPrototypeOf会报错。 Reflect.setPrototypeOf(obj, newProto)Reflect.setPrototypeOf方法用于设置对象的[object Object]属性，返回第一个参数对象，对应Object.setPrototypeOf(obj, newProto)。 Reflect.apply(func, thisArg, args)Reflect.apply方法等同于Function.prototype.apply.call(func, thisArg, args)，用于绑定this对象后执行给定函数。 一般来说，如果要绑定一个函数的this对象，可以这样写fn.apply(obj, args)，但是如果函数定义了自己的apply方法，就只能写成Function.prototype.apply.call(fn, obj, args)，采用Reflect对象可以简化这种操作。 1234567891011const ages = [11, 33, 12, 54, 18, 96];// 旧写法const youngest = Math.min.apply(Math, ages);const oldest = Math.max.apply(Math, ages);const type = Object.prototype.toString.call(youngest);// 新写法const youngest = Reflect.apply(Math.min, Math, ages);const oldest = Reflect.apply(Math.max, Math, ages);const type = Reflect.apply(Object.prototype.toString, youngest, []); Reflect.defineProperty(target, propertyKey, attributes)Reflect.defineProperty方法基本等同于Object.defineProperty，用来为对象定义属性。未来，后者会被逐渐废除，请从现在开始就使用Reflect.defineProperty代替它。 12345678910111213function MyDate() &#123; /*…*/&#125;// 旧写法Object.defineProperty(MyDate, 'now', &#123; value: () =&gt; Date.now()&#125;);// 新写法Reflect.defineProperty(MyDate, 'now', &#123; value: () =&gt; Date.now()&#125;); 如果Reflect.defineProperty的第一个参数不是对象，就会抛出错误，比如Reflect.defineProperty(1, ‘foo’)。 Reflect.getOwnPropertyDescriptor(target, propertyKey)Reflect.getOwnPropertyDescriptor基本等同于Object.getOwnPropertyDescriptor，用于得到指定属性的描述对象，将来会替代掉后者。 Reflect.isExtensible (target)Reflect.isExtensible方法对应Object.isExtensible，返回一个布尔值，表示当前对象是否可扩展。 1234567const myObject = &#123;&#125;;// 旧写法Object.isExtensible(myObject) // true// 新写法Reflect.isExtensible(myObject) // true Reflect.preventExtensions(target)Reflect.preventExtensions对应Object.preventExtensions方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。 1234567var myObject = &#123;&#125;;// 旧写法Object.preventExtensions(myObject) // Object &#123;&#125;// 新写法Reflect.preventExtensions(myObject) // true 如果参数不是对象，Object.preventExtensions在 ES5 环境报错，在 ES6 环境返回传入的参数，而Reflect.preventExtensions会报错。 12345678// ES5 环境Object.preventExtensions(1) // 报错// ES6 环境Object.preventExtensions(1) // 1// 新写法Reflect.preventExtensions(1) // 报错 Reflect.ownKeys (target)Reflect.ownKeys方法用于返回对象的所有属性，基本等同于Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和。 1234567891011121314151617var myObject = &#123; foo: 1, bar: 2, [Symbol.for('baz')]: 3, [Symbol.for('bing')]: 4,&#125;;// 旧写法Object.getOwnPropertyNames(myObject)// ['foo', 'bar']Object.getOwnPropertySymbols(myObject)//[Symbol(baz), Symbol(bing)]// 新写法Reflect.ownKeys(myObject)// ['foo', 'bar', Symbol(baz), Symbol(bing)] 实例：使用 Proxy 实现观察者模式观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。 12345678910111213const person = observable(&#123; name: '张三', age: 20&#125;);function print() &#123; console.log(`$&#123;person.name&#125;, $&#123;person.age&#125;`)&#125;observe(print);person.name = '李四';// 输出// 李四, 20 上面代码中，数据对象person是观察目标，函数print是观察者。一旦数据对象发生变化，print就会自动执行。 下面，使用 Proxy 写一个观察者模式的最简单实现，即实现observable和observe这两个函数。思路是observable函数返回一个原始对象的 Proxy 代理，拦截赋值操作，触发充当观察者的各个函数。 12345678910const queuedObservers = new Set();const observe = fn =&gt; queuedObservers.add(fn);const observable = obj =&gt; new Proxy(obj, &#123;set&#125;);function set(target, key, value, receiver) &#123; const result = Reflect.set(target, key, value, receiver); queuedObservers.forEach(observer =&gt; observer()); return result;&#125; 上面代码中，先定义了一个Set集合，所有观察者函数都放进这个集合。然后，observable函数返回原始对象的代理，拦截赋值操作。拦截函数set之中，会自动执行所有观察者。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>Proxy</tag>
        <tag>Reflect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6-Promise]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F14%2FES6-Promise%2F</url>
    <content type="text"><![CDATA[Promise 的含义Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 Promise对象有以下两个特点。One：对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态： pending（进行中） fulfilled（已成功） rejected（已失败） 只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 Two：一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 注意，为了行文方便，本章后面的resolved统一只指fulfilled状态，不包含rejected状态。 有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。 Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 如果某些事件不断地反复发生，一般来说，使用 Stream 模式是比部署Promise更好的选择。 基本用法ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。 下面代码创造了一个Promise实例。 123456789var promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。 resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去； reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。 12345promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;); then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。 Promise 新建后就会立即执行。1234567891011121314let promise = new Promise(function(resolve, reject) &#123; console.log('Promise'); resolve();&#125;);promise.then(function() &#123; console.log('resolved.');&#125;);console.log('Hi!');// Promise// Hi!// resolved 上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。 如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例 12345678var p1 = new Promise(function (resolve, reject) &#123; // ...&#125;);var p2 = new Promise(function (resolve, reject) &#123; // ... resolve(p1);&#125;) 上面代码中，p1和p2都是 Promise 的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。 注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。 注意，调用resolve或reject并不会终结 Promise 的参数函数的执行。 12345678new Promise((resolve, reject) =&gt; &#123; resolve(1); console.log(2);&#125;).then(r =&gt; &#123; console.log(r);&#125;);// 2// 1 上面代码中，调用resolve(1)以后，后面的console.log(2)还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。 一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。 12345new Promise((resolve, reject) =&gt; &#123; return resolve(1); // 后面的语句不会执行 console.log(2);&#125;) Promise.prototype.then()Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。 then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。 采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。 1234567getJSON("/post/1.json").then(function (post) &#123; return getJSON(post.commentURL);&#125;).then(function funcA(comments) &#123; console.log("resolved: ", comments);&#125;, function funcB(err) &#123; console.log("rejected: ", err);&#125;); 上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为resolved，就调用funcA，如果状态变为rejected，就调用funcB。 也可以使用箭头函数，上面的代码将更简洁。 Promise.prototype.catch()Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。 123456p.then((val) =&gt; console.log('fulfilled:', val)) .catch((err) =&gt; console.log('rejected', err));// 等同于p.then((val) =&gt; console.log('fulfilled:', val)) .then(null, (err) =&gt; console.log("rejected:", err)); 如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。 如果Promise状态已经变成resolved，再抛出错误是无效的。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。 Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。 一般来说，不要在then方法里面定义Reject状态的回调函数（即then的第二个参数），总是使用catch方法。 12345678910111213141516// badpromise .then(function(data) &#123; // success &#125;, function(err) &#123; // error &#125;);// goodpromise .then(function(data) &#123; //cb // success &#125;) .catch(function(err) &#123; // error &#125;); 上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch）。因此，建议总是使用catch方法，而不使用then方法的第二个参数。 跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。 一般总是建议，Promise 对象后面要跟catch方法，这样可以处理 Promise 内部发生的错误。catch方法返回的还是一个 Promise 对象，因此后面还可以接着调用then方法。 Promise.all()Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。 1var p = Promise.all([p1, p2, p3]); Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。） p的状态由p1、p2、p3决定，分成两种情况。 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。 12345678910111213141516const p1 = new Promise((resolve, reject) =&gt; &#123; resolve('hello');&#125;).then(result =&gt; result).catch(e =&gt; e);const p2 = new Promise((resolve, reject) =&gt; &#123; throw new Error('报错了');&#125;).then(result =&gt; result).catch(e =&gt; e);Promise.all([p1, p2]).then(result =&gt; console.log(result)).catch(e =&gt; console.log(e));// ["hello", Error: 报错了] 上面代码中，p1会resolved，p2首先会rejected，但是p2有自己的catch方法，该方法返回的是一个新的 Promise 实例，p2指向的实际上是这个实例。该实例执行完catch方法后，也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved，因此会调用then方法指定的回调函数，而不会调用catch方法指定的回调函数。 如果p2没有自己的catch方法，就会调用Promise.all()的catch方法。 1234567891011121314const p1 = new Promise((resolve, reject) =&gt; &#123; resolve('hello');&#125;).then(result =&gt; result);const p2 = new Promise((resolve, reject) =&gt; &#123; throw new Error('报错了');&#125;).then(result =&gt; result);Promise.all([p1, p2]).then(result =&gt; console.log(result)).catch(e =&gt; console.log(e));// Error: 报错了 Promise.race()Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。 1var p = Promise.race([p1, p2, p3]); 只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。 Promise.race方法的参数与Promise.all方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。 Promise.resolve()有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。 1var jsPromise = Promise.resolve($.ajax('/whatever.json')); 上面代码将jQuery生成的deferred对象，转为一个新的Promise对象。 Promise.resolve方法的参数分成四种情况。 参数是一个Promise实例 如果参数是Promise实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。 参数是一个thenable对象thenable对象指的是具有then方法的对象，比如下面这个对象。 12345let thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;; Promise.resolve方法会将这个对象转为Promise对象，然后就立即执行thenable对象的then方法。 12345678910let thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;;let p1 = Promise.resolve(thenable);p1.then(function(value) &#123; console.log(value); // 42&#125;); 上面代码中，thenable对象的then方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then方法指定的回调函数，输出42。 参数不是具有then方法的对象，或根本就不是对象 如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为resolved。 123456var p = Promise.resolve('Hello');p.then(function (s)&#123; console.log(s)&#125;);// Hello 上面代码生成一个新的Promise对象的实例p。由于字符串Hello不属于异步操作（判断方法是字符串对象不具有then方法），返回Promise实例的状态从一生成就是resolved，所以回调函数会立即执行。Promise.resolve方法的参数，会同时传给回调函数。 不带有任何参数Promise.resolve方法允许调用时不带参数，直接返回一个resolved状态的Promise对象。所以，如果希望得到一个Promise对象，比较方便的方法就是直接调用Promise.resolve方法。 需要注意的是，立即resolve的Promise对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时。 12345678910111213setTimeout(function () &#123; console.log('three');&#125;, 0);Promise.resolve().then(function () &#123; console.log('two');&#125;);console.log('one');// one// two// three 上面代码中，setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.resolve()在本轮“事件循环”结束时执行，console.log(‘one’)则是立即执行，因此最先输出。 Promise.reject()Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。 12345678var p = Promise.reject('出错了');// 等同于var p = new Promise((resolve, reject) =&gt; reject('出错了'))p.then(null, function (s) &#123; console.log(s)&#125;);// 出错了 上面代码生成一个Promise对象的实例p，状态为rejected，回调函数会立即执行。 注意，Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。这一点与Promise.resolve方法不一致。 1234567891011const thenable = &#123; then(resolve, reject) &#123; reject('出错了'); &#125;&#125;;Promise.reject(thenable).catch(e =&gt; &#123; console.log(e === thenable)&#125;)// true 上面代码中，Promise.reject方法的参数是一个thenable对象，执行以后，后面catch方法的参数不是reject抛出的“出错了”这个字符串，而是thenable对象。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6-Iterator遍历器的概念]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F14%2FES6-Iterator%E9%81%8D%E5%8E%86%E5%99%A8%E7%9A%84%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[Iterator（遍历器）的概念JavaScript 原有的表示“集合”的数据结构，主要是数组（Array）和对象（Object），ES6 又添加了Map和Set。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是Map，Map的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。 遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。 Iterator 的作用有三个： 为各种数据结构，提供一个统一的、简便的访问接口； 使得数据结构的成员能够按某种次序排列； ES6创造了一种新的遍历命令for…of循环，Iterator接口主要供for…of使用。 Iterator 的遍历过程是这样的。 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。 第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。 第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。 不断调用指针对象的next方法，直到它指向数据结构的结束位置。 每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。 下面是一个模拟next方法返回值的例子。 12345678910111213141516var it = makeIterator(['a', 'b']);it.next() // &#123; value: "a", done: false &#125;it.next() // &#123; value: "b", done: false &#125;it.next() // &#123; value: undefined, done: true &#125;function makeIterator(array) &#123; var nextIndex = 0; return &#123; next: function() &#123; return nextIndex &lt; array.length ? &#123;value: array[nextIndex++], done: false&#125; : &#123;value: undefined, done: true&#125;; &#125; &#125;;&#125; 上面代码定义了一个makeIterator函数，它是一个遍历器生成函数，作用就是返回一个遍历器对象。对数组[‘a’, ‘b’]执行这个函数，就会返回该数组的遍历器对象（即指针对象）it。 指针对象的next方法，用来移动指针。开始时，指针指向数组的开始位置。然后，每次调用next方法，指针就会指向数组的下一个成员。第一次调用，指向a；第二次调用，指向b。 next方法返回一个对象，表示当前数据成员的信息。这个对象具有value和done两个属性，value属性返回当前位置的成员，done属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用next方法。 总之，调用指针对象的next方法，就可以遍历事先给定的数据结构。 对于遍历器对象来说，done: false和value: undefined属性都是可以省略的，因此上面的makeIterator函数可以简写成下面的形式。 12345678910function makeIterator(array) &#123; var nextIndex = 0; return &#123; next: function() &#123; return nextIndex &lt; array.length ? &#123;value: array[nextIndex++]&#125; : &#123;done: true&#125;; &#125; &#125;;&#125; 由于 Iterator 只是把接口规格加到数据结构之上，所以，遍历器与它所遍历的那个数据结构，实际上是分开的，完全可以写出没有对应数据结构的遍历器对象，或者说用遍历器对象模拟出数据结构。下面是一个无限运行的遍历器对象的例子。 12345678910111213141516var it = idMaker();it.next().value // '0'it.next().value // '1'it.next().value // '2'// ...function idMaker() &#123; var index = 0; return &#123; next: function() &#123; return &#123;value: index++, done: false&#125;; &#125; &#125;;&#125; 上面的例子中，遍历器生成函数idMaker，返回一个遍历器对象（即指针对象）。但是并没有对应的数据结构，或者说，遍历器对象自己描述了一个数据结构出来。 如果使用 TypeScript 的写法，遍历器接口（Iterable）、指针对象（Iterator）和next方法返回值的规格可以描述如下。 123456789101112interface Iterable &#123; [Symbol.iterator]() : Iterator,&#125;interface Iterator &#123; next(value?: any) : IterationResult,&#125;interface IterationResult &#123; value: any, done: boolean,&#125; 默认 Iterator 接口一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是”可遍历的“（iterable）。 ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。至于属性名Symbol.iterator，它是一个表达式，返回Symbol对象的iterator属性，这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内（参见 Symbol 一章）。 123456789101112const obj = &#123; [Symbol.iterator] : function () &#123; return &#123; next: function () &#123; return &#123; value: 1, done: true &#125;; &#125; &#125;; &#125;&#125;; 上面代码中，对象obj是可遍历的（iterable），因为具有Symbol.iterator属性。执行这个属性，会返回一个遍历器对象。该对象的根本特征就是具有next方法。每次调用next方法，都会返回一个代表当前成员的信息对象，具有value和done两个属性。 ES6 的有些数据结构原生具备 Iterator 接口（比如数组），即不用任何处理，就可以被for…of循环遍历。原因在于，这些数据结构原生部署了Symbol.iterator属性（详见下文），另外一些数据结构没有（比如对象）。凡是部署了Symbol.iterator属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。 原生具备 Iterator 接口的数据结构如下。 Array Map Set String TypedArray 函数的 arguments 对象 NodeList 对象 对于原生部署 Iterator 接口的数据结构，不用自己写遍历器生成函数，for…of循环会自动遍历它们。除此之外，其他数据结构（主要是对象）的 Iterator 接口，都需要自己在Symbol.iterator属性上面部署，这样才会被for…of循环遍历。 对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作 Map 结构使用，ES5 没有 Map 结构，而 ES6 原生提供了。 下面的例子是数组的Symbol.iterator属性。 1234567let arr = ['a', 'b', 'c'];let iter = arr[Symbol.iterator]();iter.next() // &#123; value: 'a', done: false &#125;iter.next() // &#123; value: 'b', done: false &#125;iter.next() // &#123; value: 'c', done: false &#125;iter.next() // &#123; value: undefined, done: true &#125; 上面代码中，变量arr是一个数组，原生就具有遍历器接口，部署在arr的Symbol.iterator属性上面。所以，调用这个属性，就得到遍历器对象。 调用 Iterator 接口的场合有一些场合会默认调用 Iterator 接口（即Symbol.iterator方法），除了下文会介绍的for…of循环，还有几个别的场合。 1. 解构赋值对数组和 Set 结构进行解构赋值时，会默认调用Symbol.iterator方法。 1234567let set = new Set().add('a').add('b').add('c');let [x,y] = set;// x='a'; y='b'let [first, ...rest] = set;// first='a'; rest=['b','c']; 2. 扩展运算符扩展运算符（…）也会调用默认的 Iterator 接口。 12345678// 例一var str = 'hello';[...str] // ['h','e','l','l','o']// 例二let arr = ['b', 'c'];['a', ...arr, 'd']// ['a', 'b', 'c', 'd'] 上面代码的扩展运算符内部就调用 Iterator 接口。 实际上，这提供了一种简便机制，可以将任何部署了 Iterator 接口的数据结构，转为数组。也就是说，只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。 3. yield*yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。 1234567891011121314let generator = function* () &#123; yield 1; yield* [2,3,4]; yield 5;&#125;;var iterator = generator();iterator.next() // &#123; value: 1, done: false &#125;iterator.next() // &#123; value: 2, done: false &#125;iterator.next() // &#123; value: 3, done: false &#125;iterator.next() // &#123; value: 4, done: false &#125;iterator.next() // &#123; value: 5, done: false &#125;iterator.next() // &#123; value: undefined, done: true &#125; 4. 其他场合由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。 下面是一些例子。 for…of Array.from() Map(), Set(), WeakMap(), WeakSet()（比如new Map([[‘a’,1],[‘b’,2]])） Promise.all() Promise.race() Iterator接口与Generator函数Symbol.iterator方法的最简单实现，还是使用下一章要介绍的Generator函数。1234567891011121314151617181920212223var myIterable = &#123;&#125;;myIterable[Symbol.iterator] = function* () &#123; yield 1; yield 2; yield 3;&#125;;[...myIterable] // [1, 2, 3]// 或者采用下面的简洁写法let obj = &#123; * [Symbol.iterator]() &#123; yield 'hello'; yield 'world'; &#125;&#125;;for (let x of obj) &#123; console.log(x);&#125;// hello// world 上面代码中，Symbol.iterator方法几乎不用部署任何代码，只要用yield命令给出每一步的返回值即可。 遍历器对象的return()，throw()遍历器对象除了具有next方法，还可以具有return方法和throw方法。（如果你自己写遍历器对象生成函数，那么next方法是必须部署的，return方法和throw方法是否部署是可选的。） return方法的使用场合是，如果for…of循环提前退出（通常是因为出错，或者有break语句或continue语句），就会调用return方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署return方法。 1234567891011function readLinesSync(file) &#123; return &#123; next() &#123; return &#123; done: false &#125;; &#125;, return() &#123; file.close(); return &#123; done: true &#125;; &#125;, &#125;;&#125; 上面代码中，函数readLinesSync接受一个文件对象作为参数，返回一个遍历器对象，其中除了next方法，还部署了return方法。 下面的三种情况，都会触发执行return方法。 1234567891011121314151617// 情况一for (let line of readLinesSync(fileName)) &#123; console.log(line); break;&#125;// 情况二for (let line of readLinesSync(fileName)) &#123; console.log(line); continue;&#125;// 情况三for (let line of readLinesSync(fileName)) &#123; console.log(line); throw new Error();&#125; 上面代码中，情况一输出文件的第一行以后，就会执行return方法，关闭这个文件；情况二输出所有行以后，执行return方法，关闭该文件；情况三会在执行return方法关闭文件之后，再抛出错误。 注意，return方法必须返回一个对象，这是 Generator 规格决定的。 throw方法主要是配合 Generator 函数使用，一般的遍历器对象用不到这个方法。请参阅《Generator函数》一章。 for…of循环ES6 借鉴 C++、Java、C# 和 Python 语言，引入了for…of循环，作为遍历所有数据结构的统一的方法。 一个数据结构只要部署了Symbol.iterator属性，就被视为具有iterator接口，就可以用for…of循环遍历它的成员。也就是说，for…of循环内部调用的是数据结构的Symbol.iterator方法。 for…of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。 数组数组原生具备iterator接口（即默认部署了Symbol.iterator属性），for…of循环本质上就是调用这个接口产生的遍历器 JavaScript 原有的for…in循环，只能获得对象的键名，不能直接获取键值。ES6 提供for…of循环，允许遍历获得键值。 for…in循环读取键名，for…of循环读取键值。如果要通过for…of循环，获取数组的索引，可以借助数组实例的entries方法和keys方法，参见《数组的扩展》章节。 for…of循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟for…in循环也不一样。 Set 和 Map 结构Set 和 Map 结构也原生具有 Iterator 接口，可以直接使用for…of循环。 值得注意的地方有两个 首先，遍历的顺序是按照各个成员被添加进数据结构的顺序。 其次，Set 结构遍历时，返回的是一个值，而 Map 结构遍历时，返回的是一个数组，该数组的两个成员分别为当前 Map 成员的键名和键值。 123456789101112131415161718var engines = new Set(["Gecko", "Trident", "Webkit", "Webkit"]);for (var e of engines) &#123; console.log(e);&#125;// Gecko// Trident// Webkitvar es6 = new Map();es6.set("edition", 6);es6.set("committee", "TC39");es6.set("standard", "ECMA-262");for (var [name, value] of es6) &#123; console.log(name + ": " + value);&#125;// edition: 6// committee: TC39// standard: ECMA-262 123456789101112let map = new Map().set('a', 1).set('b', 2);for (let pair of map) &#123; console.log(pair);&#125;// ['a', 1]// ['b', 2]for (let [key, value] of map) &#123; console.log(key + ' : ' + value);&#125;// a : 1// b : 2 计算生成的数据结构有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6的数组、Set、Map 都部署了以下三个方法，调用后都返回遍历器对象。 entries() 返回一个遍历器对象，用来遍历[键名, 键值]组成的数组。对于数组，键名就是索引值；对于 Set，键名与键值相同。Map 结构的 Iterator 接口，默认就是调用entries方法。keys() 返回一个遍历器对象，用来遍历所有的键名。values() 返回一个遍历器对象，用来遍历所有的键值。这三个方法调用后生成的遍历器对象，所遍历的都是计算生成的数据结构。 1234567let arr = ['a', 'b', 'c'];for (let pair of arr.entries()) &#123; console.log(pair);&#125;// [0, 'a']// [1, 'b']// [2, 'c'] 类似数组的对象类似数组的对象包括好几类。下面是for…of循环用于字符串、DOM NodeList 对象、arguments对象的例子。 1234567891011121314151617181920212223// 字符串let str = "hello";for (let s of str) &#123; console.log(s); // h e l l o&#125;// DOM NodeList对象let paras = document.querySelectorAll("p");for (let p of paras) &#123; p.classList.add("test");&#125;// arguments对象function printArgs() &#123; for (let x of arguments) &#123; console.log(x); &#125;&#125;printArgs('a', 'b');// 'a'// 'b' 对于字符串来说，for…of循环还有一个特点，就是会正确识别32位 UTF-16 字符。 12345for (let x of 'a\uD83D\uDC0A') &#123; console.log(x);&#125;// 'a'// '\uD83D\uDC0A' 并不是所有类似数组的对象都具有 Iterator 接口，一个简便的解决方法，就是使用Array.from方法将其转为数组。 1234567891011let arrayLike = &#123; length: 2, 0: 'a', 1: 'b' &#125;;// 报错for (let x of arrayLike) &#123; console.log(x);&#125;// 正确for (let x of Array.from(arrayLike)) &#123; console.log(x);&#125; 对象对于普通的对象，for…of结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。但是，这样情况下，for…in循环依然可以用来遍历键名。 一种解决方法是，使用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组。 123for (var key of Object.keys(someObject)) &#123; console.log(key + ': ' + someObject[key]);&#125; 另一个方法是使用 Generator 函数将对象重新包装一下。 123456789101112function* entries(obj) &#123; for (let key of Object.keys(obj)) &#123; yield [key, obj[key]]; &#125;&#125;for (let [key, value] of entries(obj)) &#123; console.log(key, '-&gt;', value);&#125;// a -&gt; 1// b -&gt; 2// c -&gt; 3 与其他遍历语法的比较以数组为例，JavaScript 提供多种遍历语法。最原始的写法就是for循环。 123for (var index = 0; index &lt; myArray.length; index++) &#123; console.log(myArray[index]);&#125; 这种写法比较麻烦，因此数组提供内置的forEach方法。 123myArray.forEach(function (value) &#123; console.log(value);&#125;); 这种写法的问题在于，无法中途跳出forEach循环，break命令或return命令都不能奏效。 for…in循环可以遍历数组的键名。 123for (var index in myArray) &#123; console.log(myArray[index]);&#125; for…in循环有几个缺点。 数组的键名是数字，但是for…in循环是以字符串作为键名“0”、“1”、“2”等等。 for…in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。 某些情况下，for…in循环会以任意顺序遍历键名。 总之，for…in循环主要是为遍历对象而设计的，不适用于遍历数组。for…of循环相比上面几种做法，有一些显著的优点。 123for (let value of myArray) &#123; console.log(value);&#125; 有着同for…in一样的简洁语法，但是没有for…in那些缺点。 不同于forEach方法，它可以与break、continue和return配合使用。 提供了遍历所有数据结构的统一操作接口。 下面是一个使用break语句，跳出for…of循环的例子。 12345for (var n of fibonacci) &#123; if (n &gt; 1000) break; console.log(n);&#125; 上面的例子，会输出斐波纳契数列小于等于1000的项。如果当前项大于1000，就会使用break语句跳出for…of循环。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>Iterator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6-Generator]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F14%2FES6-Generator%2F</url>
    <content type="text"><![CDATA[简介基本概念Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。 Generator 函数有多种理解角度。从语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。 执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。 形式上，Generator 函数是一个普通函数，但是有两个特征。 function关键字与函数名之间有一个星号 函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。 1234567function* helloWorldGenerator() &#123; yield 'hello'; yield 'world'; return 'ending';&#125;var hw = helloWorldGenerator(); 上面代码定义了一个 Generator 函数helloWorldGenerator，它内部有两个yield表达式（hello和world），即该函数有三个状态：hello，world 和 return 语句（结束执行）。 Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。 然后接着，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。 总结调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。 ES6 没有规定，function关键字与函数名之间的星号，写在哪个位置。这导致下面的写法都能通过。 1234function * foo(x, y) &#123; ··· &#125;function *foo(x, y) &#123; ··· &#125;function* foo(x, y) &#123; ··· &#125;function*foo(x, y) &#123; ··· &#125; 由于 Generator 函数仍然是普通函数，所以一般的写法是上面的第三种，即星号紧跟在function关键字后面。 yield 表达式由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。 遍历器对象的next方法的运行逻辑如下。 遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。 下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。 如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。 如果该函数没有return语句，则返回的对象的value属性值为undefined。 需要注意的是，yield表达式后面的表达式，只有当调用next方法、并且内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。 123function* gen() &#123; yield 123 + 456;&#125; 上面代码中，yield后面的表达式123 + 456，不会立即求值，只会在next方法将指针移到这一句时，才会求值。 yield表达式与return语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield表达式。正常函数只能返回一个值，因为只能执行一次return；Generator 函数可以返回一系列的值，因为可以有任意多个yield。从另一个角度看，也可以说 Generator 生成了一系列的值，这也就是它的名称的来历（英语中，generator 这个词是“生成器”的意思）。 Generator 函数可以不用yield表达式，这时就变成了一个单纯的暂缓执行函数。 另外需要注意，yield表达式只能用在 Generator 函数里面，用在其他地方都会报错。 另外，yield表达式如果用在另一个表达式之中，必须放在圆括号里面。 与 Iterator 接口的关系上一章说过，任意一个对象的Symbol.iterator方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。 由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口。 12345678var myIterable = &#123;&#125;;myIterable[Symbol.iterator] = function* () &#123; yield 1; yield 2; yield 3;&#125;;[...myIterable] // [1, 2, 3] 上面代码中，Generator 函数赋值给Symbol.iterator属性，从而使得myIterable对象具有了 Iterator 接口，可以被…运算符遍历了。 Generator 函数执行后，返回一个遍历器对象。该对象本身也具有Symbol.iterator属性，执行后返回自身。 12345678function* gen()&#123; // some code&#125;var g = gen();g[Symbol.iterator]() === g// true next 方法的参数yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。 123456789101112function* f() &#123; for(var i = 0; true; i++) &#123; var reset = yield i; if(reset) &#123; i = -1; &#125; &#125;&#125;var g = f();g.next() // &#123; value: 0, done: false &#125;g.next() // &#123; value: 1, done: false &#125;g.next(true) // &#123; value: 0, done: false &#125; 上面代码先定义了一个可以无限运行的 Generator 函数f，如果next方法没有参数，每次运行到yield表达式，变量reset的值总是undefined。当next方法带一个参数true时，变量reset就被重置为这个参数（即true），因此i会等于-1，下一轮循环就会从-1开始递增。 这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过next方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。 注意，由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的。V8 引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数。 for…of 循环for…of循环可以自动遍历 Generator 函数时生成的Iterator对象，且此时不再需要调用next方法。 12345678910111213function *foo() &#123; yield 1; yield 2; yield 3; yield 4; yield 5; return 6;&#125;for (let v of foo()) &#123; console.log(v);&#125;// 1 2 3 4 5 上面代码使用for…of循环，依次显示5个yield表达式的值。这里需要注意，一旦next方法的返回对象的done属性为true，for…of循环就会中止，且不包含该返回对象，所以上面代码的return语句返回的6，不包括在for…of循环之中。 利用for…of循环，可以写出遍历任意对象（object）的方法。原生的 JavaScript 对象没有遍历接口，无法使用for…of循环，通过 Generator 函数为它加上这个接口，就可以用了。 123456789101112131415function* objectEntries(obj) &#123; let propKeys = Reflect.ownKeys(obj); for (let propKey of propKeys) &#123; yield [propKey, obj[propKey]]; &#125;&#125;let jane = &#123; first: 'Jane', last: 'Doe' &#125;;for (let [key, value] of objectEntries(jane)) &#123; console.log(`$&#123;key&#125;: $&#123;value&#125;`);&#125;// first: Jane// last: Doe 上面代码中，对象jane原生不具备 Iterator 接口，无法用for…of遍历。这时，我们通过 Generator 函数objectEntries为它加上遍历器接口，就可以用for…of遍历了。 加上遍历器接口的另一种写法是，将 Generator 函数加到对象的Symbol.iterator属性上面。 1234567891011121314151617function* objectEntries() &#123; let propKeys = Object.keys(this); for (let propKey of propKeys) &#123; yield [propKey, this[propKey]]; &#125;&#125;let jane = &#123; first: 'Jane', last: 'Doe' &#125;;jane[Symbol.iterator] = objectEntries;for (let [key, value] of jane) &#123; console.log(`$&#123;key&#125;: $&#123;value&#125;`);&#125;// first: Jane// last: Doe 除了for…of循环以外，扩展运算符（…）、解构赋值和Array.from方法内部调用的都是遍历器接口。这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。 123456789101112131415161718192021222324function* numbers () &#123; yield 1 yield 2 return 3 yield 4&#125;// 扩展运算符[...numbers()] // [1, 2]// Array.from 方法Array.from(numbers()) // [1, 2]// 解构赋值let [x, y] = numbers();x // 1y // 2// for...of 循环for (let n of numbers()) &#123; console.log(n)&#125;// 1// 2 Generator.prototype.throw()Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。 12345678910111213141516171819var g = function* () &#123; try &#123; yield; &#125; catch (e) &#123; console.log('内部捕获', e); &#125;&#125;;var i = g();i.next();try &#123; i.throw('a'); i.throw('b');&#125; catch (e) &#123; console.log('外部捕获', e);&#125;// 内部捕获 a// 外部捕获 b 上面代码中，遍历器对象i连续抛出两个错误。第一个错误被 Generator 函数体内的catch语句捕获。i第二次抛出错误，由于 Generator 函数内部的catch语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的catch语句捕获。 throw方法可以接受一个参数，该参数会被catch语句接收，建议抛出Error对象的实例。 123456789101112var g = function* () &#123; try &#123; yield; &#125; catch (e) &#123; console.log(e); &#125;&#125;;var i = g();i.next();i.throw(new Error('出错了！'));// Error: 出错了！(…) 注意，不要混淆遍历器对象的throw方法和全局的throw命令。上面代码的错误，是用遍历器对象的throw方法抛出的，而不是用throw命令抛出的。后者只能被函数体外的catch语句捕获。 123456789101112131415161718192021var g = function* () &#123; while (true) &#123; try &#123; yield; &#125; catch (e) &#123; if (e != 'a') throw e; console.log('内部捕获', e); &#125; &#125;&#125;;var i = g();i.next();try &#123; throw new Error('a'); throw new Error('b');&#125; catch (e) &#123; console.log('外部捕获', e);&#125;// 外部捕获 [Error: a] 上面代码之所以只捕获了a，是因为函数体外的catch语句块，捕获了抛出的a错误以后，就不会再继续try代码块里面剩余的语句了。 如果 Generator 函数内部没有部署try…catch代码块，那么throw方法抛出的错误，将被外部try…catch代码块捕获。 1234567891011121314151617var g = function* () &#123; while (true) &#123; yield; console.log('内部捕获', e); &#125;&#125;;var i = g();i.next();try &#123; i.throw('a'); i.throw('b');&#125; catch (e) &#123; console.log('外部捕获', e);&#125;// 外部捕获 a 上面代码中，Generator 函数g内部没有部署try…catch代码块，所以抛出的错误直接被外部catch代码块捕获。 如果 Generator 函数内部和外部，都没有部署try…catch代码块，那么程序将报错，直接中断执行。 throw方法被捕获以后，会附带执行下一条yield表达式。也就是说，会附带执行一次next方法。1234567891011121314var gen = function* gen()&#123; try &#123; yield console.log('a'); &#125; catch (e) &#123; // ... &#125; yield console.log('b'); yield console.log('c');&#125;var g = gen();g.next() // ag.throw() // bg.next() // c 上面代码中，g.throw方法被捕获以后，自动执行了一次next方法，所以会打印b。另外，也可以看到，只要 Generator 函数内部部署了try…catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历。 另外，throw命令与g.throw方法是无关的，两者互不影响。 这种函数体内捕获错误的机制，大大方便了对错误的处理。多个yield表达式，可以只用一个try…catch代码块来捕获错误。如果使用回调函数的写法，想要捕获多个错误，就不得不为每个函数内部写一个错误处理语句，现在只在 Generator 函数内部写一次catch语句就可以了。 Generator 函数体外抛出的错误，可以在函数体内捕获；反过来，Generator 函数体内抛出的错误，也可以被函数体外的catch捕获。 一旦 Generator 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用next方法，将返回一个value属性等于undefined、done属性等于true的对象，即 JavaScript 引擎认为这个 Generator 已经运行结束了。 Generator.prototype.return()Generator 函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历 Generator 函数。 1234567891011function* gen() &#123; yield 1; yield 2; yield 3;&#125;var g = gen();g.next() // &#123; value: 1, done: false &#125;g.return('foo') // &#123; value: "foo", done: true &#125;g.next() // &#123; value: undefined, done: true &#125; 上面代码中，遍历器对象g调用return方法后，返回值的value属性就是return方法的参数foo。并且，Generator函数的遍历就终止了，返回值的done属性为true，以后再调用next方法，done属性总是返回true。 如果return方法调用时，不提供参数，则返回值的value属性为undefined。 next()、throw()、return() 的共同点next()、throw()、return()这三个方法本质上是同一件事，可以放在一起理解。它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换yield表达式。next()是将yield表达式替换成一个值。 1234567891011const g = function* (x, y) &#123; let result = yield x + y; return result;&#125;;const gen = g(1, 2);gen.next(); // Object &#123;value: 3, done: false&#125;gen.next(1); // Object &#123;value: 1, done: true&#125;// 相当于将 let result = yield x + y// 替换成 let result = 1; 上面代码中，第二个next(1)方法就相当于将yield表达式替换成一个值1。如果next方法没有参数，就相当于替换成undefined。 throw()是将yield表达式替换成一个throw语句。 123gen.throw(new Error('出错了')); // Uncaught Error: 出错了// 相当于将 let result = yield x + y// 替换成 let result = throw(new Error('出错了')); return()是将yield表达式替换成一个return语句。 123gen.return(2); // Object &#123;value: 2, done: true&#125;// 相当于将 let result = yield x + y// 替换成 let result = return 2; yield* 表达式如果在 Generator 函数内部，调用另一个 Generator 函数，默认情况下是没有效果的。 12345678910111213141516function* foo() &#123; yield 'a'; yield 'b';&#125;function* bar() &#123; yield 'x'; foo(); yield 'y';&#125;for (let v of bar())&#123; console.log(v);&#125;// "x"// "y" 上面代码中，foo和bar都是 Generator 函数，在bar里面调用foo，是不会有效果的。 这个就需要用到yield*表达式，用来在一个 Generator 函数里面执行另一个 Generator 函数。 123456789101112131415161718192021222324252627282930function* bar() &#123; yield 'x'; yield* foo(); yield 'y';&#125;// 等同于function* bar() &#123; yield 'x'; yield 'a'; yield 'b'; yield 'y';&#125;// 等同于function* bar() &#123; yield 'x'; for (let v of foo()) &#123; yield v; &#125; yield 'y';&#125;for (let v of bar())&#123; console.log(v);&#125;// "x"// "a"// "b"// "y" 再来看一个对比的例子。 12345678910111213141516171819202122232425function* inner() &#123; yield 'hello!';&#125;function* outer1() &#123; yield 'open'; yield inner(); yield 'close';&#125;var gen = outer1()gen.next().value // "open"gen.next().value // 返回一个遍历器对象gen.next().value // "close"function* outer2() &#123; yield 'open' yield* inner() yield 'close'&#125;var gen = outer2()gen.next().value // "open"gen.next().value // "hello!"gen.next().value // "close" 从语法角度看，如果yield表达式后面跟的是一个遍历器对象，需要在yield表达式后面加上星号，表明它返回的是一个遍历器对象。这被称为yield*表达式。 yield*后面的 Generator 函数（没有return语句时），等同于在 Generator 函数内部，部署一个for…of循环。 实际上，任何数据结构只要有 Iterator 接口，就可以被yield*遍历。 如果被代理的 Generator 函数有return语句，那么就可以向代理它的 Generator 函数返回数据。 作为对象属性的Generator函数如果一个对象的属性是 Generator 函数，可以简写成下面的形式。 12345let obj = &#123; * myGeneratorMethod() &#123; ··· &#125;&#125;; 上面代码中，myGeneratorMethod属性前面有一个星号，表示这个属性是一个 Generator 函数。 它的完整形式如下，与上面的写法是等价的。 12345let obj = &#123; myGeneratorMethod: function* () &#123; // ··· &#125;&#125;; Generator 函数的thisGenerator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的prototype对象上的方法。 12345678910function* g() &#123;&#125;g.prototype.hello = function () &#123; return 'hi!';&#125;;let obj = g();obj instanceof g // trueobj.hello() // 'hi!' 但是，如果把g当作普通的构造函数，并不会生效，因为g返回的总是遍历器对象，而不是this对象。 123456function* g() &#123; this.a = 11;&#125;let obj = g();obj.a // undefined 上面代码中，Generator函数g在this对象上面添加了一个属性a，但是obj对象拿不到这个属性。 Generator函数也不能跟new命令一起用，会报错。 含义Generator 与状态机Generator 是实现状态机的最佳结构。比如，下面的clock函数就是一个状态机。 12345678var ticking = true;var clock = function() &#123; if (ticking) console.log('Tick!'); else console.log('Tock!'); ticking = !ticking;&#125; 上面代码的clock函数一共有两种状态（Tick和Tock），每运行一次，就改变一次状态。这个函数如果用 Generator 实现，就是下面这样。 12345678var clock = function* () &#123; while (true) &#123; console.log('Tick!'); yield; console.log('Tock!'); yield; &#125;&#125;; 上面的 Generator 实现与 ES5 实现对比，可以看到少了用来保存状态的外部变量ticking，这样就更简洁，更安全（状态不会被非法篡改）、更符合函数式编程的思想，在写法上也更优雅。Generator 之所以可以不用外部变量保存状态，是因为它本身就包含了一个状态信息，即目前是否处于暂停态。 Generator与协程协程（coroutine）是一种程序运行的方式，可以理解成“协作的线程”或“协作的函数”。协程既可以用单线程实现，也可以用多线程实现。前者是一种特殊的子例程，后者是一种特殊的线程。 1. 协程与子例程的差异传统的“子例程”（subroutine）采用堆栈式“后进先出”的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数。协程与其不同，多个线程（单线程情况下，即多个函数）可以并行执行，但是只有一个线程（或函数）处于正在运行的状态，其他线程（或函数）都处于暂停态（suspended），线程（或函数）之间可以交换执行权。也就是说，一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。 从实现上看，在内存中，子例程只使用一个栈（stack），而协程是同时存在多个栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行。 2. 协程与普通线程的差异不难看出，协程适合用于多任务运行的环境。在这个意义上，它与普通的线程很相似，都有自己的执行上下文、可以分享全局变量。它们的不同之处在于，同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都处于暂停状态。此外，普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。 由于 JavaScript 是单线程语言，只能保持一个调用栈。引入协程以后，每个任务可以保持自己的调用栈。这样做的最大好处，就是抛出错误的时候，可以找到原始的调用栈。不至于像异步操作的回调函数那样，一旦出错，原始的调用栈早就结束。 Generator 函数是 ES6 对协程的实现，但属于不完全实现。Generator 函数被称为“半协程”（semi-coroutine），意思是只有 Generator 函数的调用者，才能将程序的执行权还给 Generator 函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。 如果将 Generator 函数当作协程，完全可以将多个需要互相协作的任务写成 Generator 函数，它们之间使用yield表示式交换控制权。 应用Generator 可以暂停函数执行，返回任意表达式的值。这种特点使得 Generator 有多种应用场景。 1. 异步操作的同步化表达Generator 函数的暂停执行的效果，意味着可以把异步操作写在yield表达式里面，等到调用next方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在yield表达式下面，反正要等到调用next方法时再执行。所以，Generator 函数的一个重要实际意义就是用来处理异步操作，改写回调函数。 1234567891011function* loadUI() &#123; showLoadingScreen(); yield loadUIDataAsynchronously(); hideLoadingScreen();&#125;var loader = loadUI();// 加载UIloader.next()// 卸载UIloader.next() 上面代码中，第一次调用loadUI函数时，该函数不会执行，仅返回一个遍历器。下一次对该遍历器调用next方法，则会显示Loading界面（showLoadingScreen），并且异步加载数据（loadUIDataAsynchronously）。等到数据加载完成，再一次使用next方法，则会隐藏Loading界面。可以看到，这种写法的好处是所有Loading界面的逻辑，都被封装在一个函数，按部就班非常清晰。 Ajax 是典型的异步操作，通过 Generator 函数部署 Ajax 操作，可以用同步的方式表达。 1234567891011121314function* main() &#123; var result = yield request("http://some.url"); var resp = JSON.parse(result); console.log(resp.value);&#125;function request(url) &#123; makeAjaxCall(url, function(response)&#123; it.next(response); &#125;);&#125;var it = main();it.next(); 上面代码的main函数，就是通过 Ajax 操作获取数据。可以看到，除了多了一个yield，它几乎与同步操作的写法完全一样。注意，makeAjaxCall函数中的next方法，必须加上response参数，因为yield表达式，本身是没有值的，总是等于undefined。 2. 控制流管理如果有一个多步操作非常耗时，采用回调函数，可能会写成下面这样。 123456789step1(function (value1) &#123; step2(value1, function(value2) &#123; step3(value2, function(value3) &#123; step4(value3, function(value4) &#123; // Do something with value4 &#125;); &#125;); &#125;);&#125;); 采用 Promise 改写上面的代码。 12345678910Promise.resolve(step1) .then(step2) .then(step3) .then(step4) .then(function (value4) &#123; // Do something with value4 &#125;, function (error) &#123; // Handle any error from step1 through step4 &#125;) .done(); 上面代码已经把回调函数，改成了直线执行的形式，但是加入了大量 Promise 的语法。Generator 函数可以进一步改善代码运行流程。 1234567891011function* longRunningTask(value1) &#123; try &#123; var value2 = yield step1(value1); var value3 = yield step2(value2); var value4 = yield step3(value3); var value5 = yield step4(value4); // Do something with value4 &#125; catch (e) &#123; // Handle any error from step1 through step4 &#125;&#125; 然后，使用一个函数，按次序自动执行所有步骤。 12345678910scheduler(longRunningTask(initialValue));function scheduler(task) &#123; var taskObj = task.next(task.value); // 如果Generator函数未结束，就继续调用 if (!taskObj.done) &#123; task.value = taskObj.value scheduler(task); &#125;&#125; 注意，上面这种做法，只适合同步操作，即所有的task都必须是同步的，不能有异步操作。因为这里的代码一得到返回值，就继续往下执行，没有判断异步操作何时完成。如果要控制异步的操作流程，详见后面的《异步操作》一章。 下面，利用for…of循环会自动依次执行yield命令的特性，提供一种更一般的控制流管理的方法。 12345678let steps = [step1Func, step2Func, step3Func];function *iterateSteps(steps)&#123; for (var i=0; i&lt; steps.length; i++)&#123; var step = steps[i]; yield step(); &#125;&#125; 上面代码中，数组steps封装了一个任务的多个步骤，Generator 函数iterateSteps则是依次为这些步骤加上yield命令。 将任务分解成步骤之后，还可以将项目分解成多个依次执行的任务。 12345678let jobs = [job1, job2, job3];function* iterateJobs(jobs)&#123; for (var i=0; i&lt; jobs.length; i++)&#123; var job = jobs[i]; yield* iterateSteps(job.steps); &#125;&#125; 上面代码中，数组jobs封装了一个项目的多个任务，Generator 函数iterateJobs则是依次为这些任务加上yield*命令。 最后，就可以用for…of循环一次性依次执行所有任务的所有步骤。 123for (var step of iterateJobs(jobs))&#123; console.log(step.id);&#125; 再次提醒，上面的做法只能用于所有步骤都是同步操作的情况，不能有异步操作的步骤。如果想要依次执行异步的步骤，必须使用后面的《异步操作》一章介绍的方法。 for…of的本质是一个while循环，所以上面的代码实质上执行的是下面的逻辑。 12345678var it = iterateJobs(jobs);var res = it.next();while (!res.done)&#123; var result = res.value; // ... res = it.next();&#125; 3. 部署 Iterator 接口利用 Generator 函数，可以在任意对象上部署 Iterator 接口。 12345678910111213141516function* iterEntries(obj) &#123; let keys = Object.keys(obj); for (let i=0; i &lt; keys.length; i++) &#123; let key = keys[i]; yield [key, obj[key]]; &#125;&#125;let myObj = &#123; foo: 3, bar: 7 &#125;;for (let [key, value] of iterEntries(myObj)) &#123; console.log(key, value);&#125;// foo 3// bar 7 上述代码中，myObj是一个普通对象，通过iterEntries函数，就有了 Iterator 接口。也就是说，可以在任意对象上部署next方法。 4. 作为数据结构Generator 可以看作是数据结构，更确切地说，可以看作是一个数组结构，因为 Generator 函数可以返回一系列的值，这意味着它可以对任意表达式，提供类似数组的接口。 12345function *doStuff() &#123; yield fs.readFile.bind(null, 'hello.txt'); yield fs.readFile.bind(null, 'world.txt'); yield fs.readFile.bind(null, 'and-such.txt');&#125; 上面代码就是依次返回三个函数，但是由于使用了 Generator 函数，导致可以像处理数组那样，处理这三个返回的函数。 123for (task of doStuff()) &#123; // task是一个函数，可以像回调函数那样使用它&#125; 实际上，如果用 ES5 表达，完全可以用数组模拟 Generator 的这种用法。 1234567function doStuff() &#123; return [ fs.readFile.bind(null, 'hello.txt'), fs.readFile.bind(null, 'world.txt'), fs.readFile.bind(null, 'and-such.txt') ];&#125; 上面的函数，可以用一模一样的for…of循环处理！两相一比较，就不难看出 Generator 使得数据或者操作，具备了类似数组的接口。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>Generator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 async]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F14%2FES6-async%2F</url>
    <content type="text"><![CDATA[含义ES2017 标准引入了 async 函数，使得异步操作变得更加方便。async 函数是什么？一句话，它就是 Generator 函数的语法糖。前文有一个 Generator 函数，依次读取两个文件。 1234567891011121314151617const fs = require('fs');const readFile = function (fileName) &#123; return new Promise(function (resolve, reject) &#123; fs.readFile(fileName, function(error, data) &#123; if (error) return reject(error); resolve(data); &#125;); &#125;);&#125;;const gen = function* () &#123; const f1 = yield readFile('/etc/fstab'); const f2 = yield readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;; 写成async函数，就是下面这样。 123456const asyncReadFile = async function () &#123; const f1 = await readFile('/etc/fstab'); const f2 = await readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;; 一比较就会发现，async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。 async函数对 Generator 函数的改进，体现在以下四点。1. 内置执行器。Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。 asyncReadFile();上面的代码调用了asyncReadFile函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用next方法，或者用co模块，才能真正执行，得到最后结果。 2. 更好的语义。async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。 3. 更广的适用性。co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。 4. 返回值是 Promise。async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。 进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。基本用法async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。下面是一个例子。 123456789async function getStockPriceByName(name) &#123; const symbol = await getStockSymbol(name); const stockPrice = await getStockPrice(symbol); return stockPrice;&#125;getStockPriceByName('goog').then(function (result) &#123; console.log(result);&#125;); 上面代码是一个获取股票报价的函数，函数前面的async关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个Promise对象。 下面是另一个例子，指定多少毫秒后输出一个值。 123456789101112function timeout(ms) &#123; return new Promise((resolve) =&gt; &#123; setTimeout(resolve, ms); &#125;);&#125;async function asyncPrint(value, ms) &#123; await timeout(ms); console.log(value);&#125;asyncPrint('hello world', 50); 上面代码指定50毫秒以后，输出hello world。 由于async函数返回的是 Promise 对象，可以作为await命令的参数。所以，上面的例子也可以写成下面的形式。 123456789101112async function timeout(ms) &#123; await new Promise((resolve) =&gt; &#123; setTimeout(resolve, ms); &#125;);&#125;async function asyncPrint(value, ms) &#123; await timeout(ms); console.log(value);&#125;asyncPrint('hello world', 50); async 函数有多种使用形式。123456789101112131415161718192021222324252627// 函数声明async function foo() &#123;&#125;// 函数表达式const foo = async function () &#123;&#125;;// 对象的方法let obj = &#123; async foo() &#123;&#125; &#125;;obj.foo().then(...)// Class 的方法class Storage &#123; constructor() &#123; this.cachePromise = caches.open('avatars'); &#125; async getAvatar(name) &#123; const cache = await this.cachePromise; return cache.match(`/avatars/$&#123;name&#125;.jpg`); &#125;&#125;const storage = new Storage();storage.getAvatar('jake').then(…);// 箭头函数const foo = async () =&gt; &#123;&#125;; 语法async函数的语法规则总体上比较简单，难点是错误处理机制。 返回 Promise 对象async函数返回一个 Promise 对象。async函数内部return语句返回的值，会成为then方法回调函数的参数。123456async function f() &#123; return 'hello world';&#125;f().then(v =&gt; console.log(v))// "hello world" 上面代码中，函数f内部return命令返回的值，会被then方法回调函数接收到。 async函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。123456789async function f() &#123; throw new Error('出错了');&#125;f().then( v =&gt; console.log(v), e =&gt; console.log(e))// Error: 出错了 Promise 对象的状态变化async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。 下面是一个例子。 1234567async function getTitle(url) &#123; let response = await fetch(url); let html = await response.text(); return html.match(/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i)[1];&#125;getTitle('https://tc39.github.io/ecma262/').then(console.log)// "ECMAScript 2017 Language Specification" 上面代码中，函数getTitle内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行then方法里面的console.log。 await 命令正常情况下，await命令后面是一个 Promise 对象。如果不是，会被转成一个立即resolve的 Promise 对象。123456async function f() &#123; return await 123;&#125;f().then(v =&gt; console.log(v))// 123 上面代码中，await命令的参数是数值123，它被转成 Promise 对象，并立即resolve。 await命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。12345678async function f() &#123; await Promise.reject('出错了');&#125;f().then(v =&gt; console.log(v)).catch(e =&gt; console.log(e))// 出错了 注意，上面代码中，await语句前面没有return，但是reject方法的参数依然传入了catch方法的回调函数。这里如果在await前面加上return，效果是一样的。 只要一个await语句后面的 Promise 变为reject，那么整个async函数都会中断执行。1234async function f() &#123; await Promise.reject('出错了'); await Promise.resolve('hello world'); // 不会执行&#125; 上面代码中，第二个await语句是不会执行的，因为第一个await语句状态变成了reject。 有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个await放在try…catch结构里面，这样不管这个异步操作是否成功，第二个await都会执行。 1234567891011async function f() &#123; try &#123; await Promise.reject('出错了'); &#125; catch(e) &#123; &#125; return await Promise.resolve('hello world');&#125;f().then(v =&gt; console.log(v))// hello world 另一种方法是await后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误。12345678910async function f() &#123; await Promise.reject('出错了') .catch(e =&gt; console.log(e)); return await Promise.resolve('hello world');&#125;f().then(v =&gt; console.log(v))// 出错了// hello world 错误处理如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject。12345678910async function f() &#123; await new Promise(function (resolve, reject) &#123; throw new Error('出错了'); &#125;);&#125;f().then(v =&gt; console.log(v)).catch(e =&gt; console.log(e))// Error：出错了 上面代码中，async函数f执行后，await后面的 Promise 对象会抛出一个错误对象，导致catch方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制，可以参考后文的“async 函数的实现原理”。 防止出错的方法，也是将其放在try…catch代码块之中。123456789async function f() &#123; try &#123; await new Promise(function (resolve, reject) &#123; throw new Error('出错了'); &#125;); &#125; catch(e) &#123; &#125; return await('hello world');&#125; 如果有多个await命令，可以统一放在try…catch结构中。 123456789101112async function main() &#123; try &#123; const val1 = await firstStep(); const val2 = await secondStep(val1); const val3 = await thirdStep(val1, val2); console.log('Final: ', val3); &#125; catch (err) &#123; console.error(err); &#125;&#125; 下面的例子使用try…catch结构，实现多次重复尝试。 123456789101112131415const superagent = require('superagent');const NUM_RETRIES = 3;async function test() &#123; let i; for (i = 0; i &lt; NUM_RETRIES; ++i) &#123; try &#123; await superagent.get('http://google.com/this-throws-an-error'); break; &#125; catch(err) &#123;&#125; &#125; console.log(i); // 3&#125;test(); 上面代码中，如果await操作成功，就会使用break语句退出循环；如果失败，会被catch语句捕捉，然后进入下一轮循环。 使用注意点第一点，前面已经说过，await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try…catch代码块中。12345678910111213141516async function myFunction() &#123; try &#123; await somethingThatReturnsAPromise(); &#125; catch (err) &#123; console.log(err); &#125;&#125;// 另一种写法async function myFunction() &#123; await somethingThatReturnsAPromise() .catch(function (err) &#123; console.log(err); &#125;);&#125; 第二点，多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。12let foo = await getFoo();let bar = await getBar(); 上面代码中，getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发。 12345678// 写法一let [foo, bar] = await Promise.all([getFoo(), getBar()]);// 写法二let fooPromise = getFoo();let barPromise = getBar();let foo = await fooPromise;let bar = await barPromise; 上面两种写法，getFoo和getBar都是同时触发，这样就会缩短程序的执行时间。 第三点，await命令只能用在async函数之中，如果用在普通函数，就会报错。12345678async function dbFuc(db) &#123; let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; // 报错 docs.forEach(function (doc) &#123; await db.post(doc); &#125;);&#125; 上面代码会报错，因为await用在普通函数之中了。但是，如果将forEach方法的参数改成async函数，也有问题。 12345678function dbFuc(db) &#123; //这里不需要 async let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; // 可能得到错误结果 docs.forEach(async function (doc) &#123; await db.post(doc); &#125;);&#125; 上面代码可能不会正常工作，原因是这时三个db.post操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用for循环。 1234567async function dbFuc(db) &#123; let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; for (let doc of docs) &#123; await db.post(doc); &#125;&#125; 如果确实希望多个请求并发执行，可以使用Promise.all方法。当三个请求都会resolved时，下面两种写法效果相同。 1234567891011121314151617181920async function dbFuc(db) &#123; let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; let promises = docs.map((doc) =&gt; db.post(doc)); let results = await Promise.all(promises); console.log(results);&#125;// 或者使用下面的写法async function dbFuc(db) &#123; let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; let promises = docs.map((doc) =&gt; db.post(doc)); let results = []; for (let promise of promises) &#123; results.push(await promise); &#125; console.log(results);&#125; 目前，@std/esm模块加载器支持顶层await，即await命令可以不放在 async 函数里面，直接使用。 1234567891011// async 函数的写法const start = async () =&gt; &#123; const res = await fetch('google.com'); return res.text();&#125;;start().then(console.log);// 顶层 await 的写法const res = await fetch('google.com');console.log(await res.text()); 上面代码中，第二种写法的脚本必须使用@std/esm加载器，才会生效。 async 函数的实现原理async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。1234567891011async function fn(args) &#123; // ...&#125;// 等同于function fn(args) &#123; return spawn(function* () &#123; // ... &#125;);&#125; 所有的async函数都可以写成上面的第二种形式，其中的spawn函数就是自动执行器。 下面给出spawn函数的实现，基本就是前文自动执行器的翻版。 12345678910111213141516171819202122function spawn(genF) &#123; return new Promise(function(resolve, reject) &#123; const gen = genF(); function step(nextF) &#123; let next; try &#123; next = nextF(); &#125; catch(e) &#123; return reject(e); &#125; if(next.done) &#123; return resolve(next.value); &#125; Promise.resolve(next.value).then(function(v) &#123; step(function() &#123; return gen.next(v); &#125;); &#125;, function(e) &#123; step(function() &#123; return gen.throw(e); &#125;); &#125;); &#125; step(function() &#123; return gen.next(undefined); &#125;); &#125;);&#125; 与其他异步处理方法的比较我们通过一个例子，来看 async 函数与 Promise、Generator 函数的比较。 假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。 首先是 Promise 的写法。123456789101112131415161718192021222324function chainAnimationsPromise(elem, animations) &#123; // 变量ret用来保存上一个动画的返回值 let ret = null; // 新建一个空的Promise let p = Promise.resolve(); // 使用then方法，添加所有动画 for(let anim of animations) &#123; p = p.then(function(val) &#123; ret = val; return anim(elem); &#125;); &#125; // 返回一个部署了错误捕捉机制的Promise return p.catch(function(e) &#123; /* 忽略错误，继续执行 */ &#125;).then(function() &#123; return ret; &#125;);&#125; 虽然 Promise 的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是 Promise 的 API（then、catch等等），操作本身的语义反而不容易看出来。 接着是 Generator 函数的写法。123456789101112131415function chainAnimationsGenerator(elem, animations) &#123; return spawn(function*() &#123; let ret = null; try &#123; for(let anim of animations) &#123; ret = yield anim(elem); &#125; &#125; catch(e) &#123; /* 忽略错误，继续执行 */ &#125; return ret; &#125;);&#125; 上面代码使用 Generator 函数遍历了每个动画，语义比 Promise 写法更清晰，用户定义的操作全部都出现在spawn函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行 Generator 函数，上面代码的spawn函数就是自动执行器，它返回一个 Promise 对象，而且必须保证yield语句后面的表达式，必须返回一个 Promise。 最后是 async 函数的写法。1234567891011async function chainAnimationsAsync(elem, animations) &#123; let ret = null; try &#123; for(let anim of animations) &#123; ret = await anim(elem); &#125; &#125; catch(e) &#123; /* 忽略错误，继续执行 */ &#125; return ret;&#125; 可以看到Async函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将Generator写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用Generator写法，自动执行器需要用户自己提供。 实例：按顺序完成异步操作实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组 URL，然后按照读取的顺序输出结果。 Promise 的写法如下。 123456789101112function logInOrder(urls) &#123; // 远程读取所有URL const textPromises = urls.map(url =&gt; &#123; return fetch(url).then(response =&gt; response.text()); &#125;); // 按次序输出 textPromises.reduce((chain, textPromise) =&gt; &#123; return chain.then(() =&gt; textPromise) .then(text =&gt; console.log(text)); &#125;, Promise.resolve());&#125; 上面代码使用fetch方法，同时远程读取一组 URL。每个fetch操作都返回一个 Promise 对象，放入textPromises数组。然后，reduce方法依次处理每个 Promise 对象，然后使用then，将所有 Promise 对象连起来，因此就可以依次输出结果。 这种写法不太直观，可读性比较差。下面是 async 函数实现。 123456async function logInOrder(urls) &#123; for (const url of urls) &#123; const response = await fetch(url); console.log(await response.text()); &#125;&#125; 上面代码确实大大简化，问题是所有远程操作都是继发。只有前一个URL返回结果，才会去读取下一个URL，这样做效率很差，非常浪费时间。我们需要的是并发发出远程请求。 123456789101112async function logInOrder(urls) &#123; // 并发读取远程URL const textPromises = urls.map(async url =&gt; &#123; const response = await fetch(url); return response.text(); &#125;); // 按次序输出 for (const textPromise of textPromises) &#123; console.log(await textPromise); &#125;&#125; 上面代码中，虽然map方法的参数是async函数，但它是并发执行的，因为只有async函数内部是继发执行，外部不受影响。后面的for..of循环内部使用了await，因此实现了按顺序输出。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>async</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现一个回到顶部按钮]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F14%2F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%9B%9E%E5%88%B0%E9%A1%B6%E9%83%A8%E6%8C%89%E9%92%AE%2F</url>
    <content type="text"><![CDATA[前言在实际应用中，经常用到滚动到页面顶部或某个位置，一般简单用锚点处理或用js将document.body.scrollTop设置为0，结果是页面一闪而过滚到指定位置，不是特别友好。我们想要的效果是要有点缓冲效果。 现代浏览器陆续意识到了这种需求，scrollIntoView意思是滚动到可视，css中提供了scroll-behavior属性，js有Element.scrollIntoView()方法。 scroll-behavior1scroll-behavior`属性可取值`auto`|`smooth`|`inherit`|`unset scroll-behavior: smooth;是我们想要的缓冲效果。在PC浏览器中，页面默认滚动是在&lt;html&gt;标签上，移动端大多数在&lt;body&gt;标签上，在我们想要实现平滑“回到顶部”，只需在这两个标签上都加上： 123html, body &#123; scroll-behavior: smooth;&#125; 准确的说，写在容器元素上，可以让容器（非鼠标手势触发）的滚动变得平滑，而不局限于&lt;html&gt;，&lt;body&gt;标签。 利用这个css属性可以一步将原来纯css标签直接切换，变成平滑过渡切换效果。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859.tab label &#123; padding: 10px; border: 1px solid #ccc; margin-right: -1px; text-align: center; float: left; overflow: hidden;&#125;.tab::after &#123; content: ""; display: table; clear: both;&#125;.box &#123; height: 200px; border: 1px solid #ccc; scroll-behavior: smooth; overflow: hidden; margin-top: 10px;&#125;.item &#123; height: 100%; position: relative; overflow: hidden;&#125;.item input &#123; position: absolute; top: 0; height: 100%; width: 1px; border: 0; padding: 0; margin: 0; clip: rect(0 0 0 0);&#125;&lt;h1&gt;纯CSS选项卡&lt;/h1&gt;&lt;div class="tab"&gt; &lt;label for="tab1"&gt;选项卡1&lt;/label&gt; &lt;label for="tab2"&gt;选项卡2&lt;/label&gt; &lt;label for="tab3"&gt;选项卡3&lt;/label&gt;&lt;/div&gt;&lt;div class="box"&gt; &lt;div class="item"&gt; &lt;input type="text" id="tab1"&gt; &lt;p&gt;选项卡1内容&lt;/p&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;input type="text" id="tab2"&gt; &lt;p&gt;选项卡2内容&lt;/p&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;input type="text" id="tab3"&gt; &lt;p&gt;选项卡3内容&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 实现效果 也可以戳这里 再来看一下这个css属性scroll-behavior在各大浏览器中的支持情况 呃~支持度不是很好，这样一行css代码能应用上当然是最好的，不行就退化成一闪而过的效果咯。下面再看下js提供的api。 Element.scrollIntoView()Element.scrollIntoView() 方法让当前的元素滚动到浏览器窗口的可视区域内。 element.scrollIntoView(); // 等同于element.scrollIntoView(true)element.scrollIntoView(alignToTop); // Boolean型参数element.scrollIntoView(scrollIntoViewOptions); // Object型参数 参数alignToTop一个Boolean值： 如果为true，元素的顶端将和其所在滚动区的可视区域的顶端对齐。相应的scrollIntoViewOptions: {block: &quot;start&quot;, inline: &quot;nearest&quot;}。这是这个参数的默认值。 如果为false，元素的底端将和其所在滚动区的可视区域的底端对齐。相应的scrollIntoViewOptions: {block: &quot;end&quot;, inline: &quot;nearest&quot;}。 参数scrollIntoViewOptions一个带有选项的 object： 1234&#123; behavior: "auto" | "instant" | "smooth", block: "start" | "end",&#125; behavior 可选定义缓动动画， “auto”, “instant”, 或 “smooth” 之一。默认为 “auto”。 block 可选&quot;start&quot;, &quot;center&quot;, &quot;end&quot;, 或 &quot;nearest&quot;之一。默认为 &quot;center&quot;。 inline 可选&quot;start&quot;, &quot;center&quot;, &quot;end&quot;, 或 &quot;nearest&quot;之一。默认为 &quot;nearest&quot;。 浏览器支持 可以看到对于无参数的情况支持还是很好的，有参数的该API在浏览器中支持不是很好，我们可以同时结合CSS设置scroll-behavior: smooth;滚动效果，在执行滚动使用target.scrollIntoView()，即可达到“完美滚动”（不太完美）效果。 向下兼容要达到所有浏览器都有相同（类似）效果，那就要把剩余不支持scroll-behavior属性的浏览器揪出来，用js去完成使命了。 判断是否支持scroll-behavior属性很简单，用以下这一行代码 123456if(typeof window.getComputedStyle(document.body).scrollBehavior === 'undefined') &#123; // 兼容js代码&#125; else &#123; // 原生滚动api // Element.scrollIntoView()&#125; 判断是否支持scroll-behavior属性，直接利用原生Element.scrollIntoView()滚动，否则向下兼容处理。 缓冲算法缓冲的直观效果是越来越慢，直到停止，也就是在相同时间内运动的距离越来越短。这样可以设置一个定时器，移动到当前点到目标点距离的缓冲率（比如1/2，1/3，…）处，比如，缓冲率设为2，当前距离目标点64px，下一秒就是32px，然后16px，8px…，到达某个阈值结束，也就是： 1var position = position + (destination - position) / n; 下面来简单实现一个点击右下方的”回到顶部“按钮，页面缓动滚动到顶部的demo。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;div class="content"&gt; &lt;p&gt;很多内容。。。&lt;/p&gt; ... &lt;/div&gt; &lt;section class="back-to-top"&gt; 回到顶部 &lt;/section&gt;.content &#123; height: 3000px; border: 1px solid #ccc; box-shadow: 0 0 2px solid;&#125;.back-to-top &#123; width: 18px; padding: 10px; border: 1px solid #ccc; box-shadow: 0 0 2px #333; position: fixed; right: 20px; bottom: 40px;&#125;.back-to-top:hover &#123; cursor: pointer;&#125;var scrollTopSmooth = function (position) &#123; // 不存在原生`requestAnimationFrame`，用`setTimeout`模拟替代 if (!window.requestAnimationFrame) &#123; window.requestAnimationFrame = function (cb) &#123; return setTimeout(cb, 17); &#125;; &#125; // 当前滚动高度 var scrollTop = document.documentElement.scrollTop || document.body.scrollTop; // step var step = function () &#123; var distance = position - scrollTop; scrollTop = scrollTop + distance / 5; if (Math.abs(distance) &lt; 1) &#123; window.scrollTo(0, position); &#125; else &#123; window.scrollTo(0, scrollTop); requestAnimationFrame(step); &#125; &#125;; step();&#125;$backToTop = document.querySelector('.back-to-top')$backToTop.addEventListener('click', function () &#123; scrollTopSmooth(0);&#125;, false);&lt;/script&gt; 效果图 或者戳这里 简单封装上面的小demo中，缓冲算法和当前滚动业务代码耦合在一起了，下面单独拆解出单独一个函数。 1234567891011121314151617181920212223242526272829303132/*** 缓冲函数* @param &#123;Number&#125; position 当前滚动位置* @param &#123;Number&#125; destination 目标位置* @param &#123;Number&#125; rate 缓动率* @param &#123;Function&#125; callback 缓动结束回调函数 两个参数分别是当前位置和是否结束*/var easeout = function (position, destination, rate, callback) &#123; if (position === destination || typeof destination !== 'number') &#123; return false; &#125; destination = destination || 0; rate = rate || 2; // 不存在原生`requestAnimationFrame`，用`setTimeout`模拟替代 if (!window.requestAnimationFrame) &#123; window.requestAnimationFrame = function (fn) &#123; return setTimeout(fn, 17); &#125; &#125; var step = function () &#123; position = position + (destination - position) / rate; if (Math.abs(destination - position) &lt; 1) &#123; callback(destination, true); return; &#125; callback(position, false); requestAnimationFrame(step); &#125;; step();&#125; 拆分后，这个小缓冲算法就可以被重复调用啦，而且，适用于滚动到指定位置（不仅仅是到顶部）和缓冲率（控制滚动快慢），当前小demo调用： 123456789101112var scrollTopSmooth = function (position) &#123; // 当前滚动高度 var scrollTop = document.documentElement.scrollTop || document.body.scrollTop; easeout(scrollTop, position, 5, function (val) &#123; window.scrollTo(0, val); &#125;);&#125;$backToTop = document.querySelector('.back-to-top')$backToTop.addEventListener('click', function () &#123; scrollTopSmooth(200);&#125;, false); 总结综合来看，简单实现一个完美滚动注意以下即可 &lt;html&gt;，&lt;body&gt;标签加上scroll-behavior: smooth;属性； 判断当前浏览器是否支持scrollBehavior属性； 如果支持直接用原生滚动apiElement.scrollIntoView()； 如果不支持则用js小缓冲算法兼容处理。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现点击button滚动返回顶部动画]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2F%E5%AE%9E%E7%8E%B0%E7%82%B9%E5%87%BBbutton%E6%BB%9A%E5%8A%A8%E8%BF%94%E5%9B%9E%E9%A1%B6%E9%83%A8%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[实现点击button滚动返回顶部动画1234567891011121314//ES6写法 returnTop() &#123; let distance = document.documentElement.scrollTop || document.body.scrollTop; //获得当前高度 let step = distance / 20; //每步的距离 (function jump() &#123; console.log(1); if (distance &gt; 0) &#123; distance -= step; window.scrollTo(0, distance); setTimeout(jump, 10); &#125; &#125;)(); &#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[绘制虚线并且能够设置虚线宽度方法]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2F%E7%BB%98%E5%88%B6%E8%99%9A%E7%BA%BF%E5%B9%B6%E4%B8%94%E8%83%BD%E5%A4%9F%E8%AE%BE%E7%BD%AE%E8%99%9A%E7%BA%BF%E5%AE%BD%E5%BA%A6%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[绘制虚线并且能够设置虚线宽度方法:12345width: 100%;height: 2px;background-image: linear-gradient(to right, #ccc 0%, #ccc 50%, transparent 50%);background-size: 17px 2px;background-repeat: repeat-x;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5CSS3]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2FHTML5CSS3%2F</url>
    <content type="text"><![CDATA[CSS3CSS3是在CSS的接触上增加了很多新的特性，与低版本的CSS并不冲突介绍一些常用的特性 文本text-overflow clip剪切超出文本 ellipsis显示省略号 （需要与 overflow: hiddien ; white-space: nowrap 合用） 换行word-wrap允许长单词或 URL 地址换行到下一行 normal 只在允许的断字点换行 break-word 在长单词或 URL 地址内部进行换行 word-break自动换行的处理方法 normal 使用浏览器默认的换行规则 break-all 允许在单词内换行 keep-all 只能在半角空格或连字符处换行 white-space设置如何处理元素内的空白 normal 连续空白会被浏览器忽略 pre 空白会被浏览器保留 nowrap 文本不会换行，文本会在在同一行上继续，直到遇到标签为止 pre-wrap 保留空白符序列，但是正常地进行换行 pre-line 合并空白符序列，但是保留换行符 text-shadow文字阴影 ， 可以写多个，隔开(x, y, blur, color) 边框 borderborder-radius圆角半径 border-radius是缩写格式，可以把各个角单独拆分第一个值是圆角水平半径，第二个值是垂直半径,如果第二个值省略，那么其等于第一个值 border-image可以用图片作为边框的修饰 source 指定图片来源 width repeat stretch 压缩或伸展border-image的背景图片以其刚好适应border-width的宽度 repeat 简单的重复 round 压缩或伸展border-image的背景图片以图片最小单元刚好适应border-width的宽度，在此基础上重复 outset 边框图像区域超出边框的量 slice box-shadow盒子阴影效果: [inset] x-offset y-offset blur-radius spread-radius color阴影类型，X-offset，Y-offset，阴影模糊半径，阴影扩展半径，阴影颜色可以使用一个或多个投影，如果使用多个投影时必须需要用逗号,分开 box-sizing 框大小可以设置 width 和 height 属性中包含了 padding(内边距) 和 border(边框)。如果使用，推荐在所有元素使用 box-sizing background 背景background-size规定背景图片的尺寸 length: 设置背景图像的高度和宽度，第一个值设置宽度，第二个值设置高度，如果只设置一个值，则第二个值会被设置为auto percentage: 以父元素的百分比来设置背景图像的宽度和高度，第一个值设置宽度，第二个值设置高度，如果只设置一个值，则第二个值会被设置为auto cover: 把背景图像扩展至足够大，以使背景图像完全覆盖背景区域，背景图像的某些部分也许无法显示在背景定位区域中 contain: 把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域 background-origin相对于什么位置来定位 如果背景图像的 background-attachment 属性为fixed，则该属性没有效果 padding-box: 背景图像相对于内边距框来定位 border-box: 背景图像相对于边框盒来定位 content-box: 背景图像相对于内容框来定位 background-clip规定背景的绘制区域 padding-box: 背景被裁剪到边框盒 border-box: 背景被裁剪到内边距框 content-box: 背景被裁剪到内容框 多背景在之前的CSS中只能使用一张背景图片，CSS3可以使用多张背景图片 渐变 gradient（在background里设置） 线性渐变 linear-gradient在线性渐变过程中，颜色沿着一条直线过渡：从左侧到右侧、从右侧到左侧、从顶部到底部、从底部到顶部或着沿任何任意轴（[[&lt;angle&gt; | to &lt;side-or-corner&gt; ],]?&lt;color-stop&gt;[,&lt;color-stop&gt;]+） 径向渐变 radial-gradient径向渐变是圆形或椭圆形渐变。颜色不再沿着一条直线轴变化，而是从一个起点朝所有方向混合。但相对线性渐变要比径向渐变复杂的多。（[[&lt;shape&gt; || &lt;size&gt;] [at &lt;position&gt;]?,| at &lt;position&gt;,]?&lt;color-stop&gt;[,&lt;color-stop&gt;]+） 过渡 transition是元素从一种样式逐渐改变为另一种的效果: property, duration, timing-func, delay 这其实是一个简写形式，可以单独定义成各个属性 一般加在原始元素上 注意事项 目前，各大浏览器（包括IE 10）都已经支持无前缀的transition，所以transition已经可以很安全地不加浏览器前缀 transition需要明确知道，开始状态和结束状态的具体数值，才能计算出中间状态，什么none到block之类的是不行的 transition是一次性的，不能重复发生，除非一再触发 动画 animation先定义动画@keyframes ， 再绑定动画缩写: name, duration, timing-func, delay, fill-mode, direction, iteration-count animation-fill-mode动画结束以后，会立即从结束状态跳回到起始状态，此属性可以改变默认行为 none：默认值，回到动画没开始时的状态 forwards：让动画停留在结束状态 backwards：让动画回到第一帧的状态 both: 根据animation-direction（见后）轮流应用forwards和backwards规则 animation-direction动画循环播放时，每次都是从结束状态跳回到起始状态，再开始播放。animation-direction属性，可以改变这种行为 还可以取alternate、reverse、alternate-reverse等值 最常用的值是normal和reverse。浏览器对其他值的支持情况不佳，应该慎用 animation-play-state有时，动画播放过程中，会突然停止。这时，默认行为是跳回到动画的开始状态，如果想让动画保持突然终止时的状态，就要使用animation-play-state属性。 paused running 不可写进缩写 变形 transform修改元素的变形、旋转、缩放、倾斜特性，在CSS3中transform主要包括以下几种：旋转rotate、扭曲skew、缩放scale和移动translate以及矩阵变形matrix transform中使用多个属性时却需要有空格隔开，可用于内联(inline)元素和块级(block)元素 rotate 旋转可以通过rotate使元素旋转一定的度数 旋转是顺时针的 旋转之后元素仍占据原来位置，实际上所有的transform都是这样，缩放、位移等都不会改变元素占据的位置 元素旋转的的基点默认是中心，可以通过transform-origin属性改变 transform-origin的取值可以是 top, bottom, left, right, center 百分数 transform-origin属性对下面介绍的transform都有作用 translate 位移使元素平移 scale 缩放可以通过scale使元素缩放一定的比例，和translate类似，也有三个方法 scale(x,y)：使元素水平方向和垂直方向同时缩放 scaleX(x)：元素仅水平方向缩放 scaleY(y)：元素仅垂直方向缩放 对于scale只设置一个参数，一相同的比例缩放两个方向 skew 扭曲可以通过skew使元素扭曲一定的度数，和上面一样也有三中类似的用法 transform:skew(10deg, 20deg);transform:skewX(10deg);transform:skewY(10deg);transform:skew(10deg); matrix 矩阵matrix(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;) 以一个含六值的(a,b,c,d,e,f)变换矩阵的形式指定一个2D变换，相当于直接应用一个[a b c d e f]变换矩阵。 就是基于水平方向（X轴）和垂直方向（Y轴）重新定位元素,此属性值使用涉及到数学中的矩阵，感兴趣大家可以自己了解一下 3D效果CSS3带来了DOM的3D效果，元素需要设置需要设置perspective来激活3D效果，可以通过两种方式实现 在transform属性中使用perspective方法transform: perspective( 600px ); 直接使用perspective属性perspective: 600px; perspective属性的值决定了3D效果的强烈程度，可以认为是观察者到页面的距离。值越大距离越远，视觉上的3D效果就会相应的减弱。 这两种方式都会触发3D效果，但是有一点不同： 第一种方式直接在一个元素上触发3D变形，但是当多个元素的时候变形效果和预期会有所不同，如果使用同样的方法作用于不同位置的元素的时候，每个元素会有自己的轴心 为了解决这个问题，需要在父元素使用perspective属性，这样每个子元素都共享相同的3D空间 12345rotateX( angle )rotateY( angle )rotateZ( angle )translateZ( tz )scaleZ( sz ) 有几个变形方法的缩写，这些方法需要把三个参数写全 123translate3d( tx, ty, tz )scale3d( sx, sy, sz )rotate3d( rx, ry, rz, angle ) 任意3D操作会触发硬件加速，甚至可能变形只用到了2D的，或者没有做任何事情（比如translate3d(0,0,0)）。需要注意的是这只是当前的表现，未来可能变化（这也是为什么我们没有写文档或者鼓励这么做），但是这在很多场景下非常有用，可以显著的提高渲染性能 HTML5介绍，特性 见下题目一、二 Cookie, LocalStorage 与 SessionStorage 的异同基本概念CookieCookie 是小甜饼的意思。顾名思义，cookie 确实非常小，它的大小限制为4KB左右，是网景公司的前雇员 Lou Montulli 在1993年3月的发明。它的主要用途有保存登录信息，比如你登录某个网站市场可以看到“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。 localStoragelocalStorage 是 HTML5 标准中新加入的技术，它并不是什么划时代的新东西。早在 IE 6 时代，就有一个叫 userData 的东西用于本地存储，而当时考虑到浏览器兼容性，更通用的方案是使用 Flash。而如今，localStorage 被大多数浏览器所支持，如果你的网站需要支持 IE6+，那以 userData 作为你的 polyfill 的方案是种不错的选择。 sessionStoragesessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。做过后端开发的同学应该知道 Session 这个词的意思，直译过来是“会话”。而 sessionStorage 是一个前端的概念，它只是可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但当页面关闭后，sessionStorage 中的数据就会被清空。 特性 Cookie localStorage sessionStorage 数据的生命期 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效 除非被清除，否则永久保存 仅在当前会话下有效，关闭页面或浏览器后被清除 存放数据大小 4K左右 一般为5MB 与服务器端通信 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 仅在客户端（即浏览器）中保存，不参与和服务器的通信 易用性 需要程序员自己封装，源生的Cookie接口不友好 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 一般情况下浏览器端不会修改 cookie，但会频繁操作两个storage cookie有path概念，子路径可以访问父路径 cookie，父路径不能访问子路径 cookie 共享：sessionStorage不能共享，localStorage在同源文档之间共享， cookie在同源且符合path规则的文档之间共享 如果保存了 cookie的话，http请求中一定会带上；而两个storage可以由脚本选择性的提交 安全性方面， cookie中最好不要放置任何明文的东西。两个storage的数据提交后在服务端一定要校验 localStorage和sessionStorage的主要区别在于存储的有效期和作用域不同。localStorage存储的数据是永久性的，其作用域限定在文档源级别（只要URL的协议、端口、主机名三者中有一个不同，就属于不同的文档源）。除此之外，localStorage也受浏览器供应商限制，如果使用chrome访问一个网站，下次用firefox再次访问是获取不到上次存储的数据的。 而sessionStorage的有效期仅存在于浏览器的标签页。也就是说如果关闭标签页后，通过sessionStorage存储的数据就都被删除了。sessionStorage的作用域不仅被限制在文档源，还被限定在窗口中，也就是同一标签页中。注意，这里说的窗口是指顶级窗口，若果同一标签页中包含多个&lt;iframe&gt;元素，这两者之间也是可以共享sessionStorage的。 使用 local storage和session storage主要通过在js中操作这两个对象来实现，分别为window.localStorage和window.sessionStorage. 这两个对象均是Storage类的两个实例，自然也具有Storage类的属性和方法。 但是cookie需要前端开发者自己封装setCookie，getCookie。但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。 相同 三者都是键值对的集合 都会在浏览器端保存，有大小限制，同源限制 应用场景有了对上面这些差别的直观理解，我们就可以讨论三者的应用场景了。 因为考虑到每个 HTTP 请求都会带着 Cookie 的信息，所以 Cookie 要非常精简，比较常用的一个应用场景就是判断用户是否登录。针对登录过的用户，服务器端会在他登录时往 Cookie 中插入一段加密过的唯一辨识单一用户的辨识码，下次只要读取这个值就可以判断当前用户是否登录啦。曾经还使用 Cookie 来保存用户在电商网站的购物车信息，如今有了 localStorage，在这个方面就不需要cookie了。 而另一方面 localStorage 接替了 Cookie 管理购物车的工作，同时也能胜任其他一些工作。比如HTML5游戏通常会产生一些本地数据，localStorage 也是非常适用的。如果遇到一些内容特别多的表单，为了优化用户体验，我们可能要把表单页面拆分成多个子页面，然后按步骤引导用户填写。这时候 sessionStorage 的作用就发挥出来了。 cookie与session的区别于联系（1）cookie与session的区别：cookie数据保存在客户端，session数据保存在服务器端 如果web服务器端使用的是session，那么所有的数据都保存在服务器上，客户端每次请求服务器的时候会发送当前会话的sessionid，服务器根据当前sessionid判断相应的用户数据标志，以确定用户是否登录或具有某种权限。由于数据是存储在服务器上面，所以你不能伪造，但是如果你能够获取某个登录用户的 sessionid，用特殊的浏览器伪造该用户的请求也是能够成功的。sessionid是服务器和客户端链接时候随机分配的，一般来说是不会有重复，但如果有大量的并发请求，也不是没有重复的可能性。 如果浏览器使用的是cookie，那么所有的数据都保存在浏览器端，比如你登录以后，服务器设置了cookie用户名，那么当你再次请求服务器的时候，浏览器会将用户名一块发送给服务器，这些变量有一定的特殊标记。服务器会解释为cookie变量，所以只要不关闭浏览器，那么cookie变量一直是有效的，所以能够保证长时间不掉线。如果你能够截获某个用户的 cookie变量，然后伪造一个数据包发送过去，那么服务器还是认为你是合法的。所以，使用 cookie被攻击的可能性比较大。如果设置了的有效时间，那么它会将 cookie保存在客户端的硬盘上，下次再访问该网站的时候，浏览器先检查有没有 cookie，如果有的话，就读取该 cookie，然后发送给服务器。如果你在机器上面保存了某个论坛 cookie，有效期是一年，如果有人入侵你的机器，将你的 cookie拷走，然后放在他的浏览器的目录下面，那么他登录该网站的时候就是用你的的身份登录的。所以 cookie是可以伪造的。当然，伪造的时候需要主意，直接copy cookie文件到 cookie目录，浏览器是不认的，他有一个index.dat文件，存储了 cookie文件的建立时间，以及是否有修改，所以你必须先要有该网站的 cookie文件，并且要从保证时间上骗过浏览器。 （2）cookie和session的共同之处：cookie和session都是用来跟踪浏览器用户身份的会话方式。 题目1： HTML5是什么？有哪些新特性？有哪些新增标签？如何让低版本的 IE 支持 HTML5新标签HTML5是什么:HTML5是超文本标记语言的第五次重大修改，2014年10月29日标准规范制定完成。 新特性： 语义特性HTML5赋予网页更好的意义和结构。更加丰富的标签将随着对RDFa的，微数据与微格式等方面的支持，构建对程序、对用户都更有价值的数据驱动的Web。 本地存储特性基于HTML5开发的网页APP拥有更短的启动时间，更快的联网速度，这些全得益于HTML5 APP Cache，以及本地存储功能。Indexed DB（html5本地存储最重要的技术之一）和API说明文档。 设备兼容特性从Geolocation功能的API文档公开以来，HTML5为网页应用开发者们提供了更多功能上的优化选择，带来了更多体验功能的优势。HTML5提供了前所未有的数据与应用接入开放接口。使外部应用可以直接与浏览器内部的数据直接相连，例如视频影音可直接与microphones及摄像头相联。 连接特性更有效的连接工作效率，使得基于页面的实时聊天，更快速的网页游戏体验，更优化的在线交流得到了实现。HTML5拥有更有效的服务器推送技术，Server-Sent Event和WebSockets就是其中的两个特性，这两个特性能够帮助我们实现服务器将数据“推送”到客户端的功能。 网页多媒体特性支持网页端的Audio、Video等多媒体功能， 与网站自带的APPS，摄像头，影音功能相得益彰。三维、图形及特效特性（Class: 3D, Graphics &amp; Effects）基于SVG、Canvas、WebGL及CSS3的3D功能，用户会惊叹于在浏览器中，所呈现的惊人视觉效果。 性能与集成特性没有用户会永远等待你的Loading——HTML5会通过XMLHttpRequest2等技术，解决以前的跨域等问题，帮助您的Web应用和网站在多样化的环境中更快速的工作。 CSS3特性在不牺牲性能和语义结构的前提下，CSS3中提供了更多的风格和更强的效果。此外，较之以前的Web排版，Web的开放字体格式（WOFF）也提供了更高的灵活性和控制性 新增标签 元素 描述 canvas 标签定义图形，比如图表和其他图像。该标签基于 JavaScript 的绘图 API audio 定义音频内容 video 定义视频（video 或者 movie） source 定义多媒体资源 &lt;video&gt; 和&lt;audio&gt; embed 定义嵌入的内容，比如插件 track 为诸如 &lt;video&gt; 和 &lt;audio&gt; 元素之类的媒介规定外部文本轨道 datalist 定义选项列表。与 input 元素配合使用该元素，来定义 input 可能的值 keygen 规定用于表单的密钥对生成器字段 output 定义不同类型的输出，比如脚本的输出 article 定义页面正文内容 aside 定义页面内容之外的内容 bdi 设置一段文本，使其脱离其父元素的文本方向设置 command 定义命令按钮，比如单选按钮、复选框或按钮 details 用于描述文档或文档某个部分的细节 dialog 定义对话框，比如提示框 summary 标签包含 details 元素的标题 figure 规定独立的流内容（图像、图表、照片、代码等等） figcaption 定义 &lt;figure&gt; 元素的标题 footer 定义 section 或 document 的页脚 header 定义了文档的头部区域 mark 定义带有记号的文本 meter 定义度量衡。仅用于已知最大和最小值的度量 nav 导航 progress 定义任何类型的任务的进度 ruby 定义 ruby 注释（中文注音或字符） rt 定义字符（中文注音或字符）的解释或发音 rp 在 ruby 注释中使用，定义不支持 ruby 元素的浏览器所显示的内容 section 定义文档中的节（section、区段） time 定义日期或时间 wbr 规定在文本中的何处适合添加换行符 让低版本的 IE 支持 HTML5新标签使用html5shiv.js 123&lt;!--[if lt IE 9]&gt; &lt;script type="text/javascript" src="scripts/html5shiv.js"&gt;&lt;/script&gt;&lt;![endif]--&gt; 注意 如果版本小于IE9就引入html5shiv.js，IE9以前的浏览器就能使用h5标签，并使用定义好的样式了。这个标签必须放在head标签内，因为浏览器要在解析之前知道这个元素。 也可以直接声明 123&lt;!--[if lt IE 9]&gt; (function()&#123;if(!/*@cc_on!@*/0)return;var e = "abbr,article,aside,audio,canvas,datalist,details,dialog,eventsource,figure,footer,header,hgroup,mark,menu,meter,nav,output,progress,section,time,video".split(','),i=e.length;while(i--)&#123;document.createElement(e[i])&#125;&#125;)()&lt;![endif]--&gt; 题目2： input 有哪些新增类型？ color date datetime-local email 个月 number range search tel time url week 题目3： 浏览器本地存储中 cookie 和 localStorage 有什么区别？ localStorage 如何存储删除数据。 特性 Cookie localStorage 数据的生命期 默认情况下，cookie开始于浏览器启动，结束于浏览器关闭，但是可以手动设置cookie的过期时间，同时，到期后被删除 除非被清除，否则永久保存 存放数据大小 4K左右 一般为5MB 与服务器端通信 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 仅在客户端（即浏览器）中保存，不参与和服务器的通信 易用性 需要程序员自己封装，源生的Cookie接口不友好 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 localStorage存储数据：12localStorage.setItem(key,value);localStorage.key = value; localStorage删除数据：12localStorage.removeItem(key) //删除指定数据localStorage.clear() //删除所有数据 localStorage读取数据：12localStorage.getItem(key,value);localStorage.key = value;]]></content>
      <categories>
        <category>CSS</category>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[media用法总结]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2Fmedia%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[CSS3 @media 用法总结1234//语法：@media mediatype and | not | only (media feature) &#123; css-code; &#125;//也可以针对不同的媒体使用不同的stylesheets: &lt;link rel="stylesheet" media="mediatype and|not|only (media feature)" href="mystylesheet.css"&gt; 一、首先是&lt;meta&gt;标签1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"&gt; 这段代码的几个参数解释： width = device-width：宽度等于当前设备的宽度 initial-scale：初始的缩放比例（默认设置为1.0） minimum-scale：允许用户缩放到的最小比例（默认设置为1.0） maximum-scale：允许用户缩放到的最大比例（默认设置为1.0） user-scalable：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面） 二、&lt;head&gt;标签中引入（CSS2 media）其实并不是只有CSS3才支持Media的用法，早在CSS2开始就已经支持Media，具体用法，就是在HTML页面的head标签中插入如下代码： 例如我们想知道现在的移动设备是不是纵向放置的显示屏，可以这样写： 1&lt;link rel="stylesheet" type="text/css" media="screen and (orientation:portrait)" ;href="style.css"&gt; 页面宽度小于960的执行指定的样式文件： 1&lt;link rel="stylesheet" type="text/css" media="screen and (max-width:960px)" href="style.css"&gt; 既然CSS2可以实现CSS的这个效果为什么不用这个方法呢，很多人应该会问，但是上面这个方法，最大的弊端是他会增加页面http的请求次数，增加了页面负担，我们用CSS3把样式都写在一个文件里面才是最佳的方法。 下面来解释一下遇到冲突时的机制： 123&lt;link rel="stylesheet" href="styleA.css" media="screen and (min-width: 800px)"&gt; &lt;link rel="stylesheet" href="styleB.css" media="screen and (min-width: 600px) and (max-width: 800px)"&gt; &lt;link rel="stylesheet" href="styleC.css" media="screen and (max-width: 600px)"&gt; 上面将设备分成3种，分别是宽度大于800px时，应用 styleA ，宽度在600px到800px之间时应用 styleB ，以及宽度小于600px时应用 styleC 。那假如宽度正好等于800px时该应用那个样式？是 styleB，因为前两条表达式都成立，按CSS默认优先级规则后者覆盖了前者。 因此，为了避免冲突，这个例子正常情况应该这样写： 123&lt;link rel="stylesheet" href="styleA.css" media="screen"&gt; &lt;link rel="stylesheet" href="styleB.css" media="screen and (max-width: 800px)"&gt; &lt;link rel="stylesheet" href="styleC.css" media="screen and (max-width: 600px)"&gt; 三、回归CSS3 @media上面我们大概讲了下CSS2的媒体查询用法，现在我们重新回到CSS3的媒体查询，在第一段代码上面我用的是小于960px的尺寸的写法，那现在我们来实现等于960px尺寸的代码，以下代码需要写在style标签或者css文件中： 123@media screen and (max-device-width:960px)&#123; body&#123;background:red;&#125;&#125; 然后就是当浏览器尺寸大于960px时候的代码了： 123@media screen and (min-width:960px)&#123; body&#123;background:orange;&#125;&#125; 我们还可以混合使用上面的用法： 123@media screen and (min-width:960px) and (max-width:1200px)&#123; body&#123;background:yellow;&#125;&#125; 上面的这段代码的意思是当页面宽度大于960px小于1200px的时候执行下面的CSS。 四、Media所有参数汇总以上就是我们最常需要用到的媒体查询器的三个特性，大于，等于，小于的写法。媒体查询器的全部功能肯定不止这三个功能，下面是我总结的它的一些参数用法解释： width:浏览器可视宽度。 height:浏览器可视高度。 device-width:设备屏幕的宽度。 device-height:设备屏幕的高度。 orientation:检测设备目前处于横向还是纵向状态。 aspect-ratio:检测浏览器可视宽度和高度的比例。(例如：aspect-ratio:16/9) device-aspect-ratio:检测设备的宽度和高度的比例。 color:检测颜色的位数。（例如：min-color:32就会检测设备是否拥有32位颜色） color-index:检查设备颜色索引表中的颜色，他的值不能是负数。 monochrome:检测单色楨缓冲区域中的每个像素的位数。（这个太高级，估计咱很少会用的到） resolution:检测屏幕或打印机的分辨率。(例如：min-resolution:300dpi或min-resolution:118dpcm)。 grid:检测输出的设备是网格的还是位图设备。 12345(max-width:599px) (min-width:600px) (orientation:portrait) 竖屏(orientation:landscape) 横屏(-webkit-min-device-pixel-ratio: 2) 像素比 五、媒体类型1.all 所有媒体 2.braille 盲文触觉设备 3.embossed 盲文打印机 4.print 手持设备 5.projection 打印预览 6.screen 彩屏设备 7.speech ‘听觉’类似的媒体类型 8.tty 不适用像素的设备 9.tv 电视 六、关键字1.and 2.not not关键字是用来排除某种制定的媒体类型 3.only only用来定某种特定的媒体类型 -很多时候是用来对那些不支持媒体特性但却支持媒体类型的设备 七、浏览器支持情况IE8- IE9+ Chrome 5+ Opera 10+ Firefox 3.6+&lt; Safari 4+ 八、常用的几种屏幕宽度设定：123456789101112131415@media screen and (min-width: 1200px) &#123; css-code;&#125;@media screen and(min-width: 960px) and (max-width: 1199px) &#123; css-code;&#125;@media screen and(min-width: 768px) and (max-width: 959px) &#123; css-code;&#125;@media screen and(min-width: 480px) and (max-width: 767px) &#123; css-code;&#125;@media screen and (max-width: 479px) &#123; css-code;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS基础知识]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2FCSS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[CSS的全称是什么? Cascading Style Sheets 叠层样式表一种用来表现HTML或XML等文件样式的计算机语言。 CSS有几种引入方式? link 和@import 有什么区别? 内联样式内联方式指的是直接在HTML标签中的style属性中添加CSS。&lt;h1 style=&quot;color:red&quot;&gt; &lt;/h1&gt; 内部样式内部样式指的是在HTML头部中的标签中写CSS代码。 12345&lt;style type="text/css"&gt; h1&#123; color:red;&#125;&lt;/style&gt; 外部样式。分为链接和导入 链接方式链接方式指的是使用HTML头部的标签引入外部的CSS文件。 123&lt;head&gt;&lt;link rel="stylesheet" type="text/css" href="style.css"&gt;&lt;/head&gt; 导入方式导入方式指的是使用CSS规则引入外部CSS文件。 123&lt;style&gt; @import url(style.css);&lt;/style&gt; 比较link和@import区别link 属于 HTML，通过 标签中的 href 属性来引入外部文件，而 @import 属于 CSS，所以导入语句应写在 CSS 中，要注意的是导入语句应写在样式表的开头，否则无法正确导入外部文件；使用链接方式时，会在装置页面主体部分之前装载CSS文件，这样显示出来的网页从一开始就是带有样式的效果，而使用导入式时，会在整个页面装载完成后再装载CSS文件，对于有的浏览器来说，在一些情况下，如果网页文件的体积比较大，则会出现先显示无样式的页面，闪烁一下之后再出现样式设置后的效果。从浏览者的感受来说，这是使用导入式的一个缺陷。兼容性的差别。@import是CSS2.1提出，在IE5上才能识别。link无此问题。link支持使用Javascript控制DOM去改变样式；而@import不支持 以下这几种文件路径分别用在什么地方，代表什么意思? css/a.css：相对路径：代表当前目录下css文件夹中的a.css文件 ./css/a.css相对路径：代表当前目录下css文件夹中的a.css文件（加单个点与不加相同） b.css相对路径：代表当前目录下b.css文件 ../imgs/a.png相对路径：代表上级目录下imgs文件夹中的a.png文件 /Users/hunger/project/css/a.css/static/css/a.css绝对路径：代表本地绝对路径a.css文件 http://cdn.xxxx.com/kejian1/8-1.png网络路径：代表网站的图片路径 /static/css/a.css网站相对路径：代表网站服务器根目录static文件夹中的css文件夹中的a.css文件 如果我想在网页上展示一个图片，需要怎么操作? 将本地图片发到服务器上，或者直接从别的网站复制图片地址。使用&lt;img src=&quot;地址&quot;&gt; 列出5条以上html和 css 的书写规范 在每个 HTML 页面的第一行添加声明 添加标签 属性名 与之后的 :之间不允许包含空格，:与属性值之间必须包含空格。 使用英文小写 +、&gt;、~ 选择器的两边各保留一个空格。 RGB颜色值必须使用十六进制记号形式 #rrggbb。不允许使用 rgb()。 需要在 Windows 平台显示的中文内容，其字号应不小于 12px。 使用 4 个空格做为一个缩进层级，不允许使用 2 个空格 或 tab 字符别忘记结束符 使用外联式css样式 选择器 与 { 之间必须包含空格。 使用注释，方便以后或其他人理解]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS常见样式2]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2FCSS%E5%B8%B8%E8%A7%81%E6%A0%B7%E5%BC%8F2%2F</url>
    <content type="text"><![CDATA[CSS常见样式背景样式 属性 描述 background 简写属性，作用是将背景属性设置在一个声明中 background-attachment 背景图像是否固定或者随着页面的其余部分滚动 background-color 设置元素的背景颜色 background-image 把图像设置为背景 background-position 设置背景图像的起始位置 background-repeat 设置背景图像是否及如何重复 background-size 设置背景的大小(兼容性) background-position：默认左上角x yx% y%[top | center | bottom] [left | center | right] background-repeatno-repeat：背景图片在规定位置repeat-x：图片横向重复repeat-y：图片纵向重复repeat：全部重复 background-size100px 100pxcontaincover 12345background-color: #F00;background-image: url(background.gif);background-repeat: no-repeat;background-attachment: fixed;background-position: 0 0; 可以缩写为一句： background: #f00 url(background.gif) no-repeat fixed 0 0; 提醒： 要显示出background-img:容器需有 窗口，要被撑开。 text-align: center的作用是什么，作用在什么元素上？能让什么元素水平居中作用是让行内元素（包括inline-block）水平居中作用在要水平居中的行内元素的父元素上 IE 盒模型和W3C盒模型有什么区别?区别W3C标准盒模型中padding、border所占的空间不在width、height范围内，大家俗称的IE的盒模型width包括content尺寸＋padding＋border。 ie678怪异模式（不添加 doctype）使用 ie 盒模型，宽度=边框+padding+内容宽度。chrome， ie9+, ie678(添加 doctype) 使用标准盒模型， 宽度= 内容宽度。 { box-sizing: border-box;}的作用是什么？css3新样式box-sizing：允许以特定的方式定义匹配某个区域的特定元素值：box-sizing: content-box：w3c标准盒模型box-sizing: border-box：“IE盒模型” line-height: 2和line-height: 200%有什么区别?计算方法的区别。 数值：继承的时候，浏览器会先将line-height这个属性继承给子元素，再由子元素计算。根据自身元素font-size的2倍计算。 百分数：继承的时候，浏览器会先将行高对应的具体的数值计算出来以后再继承。根据父元素的font-size的200%计算。 另外 height = line-heihgt 可以用来 垂直居中单行文本 inline-block有什么特性？如何去除缝隙？高度不一样的inline-block元素如何顶端对齐? inline-block 内联块级元素，既能放在一行（内联元素特性），又能设置宽高及padding margin（块级元素特性）。 inline-block 元素间的空白/回车换行会产生缝隙，去除缝隙可以使html标签连续（无空白/折行），还可以设置其父元素font-size:0; 然后在inline-block元素内恢复font-size。 在父元素中使用vertical-align:top; 可以让高度不一样的inline-block 元素顶端对齐。（值还有更多） 行内元素和inline-block元素水平方向上默认情况下是按基线对齐 CSS sprite 是什么?CSS精灵图（雪碧图）CSS Sprites在国内很多人叫css精灵是一种网页图片应用处理方式。它允许你将一个页面涉及到的所有零星图片都包含到一张大图中去，这样一来，当访问该页面时，载入的图片就不会像以前那样一幅一幅地慢慢显示出来了。对于当前网络流行的速度而言，不高于200KB的单张图片的所需载入时间基本是差不多的，所以无需顾忌这个问题。加速的关键，不是降低重量，而是减少个数。传统切图讲究精细，图片规格越小越好，重量越小越好，其实规格大小无所谓，计算机统一都按byte计算。客户端每显示一张图片都会向服务器发送请求。所以，图片越多请求次数越多，造成延迟的可能性也就越大。 简单来说：指将不同的图片/图标合并在一张图上。使用CSS Sprite 可以减少网络请求，提高网页加载性能。 让一个元素”看不见”有几种方式？有什么区别?隐藏or透明 opacity: 0 ; 透明度为0，占据文档空间，元素绑定的事件还是会触发事件。 visibility: hidden ; 类似于 opacity:0，但绑定的事件不会触发。 background-color: rgba(0，0，0，0); 只是背景色透明 display:none; 消失，不占用位置，浏览器不会去绘制它，但存在于DOM树，绑定的事件不会触发。 前三种方法仅仅是改变其透明度，让其”假消失”，看不见，但存在。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS常见样式1]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2FCSS%E5%B8%B8%E8%A7%81%E6%A0%B7%E5%BC%8F1%2F</url>
    <content type="text"><![CDATA[CSS常见样式块级元素和行内元素分别有哪些？动手测试并列出4条以上的特性区别块级元素行内元素块级(block-level); 行内(内联、inline-level) 块级元素 VS 行内元素区别1：块级元素宽度占据整行，行内元素占据自身宽度的空间，能多个并列排序，直到一行排列不下，换下一行。区别2：块级元素可以包含块级元素和行内元素；行内元素内只能包含行内元素和文本区别3：块级元素可以设置宽高；行内元素则不能设置宽高（行内元素的高度是由line-height来决定，宽度由具体的内容来决定）区别4：块级元素可以设置上下左右的margin、padding 边距；行内元素只对左右方向的margin、padding生效，上下无效（行内元素对于上下padding，可以看到背景色和边框的影响，但高度还是无法撑开）区别5：块级元素，默认为display: block；行内元素表示为display:inline.区别6：行内元素可以”感受”到浮动元素的存在。 block-leveldiv h1 h2 h3 h4 h5 h6 p hrform ul dl ol pre tableli dd dt tr td th inline-levelem strong span a br imgbutton input label select textareacode script 什么是 CSS 继承? 哪些属性能继承，哪些不能？ css继承：继承就是子标签继承了上级标签的CSS样式的属性。 不可继承的：display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-bread-before和unicode-bidi。 所有元素可继承：visibility和cursor。 内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction。 终端块状元素可继承：text-indent和text-align。 列表元素可继承：list-style、list-style-type、list-style-position、list-style-image。 表格元素可继承：border-collapse。 如何让块级元素水平居中？如何让行内元素水平居中?水平居中 内联元素：在其父元素身上加 text-align:center； 块级元素： 固定宽度的div margin-left: auto margin-right: auto 不固定宽度的 div（有这种无脑需求？） margin: 0 100px; 用 CSS 实现一个三角形1234567 &lt;div class="box"&gt;&lt;/div&gt;.box &#123; width: 0; height: 0; border: 50px solid transparent; border-bottom: 50px solid #ccc;&#125; 设置块级元素的宽高都为0px，上下左右border设置实线solid，留一个设置为有颜色，其他三个为transparent透明，调整4个border的px可实现不同形状三角形(见最后任务4) 单行文本溢出加 …如何实现?首先设置不换行：white-space:nowrap;其次设置超出隐藏：overflow:hidden;再设置文本溢出显示为省略号：text-overflow:ellipsis; px, em, rem vw有什么区别 px 是绝对长度单位。em、rem 是相对长度单位 em如果用于font-size属性本身，则相对于父元素的font-size。若用于其它属性，则相对于元素本身的font-size当没有设置font-size时，chrome浏览器会有一个默认的 em 设置：1em = 16px缺点：容易混乱 remrem 是相对于根元素html的font-size属性的计算值，比较好计算当没有设置 font-size 时，浏览器会有一个默认的 rem 设置：1rem = 16px，这点与 em 是一致的兼容性：IE8-不支持 vw vh: 相对单位，1vw 为屏幕宽度的1% 兼容性 解释下面代码的作用?为什么要加引号? 字体里\5b8b\4f53代表什么?123body&#123; font: 12px/1.5 tahoma,arial,'Hiragino Sans GB','\5b8b\4f53',sans-serif;&#125; 设置body的字样为大小12px，1.5倍行高，字体选择依次为 tahoma,arial,’Hiragino Sans GB’,’\5b8b\4f53’,sans-serif有空格的内容要加引号，才会被认为是一个整体。不然会被认为是两个字体里\5b8b\4f53代表的是黑体的unicode码。文字先转化为相应的unicode码，再通过不同的字体库依据这个编码来转化为相应的字体(直接写成中文，浏览器有可能不能识别，所以要写成Unicode编码。) 去除元素默认 margin padding ：*{margin:0;padding:0} 颜色单词: red, blue, pink, yellow, white, black十六进制: #000000, #fff, #eee, #ccc, #666, #333, #f00, #0f0, #00frgb: rgb(255, 255, 255), rgb(0, 255, 0)rgba: rgba(0,0,0,0.5)更多 隐藏or透明opacity: 0 ; 透明度为0，整体visibility: hidden ; 和opacity:0 类似display:none; 消失，不占用位置background-color: rgba(0，0，0，0.2) 只是背景色透明 inline-block既呈现 inline 特性(不占据一整行，宽度由内容宽度决定)又呈现 block 特性 (可设置宽高，内外边距)缝隙问题 line-heightline-height: 2line-height: 100%height = line-heihgt 来垂直居中单行文本]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS选择器]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2FCSS%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[CSS选择器选择器类型 基础选择器 组合选择器 属性选择器 伪类选择器 伪元素选择器 基础选择器 选择器 含义 * 通用元素选择器，匹配页面任何元素（这也就决定了我们很少使用） #id id选择器，匹配特定id的元素 .class 类选择器，匹配class包含(不是等于)特定类的元素 element 标签选择器 组合选择器 选择器 含义 E,F 多元素选择器，用,分隔，同时匹配元素E或元素F E F 后代选择器，用空格分隔，匹配E元素所有的后代（不只是子元素、子元素向下递归）元素F E&gt;F 子元素选择器，用&gt;分隔，匹配E元素的所有直接子元素 E+F 直接相邻选择器，匹配E元素之后的相邻的同级元素F E~F 普通相邻选择器（弟弟选择器），匹配E元素之后的同级元素F（无论直接相邻与否） .class1.class2 id和class选择器和选择器连写的时候中间没有分隔符，. 和 # 本身充当分隔符的元素 element#id id和class选择器和选择器连写的时候中间没有分隔符，. 和 # 本身充当分隔符的元素 属性选择器 选择器 含义 E[attr] 匹配所有具有属性attr的元素，div[id]就能取到所有有id属性的div E[attr = value] 匹配属性attr值为value的元素，div[id=test],匹配id=test的div E[attr ~= value] 匹配所有属性attr具有多个空格分隔、其中一个值等于value的元素 E[attr ^= value] 匹配属性attr的值以value开头的元素 E[attr $= value] 匹配属性attr的值以value结尾的元素 E[attr *= value] 匹配属性attr的值包含value的元素 伪类选择器 选择器 含义 E:first-child 匹配作为长子（第一个子女）的元素E E:link 匹配所有未被点击的链接 E:visited 匹配所有已被点击的链接 E:active 匹配鼠标已经其上按下、还没有释放的E元素 E:hover 匹配鼠标悬停其上的E元素 E:focus 匹配获得当前焦点的E元素 E:lang(c) 匹配lang属性等于c的E元素 E:enabled 匹配表单中可用的元素 E:disabled 匹配表单中禁用的元素 E:checked 匹配表单中被选中的radio或checkbox元素 E::selection 匹配用户当前选中的元素 所有选择器列表在 MDN 伪类选择器 选择器 含义 E:root 匹配文档的根元素，对于HTML文档，就是HTML元素 E:nth-child(n) 匹配其父元素的第n个子元素，第一个编号为1 E:nth-last-child(n) 匹配其父元素的倒数第n个子元素，第一个编号为1 E:nth-of-type(n) 与:nth-child()作用类似，但是仅匹配使用同种标签的元素 E:nth-last-of-type(n) 与:nth-last-child() 作用类似，但是仅匹配使用同种标签的元素 E:last-child 匹配父元素的最后一个子元素，等同于:nth-last-child(1) E:first-of-type 匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1) E:last-of-type 匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(1) E:only-child 匹配父元素下仅有的一个子元素，等同于:first-child:last-child或 :nth-child(1):nth-last-child(1) E:only-of-type 匹配父元素下使用同种标签的唯一一个子元素，等同于:first-of-type:last-of-type或 :nth-of-type(1):nth-last-of-type(1) E:empty 匹配一个不包含任何子元素的元素，文本节点也被看作子元素 E:not(selector) 匹配不符合当前选择器的任何元素 n的取值1，2，3，4，52n+1, 2n, 4n-1odd, even 伪元素选择器 选择器 含义 E::first-line 匹配E元素内容的第一行 E::first-letter 匹配E元素内容的第一个字母 E::before 在E元素之前插入生成的内容 E::after 在E元素之后插入生成的内容 CSS优先级从高到低分别是 在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式 作为style属性写在元素标签上的内联样式 id选择器 类选择器 伪类选择器 属性选择器 标签选择器 通配符选择器 浏览器自定义 复杂场景12#test p.class1 &#123;...&#125;#test .class1.class2 &#123;...&#125; 行内样式 &lt;div style=&quot;xxx&quot;&gt;&lt;/div&gt;==&gt; a ID 选择器 ==&gt; b 类，属性选择器和伪类选择器 ==&gt; c 标签选择器、伪元素 ==&gt; d示例： 12345678910* &#123;&#125; /* a=0 b=0 c=0 d=0 -&gt; 0,0,0,0 */p &#123;&#125; /* a=0 b=0 c=0 d=1 -&gt; 0,0,0,1 */a:hover &#123;&#125; /* a=0 b=0 c=0 d=2 -&gt; 0,0,0,2 */ul li &#123;&#125; /* a=0 b=0 c=0 d=2 -&gt; 0,0,0,2 */ul ol+li &#123;&#125; /* a=0 b=0 c=0 d=3 -&gt; 0,0,0,3 */h1+input[type=hidden]&#123;&#125; /* a=0 b=0 c=1 d=2 -&gt; 0,0,1,1 */ul ol li.active &#123;&#125; /* a=0 b=0 c=1 d=3 -&gt; 0,0,1,3 */#ct .box p &#123;&#125; /* a=0 b=1 c=1 d=1 -&gt; 0,1,1,1 */div#header:after &#123;&#125; /* a=0 b=1 c=0 d=2 -&gt; 0,1,0,2 */style="" /* a=1 b=0 c=0 d=0 -&gt; 1,0,0,0 */ 样式覆盖123div &#123;color: #333;&#125;....div &#123;color: #666;&#125; 这样div文案的颜色明显会是#666 class 和 id 的使用场景?id是制定标签的唯一标识，格式为：&lt;input type=password id=&quot;userpwd&quot;&gt; ,id属性的值在当前的page页面要是唯一的。应用场景： 根据提供的唯一id号，快速获取标签对象。如：document.getElementById(id) 用于充当label标签for属性的值：示例：&lt;label for=&#39;userid&#39;&gt;用户名：&lt;/label&gt;，表示单击此label标签时，id为userid的标签获得焦点。 Class用来指定标签的类名，格式为&lt;input type=button class=&quot;btnsubmit&quot; /&gt;，可以把多个类，放在一个class属性里，但必须用空格隔开；如：class=&#39;btnsubmit btnopen&#39;应用场景：CSS操作，把一些特定样式放到一个class类中，需要此样式的标签，可以在添加此类。 a:link, a:hover, a:active, a:visited 的顺序是怎样的？ 为什么？正确顺序为：a:link、a:visited、a:hover、a:active原因： 鼠标经过的“未访问链接”同时拥有a:link、a:hover、a:active三种属性，后面的属性会覆盖前面的属性定义，所以a:link必须放在a:hover的前面，a:hover必须放在a:active的前 鼠标经过的“已访问链接”同时拥有a:visited、a:hover、a:link三种属性，后面的属性会覆盖前面的属性定义，此时a:visted和a:link必须放在a:hover的前面 以下选择器分别是什么意思? 选择器 意义 #header{} 选择id为header的元素 .header{} 选择class为header的元素 .header .logo{} 选择class为header元素下的子元素及所有后代元素class名为logo的元素 .header.mobile{} 选择同时有class名header和mobile的元素 .header p, .header h3{} 选择class为header下的所有p标签以及class为header所有h3标签 #header .nav&gt;li{} 选择id为header下的class为nav的直接子元素li #header a:hover{} 选择id为header下的所以a:hover的伪类选择器元素 #header .logo~p{} 选择id为header下的class为logo的元素之后的所有同级p标签 #header input[type=”text”]{} 选择id为header下的所有input标签的属性值type=”text”的元素 div:first-child、div:first-of-type、div :first-child和div :first-of-type的作用和区别 （注意空格的作用）div:first-child：匹配div元素父元素中的第一个div元素div :first-child：匹配div元素下的第一个子元素div:first-of-type：匹配div元素父元素下的同种类型(这里是div元素)的第一个元素div :first-of-type：匹配div元素下同种类型的第一个元素 运行如下代码，解析下输出样式的原因。12345678910111213&lt;style&gt;.item1:first-child&#123; color: red;&#125;.item1:first-of-type&#123; background: blue;&#125;&lt;/style&gt; &lt;div class="ct"&gt; &lt;p class="item1"&gt;aa&lt;/p&gt; &lt;h3 class="item1"&gt;bb&lt;/h3&gt; &lt;h3 class="item1"&gt;ccc&lt;/h3&gt; &lt;/div&gt; 原因： 123.item1:first-child&#123; color: red;&#125; 定义选择了class名为item1的父元素的第一个子元素，即div下的第一个元素p的文字颜色显示为红色 123.item1:first-of-type&#123; background: blue;&#125; 定义选择了class名为item1的父元素下的同种类型（p与h3）的第一个元素，即div下的p标签和第一个h3标签 （包括其嵌套的元素）的背景颜色显示为蓝色]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>选择器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浮动]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2F%E6%B5%AE%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[浮动基本概念浮动模型也是一种可视化格式模型，浮动的框可以左右移动（根据float属性值而定），直到它的外边缘碰到包含框或者另一个浮动元素的框的边缘。浮动元素不在文档的普通流中，文档的普通流中的元素表现的就像浮动元素不存在一样. 普通流：（normal flow)，或者称之为常规流。 浮动：浮动的框可以左右移动，直至它的外边缘遇到包含框或者另一个浮动框的边缘。浮动框不属于文档中的普通流，当一个元素浮动之后，不会影响到块级框的布局而只会影响内联框（通常是文本）的排列，文档中的普通流就会表现得和浮动框不存在一样，当浮动框高度超出包含框的时候，也就会出现包含框不会自动伸高来闭合浮动元素（“高度塌陷”现象）。顾名思义，就是漂浮于普通流之上，像浮云一样，但是只能左右浮动。 而 float 元素脱离了 normal flow 就相当于进入了一个平行空间，不再与其后边及父级块级元素发生反应，这一特性使得 float 元素无法撑起父元素的高度， 导致父元素塌陷。 其他的文本和行内元素环绕 float元素，但是 float 后的块级元素会与其发生重叠。 解决问题因为浮动元素的父元素有高度塌陷的问题。 (顺便可以解决浮动元素与普通流中的块级元素有重叠的问题)两种方案 采用clear属性清除浮动.通过在浮动元素的末尾添加一个空元素，设置 clear：both属性，after伪元素其实也是通过 content 在元素的后面生成了内容为一个块级元素. 让浮动元素的父元素形成BFC，可以包含浮动 实施采用clear属性： 浮动的父元素设置 :after伪元素，clear:both/left/right;，content=&quot;&quot;;， display:block/table;。a. 至于content里面是点还是其他都是可以的,里面内容为空firefox直到7.0 content:”” 仍然会产生额外的空隙(待亲自实验)。b. display:block 使生成的元素以块级元素显示,占满剩余空间。c. content 为点的话可以加 height:0 避免生成内容破坏原有布局的高度； visibility:hidden 使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互。 在浮动元素末尾加一个空div，并设置clear属性。 让浮动元素的父元素形成BFC： float: left / right(除none以外值) display: table-cell / table-caption / inline-block/flex/inline-flex overflow: hidden / auto / scroll (除visible以外) position: absolute / fixedBFC的几种方式都有各自的问题，上面提到使用BFC使用float的时候会使父容器长度缩短，而且还有个重要缺陷——父容器float解决了其塌陷问题，那么父容器的父容器怎么办？overflow属性会影响滚动条和绝对定位的元素；position会改变元素的定位方式，这是我们不希望的，display这几种方式依然没有解决低版本IE问题。 BFCBFC的全称是 Block Format Content 块级格式化上下文三个特性： BFC会阻止垂直外边距（margin-top、margin-bottom）重叠a. 按照BFC的定义，只有同属于一个BFC时，两个元素才有可能发生垂直margin的重叠，这个包括相邻元素，嵌套元素，只要他们之间没有阻挡(例如边框，非空内容，padding等)就会发生margin重叠。b. 因此要解决margin重叠问题，只要让它们不在同一个BFC就行了，但是对于两个相邻元素来说，意义不大，没有必要给它们加个外壳，但是对于嵌套元素来说就很有必要了，只要把父元素设为BFC就可以了。这样子元素的margin就不会和父元素的margin发生重叠 BFC不会重叠浮动元素 BFC可以包含浮动 通俗地来说：创建了 BFC的元素就是一个独立的盒子，里面的子元素不会在布局上影响外面的元素，反之亦然，同时BFC任然属于文档中的普通流。 我们可以利用BFC的第三条特性来“清浮动”，这里其实说清浮动已经不再合适，应该说包含浮动。也就是说只要父容器形成BFC就可以。 局限性上面提到使用BFC使用float的时候会使父容器长度缩短，而且还有个重要缺陷——父容器float解决了其塌陷问题，那么父容器的父容器怎么办？难道要全部使用folat吗（确实有这种布局方式倒是）。BFC的几种方式都有各自的问题，overflow属性会影响滚动条和绝对定位的元素；position会改变元素的定位方式，这是我们不希望的，display这几种方式依然没有解决低版本IE问题。。。 hasLayout我们知道在IE6、7内有个布局Layout的概念，很多bug正是由hasLayout导致的 当元素的hasLayout属性值为false的时候，元素的尺寸和位置由最近拥有布局的祖先元素控制当元素的hasLayout属性值为true的时候会达到和BFC类似的效果，元素负责本身及其子元素的尺寸设置和定位利用这点儿在IE6、7下完成清浮动，先看看怎么使元素hasLayout为true position: absolutefloat: left|rightdisplay: inline-blockwidth: 除 “auto” 外的任意值height: 除 “auto” 外的任意值zoom: 除 “normal” 外的任意值writing-mode: tb-rl在IE7中使用overflow: hidden|scroll|auto 也可以使hasLayout为true 综上所述： 在支持BFC的浏览器（IE8+，firefox，chrome，safari）可以通过创建新的BFC闭合浮动；在不支持 BFC的浏览器 （IE6-7），可以通过触发 hasLayout 闭合浮动。 通用的清理浮动方案一、 12345678910.clearfix:after &#123; content:"."; display:block; height:0; visibility:hidden; clear:both; &#125;.clearfix &#123; *zoom:1; &#125; display:block 使生成的元素以块级元素显示,占满剩余空间; height:0 避免生成内容破坏原有布局的高度。 visibility:hidden 使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互; 通过 content:”.”生成内容作为最后一个元素，至于content里面是点还是其他都是可以的，例如oocss里面就有经典的 content:”XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX”,有些版本可能content 里面内容为空,一丝冰凉不推荐这样做的,firefox直到7.0 content:”” 仍然会产生额外的空隙；(待验证，目前好像都是采用空的比较多) zoom：1 触发IE hasLayout。 二、 1234567891011// 全浏览器通用的clearfix方案// 引入了zoom以支持IE6/7.clearfix&#123; *zoom:1;&#125;.clearfix:after&#123; content:" "; display:table; clear:both;&#125; 如果我们想要与BFC行为保持一致，或者解决上边距折叠问题 三、精益求精方案：由Nicolas Gallagher 提出来的,原文:A new micro clearfix hackNicolas Gallagher，该方法也不存在firefox中空隙的问题。 1234567891011121314/* For modern browsers */// 全浏览器通用的clearfix方案【推荐】// 引入了zoom以支持IE6/7// 同时加入:before以解决现代浏览器上边距折叠的问题.cf:before,.cf:after &#123;content:" ";display:table;&#125;.cf:after &#123; clear:both; &#125;/* For IE 6/7 (trigger hasLayout) */.cf &#123; zoom:1; &#125; 需要注意的是：上面的方法用到了 ：before伪元素，是用来处理margin边距重叠的，由于内部元素 float 创建了BFC，导致内部元素的margin-top和 上一个盒子的margin-bottom 发生叠加。如果这不是你所希望的，那么就可以加上before，如果只是单纯的闭合浮动，after就够了 除了以上方案外，还有一些其他的方案，比如将父元素的 display 样式属性改为display:table或者position:fixed，但是这些方案容易带来更大的副作用，得不偿失，所以实践中一般都会使用clear属性/修改父元素的overflow属性]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFC]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2FBFC%2F</url>
    <content type="text"><![CDATA[BFC 已经是一个耳听熟闻的词语了，网上有许多关于 BFC 的文章，介绍了如何触发 BFC 以及 BFC 的一些用处（如清除浮动，防止 margin 重叠等）。 一、BFC是什么？ 在解释 BFC 是什么之前，需要先介绍 Box、Formatting Context的概念。 Box: CSS布局的基本单位Box 是 CSS 布局的对象和基本单位， 直观点来说，就是一个页面是由很多个 Box 组成的。元素的类型和 display 属性，决定了这个 Box 的类型。 不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染。让我们看看有哪些盒子： block-level box: display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context； inline-level box: display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context； run-in box: css3 中才有， 这儿先不讲了。 Formatting context Formatting context 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)。 CSS2.1 中只有 BFC 和 IFC, CSS3 中还增加了 GFC 和 FFC。 BFC 定义 BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。 BFC布局规则： 内部的Box会在垂直方向，一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算 二、哪些元素会生成BFC? 根元素 float属性不为none position为absolute或fixed display为inline-block, table-cell, table-caption, flex, inline-flex overflow不为visible 三、BFC的作用及原理1. 自适应两栏布局代码： 12345678910111213141516171819202122&lt;style&gt; body &#123; width: 300px; position: relative; &#125; .aside &#123; width: 100px; height: 150px; float: left; background: #f66; &#125; .main &#123; height: 200px; background: #fcc; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="aside"&gt;&lt;/div&gt; &lt;div class="main"&gt;&lt;/div&gt;&lt;/body&gt; 根据BFC布局规则第3条： 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 因此，虽然存在浮动的元素aside，但main的左边依然会与包含块的左边相接触。 根据BFC布局规则第四条： BFC的区域不会与float box重叠。 我们可以通过触发main生成BFC， 来实现自适应两栏布局。 123.main &#123; overflow: hidden;&#125; 当触发main生成BFC后，这个新的BFC为了不与浮动的aside重叠。因此会根据包含块的宽度，和aside的宽度，自动变窄。效果如下：： 2. 清除内部浮动代码： 12345678910111213141516171819 &lt;style&gt; .par &#123; border: 5px solid #fcc; width: 300px; &#125; .child &#123; border: 5px solid #f66; width:100px; height: 100px; float: left; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="par"&gt; &lt;div class="child"&gt;&lt;/div&gt; &lt;div class="child"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 根据BFC布局规则第六条： 计算BFC的高度时，浮动元素也参与计算 解决方案一般有两种1). 利用 clear属性，清除浮动 123对父元素加一个class:floatfix添加如下CSS 12345678.floatfix&#123; *zoom:1;&#125;.floatfix:after&#123; content:""; display:table; clear:both;&#125; 2). 使父容器形成BFC 为达到清除内部浮动，我们可以触发par生成BFC，那么par在计算高度时，par内部的浮动元素child也会参与计算。 代码： 123 .par &#123; overflow: hidden;&#125; 效果如下： 3. 防止垂直 margin 重叠代码： 1234567891011121314 &lt;style&gt; p &#123; color: #f55; background: #fcc; width: 200px; line-height: 100px; text-align:center; margin: 100px; &#125;&lt;/style&gt;&lt;body&gt; &lt;p&gt;Haha&lt;/p&gt; &lt;p&gt;Hehe&lt;/p&gt;&lt;/body&gt; 页面： 两个p之间的距离为100px，发送了margin重叠。 根据BFC布局规则第二条： Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 折叠的结果： 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。 两个外边距一正一负时，折叠结果是两者的相加的和。 我们可以在p外面包裹一层容器，并触发该容器生成一个BFC。那么两个P便不属于同一个BFC，就不会发生margin重叠了。 代码： 12345678910111213141516171819&lt;style&gt; .wrap &#123; overflow: hidden; &#125; p &#123; color: #f55; background: #fcc; width: 200px; line-height: 100px; text-align:center; margin: 100px; &#125;&lt;/style&gt;&lt;body&gt; &lt;p&gt;Haha&lt;/p&gt; &lt;div class="wrap"&gt; &lt;p&gt;Hehe&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 效果如下: 浮动和绝对定位不与任何元素产生 margin 折叠原因： 浮动元素和绝对定位元素不与其他盒子产生外边距折叠是因为元素会脱离当前的文档流，违反了上面所述的两个margin是邻接的条件同时，又因为浮动和绝对定位会使元素为它的内容创建新的BFC，因此该元素和子元素所处的BFC是不相同的，因此也不会产生margin的折叠。 自己经验添加父子元素margin合并可以给父元素添加border或者padding解决 高级解决父子元素margin合并问题: 1.no-collapse::before&#123;content:'';display:table;&#125;,.no-collapse::after&#123;content:'';display:table;&#125; 总结 其实以上的几个例子都体现了BFC布局规则第五条： BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 因为BFC内部的元素和外部的元素绝对不会互相影响，因此， 当BFC外部存在浮动时，它不应该影响BFC内部Box的布局，BFC会通过变窄，而不与浮动有重叠。同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见布局居中]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2F%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[两栏布局左侧固定宽度右边自适应负margin方法：1234567891011121314151617181920&lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt;.left&#123; width:200px; height:300px; margin-right:10px; background:red; float:left;&#125;.right&#123; width:100%; height:400px; float:right; margin-right:-210px; background:blue;&#125;&lt;/style&gt; overflow方法:123456789101112131415161718&lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt;.left&#123; width:200px; height:300px; margin-right:10px; background:red; float:left;&#125;.right&#123; height:400px; background:blue; overflow:hidden;&#125;&lt;/style&gt; position方法:12345678910111213141516171819202122232425&lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt;.container&#123; position:relative;&#125;.left&#123; position:absolute; top:0; left:0; width:200px; height:300px; background:red;&#125;.right&#123; position:absolute; top:0; left:210px; right:0; height:400px; background:blue;&#125;&lt;/style&gt; flex方法:1234567891011121314151617181920&lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt;.container&#123; display:flex;&#125;.left&#123; width:200px; height:300px; background:red; margin-right:10px;&#125;.right&#123; flex:1; height:400px; background:blue;&#125;&lt;/style&gt; 三栏布局margin方法1234567891011121314151617181920212223242526&lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;div class="center"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt;.left&#123; width:200px; height:300px; background:red; margin:0 10px; float:left;&#125;.center&#123; height:400px; background:pink; overflow:auto;&#125;.right&#123; width:200px; height:300px; background:blue; float:right; margin:0 10px;&#125;&lt;/style&gt; overflow方法1234567891011121314151617181920212223242526&lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;div class="center"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt;.left&#123; width:200px; height:300px; background:red; margin:0 10px; float:left;&#125;.center&#123; height:400px; background:pink; overflow:auto;&#125;.right&#123; width:200px; height:300px; background:blue; float:right; margin:0 10px;&#125;&lt;/style&gt; position方法12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt;&lt;style&gt;*&#123; box-sizing:border-box; margin:0; padding:0;&#125;.container&#123; position:relative;&#125;.left&#123; width:200px; height:300px; background:red; margin:0 10px; position:absolute; top:0; left:0;&#125;.center&#123; width:calc(100% - 440px); height:400px; background:pink; position:absolute; top:0; left:50%; transform:translateX(-50%);&#125;.right&#123; width:200px; height:300px; background:blue; position:absolute; top:0; right:0; margin:0 10px;&#125;&lt;/style&gt; flex方法123456789101112131415161718192021222324252627282930313233&lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt;*&#123; box-sizing:border-box; padding:0; margin:0;&#125;.container&#123; display:flex;&#125;.left&#123; width:200px; height:300px; background:red; margin:0 10px; &#125;.center&#123; height:400px; background:pink; flex:1;&#125;.right&#123; width:200px; height:300px; background:blue; margin:0 10px;&#125;&lt;/style&gt; 块级元素居中margin方法123456789.container&#123; background:grey;&#125;.item&#123; width:300px; height:200px; background:red; margin:0 auto;&#125; position方法12345678910111213.container&#123; background:grey; position:relative;&#125;.item&#123; width:300px; height:200px; background:red; position:absolute; top:0; left:50%; transform:translateX(-50%)&#125; display:flex12345678910.container&#123; background:grey; display:flex; justify-content:center;&#125;.item&#123; width:300px; height:200px; background:red;&#125; text-align:center 12345678910.container&#123; background:grey; text-align:center;&#125;.item&#123; width:300px; height:200px; background:red; display:inline-block;&#125; 多行文字水平垂直居中123456789101112131415161718192021&lt;section&gt; &lt;div class="container"&gt; &lt;h1 class="title"&gt;这是标题&lt;/h1&gt; &lt;p class="content"&gt;这是一大段文字内容这是一大段文字内容这是一大段文字内容这是一大段文字内容这是一大段文字内容这是一大段文字内容&lt;/p&gt; &lt;/div&gt;&lt;/section&gt;&lt;style&gt;section&#123; margin:0 auto; width:600px;&#125;.container&#123; padding:0 100px; width:600px; height:600px; background:grey; text-align:center; display:table-cell; vertical-align:middle;&#125;&lt;/style&gt; image水平垂直居中123456789101112131415161718 &lt;div class="container"&gt; &lt;img src="" alt="图片"&gt; &lt;/div&gt;.container&#123; width:300px; height:300px; border:1px solid red; text-align:center;&#125;.container::after&#123; content:''; height:100%; display:inline-block; vertical-align:middle;&#125;img&#123; vertical-align:middle;&#125; 浏览器固定水平垂直居中12345678.box&#123; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:#ccc; text-align:center;&#125; 水平居中SVG和font/img1234567svg&#123;vertical-align:middle&#125;span&#123;vertical-align:middle&#125;img&#123; vertical-align:middle&#125; 经典文章:https://www.zhangxinxu.com/wordpress/2015/08/css-deep-understand-vertical-align-and-line-height/]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见布局居中]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2F%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E5%8A%A0-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[文本溢出加 … 如何实现单行12345span&#123;overflow:hidden;text-overflow:ellipsis;white-space:nowarp;&#125; 多行1234567span&#123;width:100px,display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:3; //行数overflow:hidden;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>布局</tag>
        <tag>FONT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex布局]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2Fflex%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[常见布局 normal flow（正常流） float + clear（浮动+清楚浮动） position relative + absolute （相对定位+绝对定位） display inline-block （改变元素属性） -margin（负外边距） Flex布局特性 块级布局侧重垂直方向、行内布局侧重水平方向，flex布局是与方向无关的 flex布局可以实现空间自动分配、自动对齐（全称:the flexible box Module） flex适用于简单的线性布局，更复杂的布局要交给grid布局（目前还没发布） ​ 语法 display: flex; display: inline-flex; 设为Flex布局后，子元素的loat,clear和vertical-align属性将失效。 Flex基础概念采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。 上图水平是主轴(main axis)垂直是侧轴(cross axis)。主轴的开始位置叫做main start，结束位置叫做main end；侧轴的开始位置叫做cross start，结束位置叫做cross end 。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的侧轴空间叫做cross size。 Flex container容器属性flex-direction: 决定了主轴的方向（即项目的排列方向)1234.box&#123; display:flex; flex-direction:column-revers|column|row-reverse|row; &#125; 属性名 说明 row(默认) 主轴方向为水平，起点在左端 row- reverse 主轴方向为水平，起点在右端 column 主轴方向为垂直，起点在上端 column-reverse 主轴方向为垂直，起点在下端 单独添加flex-direction: row; //默认是不会换行 flex-wrap: 定义如果一条轴线排不下，如何换行12345.box&#123; display:flex; flex-direction:now flex-wrap:wrap; &#125; 属性名 说明 nowrap(默认) 不换行 wrap 换行 wrap-reverse 换行反转 flex-flow（以上两个属性的简写） flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 1234.box&#123; display:flex; flex-flow: row nowrap; &#125; justify-content:定义了项目在主轴上的对齐方式1234.box&#123; display:flex; justify-content:flex-start | flex-end | center | space-between | space-around;&#125; 属性名 说明 flex-start(默认) 项目沿着主轴方向的起始位置靠齐 flex-end 项目沿着主轴方向的结束位置靠齐，和flex-start相反 space-between 项目在主轴方向上两端对齐，其中的间隔相等 space-around 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍 align-items定义项目在交叉轴上如何对齐1234.box&#123; display:flex; align-items:flex-start | flex-end | center | baseline | stretch;&#125; 属性名 说明 flex-start 项目沿着侧轴上的起点对齐 flex-end 项目沿着侧轴上的终点对齐 center 项目在侧轴方向上居中对齐 stretch(默认) 如果项目未设置高度或高度为auto,将占满整个容器的高度。 align-content多行多列内容对齐方式注意如果项目只有一行，属性不起作用 1234.box&#123; display:flex; align-content:flex-start | flex-end | center | space-between | space-around | stretch;&#125; 属性名 说明 flex-start 项目与侧轴的起点对齐 flex-end 项目与侧轴的终点对齐 center 项目与侧轴的中点对齐 space-between 与侧轴两端对齐，轴线之间的间隔平均分布 space-around 每行轴线两侧的间隔都相等。所以轴线之间的间隔比轴线与边框的间隔大一倍 stretch（默认） 轴线占满整个测轴 flex item项目属性 order属性：定义项目的排列顺序。数值越小，排列越靠前，默认为0 .item{order: &lt;integer&gt;;} flex-grow属性:定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大 .item{flex-grow:&lt;number&gt;;} flex-grow为零的话则不变化，不能为負值。如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项的2倍。 flex-shrink属性：定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小 .item{flex-shrink:&lt;number&gt;;} 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。 flex-basis属性:定义了在分配多余空间之前，项目占据的主轴空间（main size） 浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。它可以设为跟width或height属性一样的值，则项目将占据固定空间 .item{flex-basis: &lt;length&gt;| auto; flex属性：flex-grow,flex-shrink和flex-basis的简写 默认值为0 1 auto。后两个属性可选。该属性有两个快捷值：auto(1 1 auto) 和 none (0 0 auto)。 align-self属性：允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性 默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 .item{align-self:auto | flex-start | flex-end | center | baseline | stretch;} 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 最近发现一篇很详细关于flex box 布局的博客链接阮一峰flex实战布局教程]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
