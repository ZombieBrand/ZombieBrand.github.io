<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前端缓存]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F17%2F%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[localStorage 还能这么用 HTML5中 Web Storage 的出现，主要是为了弥补使用 Cookie 作为本地存储的不足。Cookie 存储的数据量非常小，而且数据会自动携带到请求头里，但服务器端可能并不关心这些数据，所以会造成带宽的浪费。 Web Storage 提供了两个存储对象：localStorage 和 sessionStorage。 sessionStorage 存储的数据仅在本次会话有用，会话结束后会自动失效，而且数据仅在当前窗口有效，同一源下新窗口也访问不到其他窗口基于sessionStorage 存储的数据。也是由于这些特性，导致 sessionStorage 的使用场景会比较少。 localStorage 可以永久存储，而且同源下数据多窗口也能共享，。看起来很美好，但 localStorage 也有短板，绝大多数浏览器有 5M 的大小限制。但是这不足以成为大家使用 localStorage 的障碍，要知道 Cookie 只有 4K 的大小，多了一千多倍，偷着乐吧。 localStorage 的基本使用讲这个内容的文章网上太多了，现在再来讲有点老套了。这里就不做更多介绍了，不清楚的读者可以看这里。 有两点需要注意一下。在 setItem 时，可能会达到大小限制，最好加上错误捕捉 1： 123456789101112131415161718192021222324252627282930try &#123; localStorage.setItem(key, value);&#125; catch(e) &#123; if (isQuotaExceeded(e)) &#123; // Storage full, maybe notify user or do some clean-up &#125;&#125;function isQuotaExceeded(e) &#123; var quotaExceeded = false; if (e) &#123; if (e.code) &#123; switch (e.code) &#123; case 22: quotaExceeded = true; break; case 1014: // Firefox if (e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &#123; quotaExceeded = true; &#125; break; &#125; &#125; else if (e.number === -2147024882) &#123; // Internet Explorer 8 quotaExceeded = true; &#125; &#125; return quotaExceeded;&#125; 另外在存储容量快满时，会造成 getItem 性能急剧下降 2。 我们下面看看 localStorage 有哪些脑洞大开的用法。 缓存静态文件你不禁要问，HTTP 协议不是本来就支持缓存文件吗（之前写过一篇文章《Web缓存之HTTP指南》），为什么还要使用 localStorage 来缓存？为了可编程化，通俗一点说就是把命运握在自己手中。 HTTP 协议的缓存，可以由用户浏览器清除或禁用缓存，也可以由 Web 服务器设置过期时间或不缓存。对于前端工程师，这更像是一个黑盒，想要决定文件是访问缓存还是访问远程显得有些力不从心了。 使用 localStorage 控制文件缓存的方式有两种： 使用 Loader 加载静态文件 借助服务器端将静态文件 inline 化 这两种方式一般都会提前做好缓存过期策略，通常是使用版本号来控制，下面还会细讲。否则文件新版上线，用户客户端还是旧版，这就麻烦大了，而且这类问题，还不好调试不好重现。 使用 Loader 加载静态文件由于请求都是动态发出的，所以可以对请求拦截处理。大致流程如下： 查看请求的文件 url 是否有缓存到 localStorage 如果没有，到第 2 大步 如果有，判断文件是否过期或版本号是否匹配 过期或不匹配，到第 2 大步 文件内容有效，到第 4 大步 请求远程文件 缓存最新文件内容 执行文件内容 这个方式有个开源库：basket.js。 借助服务器端将静态文件 inline 化这个方式比上面那种更进一步，在第一次响应时把需要放入 localStorage 的文件都内联进 html 中，后面每次响应只要文件版本没有变化，都是渲染一段从 localStorage 加载该文件的代码。这样做的好处是可以有效减少请求次数，即使是第一次。 版本号不匹配（版本号可记在 Cookie 中，第一次访问没有版本号），服务端响应内容： 1234567891011&lt;script&gt;function script2ls(id) &#123; var script = document.getElementById(id); if (script) &#123; localStorage[id] = script.innerHTML; &#125;&#125;&lt;/script&gt;&lt;script id="jquery.js"&gt;...jquery source code...&lt;/script&gt;&lt;script&gt;script2ls('jquery.js')&lt;/script&gt; 版本号匹配，服务端响应内容： 123456789&lt;script&gt;function ls2script(id) &#123; var script = document.createElement('script'); script.text = localStorage[id]; document.head.appendChild(script);&#125;&lt;/script&gt;&lt;script&gt;ls2script('jquery.js')&lt;/script&gt; 不过使用 localStorage 缓存文件会有 XSS 的风险，而且造成的伤害可能是永久的 3。 同源窗口通信你可能不禁又要问，不是有 postMessage 吗？没错 postMessage 确实可以用于窗口或 iframe 间通信，但是前提是你必须拿到打开新窗或 iframe 的句柄对象： 12var popup = window.open(...popup details...);popup.postMessage("hello there!", "http://example.com"); 这样在新窗中再打开新窗，似乎就不好传递消息了。 你可能还想问，为什么要在窗口间通信？好问题，没有应用场景的技术都是耍流氓。像多窗口共用的一些组件，而且对数据实时同步都有较高要求的都会是这个技术的应用场景。比如通知中心上面的未读数量，两个窗口，A 窗口更新为 8，切到 B 窗口还是 9，这就造成了体验不一致，这个例子可能还觉得无关痛痒；再比如购物车，两个产品窗口，A 窗口添加到购物车，切到 B 窗口添加到购物车，发现没有 A 添加的产品，这样就比较严重了。这当然也可以通过每个窗口都与后台建立连接来更新，但用户如果开十几个窗口就开销大了。 有了同源窗口通信，我们就可以只有一个窗口与后台建立连接，收到更新后，广播给其他窗口就可以。说了这么多，实现原理是怎样的呢？ 其实原理也简单，每次 localStorage 中有任何变动都会触发一个 storage 事件，所有窗口都监听这个事件，一旦有窗口更新 localStorage，其他窗口都会收到通知，根据事件中的 key 把不关心的变动过滤掉。原理是很简单，但是要实现一套完整的广播机制还是有些复杂，你需要： 管理好每个窗口的唯一 ID 防止消息重复 防止消息发给不关心的窗口 窗口心跳 keep alive 主窗口选举 … 不用担心，已经有了不错的开源实现：diy/intercom.js、tejacques/crosstab 其他作为前端 DB 的存储介质你可能不满足于用键值对保存数据，你还想保存更复杂的数据结构。 灵活存取 json 格式的数据：typicode/lowdb 通过 sql 对数据 CURD 操作：agershun/alasql 表单自动持久化在填写表单时，遇到浏览器奔溃或者误操作导致填写内容丢失，此刻用户的内心也应该是奔溃的。误操作还可以加一个 beforeunload 事件，在关闭浏览器或跳出当前页前提醒一下用户。那浏览器崩溃呢，将数据变更实时保存到后台，这样似乎开销很大，实时保存到 localStorage 是个不错的解决方案，真巧，也有一个开源实现：simsalabim/sisyphus 总结文件缓存现在有更好的解决方案，没错，说的就是 Service Worker 的 CacheStorage。 不过多了解一些脑洞大开的想法，有利于拓展解决问题的思路。]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>localStorage</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端入门常见适配问题]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F17%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%85%A5%E9%97%A8%E5%B8%B8%E8%A7%81%E9%80%82%E9%85%8D%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[移动端开发分为4类 Native（原生 APP）使用 Java/Objective-C/Swift 开发 Webapp在手机浏览器上展示的网页 Hybird（混合应用）Native + Html 微信小程序https://www.zhihu.com/topic/20061410/hot 比较 开发成本开发App成本比较大：android + ios+前端+后台Webapp=微信小程序：前端 更新Native：需要提示用户更新下载新版本Webapp=Hybird=小程序： 不需要用户更新下载新版本 性能体验Native：体验最佳，速度快，功能强大Hybird：次之Webapp：最差 安装方式Native=Hybird：下载安装Webapp：无需下载 跨平台andriod平台ios平台Webapp：不需要考虑平台 移动端和 PC 的区别 开发流程一样：psd稿子-&gt;切图-&gt;分析功能-&gt;&gt;写html-&gt;写css-&gt;写js 移动端vsPC端，移动端的布局更简单 1.触摸事件touchstart, touchend, touchmove, touchcancel touchcancel：系统取消touch事件的时候触发（不常用） touchstart立即响应 123456node.addEventListener(&apos;touchstart&apos;, function()&#123; console.log(&apos;start touch&apos;)&#125;)node.addEventListener(&apos;touchend&apos;, function()&#123; console.log(&apos;&apos;)&#125;) JS没有滑动事件，我们可以用触摸点的坐标来判断滑动方向。 2.移动端 300ms 延时300ms 延时的原因 出于对手指触摸滑动的区分，移动端页面对于触摸事件会有 300 毫秒的延迟。 2007 年初，苹果公司在发布首款 iPhone 前夕，遇到一个问题 —— 当时的网站都是为大屏幕设备所设计的。于是苹果的工程师们做了一些约定，应对 iPhone 这种小屏幕浏览桌面端站点的问题。 这当中最出名的，当属双击缩放(double tap to zoom)，浏览PC页面时，默认缩小显示（980px的视窗宽度），用手指在屏幕上快速点击两次，Safari 浏览器会将网页缩放至原始比例。 假定用户在 iOS Safari 里边点击了一个链接。由于用户可以进行双击缩放或者双击滚动的操作，当用户一次点击屏幕之后，浏览器并不能立刻判断用户是确实要打开这个链接，还是想要进行双击操作。因此，iOS Safari 就等待 300 毫秒，以判断用户是否再次点击了屏幕。 避免300ms延时的方法方案一：禁止缩放，就无需等待300ms 12&lt;meta name=&quot;viewport&quot; content=&quot;user-scalable=no&quot;&gt; 禁止用户缩放&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1,maximum-scale=1&quot;&gt; 禁止浏览器缩放 方案二：更改默认的视口宽度 用 标签配置width=device-width。 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;将视口大小设为设备本身的尺寸 Chrome 32对包含 width=device-width 或者置为比 viewport 值更小的页面上禁用双击缩放。没有双击缩放就没有 300 毫秒点击延迟。 iOS 9.3 中：Safari 针对移动版的网页去掉了点击时的 300ms 延迟。对于网页开发者来说，不再需要引入类似 FastClick 这样的 Hack 了。双击放大的功能仍然可用，但是必须点击链接之外的地方才有效（否则就直接进入链接了） 方案三：CSS touch-action: manipulation; CSS属性 touch-action 用于指定某个给定的区域是否允许用户操作，以及如何响应用户操作（比如浏览器自带的划动、缩放等） 移动端300ms延迟，就可以使用touch-action: manipulation;来解决。 manipulation: 浏览器只允许进行滚动和持续缩放操作，禁用其他非标准手势，例如双击以进行缩放，也就没有300 毫秒点击延迟啦。 方案四：使用fastclick库 FastClick 是 FT Labs 专门为解决移动端浏览器 300 毫秒点击延迟问题所开发的一个轻量级的库。简而言之，FastClick 在检测到 touchend 事件的时候，会通过 DOM 自定义事件立即触发一个模拟 click 事件，并把浏览器在 300 毫秒之后真正触发的 click 事件阻止掉。用法很简单： 123456789//引入fastclick.js&lt;script type=&apos;application/javascript&apos; src=&apos;/path/to/fastclick.js&apos;&gt;&lt;/script&gt;//在body里面写if (&apos;addEventListener&apos; in document) &#123; document.addEventListener(&apos;DOMContentLoaded&apos;, function() &#123; FastClick.attach(document.body); &#125;, false);&#125; 3.常见手势 image 但原生js只有touchstart, touchend, touchmove事件， hammerjs 为我们实现了一个手势库 4.滚动以往我们可以通过CSS的overflow:scroll或者overflow:auto实现滚动，但是在移动端这样效果不好。可以使用iscroll 5.需要设置viewport来控制屏幕全屏显示，禁止缩放inital-scale页面初始的放大倍数，maximum-scale最大放大倍数 user-scalable=no 页面不可以放大缩小 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, height=device-height, inital-scale=1.0, maximum-scale=1.0, user-scalable=no;&quot; /&gt; 6.页面适配-动态 rem （移动端方案，不是响应式）响应式方案目的是一份代码解决手机、平板、电脑的页面适配。 meta:vp禁止缩放&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, height=device-height, inital-scale=1.0, maximum-scale=1.0, user-scalable=no;&quot; /&gt; 尽量不要写width/height，该用max-width/max-height 多用flex布局 media query 动态 rem方案而动态 rem是只针对移动端页面的适配方法。例如手机淘宝 在移动端宽度不适合再用固定宽度px，我们希望整体等比缩放。如果用媒体查询的响应式，那么对于宽度不同的手机，显示页面内容的宽度仍然一样，内容居中，只是两边留白宽度不同。 rem是CSS3新增的一个相对单位（root em，根em），相对的只是HTML根元素（1rem=html font size）。通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应（em也是相对长度单位，但会继承父级元素的字体大小）。 rem是相对于根节点html的font-size的倍数，浏览器对font-size值有限制，一般font-size最小值默认为12。 动态 rem方案1 meta:vp禁止缩放&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, height=device-height, inital-scale=1.0, maximum-scale=1.0, user-scalable=no;&quot; /&gt; document.documentElement.clientWidth动态获取页面宽度 赋给html的font-size，即拼接成html{font-size:&#39;+document.documentElement.clientWidth +&#39;px;} 所有需要跟视觉稿一致的地方，按比例算出rem值示例1 动态rem方案2 meta:vp禁止缩放&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, height=device-height, inital-scale=1.0, maximum-scale=1.0, user-scalable=no;&quot; /&gt; document.documentElement.clientWidth动态获取页面宽度width 赋给html的font-size，即拼接成html{font-size:&#39;+ width/10 +&#39;px;} 10rem==页面宽度width 所有单位都用rem == 所有长度都以页面的宽度为基准示例2 动态rem方案3 + retina下，border: 1px问题 普通屏幕CSS 1px == 设备的1px 在RetinaCSS 1px == 设备的2px设计师要求 border-width == 设备的1px所以我们让border-width ：0.5px== 设备的1px（兼容性有问题，不是所有的浏览器都支持0.5px） 解决方案： 1.获取设备 像素比window.devicePixelRatio 2.var sacle = 1/window.devicePixelRatio; 3.让rem变为rem*像素比 4.border-top:1px solid red; 示例3 移动端高清、多屏适配方案-阿里 移动web适配-rem-腾讯 动态rem方案可以被css3中相对长度单位vw 取代 查看浏览器对vw的支持情况 vw 相对于视口的宽度。视口被均分为100单位的vw(即浏览器可视区) 100vw = 可视区宽度 vh 相对于视口的高度。视口被均分为100单位的vh(即浏览器可视区) 100vh = 可视区高度 7.开发调试PC端：采用本地编写，浏览器查看，dev-tools调试 移动端：npm install browser-sync 用于在手机端验证和调试。手机通过连接局域网地址也可以访问页面。 12345678$ browser-sync[Browsersync] Access URLs: --------------------------------------- Local: http://localhost:3000 External: http://192.168.10.101:3000 --------------------------------------- UI: http://localhost:3001 (调试地址) UI External: http://192.168.10.101:3001 8.移动端解决方法收集https://github.com/jtyjty99999/mobileTech/blob/master/README.md image place holder占位图片定制化]]></content>
      <categories>
        <category>移动端</category>
        <category>适配</category>
      </categories>
      <tags>
        <tag>移动端</tag>
        <tag>适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端rem适配]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F17%2F%E7%A7%BB%E5%8A%A8%E7%AB%AFrem%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[关于移动端 rem 布局的一些总结先上一段代码原理下边 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155!function(win, lib) &#123; var timer, doc = win.document, docElem = doc.documentElement, vpMeta = doc.querySelector('meta[name="viewport"]'), flexMeta = doc.querySelector('meta[name="flexible"]'), dpr = 0, scale = 0, flexible = lib.flexible || (lib.flexible = &#123;&#125;); // 设置了 viewport meta if (vpMeta) &#123; console.warn("将根据已有的meta标签来设置缩放比例"); var initial = vpMeta.getAttribute("content").match(/initial\-scale=([\d\.]+)/); if (initial) &#123; scale = parseFloat(initial[1]); // 已设置的 initialScale dpr = parseInt(1 / scale); // 设备像素比 devicePixelRatio &#125; &#125; // 设置了 flexible Meta else if (flexMeta) &#123; var flexMetaContent = flexMeta.getAttribute("content"); if (flexMetaContent) &#123; var initial = flexMetaContent.match(/initial\-dpr=([\d\.]+)/), maximum = flexMetaContent.match(/maximum\-dpr=([\d\.]+)/); if (initial) &#123; dpr = parseFloat(initial[1]); scale = parseFloat((1 / dpr).toFixed(2)); &#125; if (maximum) &#123; dpr = parseFloat(maximum[1]); scale = parseFloat((1 / dpr).toFixed(2)); &#125; &#125; &#125; // viewport 或 flexible // meta 均未设置 if (!dpr &amp;&amp; !scale) &#123; // QST // 这里的 第一句有什么用 ? // 和 Android 有毛关系 ? var u = (win.navigator.appVersion.match(/android/gi), win.navigator.appVersion.match(/iphone/gi)), _dpr = win.devicePixelRatio; // 所以这里似乎是将所有 Android 设备都设置为 1 了 dpr = u ? ( (_dpr &gt;= 3 &amp;&amp; (!dpr || dpr &gt;= 3)) ? 3 : (_dpr &gt;= 2 &amp;&amp; (!dpr || dpr &gt;= 2)) ? 2 : 1 ) : 1; scale = 1 / dpr; &#125; docElem.setAttribute("data-dpr", dpr); // 插入 viewport meta if (!vpMeta) &#123; vpMeta = doc.createElement("meta"); vpMeta.setAttribute("name", "viewport"); vpMeta.setAttribute("content", "initial-scale=" + scale + ", maximum-scale=" + scale + ", minimum-scale=" + scale + ", user-scalable=no"); if (docElem.firstElementChild) &#123; docElem.firstElementChild.appendChild(vpMeta) &#125; else &#123; var div = doc.createElement("div"); div.appendChild(vpMeta); doc.write(div.innerHTML); &#125; &#125; function setFontSize() &#123; var winWidth = docElem.getBoundingClientRect().width; if (winWidth / dpr &gt; 540) &#123; (winWidth = 540 * dpr); &#125; // 根节点 fontSize 根据宽度决定 var baseSize = winWidth / 10; docElem.style.fontSize = baseSize + "px"; flexible.rem = win.rem = baseSize; &#125; // 调整窗口时重置 win.addEventListener("resize", function() &#123; clearTimeout(timer); timer = setTimeout(setFontSize, 300); &#125;, false); // 这一段是我自己加的 // orientationchange 时也需要重算下吧 win.addEventListener("orientationchange", function() &#123; clearTimeout(timer); timer = setTimeout(setFontSize, 300); &#125;, false); // pageshow // keyword: 倒退 缓存相关 win.addEventListener("pageshow", function(e) &#123; if (e.persisted) &#123; clearTimeout(timer); timer = setTimeout(setFontSize, 300); &#125; &#125;, false); // 设置基准字体 if ("complete" === doc.readyState) &#123; doc.body.style.fontSize = 12 * dpr + "px"; &#125; else &#123; doc.addEventListener("DOMContentLoaded", function() &#123; doc.body.style.fontSize = 12 * dpr + "px"; &#125;, false); &#125; setFontSize(); flexible.dpr = win.dpr = dpr; flexible.refreshRem = setFontSize; flexible.rem2px = function(d) &#123; var c = parseFloat(d) * this.rem; if ("string" == typeof d &amp;&amp; d.match(/rem$/)) &#123; c += "px"; &#125; return c; &#125;; flexible.px2rem = function(d) &#123; var c = parseFloat(d) / this.rem; if ("string" == typeof d &amp;&amp; d.match(/px$/)) &#123; c += "rem"; &#125; return c; &#125;&#125;(window, window.lib || (window.lib = &#123;&#125;)); 视口在前一段时间，我曾经写过一篇关于viewport的文章。最近由于在接触移动端开发，对viewport有了新的理解。于是，打算重新写一篇文章，介绍移动端视口的相关概念。 关于这篇文章说到的所有知识，本质上离不开以下代码 12345&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot; /&gt;@media all and (max-width: 320px) &#123; // do something&#125; 了解过移动端开发的朋友，其实对以上的代码就不会陌生。上面的代码，主要涉及到meta视口标签与媒体查询。单单以上简短的代码就需要明白： 像素(pixel) 视口(viewport) 分辨率(resolution)与设备像素比(device-pixel-ratio) meta视口标签 媒体查询(media query) JavaScript相关的属性和方法 如何实现移动端响应式适配的问题 那就进入主题吧：） 像素在移动端上，所谓的像素分为两种 CSS像素：CSS像素就是我们在编写CSS代码时的像素。 设备像素：设备屏幕的物理像素，任何设备的物理像素的数量都是固定的。 1个CSS像素等于多少个设备像素取决于屏幕特性(是否是高清屏)和用户缩放的比例。当用户将屏幕从100%放大到200%时，1个CSS像素等于2个设备像素，反之相反；当屏幕为Retina高清屏(如iPhone6，dpr=2)时，1个CSS像素就等于2个设备像素，反之相反。 需要明白一点的是，2个设备像素并不是说它扩大了两倍，而是说在页面上仍然显示的是1px(1个CSS像素)，但是这1px是由2个设备像素组成。像素点变多了，因此图像会变得更加清晰。下面这幅图大致说明了CSS像素和设备像素的区别。 视口在移动端上，存在三种不同的视口。 布局视口：在PC端上，布局视口等于浏览器窗口的宽度。而在移动端上，由于要使为PC端浏览器设计的网站能够完全显示在移动端的小屏幕里，此时的布局视口会远大于移动设备的屏幕。在移动端，默认情况下，布局视口等于浏览器窗口宽度。布局视口限制了CSS的布局。在JavaScirpt上获取布局视口的宽度可以通过document.documentElement.clientWidth | document.body.clientWidth得到。 视觉视口：视觉视口是用户正在看到的区域。用户可以缩放来操作视觉视口，而不影响视觉视口的宽度。视觉视口决定了用户看到了什么。在JavaScript上获取视觉视口的宽度可以通过`window.innerWidth得到。 在PC端上，视觉视口等于布局视口的宽度，无论用户是放大屏幕还是缩小屏幕，这两个视口的宽度仍然相等。但是，在移动端上，并非如此。缩放屏幕的过程实质上就是CSS像素缩放的过程。当用户将屏幕放到到两倍时，视觉视口变小了(因为视觉视口中CSS像素变少了)，而每单位的CSS像素却变大了，因此1px(1个CSS像素)等于2个设备像素。同理，当为iPhone6(dpr=2)时，视觉视口中CSS像素变少了，但是1px等于2个设备像素。当用户缩小屏幕时也是同样的道理。缩放的过程并不会影响布局视口的大小。 也就是说，高清屏(dpr&gt;=2)或屏幕放大时，视觉视口变小(CSS像素变少)，每单位的CSS像素等于更多的设备像素；非高清屏(dpr&lt;2)或屏幕缩小时，视觉视口变大(CSS像素变多)，每单位的CSS像素等于更少的设备像素。但是无论放大或缩小屏幕，布局视口的宽度仍然保持不变。 理想视口：由于默认情况下布局视口等于浏览器窗口宽度，因此在移动端上需要通过放大或缩小视觉视口来查看页面内容，这当然体验糟糕啊！因此在移动端引入了理想视口的概念。理想视口的出现必须需要设置meta视口标签，此时布局视口等于理想视口的宽度。常见的，iPhone6的理想视口为375px 667px，iPhon6 plus的理想视口为414px 736px。在JavaScript上获取理想视口的宽度window.screen.width得到。 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot; /&gt; 当设置了meta视口标签之后，iPhone6的布局视口宽度将等于375px，iPhone6plus布局视口的宽度等于414px。其他移动设备相似。 理想视口会随着屏幕的旋转而改变。当iPhone6为肖像模式时(即竖屏)，此时理想视口为375px 667px；但为横屏模式时，此时理想视口为667px 375px。 分辨率与设备像素比分辨率是指每英寸内点的个数，单位是dpi或者dppx。设备像素比是指设备像素与理想视口宽度的比值，没有单位。 分辨率在CSS上可以通过resolution属性设置。一般情况下会使用dpi作为分辨率的单位，因为dppx并非所有浏览器都支持。 而设备像素比在CSS上可以通过device-pixel-ratio属性设置，而在JavaScript上可以通过window.devicePixelRatio属性获取。 同时，1dpr=96dpi。举个例子。在iPhon6下，理想视口宽度为375px，而设备像素为750px，因此此时设备像素比为2，分辨率为192dpi。因此如果为iPhon6以下的设备写某个特定样式，可以这样写 123456789101112// 注意，device-pixel-ratio需要带上-webkit-前缀，保证浏览器兼容性问题。@media all and (max-width: 375px) and (-webkit-max-device-pixel-ratio: 2) &#123; body &#123; background-color: red; &#125;&#125;或者@media all and (max-width: 375px) and (max-resolution: 192dpi) &#123; body &#123; background-color: red; &#125;&#125; meta视口标签meta视口标签是是设置理想视口的重要元素，主要用于将布局视口的尺寸和理想视口的尺寸相匹配。meta视口标签存在5个指令 width：设置布局视口的宽度，一般设为device-width。 initial-scale：初始缩放比例。1即100%，2即200%，以此类推 maximum=scale：最大缩放比例。 minimum-scale：最小缩放比例。 user-scalable：是否静止用户进行缩放，默认为no。 需要注意的是，缩放是根据理想视口进行计算的。缩放程度与视觉视口的宽度是逆相关的。也就是说，当你将屏幕放到到2倍时，视觉视口为理想视口的一半，此时每单位的CSS像素等于2个设备像素。缩小时则相反。 响应式适配问题理解了一些基本概念之后，我们来看看如何实现响应式适配。 一般情况下，前端开发工程师会根据设计师给的设计稿进行开发。而设计稿一般是根据iPhon6手机进行页面的设计的。我们知道iPhone6的理想视口宽度为375px，同时iPhone6的设备像素比为2，设备像素为750px。我们需要在只有一份设计稿的情况下写出适应各种屏幕不一的终端设备，因此需要一些移动端响应式适配的方案。此时需要用到的一个单位是REM。简单的说，REM会根据HTML元素的font-size进行设置。当HTML元素的font-size: 16px时，1rem = 16px, 1.5rem = 24px 个人总结出了两套响应式适配的方案(前提是设置meta视口标签)。两套方案由一个共同点：给定一个基准值。 假如现在拿到的设计稿是根据iPhone6进行设计的。 方案一方案一是设计稿给什么尺寸，我们就将其缩小100倍，最后换算成rem单位。比如，设计稿上某个title的font-size为32px，此时写CSS样式时就直接缩小100倍，即0.32rem。 由于rem是根据根元素进行设置的，所以我们需要设置根元素的font-size。 给HTML设置font-size的基本思路： 通过window.screen.width获取不同移动设备的理想视口宽度。 规定基准值为750px(此值为iPhon6的设备像素)。 (1) / (2) * 100即得到HTML元素的font-size。(乘于100是因为我们在前面将字体缩小了100倍，此时要乘回来) 换算成公式即：设计稿尺寸 / 100 * (不同设备的理想视口宽度 / 基准值 * 100) 举个例子。 1234// 根据不同设备的理想视口宽度动态设置根元素的`font-size`。let idealViewWidth = window.screen.width;const BASICVALUE = 750;document.documentElement.style.fontSize = (idealViewWidth / BASICVALUE) * 100 + &apos;px&apos;; 因此，在不同设备下的HTML元素的font-size大小和实际像素如下 12345678iPhone5 : (320 / 750) * 100 = 42.667pxiPhone6 : (375 / 750) * 100 = 50pxiPhone6+: (414 / 750) * 100 = 55.2px假如设计稿上标注.title类上的字体为32px，此时有iPhone5上的某字体: 42.667 * 0.32rem = 13.653pxiPhone6上的某字体： 50 * 0.32rem = 16pxiPhone6+上的某字体: 55.2 * 0.32rem = 17.664px 可以看出，在不同设备下，同一字号的字体使用rem单位可以实现不同设备的响应式适配。不单单在字体上可以使用，在移动端上的width、height等涉及单位的都可以使用。这样的话，就可以在不同设备下完美的复现设计稿的要求。 方案二此方案使用了SASS预处理器。基本思路： 设置根元素的font-size。通过获取不同设备的理想视口宽度，再除以10。(除以10是因为不想font-size太大。) 给定基准值，此时给的基准值为75px(此值为iPhone6的设备像素除以10) 写SASS Function 代码如下 123456789101112131415161718192021222324252627SASS@function px2rem ($value) &#123; $para: 75px; @return $value / $para + rem;&#125;JSlet idealViewWidth = window.screen.width;document.documentElement.style.fontSize = idealViewWidth / 10 + &apos;px&apos;;在不同设备下根元素的`font-size`：iPhone5 : 320px / 10 = 32pxiPhone6 : 375px / 10 = 37.5pxiPhone6+: 414px / 10 = 41.4px根据以上，可以看一个例子。某设计稿下5个li，横向排布，每个的宽度为200pxCSS@import (路径名)iPhone5: li &#123; width: px2rem(200px) &#125; =&gt; width: 85.333px// 此时(200px / 75px = 2.667rem) 2.667rem = 2.667 * (320 / 10) = 85.3333pxiPhone6: li &#123; width: px2rem(200px) &#125; =&gt; width: 100px// 此时(200px / 75px = 2.667rem) 2.667rem = 2.667 * (375 / 10) = 100pxiPhone6+: li &#123; width: px2rem(200px) &#125; =&gt; width: 4138px// 此时(200px / 75px = 2.667rem) 2.667rem = 2.667 * (414 / 10) = 110.4138px因此，一个200px的(实际只有100px)的li元素的宽度在不同设备下显示了不同的宽度，实现了响应式适配的问题。 方案三方案三与前两个方案不相同，此方案并不需要给根元素设置font-size，不需要基准值。此方案是根据不同设备的dpr来实现页面的缩放的。 基本思路如下： 通过window.devicePixelRatio获取设备的dpr 根据不同的dpr缩放页面，动态设置meta视口标签。(缩放是放大或缩小CSS的过程，根据理想视口进行缩放，与视觉视口方向相反) 代码如下： 1234567891011121314let dpr = window.devicePixelRatio;let meta = document.createElement(&apos;meta&apos;);let initialScale = 1 / dpr;let maximumScale = 1 / dpr;let minimumScale = 1 / dpr;meta.setAttribute(&apos;name&apos;, &apos;viewport&apos;);meta.setAttribute(&apos;content&apos;, `width=device-width, user-scalable=no, initial-scale=$&#123;initialScale&#125;, maximum-scale=$&#123;maximumScale&#125;, minimum-scale=$&#123;minimumScale&#125;`);document.head.appendChild(meta);因此，可以直接根据设计稿的尺寸写CSS样式，如设计稿下有5个li元素，宽度为200px，此时不同设备下li的宽度iPhone5 : li &#123; width: 200px &#125; 实际宽度为：100pxiPhone6 : li &#123; width: 200px &#125; 实际宽度为：100pxiPhone6+: li &#123; width: 200px &#125; 实际宽度为：66.667px 以上三种方法解决了大部分移动端响应式适配的问题，但是在1px问题上，使用以上的方法仍然(除了第三个方案)，都不能很好的解决1px的问题。有时间写一篇文章介绍如何解决1px的问题。 淘宝flexible适配方法原文来源 直接插入到HTML中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152! function (a, b) &#123; function c() &#123; var b = f.getBoundingClientRect().width; b / i &gt; 540 &amp;&amp; (b = 540 * i); var c = b / 10; f.style.fontSize = c + "px", k.rem = a.rem = c &#125; var d, e = a.document, f = e.documentElement, g = e.querySelector('meta[name="viewport"]'), h = e.querySelector('meta[name="flexible"]'), i = 0, j = 0, k = b.flexible || (b.flexible = &#123;&#125;); if (g) &#123; console.warn("将根据已有的meta标签来设置缩放比例"); var l = g.getAttribute("content").match(/initial\-scale=([\d\.]+)/); l &amp;&amp; (j = parseFloat(l[1]), i = parseInt(1 / j)) &#125; else if (h) &#123; var m = h.getAttribute("content"); if (m) &#123; var n = m.match(/initial\-dpr=([\d\.]+)/), o = m.match(/maximum\-dpr=([\d\.]+)/); n &amp;&amp; (i = parseFloat(n[1]), j = parseFloat((1 / i).toFixed(2))), o &amp;&amp; (i = parseFloat(o[1]), j = parseFloat((1 / i).toFixed(2))) &#125; &#125; if (!i &amp;&amp; !j) &#123; var p = a.navigator.userAgent, q = (!!p.match(/android/gi), !!p.match(/iphone/gi)), r = q &amp;&amp; !!p.match(/OS 9_3/), s = a.devicePixelRatio; i = q &amp;&amp; !r ? s &gt;= 3 &amp;&amp; (!i || i &gt;= 3) ? 3 : s &gt;= 2 &amp;&amp; (!i || i &gt;= 2) ? 2 : 1 : 1, j = 1 / i &#125; if (f.setAttribute("data-dpr", i), !g) if (g = e.createElement("meta"), g.setAttribute("name", "viewport"), g.setAttribute("content", "initial-scale=" + j + ", maximum-scale=" + j + ", minimum-scale=" + j + ", user-scalable=no"), f.firstElementChild) f.firstElementChild.appendChild(g); else &#123; var t = e.createElement("div"); t.appendChild(g), e.write(t.innerHTML) &#125; a.addEventListener("resize", function () &#123; clearTimeout(d), d = setTimeout(c, 300) &#125;, !1), a.addEventListener("pageshow", function (a) &#123; a.persisted &amp;&amp; (clearTimeout(d), d = setTimeout(c, 300)) &#125;, !1), "complete" === e.readyState ? e.body.style.fontSize = 12 * i + "px" : e.addEventListener("DOMContentLoaded", function () &#123; e.body.style.fontSize = 12 * i + "px" &#125;, !1), c(), k.dpr = a.dpr = i, k.refreshRem = c, k.rem2px = function (a) &#123; var b = parseFloat(a) * this.rem; return "string" == typeof a &amp;&amp; a.match(/rem$/) &amp;&amp; (b += "px"), b &#125;, k.px2rem = function (a) &#123; var b = parseFloat(a) / this.rem; return "string" == typeof a &amp;&amp; a.match(/px$/) &amp;&amp; (b += "rem"), b &#125;&#125;(window, window.lib || (window.lib = &#123;&#125;));]]></content>
      <categories>
        <category>适配</category>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>rem</tag>
        <tag>移动端</tag>
        <tag>适配</tag>
        <tag>Flexible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式实例]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F17%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[收集在业务中经常使用的正则表达式实例，方便以后进行查找，减少工作量。 校验基本日期格式 校验密码强度 校验中文 由数字、26个英文字母或下划线组成的字符串 校验E-Mail 地址 校验身份证号码 校验日期 校验金额 校验手机号 判断IE的版本 校验IP-v4地址 校验IP-v6地址 检查URL的前缀 提取URL链接 文件路径及扩展名校验 提取Color Hex Codes 提取网页图片 提取页面超链接 查找CSS属性 抽取注释 转换千分位分隔符 1. 校验基本日期格式12var reg1 = /^\d&#123;4&#125;(\-|\/|\.)\d&#123;1,2&#125;\1\d&#123;1,2&#125;$/;var reg2 = /^(^(\d&#123;4&#125;|\d&#123;2&#125;)(\-|\/|\.)\d&#123;1,2&#125;\3\d&#123;1,2&#125;$)|(^\d&#123;4&#125;年\d&#123;1,2&#125;月\d&#123;1,2&#125;日$)$/; 2. 校验密码强度密码的强度必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。 1var reg = /^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$/; 网友提供的解决检测特殊字符的方法 1var reg = /^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$/; 3. 校验中文字符串仅能是中文。 1var reg = /^[\\u4e00-\\u9fa5]&#123;0,&#125;$/; 4. 由数字、26个英文字母或下划线组成的字符串1var reg = /^\\w+$/; 5. 校验E-Mail 地址同密码一样，下面是E-mail地址合规性的正则检查语句。 1var reg = /[\\w!#$%&amp;&apos;*+/=?^_`&#123;|&#125;~-]+(?:\\.[\\w!#$%&amp;&apos;*+/=?^_`&#123;|&#125;~-]+)*@(?:[\\w](?:[\\w-]*[\\w])?\\.)+[\\w](?:[\\w-]*[\\w])?/; 6. 校验身份证号码下面是身份证号码的正则校验。15 或 18位。 15位： 1var reg = /^[1-9]\\d&#123;7&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d&#123;3&#125;$/; 18位： 1var reg = /^[1-9]\\d&#123;5&#125;[1-9]\\d&#123;3&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d&#123;3&#125;([0-9]|X)$/; 7. 校验日期“yyyy-mm-dd” 格式的日期校验，已考虑平闰年。 1var reg = /^(?:(?!0000)[0-9]&#123;4&#125;-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]&#123;2&#125;(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$/; 8. 校验金额金额校验，精确到2位小数。 1var reg = /^[0-9]+(.[0-9]&#123;2&#125;)?$/; 9. 校验手机号下面是国内 13、15、18开头的手机号正则表达式。（可根据目前国内收集号扩展前两位开头号码） 1var reg = /^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d&#123;8&#125;$/; 10. 判断IE的版本IE目前还没被完全取代，很多页面还是需要做版本兼容，下面是IE版本检查的表达式。 1var reg = /^.*MSIE [5-8](?:\\.[0-9]+)?(?!.*Trident\\\/[5-9]\\.0).*$/; 11. 校验IP-v4地址1var reg = /\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b/; 12. 校验IP-v6地址1var reg = /(([0-9a-fA-F]&#123;1,4&#125;:)&#123;7,7&#125;[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,7&#125;:|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,6&#125;:[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,5&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,2&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,3&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,3&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,2&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,5&#125;|[0-9a-fA-F]&#123;1,4&#125;:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,6&#125;)|:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,7&#125;|:)|fe80:(:[0-9a-fA-F]&#123;0,4&#125;)&#123;0,4&#125;%[0-9a-zA-Z]&#123;1,&#125;|::(ffff(:0&#123;1,4&#125;)&#123;0,1&#125;:)&#123;0,1&#125;((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;:((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9]))/; 13. 检查URL的前缀应用开发中很多时候需要区分请求是HTTPS还是HTTP，通过下面的表达式可以取出一个url的前缀然后再逻辑判断。 123if (!s.match(/^[a-zA-Z]+:\/\//)) &#123; s = &apos;http://&apos; + s;&#125; 14. 提取URL链接下面的这个表达式可以筛选出一段文本中的URL。 1var reg = /^(f|ht)&#123;1&#125;(tp|tps):\/\/([\w-]+\.)+[\w-]+(\/[\w- ./?%&amp;=]*)?/; 15. 文件路径及扩展名校验验证windows下文件路径和扩展名（下面的例子中为.txt文件） 1var reg = /^([a-zA-Z]\\:|\\\\)\\\\([^\\]+\\)*[^\\/:*?&quot;&lt;&gt;|]+\\.txt(l)?$/; 16. 提取Color Hex Codes有时需要抽取网页中的颜色代码，可以使用下面的表达式。 1var reg = /^#([A-Fa-f0-9]&#123;6&#125;|[A-Fa-f0-9]&#123;3&#125;)$/; 17. 提取网页图片假若你想提取网页中所有图片信息，可以利用下面的表达式。 1var reg = /\\&lt; *[img][^\\&gt;]*[src] *= *[\\&quot;\&apos;]&#123;0,1&#125;([^\\&quot;\&apos;\ &gt;]*)/; 18. 提取页面超链接提取html中的超链接。 1var reg = /(&lt;a\\s*(?!.*\\brel=)[^&gt;]*)(href=&quot;https?:\/\/)((?!(?:(?:www\\.)?&apos;.implode(&apos;|(?:www\\.)?&apos;, $follow_list).&apos;))[^&quot;]+)&quot;((?!.*\\brel=)[^&gt;]*)(?:[^&gt;]*)&gt;/; 19. 查找CSS属性通过下面的表达式，可以搜索到相匹配的CSS属性。 1var reg = /^\\s*[a-zA-Z\\-]+\\s*[:]&#123;1&#125;\\s[a-zA-Z0-9\\s.#]+[;]&#123;1&#125;/; 20. 抽取注释如果你需要移除HMTL中的注释，可以使用如下的表达式。 1var reg = /&lt;!--(.*?)--&gt;/; 21. 转换千分位分隔符1return total.toString().replace(/\B(?=(\d&#123;3&#125;)+$)/g, &apos;,&apos;);]]></content>
      <categories>
        <category>正则</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用正则表达式]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F17%2F%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[原文链接：正则表达式手册 字符 描述 \ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\n”匹配一个换行符。串行“\\”匹配“\”而“\(”则匹配“(”。 ^ 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo*能匹配“z”以及“zoo”。*等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。 ? 匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。 {n} n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。 {n,} n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。 {n,m} m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。 . 匹配除“\n”之外的任何单个字符。要匹配包括“\n”在内的任何字符，请使用像“(.\n)”的模式。 (pattern) 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“\(”或“` ”。` (?:pattern) 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“`( )”来组合一个模式的各个部分是很有用。例如“industr(?:y ies)”就是一个比“industry industries`”更简略的表达式。 (?=pattern) 正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“`Windows(?=95 98 NT 2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows`”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“`Windows(?!95 98 NT 2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows`”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?&lt;=pattern) 反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“`(?&lt;=95 98 NT 2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows`”。 (?&lt;!pattern) 反向否定预查，与正向否定预查类拟，只是方向相反。例如“`(?&lt;!95 98 NT 2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows`”。 `x y` 匹配x或y。例如，“`z food”能匹配“z”或“food”。“(z f)ood”则匹配“zood”或“food`”。 [xyz] 字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“p”。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。 \b 匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。 \B 匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。 \cx 匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。 \d 匹配一个数字字符。等价于[0-9]。 \D 匹配一个非数字字符。等价于[^0-9]。 \f 匹配一个换页符。等价于\x0c和\cL。 \n 匹配一个换行符。等价于\x0a和\cJ。 \r 匹配一个回车符。等价于\x0d和\cM。 \s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[\f\n\r\t\v]。 \S 匹配任何非空白字符。等价于[^\f\n\r\t\v]。 \t 匹配一个制表符。等价于\x09和\cI。 \v 匹配一个垂直制表符。等价于\x0b和\cK。 \w 匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。 \W 匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。 \xn 匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\x41”匹配“A”。“\x041”则等价于“\x04&amp;1”。正则表达式中可以使用ASCII编码。 \num 匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\1”匹配两个连续的相同字符。 \n 标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。 \nm 标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\nm将匹配八进制转义值nm。 \nml 如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。 \un 匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（©）。 常用正则表达式 匹配内容 正则表达式 用户名 /^[a-z0-9_-]{3,16}$/ 密码 /^[a-z0-9_-]{6,18}$/ 十六进制值 `/^#?([a-f0-9]{6} [a-f0-9]{3})$/` 电子邮箱 /^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,6})$/ /^[a-z\d]+(\.[a-z\d]+)*@([\da-z](-[\da-z])?)+(\.{1,2}[a-z]+)+$/ URL /^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/ IP 地址 `/((2[0-4]d 25[0-5] [01]?dd?).){3}(2[0-4]d 25[0-5] [01]?dd?)//^(?:(?:25[0-5] 20-4 [01]?0-9?).){3}(?:25[0-5] 20-4 [01]?0-9?)$/` HTML标签 `/^&lt;([a-z]+)([^&lt;]+)(?:&gt;(.) s+/&gt;)$/` 删除代码\注释 `(?&lt;!http: S)//.*$` Unicode编码中的汉字范围 /^[\u2E80-\u9FFF]+$/]]></content>
      <categories>
        <category>正则</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[摘抄面向对象实战之拖拽对象封装]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F17%2F%E6%91%98%E6%8A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%AE%9E%E6%88%98%E4%B9%8B%E6%8B%96%E6%8B%BD%E5%AF%B9%E8%B1%A1%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[前面几篇文章，我跟大家分享了JavaScript的一些基础知识，这篇文章，将会进入第一个实战环节：利用前面几章的所涉及到的知识，封装一个拖拽对象。为了能够帮助大家了解更多的方式与进行对比，我会使用三种不同的方式来实现拖拽。 不封装对象直接实现； 利用原生JavaScript封装拖拽对象； 通过扩展jQuery来实现拖拽对象。 本文的例子会放置于codepen.io中，供大家在阅读时直接查看。如果对于codepen不了解的同学，可以花点时间稍微了解一下。 拖拽的实现过程会涉及到非常多的实用小知识，因此为了巩固我自己的知识积累，也为了大家能够学到更多的知识，我会尽量详细的将一些细节分享出来，相信大家认真阅读之后，一定能学到一些东西。 1、如何让一个DOM元素动起来我们常常会通过修改元素的top，left，translate来其的位置发生改变。在下面的例子中，每点击一次按钮，对应的元素就会移动5px。大家可点击查看。 点击查看一个让元素动起来的小例子 由于修改一个元素top/left值会引起页面重绘，而translate不会，因此从性能优化上来判断，我们会优先使用translate属性。 2、如何获取当前浏览器支持的transform兼容写法transform是css3的属性，当我们使用它时就不得不面对兼容性的问题。不同版本浏览器的兼容写法大致有如下几种： [&#39;transform&#39;, &#39;webkitTransform&#39;, &#39;MozTransform&#39;, &#39;msTransform&#39;, &#39;OTransform&#39;] 因此我们需要判断当前浏览器环境支持的transform属性是哪一种，方法如下： 1234567891011121314151617181920// 获取当前浏览器支持的transform兼容写法function getTransform() &#123; var transform = '', divStyle = document.createElement('div').style, // 可能涉及到的几种兼容性写法，通过循环找出浏览器识别的那一个 transformArr = ['transform', 'webkitTransform', 'MozTransform', 'msTransform', 'OTransform'], i = 0, len = transformArr.length; for(; i &lt; len; i++) &#123; if(transformArr[i] in divStyle) &#123; // 找到之后立即返回，结束函数 return transform = transformArr[i]; &#125; &#125; // 如果没有找到，就直接返回空字符串 return transform;&#125; 该方法用于获取浏览器支持的transform属性。如果返回的为空字符串，则表示当前浏览器并不支持transform，这个时候我们就需要使用left，top值来改变元素的位置。如果支持，就改变transform的值。 3、 如何获取元素的初始位置我们首先需要获取到目标元素的初始位置，因此这里我们需要一个专门用来获取元素样式的功能函数。 但是获取元素样式在IE浏览器与其他浏览器有一些不同，因此我们需要一个兼容性的写法。 1234function getStyle(elem, property) &#123; // ie通过currentStyle来获取元素的样式，其他浏览器通过getComputedStyle来获取 return document.defaultView.getComputedStyle ? document.defaultView.getComputedStyle(elem, false)[property] : elem.currentStyle[property];&#125; 有了这个方法之后，就可以开始动手写获取目标元素初始位置的方法了。 1234567891011121314151617181920212223242526272829function getTargetPos(elem) &#123; var pos = &#123;x: 0, y: 0&#125;; var transform = getTransform(); if(transform) &#123; var transformValue = getStyle(elem, transform); if(transformValue == 'none') &#123; elem.style[transform] = 'translate(0, 0)'; return pos; &#125; else &#123; var temp = transformValue.match(/-?\d+/g); return pos = &#123; x: parseInt(temp[4].trim()), y: parseInt(temp[5].trim()) &#125; &#125; &#125; else &#123; if(getStyle(elem, 'position') == 'static') &#123; elem.style.position = 'relative'; return pos; &#125; else &#123; var x = parseInt(getStyle(elem, 'left') ? getStyle(elem, 'left') : 0); var y = parseInt(getStyle(elem, 'top') ? getStyle(elem, 'top') : 0); return pos = &#123; x: x, y: y &#125; &#125; &#125;&#125; 在拖拽过程中，我们需要不停的设置目标元素的新位置，这样它才会移动起来，因此我们需要一个设置目标元素位置的方法。 1234567891011// pos = &#123; x: 200, y: 100 &#125;function setTargetPos(elem, pos) &#123; var transform = getTransform(); if(transform) &#123; elem.style[transform] = 'translate('+ pos.x +'px, '+ pos.y +'px)'; &#125; else &#123; elem.style.left = pos.x + 'px'; elem.style.top = pos.y + 'px'; &#125; return elem;&#125; 5、我们需要用到哪些事件？在pc上的浏览器中，结合mousedown、mousemove、mouseup这三个事件可以帮助我们实现拖拽。 mousedown 鼠标按下时触发 mousemove 鼠标按下后拖动时触发 mouseup 鼠标松开时触发 而在移动端，分别与之对应的则是touchstart、touchmove、touchend。 当我们将元素绑定这些事件时，有一个事件对象将会作为参数传递给回调函数，通过事件对象，我们可以获取到当前鼠标的精确位置，鼠标位置信息是实现拖拽的关键。 事件对象十分重要，其中包含了非常多的有用的信息，这里我就不扩展了，大家可以在函数中将事件对象打印出来查看其中的具体属性，这个方法对于记不清事件对象重要属性的童鞋非常有用。 6、拖拽的原理当事件触发时，我们可以通过事件对象获取到鼠标的精切位置。这是实现拖拽的关键。当鼠标按下(mousedown触发)时，我们需要记住鼠标的初始位置与目标元素的初始位置，我们的目标就是实现当鼠标移动时，目标元素也跟着移动，根据常理我们可以得出如下关系： 1移动后的鼠标位置 - 鼠标初始位置 = 移动后的目标元素位置 - 目标元素的初始位置 如果鼠标位置的差值我们用dis来表示，那么目标元素的位置就等于： 1移动后目标元素的位置 = dis + 目标元素的初始位置 通过事件对象，我们可以精确的知道鼠标的当前位置，因此当鼠标拖动(mousemove)时，我们可以不停的计算出鼠标移动的差值，以此来求出目标元素的当前位置。这个过程，就实现了拖拽。 而在鼠标松开(mouseup)结束拖拽时，我们需要处理一些收尾工作。详情见代码。 7、 我又来推荐思维导图辅助写代码了常常有新人朋友跑来问我，如果逻辑思维能力不强，能不能写代码做前端。我的答案是：能。因为借助思维导图，可以很轻松的弥补逻辑的短板。而且比在自己头脑中脑补逻辑更加清晰明了，不易出错。 上面第六点我介绍了原理，因此如何做就显得不是那么难了，而具体的步骤，则在下面的思维导图中明确给出，我们只需要按照这个步骤来写代码即可，试试看，一定很轻松。 8、代码实现part1、准备工作 12345678910// 获取目标元素对象var oElem = document.getElementById('target');// 声明2个变量用来保存鼠标初始位置的x，y坐标var startX = 0;var startY = 0;// 声明2个变量用来保存目标元素初始位置的x，y坐标var sourceX = 0;var sourceY = 0; part2、功能函数 因为之前已经贴过代码，就不再重复 1234567891011// 获取当前浏览器支持的transform兼容写法function getTransform() &#123;&#125;// 获取元素属性function getStyle(elem, property) &#123;&#125;// 获取元素的初始位置function getTargetPos(elem) &#123;&#125;// 设置元素的初始位置function setTargetPos(elem, potions) &#123;&#125; part3、声明三个事件的回调函数 这三个方法就是实现拖拽的核心所在，我将严格按照上面思维导图中的步骤来完成我们的代码。 1234567891011121314151617181920212223242526272829303132333435363738// 绑定在mousedown上的回调，event为传入的事件对象function start(event) &#123; // 获取鼠标初始位置 startX = event.pageX; startY = event.pageY; // 获取元素初始位置 var pos = getTargetPos(oElem); sourceX = pos.x; sourceY = pos.y; // 绑定 document.addEventListener('mousemove', move, false); document.addEventListener('mouseup', end, false);&#125;function move(event) &#123; // 获取鼠标当前位置 var currentX = event.pageX; var currentY = event.pageY; // 计算差值 var distanceX = currentX - startX; var distanceY = currentY - startY; // 计算并设置元素当前位置 setTargetPos(oElem, &#123; x: (sourceX + distanceX).toFixed(), y: (sourceY + distanceY).toFixed() &#125;)&#125;function end(event) &#123; document.removeEventListener('mousemove', move); document.removeEventListener('mouseup', end); // do other things&#125; OK，一个简单的拖拽，就这样愉快的实现了。点击下面的链接，可以在线查看该例子的demo。 使用原生js实现拖拽 9、封装拖拽对象在前面一章我给大家分享了面向对象如何实现，基于那些基础知识，我们来将上面实现的拖拽封装为一个拖拽对象。我们的目标是，只要我们声明一个拖拽实例，那么传入的目标元素将自动具备可以被拖拽的功能。 在实际开发中，一个对象我们常常会单独放在一个js文件中，这个js文件将单独作为一个模块，利用各种模块的方式组织起来使用。当然这里没有复杂的模块交互，因为这个例子，我们只需要一个模块即可。 为了避免变量污染，我们需要将模块放置于一个函数自执行方式模拟的块级作用域中。 1234;(function() &#123; ...&#125;)(); 在普通的模块组织中，我们只是单纯的将许多js文件压缩成为一个js文件，因此此处的第一个分号则是为了防止上一个模块的结尾不用分号导致报错。必不可少。当然在通过require或者ES6模块等方式就不会出现这样的情况。 我们知道，在封装一个对象的时候，我们可以将属性与方法放置于构造函数或者原型中，而在增加了自执行函数之后，我们又可以将属性和方法防止与模块的内部作用域。这是闭包的知识。 那么我们面临的挑战就在于，如何合理的处理属性与方法的位置。 当然，每一个对象的情况都不一样，不能一概而论，我们需要清晰的知道这三种位置的特性才能做出最适合的决定。 构造函数中： 属性与方法为当前实例单独拥有，只能被当前实例访问，并且每声明一个实例，其中的方法都会被重新创建一次。 原型中： 属性与方法为所有实例共同拥有，可以被所有实例访问，新声明实例不会重复创建方法。 模块作用域中：属性和方法不能被任何实例访问，但是能被内部方法访问，新声明的实例，不会重复创建相同的方法。 对于方法的判断比较简单。 因为在构造函数中的方法总会在声明一个新的实例时被重复创建，因此我们声明的方法都尽量避免出现在构造函数中。 而如果你的方法中需要用到构造函数中的变量，或者想要公开，那就需要放在原型中。 如果方法需要私有不被外界访问，那么就放置在模块作用域中。 对于属性放置于什么位置有的时候很难做出正确的判断，因此我很难给出一个准确的定义告诉你什么属性一定要放在什么位置，这需要在实际开发中不断的总结经验。但是总的来说，仍然要结合这三个位置的特性来做出最合适的判断。 如果属性值只能被实例单独拥有，比如person对象的name，只能属于某一个person实例，又比如这里拖拽对象中，某一个元素的初始位置，也仅仅只是这个元素的当前位置，这个属性，则适合放在构造函数中。 而如果一个属性仅仅供内部方法访问，这个属性就适合放在模块作用域中。 关于面向对象，上面的几点思考我认为是这篇文章最值得认真思考的精华。如果在封装时没有思考清楚，很可能会遇到很多你意想不到的bug，所以建议大家结合自己的开发经验，多多思考，总结出自己的观点。 根据这些思考，大家可以自己尝试封装一下。然后与我的做一些对比，看看我们的想法有什么不同，在下面例子的注释中，我将自己的想法表达出来。 点击查看已经封装好的demo js 源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132;(function() &#123; // 这是一个私有属性，不需要被实例访问 var transform = getTransform(); function Drag(selector) &#123; // 放在构造函数中的属性，都是属于每一个实例单独拥有 this.elem = typeof selector == 'Object' ? selector : document.getElementById(selector); this.startX = 0; this.startY = 0; this.sourceX = 0; this.sourceY = 0; this.init(); &#125; // 原型 Drag.prototype = &#123; constructor: Drag, init: function() &#123; // 初始时需要做些什么事情 this.setDrag(); &#125;, // 稍作改造，仅用于获取当前元素的属性，类似于getName getStyle: function(property) &#123; return document.defaultView.getComputedStyle ? document.defaultView.getComputedStyle(this.elem, false)[property] : this.elem.currentStyle[property]; &#125;, // 用来获取当前元素的位置信息，注意与之前的不同之处 getPosition: function() &#123; var pos = &#123;x: 0, y: 0&#125;; if(transform) &#123; var transformValue = this.getStyle(transform); if(transformValue == 'none') &#123; this.elem.style[transform] = 'translate(0, 0)'; &#125; else &#123; var temp = transformValue.match(/-?\d+/g); pos = &#123; x: parseInt(temp[4].trim()), y: parseInt(temp[5].trim()) &#125; &#125; &#125; else &#123; if(this.getStyle('position') == 'static') &#123; this.elem.style.position = 'relative'; &#125; else &#123; pos = &#123; x: parseInt(this.getStyle('left') ? this.getStyle('left') : 0), y: parseInt(this.getStyle('top') ? this.getStyle('top') : 0) &#125; &#125; &#125; return pos; &#125;, // 用来设置当前元素的位置 setPostion: function(pos) &#123; if(transform) &#123; this.elem.style[transform] = 'translate('+ pos.x +'px, '+ pos.y +'px)'; &#125; else &#123; this.elem.style.left = pos.x + 'px'; this.elem.style.top = pos.y + 'px'; &#125; &#125;, // 该方法用来绑定事件 setDrag: function() &#123; var self = this; this.elem.addEventListener('mousedown', start, false); function start(event) &#123; self.startX = event.pageX; self.startY = event.pageY; var pos = self.getPosition(); self.sourceX = pos.x; self.sourceY = pos.y; document.addEventListener('mousemove', move, false); document.addEventListener('mouseup', end, false); &#125; function move(event) &#123; var currentX = event.pageX; var currentY = event.pageY; var distanceX = currentX - self.startX; var distanceY = currentY - self.startY; self.setPostion(&#123; x: (self.sourceX + distanceX).toFixed(), y: (self.sourceY + distanceY).toFixed() &#125;) &#125; function end(event) &#123; document.removeEventListener('mousemove', move); document.removeEventListener('mouseup', end); // do other things &#125; &#125; &#125; // 私有方法，仅仅用来获取transform的兼容写法 function getTransform() &#123; var transform = '', divStyle = document.createElement('div').style, transformArr = ['transform', 'webkitTransform', 'MozTransform', 'msTransform', 'OTransform'], i = 0, len = transformArr.length; for(; i &lt; len; i++) &#123; if(transformArr[i] in divStyle) &#123; return transform = transformArr[i]; &#125; &#125; return transform; &#125; // 一种对外暴露的方式 window.Drag = Drag;&#125;)();// 使用：声明2个拖拽实例new Drag('target');new Drag('target2'); 这样一个拖拽对象就封装完毕了。 建议大家根据我提供的思维方式，多多尝试封装一些组件。比如封装一个弹窗，封装一个循环轮播等。练得多了，面向对象就不再是问题了。这种思维方式，在未来任何时候都是能够用到的。 下一章分析jQuery对象的实现，与如何将我们这里封装的拖拽对象扩展为jQuery插件。]]></content>
      <categories>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>拖拽对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[摘抄面向对象]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F17%2F%E6%91%98%E6%8A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[如果要我总结一下学习前端以来我遇到了哪些瓶颈，那么面向对象一定是第一个毫不犹豫想到的。尽管我现在对于面向对象有了一些的了解，但是当初的那种似懂非懂的痛苦，依然历历在目。 为了帮助大家能够更加直观的学习和了解面向对象，我会用尽量简单易懂的描述来展示面向对象的相关知识。并且也准备了一些实用的例子帮助大家更加快速的掌握面向对象的真谛。 jQuery的面向对象实现 封装拖拽 简易版运动框架封装 这可能会花一点时间，但是却值得期待。所以如果有兴趣的朋友可以来简书和公众号关注我。 而这篇文章主要来聊一聊关于面向对象的一些重要的基本功。 一、对象的定义在ECMAScript-262中，对象被定义为“无序属性的集合，其属性可以包含基本值，对象或者函数”。 也就是说，在JavaScript中，对象无非就是由一些列无序的key-value对组成。其中value可以是基本值，对象或者函数。 1234567// 这里的person就是一个对象var person = &#123; name: 'Tom', age: 18, getName: function() &#123;&#125;, parent: &#123;&#125;&#125; 创建对象我们可以通过new的方式创建一个对象。 1var obj = new Object(); 也可以通过对象字面量的形式创建一个简单的对象。 1var obj = &#123;&#125;; 当我们想要给我们创建的简单对象添加方法时，可以这样表示。 1234567891011121314// 可以这样var person = &#123;&#125;;person.name = "TOM";person.getName = function() &#123; return this.name;&#125;// 也可以这样var person = &#123; name: "TOM", getName: function() &#123; return this.name; &#125;&#125; 访问对象的属性和方法假如我们有一个简单的对象如下： 1234567var person = &#123; name: 'TOM', age: '20', getName: function() &#123; return this.name &#125;&#125; 当我们想要访问他的name属性时，可以用如下两种方式访问。 1234person.name// 或者person['name'] 如果我们想要访问的属性名是一个变量时，常常会使用第二种方式。例如我们要同时访问person的name与age，可以这样写： 123['name', 'age'].forEach(function(item) &#123; console.log(person[item]);&#125;) 这种方式一定要重视，记住它以后在我们处理复杂数据的时候会有很大的帮助。 二、工厂模式使用上面的方式创建对象很简单，但是在很多时候并不能满足我们的需求。就以person对象为例。假如我们在实际开发中，不仅仅需要一个名字叫做TOM的person对象，同时还需要另外一个名为Jake的person对象，虽然他们有很多相似之处，但是我们不得不重复写两次。 123456789101112131415var perTom = &#123; name: 'TOM', age: 20, getName: function() &#123; return this.name &#125;&#125;;var perJake = &#123; name: 'Jake', age: 22, getName: function() &#123; return this.name &#125;&#125; 很显然这并不是合理的方式，当相似对象太多时，大家都会崩溃掉。 我们可以使用工厂模式的方式解决这个问题。顾名思义，工厂模式就是我们提供一个模子，然后通过这个模子复制出我们需要的对象。我们需要多少个，就复制多少个。 123456789101112131415161718var createPerson = function(name, age) &#123; // 声明一个中间对象，该对象就是工厂模式的模子 var o = new Object(); // 依次添加我们需要的属性与方法 o.name = name; o.age = age; o.getName = function() &#123; return this.name; &#125; return o;&#125;// 创建两个实例var perTom = createPerson('TOM', 20);var PerJake = createPerson('Jake', 22); 相信上面的代码并不难理解，也不用把工厂模式看得太过高大上。很显然，工厂模式帮助我们解决了重复代码上的麻烦，让我们可以写很少的代码，就能够创建很多个person对象。但是这里还有两个麻烦，需要我们注意。 第一个麻烦就是这样处理，我们没有办法识别对象实例的类型。使用instanceof可以识别对象的类型，如下例子： 12345var obj = &#123;&#125;;var foo = function() &#123;&#125;console.log(obj instanceof Object); // trueconsole.log(foo instanceof Function); // true 因此在工厂模式的基础上，我们需要使用构造函数的方式来解决这个麻烦。 三、构造函数在JavaScript中，new关键字可以让一个函数变得与众不同。通过下面的例子，我们来一探new关键字的神奇之处。 123456function demo() &#123; console.log(this);&#125;demo(); // windownew demo(); // demo 为了能够直观的感受他们不同，建议大家动手实践观察一下。很显然，使用new之后，函数内部发生了一些变化，让this指向改变。那么new关键字到底做了什么事情呢。嗯，其实我之前在文章里用文字大概表达了一下new到底干了什么，但是一些同学好奇心很足，总期望用代码实现一下，我就大概以我的理解来表达一下吧。 1234567891011121314151617181920212223242526272829303132333435363738// 先一本正经的创建一个构造函数，其实该函数与普通函数并无区别var Person = function(name, age) &#123; this.name = name; this.age = age; this.getName = function() &#123; return this.name; &#125;&#125;// 将构造函数以参数形式传入function New(func) &#123; // 声明一个中间对象，该对象为最终返回的实例 var res = &#123;&#125;; if (func.prototype !== null) &#123; // 将实例的原型指向构造函数的原型 res.__proto__ = func.prototype; &#125; // ret为构造函数执行的结果，这里通过apply，将构造函数内部的this指向修改为指向res，即为实例对象 var ret = func.apply(res, Array.prototype.slice.call(arguments, 1)); // 当我们在构造函数中明确指定了返回对象时，那么new的执行结果就是该返回对象 if ((typeof ret === "object" || typeof ret === "function") &amp;&amp; ret !== null) &#123; return ret; &#125; // 如果没有明确指定返回对象，则默认返回res，这个res就是实例对象 return res;&#125;// 通过new声明创建实例，这里的p1，实际接收的正是new中返回的resvar p1 = New(Person, 'tom', 20);console.log(p1.getName());// 当然，这里也可以判断出实例的类型了console.log(p1 instanceof Person); // true JavaScript内部再通过其他的一些特殊处理，将var p1 = New(Person, &#39;tom&#39;, 20); 等效于var p1 = new Person(&#39;tom&#39;, 20);。就是我们认识的new关键字了。具体怎么处理的，我也不知道，别刨根问底了，一直回答下去太难 - -！ 老实讲，你可能很难在其他地方看到有如此明确的告诉你new关键字到底对构造函数干了什么的文章了。理解了这段代码，你对JavaScript的理解又比别人深刻了一分，所以，一本正经厚颜无耻求个赞可好？ 当然，很多朋友由于对于前面几篇文章的知识理解不够到位，会对new的实现表示非常困惑。但是老实讲，如果你读了我的前面几篇文章，一定会对这里new的实现有似曾相识的感觉。而且我这里已经尽力做了详细的注解，剩下的只能靠你自己了。 但是只要你花点时间，理解了他的原理，那么困扰了无数人的构造函数中this到底指向谁就变得非常简单了。 所以，为了能够判断实例与对象的关系，我们就使用构造函数来搞定。 123456789101112var Person = function(name, age) &#123; this.name = name; this.age = age; this.getName = function() &#123; return this.name; &#125;&#125;var p1 = new Person('Ness', 20);console.log(p1.getName()); // Nessconsole.log(p1 instanceof Person); // true 关于构造函数，如果你暂时不能够理解new的具体实现，就先记住下面这几个结论吧。 与普通函数相比，构造函数并没有任何特别的地方，首字母大写只是我们约定的小规定，用于区分普通函数； new关键字让构造函数具有了与普通函数不同的许多特点，而new的过程中，执行了如下过程： 声明一个中间对象； 将该中间对象的原型指向构造函数的原型； 将构造函数的this，指向该中间对象； 返回该中间对象，即返回实例对象。 四、原型虽然构造函数解决了判断实例类型的问题，但是，说到底，还是一个对象的复制过程。跟工厂模式颇有相似之处。也就是说，当我们声明了100个person对象，那么就有100个getName方法被重新生成。 这里的每一个getName方法实现的功能其实是一模一样的，但是由于分别属于不同的实例，就不得不一直不停的为getName分配空间。这就是工厂模式存在的第二个麻烦。 显然这是不合理的。我们期望的是，既然都是实现同一个功能，那么能不能就让每一个实例对象都访问同一个方法？ 当然能，这就是原型对象要帮我们解决的问题了。 我们创建的每一个函数，都可以有一个prototype属性，该属性指向一个对象。这个对象，就是我们这里说的原型。 当我们在创建对象时，可以根据自己的需求，选择性的将一些属性和方法通过prototype属性，挂载在原型对象上。而每一个new出来的实例，都有一个__proto__属性，该属性指向构造函数的原型对象，通过这个属性，让实例对象也能够访问原型对象上的方法。因此，当所有的实例都能够通过__proto__访问到原型对象时，原型对象的方法与属性就变成了共有方法与属性。 我们通过一个简单的例子与图示，来了解构造函数，实例与原型三者之间的关系。 由于每个函数都可以是构造函数，每个对象都可以是原型对象，因此如果在理解原型之初就想的太多太复杂的话，反而会阻碍你的理解，这里我们要学会先简化它们。就单纯的剖析这三者的关系。 1234567891011121314// 声明构造函数function Person(name, age) &#123; this.name = name; this.age = age;&#125;// 通过prototye属性，将方法挂载到原型对象上Person.prototype.getName = function() &#123; return this.name;&#125;var p1 = new Person('tim', 10);var p2 = new Person('jak', 22);console.log(p1.getName === p2.getName); // true 通过图示我们可以看出，构造函数的prototype与所有实例对象的__proto__都指向原型对象。而原型对象的constructor指向构造函数。 除此之外，还可以从图中看出，实例对象实际上对前面我们所说的中间对象的复制，而中间对象中的属性与方法都在构造函数中添加。于是根据构造函数与原型的特性，我们就可以将在构造函数中，通过this声明的属性与方法称为私有变量与方法，它们被当前被某一个实例对象所独有。而通过原型声明的属性与方法，我们可以称之为共有属性与方法，它们可以被所有的实例对象访问。 当我们访问实例对象中的属性或者方法时，会优先访问实例对象自身的属性和方法。 123456789101112131415function Person(name, age) &#123; this.name = name; this.age = age; this.getName = function() &#123; console.log('this is constructor.'); &#125;&#125;Person.prototype.getName = function() &#123; return this.name;&#125;var p1 = new Person('tim', 10);p1.getName(); // this is constructor. 在这个例子中，我们同时在原型与构造函数中都声明了一个getName函数，运行代码的结果表示原型中的访问并没有被访问。 我们还可以通过in来判断，一个对象是否拥有某一个属性/方法，无论是该属性/方法存在与实例对象还是原型对象。 123456789101112function Person(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.getName = function() &#123; return this.name;&#125;var p1 = new Person('tim', 10);console.log('name' in p1); // true in的这种特性最常用的场景之一，就是判断当前页面是否在移动端打开。 123isMobile = 'ontouchstart' in document;// 很多人喜欢用浏览器UA的方式来判断，但并不是很好的方式 更简单的原型写法 根据前面例子的写法，如果我们要在原型上添加更多的方法，可以这样写： 123456function Person() &#123;&#125;Person.prototype.getName = function() &#123;&#125;Person.prototype.getAge = function() &#123;&#125;Person.prototype.sayHello = function() &#123;&#125;... ... 除此之外，我还可以使用更为简单的写法。 12345678function Person() &#123;&#125;Person.prototype = &#123; constructor: Person, getName: function() &#123;&#125;, getAge: function() &#123;&#125;, sayHello: function() &#123;&#125;&#125; 这种字面量的写法看上去简单很多，但是有一个需要特别注意的地方。Person.prototype = {}实际上是重新创建了一个{}对象并赋值给Person.prototype，这里的{}并不是最初的那个原型对象。因此它里面并不包含constructor属性。为了保证正确性，我们必须在新创建的{}对象中显示的设置constructor的指向。即上面的constructor: Person。 五、原型链原型对象其实也是普通的对象。几乎所有的对象都可能是原型对象，也可能是实例对象，而且还可以同时是原型对象与实例对象。这样的一个对象，正是构成原型链的一个节点。因此理解了原型，那么原型链并不是一个多么复杂的概念。 我们知道所有的函数都有一个叫做toString的方法。那么这个方法到底是在哪里的呢？ 先随意声明一个函数： 1function add() &#123;&#125; 那么我们可以用如下的图来表示这个函数的原型链。 其中add是Function对象的实例。而Function的原型对象同时又是Object原型的实例。这样就构成了一条原型链。原型链的访问，其实跟作用域链有很大的相似之处，他们都是一次单向的查找过程。因此实例对象能够通过原型链，访问到处于原型链上对象的所有属性与方法。这也是foo最终能够访问到处于Object原型对象上的toString方法的原因。 基于原型链的特性，我们可以很轻松的实现继承。 六、继承我们常常结合构造函数与原型来创建一个对象。因为构造函数与原型的不同特性，分别解决了我们不同的困扰。因此当我们想要实现继承时，就必须得根据构造函数与原型的不同而采取不同的策略。 我们声明一个Person对象，该对象将作为父级，而子级cPerson将要继承Person的所有属性与方法。 12345678function Person(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.getName = function() &#123; return this.name;&#125; 首先我们来看构造函数的继承。在上面我们已经理解了构造函数的本质，它其实是在new内部实现的一个复制过程。而我们在继承时想要的，就是想父级构造函数中的操作在子级的构造函数中重现一遍即可。我们可以通过call方法来达到目的。 12345// 构造函数的继承function cPerson(name, age, job) &#123; Person.call(this, name, age); this.job = job;&#125; 而原型的继承，则只需要将子级的原型对象设置为父级的一个实例，加入到原型链中即可。 12345// 继承原型cPerson.prototype = new Person(name, age);// 添加更多方法cPerson.prototype.getLive = function() &#123;&#125; 当然关于继承还有更好的方式。 七、更好的继承假设原型链的终点Object.prototype为原型链的E(end)端，原型链的起点为S(start)端。 通过前面原型链的学习我们知道，处于S端的对象，可以通过S -&gt; E的单向查找，访问到原型链上的所有方法与属性。因此这给继承提供了理论基础。我们只需要在S端添加新的对象，那么新对象就能够通过原型链访问到父级的方法与属性。因此想要实现继承，是一件非常简单的事情。 因为封装一个对象由构造函数与原型共同组成，因此继承也会分别有构造函数的继承与原型的继承。 假设我们已经封装好了一个父类对象Person。如下。 123456789101112var Person = function(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.getName = function() &#123; return this.name;&#125;Person.prototype.getAge = function() &#123; return this.age;&#125; 构造函数的继承比较简单，我们可以借助call/apply来实现。假设我们要通过继承封装一个Student的子类对象。那么构造函数可以如下实现。 12345678910111213var Student = function(name, age, grade) &#123; // 通过call方法还原Person构造函数中的所有处理逻辑 Student.call(Person, name, age); this.grade = grade;&#125;// 等价于var Student = function(name, age, grade) &#123; this.name = name; this.age = age; this.grade = grade;&#125; 原型的继承则稍微需要一点思考。首先我们应该考虑，如何将子类对象的原型加入到原型链中？我们只需要让子类对象的原型，成为父类对象的一个实例，然后通过__proto__就可以访问父类对象的原型。这样就继承了父类原型中的方法与属性了。 因此我们可以先封装一个方法，该方法根据父类对象的原型创建一个实例，该实例将会作为子类对象的原型。 1234567891011function create(proto, options) &#123; // 创建一个空对象 var tmp = &#123;&#125;; // 让这个新的空对象成为父类对象的实例 tmp.__proto__ = proto; // 传入的方法都挂载到新对象上，新的对象将作为子类对象的原型 Object.defineProperties(tmp, options); return tmp;&#125; 简单封装了create对象之后，我们就可以使用该方法来实现原型的继承了。 1234567891011Student.prototype = create(Person.prototype, &#123; // 不要忘了重新指定构造函数 constructor: &#123; value: Student &#125; getGrade: &#123; value: function() &#123; return this.grade &#125; &#125;&#125;) 那么我们来验证一下我们这里实现的继承是否正确。 12345var s1 = new Student('ming', 22, 5);console.log(s1.getName()); // mingconsole.log(s1.getAge()); // 22console.log(s1.getGrade()); // 5 全部都能正常访问，没问题。在ECMAScript5中直接提供了一个Object.create方法来完成我们上面自己封装的create的功能。因此我们可以直接使用Object.create. 1234567891011Student.prototype = create(Person.prototype, &#123; // 不要忘了重新指定构造函数 constructor: &#123; value: Student &#125; getGrade: &#123; value: function() &#123; return this.grade &#125; &#125;&#125;) 完整代码如下： 123456789101112131415161718192021222324252627282930313233343536function Person(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.getName = function() &#123; return this.name&#125;Person.prototype.getAge = function() &#123; return this.age;&#125;function Student(name, age, grade) &#123; // 构造函数继承 Person.call(this, name, age); this.grade = grade;&#125;// 原型继承Student.prototype = Object.create(Person.prototype, &#123; // 不要忘了重新指定构造函数 constructor: &#123; value: Student &#125; getGrade: &#123; value: function() &#123; return this.grade &#125; &#125;&#125;)var s1 = new Student('ming', 22, 5);console.log(s1.getName()); // mingconsole.log(s1.getAge()); // 22console.log(s1.getGrade()); // 5 八、属性类型在上面的继承实现中，使用了一个大家可能不太熟悉的方法defineProperties。并且在定义getGrade时使用了一个很奇怪的方式。 12345getGrade: &#123; value: function() &#123; return this.grade &#125;&#125; 这其实是对象中的属性类型。在我们平常的使用中，给对象添加一个属性时，直接使用object.param的方式就可以了，或者直接在对象中挂载。 123var person = &#123; name: 'TOM'&#125; 在ECMAScript5中，对每个属性都添加了几个属性类型，来描述这些属性的特点。他们分别是 configurable: 表示该属性是否能被delete删除。当其值为false时，其他的特性也不能被改变。默认值为true enumerable: 是否能枚举。也就是是否能被for-in遍历。默认值为true writable: 是否能修改值。默认为true value: 该属性的具体值是多少。默认为undefined get: 当我们通过person.name访问name的值时，get将被调用。该方法可以自定义返回的具体值时多少。get默认值为undefined set: 当我们通过person.name = &#39;Jake&#39;设置name的值时，set方法将被调用。该方法可以自定义设置值的具体方式。set默认值为undefined 需要注意的是，不能同时设置value、writable 与 get、set的值。 我们可以通过Object.defineProperty方法来修改这些属性类型。 下面我们用一些简单的例子来演示一下这些属性类型的具体表现。 configurable 1234567891011121314151617181920212223// 用普通的方式给person对象添加一个name属性，值为TOMvar person = &#123; name: 'TOM'&#125;// 使用delete删除该属性delete person.name; // 返回true 表示删除成功// 通过Object.defineProperty重新添加name属性// 并设置name的属性类型的configurable为false，表示不能再用delete删除Object.defineProperty(person, 'name', &#123; configurable: false, value: 'Jake' // 设置name属性的值&#125;)// 再次delete，已经不能删除了delete person.name // falseconsole.log(person.name) // 值为Jake// 试图改变valueperson.name = "alex";console.log(person.name) // Jake 改变失败 enumerable 123456789101112131415161718192021222324252627var person = &#123; name: 'TOM', age: 20&#125;// 使用for-in枚举person的属性var params = [];for(var key in person) &#123; params.push(key);&#125;// 查看枚举结果console.log(params); // ['name', 'age']// 重新设置name属性的类型，让其不可被枚举Object.defineProperty(person, 'name', &#123; enumerable: false&#125;)var params_ = [];for(var key in person) &#123; params_.push(key)&#125;// 再次查看枚举结果console.log(params_); // ['age'] writable 12345678910111213141516171819var person = &#123; name: 'TOM'&#125;// 修改name的值person.name = 'Jake';// 查看修改结果console.log(person.name); // Jake 修改成功// 设置name的值不能被修改Object.defineProperty(person, 'name', &#123; writable: false&#125;)// 再次试图修改name的值person.name = 'alex';console.log(person.name); // Jake 修改失败 value 12345678var person = &#123;&#125;// 添加一个name属性Object.defineProperty(person, 'name', &#123; value: 'TOM'&#125;)console.log(person.name) // TOM get/set 12345678910111213141516171819202122var person = &#123;&#125;// 通过get与set自定义访问与设置name属性的方式Object.defineProperty(person, 'name', &#123; get: function() &#123; // 一直返回TOM return 'TOM' &#125;, set: function(value) &#123; // 设置name属性时，返回该字符串，value为新值 console.log(value + ' in set'); &#125;&#125;)// 第一次访问name，调用getconsole.log(person.name) // TOM// 尝试修改name值，此时set方法被调用person.name = 'alex' // alex in set// 第二次访问name，还是调用getconsole.log(person.name) // TOM 请尽量同时设置get、set。如果仅仅只设置了get，那么我们将无法设置该属性值。如果仅仅只设置了set，我们也无法读取该属性的值。 Object.defineProperty只能设置一个属性的属性特性。当我们想要同时设置多个属性的特性时，需要使用我们之前提到过的Object.defineProperties 12345678910111213141516171819var person = &#123;&#125;Object.defineProperties(person, &#123; name: &#123; value: 'Jake', configurable: true &#125;, age: &#123; get: function() &#123; return this.value || 22 &#125;, set: function(value) &#123; this.value = value &#125; &#125;&#125;)person.name // Jakeperson.age // 22 读取属性的特性值我们可以使用Object.getOwnPropertyDescriptor方法读取某一个属性的特性值。 123456789101112131415161718var person = &#123;&#125;Object.defineProperty(person, 'name', &#123; value: 'alex', writable: false, configurable: false&#125;)var descripter = Object.getOwnPropertyDescriptor(person, 'name');console.log(descripter); // 返回结果如下descripter = &#123; configurable: false, enumerable: false, value: 'alex', writable: false&#125; 九、总结 关于面向对象的基础知识大概就是这些了。我从最简单的创建一个对象开始，解释了为什么我们需要构造函数与原型，理解了这其中的细节，有助于我们在实际开发中灵活的组织自己的对象。因为我们并不是所有的场景都会使用构造函数或者原型来创建对象，也许我们需要的对象并不会声明多个实例，或者不用区分对象的类型，那么我们就可以选择更简单的方式。 我们还需要关注构造函数与原型的各自特性，有助于我们在创建对象时准确的判断我们的属性与方法到底是放在构造函数中还是放在原型中。如果没有理解清楚，这会给我们在实际开发中造成非常大的困扰。 最后接下来的几篇文章，我会挑几个面向对象的例子，继续帮助大家掌握面向对象的实际运用。]]></content>
      <categories>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[摘抄详解ES6]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F17%2F%E6%91%98%E6%8A%84%E8%AF%A6%E8%A7%A3ES6%2F</url>
    <content type="text"><![CDATA[对于新人朋友来说，想要自己去搞定一个ES6开发环境并不是一件容易的事情，因为构建工具的学习本身又是一个非常大的方向，我们需要花费不少的时间才能掌握它。 好在慢慢的开始有大神提供了一些非常简单易懂，学习成本非常低的解决方案来帮助大家学习。create-react-app就是这些解决方案中，个人认为最简单易懂的一种方式。 所以在学习ES6 modules之前，先跟大家介绍一下create-react-app的安装与使用。 尽管create-react-app的目的是用于开发react程序，但是我们仅仅只用来学习ES6是再合适不过了。当然你也可以借助vue-cli来学习，同样十分简单。 1、确保自己的本地环境已经安装了node与npm通常安装的方式就是去node的官方网站下载安装，在安装node的时候，npm也会一起被安装。 下载地址： http://nodejs.cn/download/ 2、安装一个好用的命令行工具在windows环境下，系统默认的cmd非常难用，所以我个人比较推荐大家使用git.bash 或者 cmder。 git 下载地址： https://git-scm.com/downloads在git安装目录下会有一个bash工具，找到安装目录直接使用即可。 cmder下载地址： http://cmder.net/ 在mac上就方便很多了，你可以直接使用系统自带的terminal工具，就非常好用。但是一般我推荐大家使用iterm2，并安装oh my zsh插件。具体的配置大家可以自己去折腾，网上的教程应该足够帮助你搞定这一切了。 iterm2 下载地址 http://www.iterm2.com/downloads.html oh my zsh 主题选择 https://github.com/robbyrussell/oh-my-zsh/wiki/External-themes 另外还强烈推荐一款超高颜值的终端工具 hyperTerm。 这款工具的特色就是颜值高，第一感觉就是惊艳，大家不妨一试。 hyperTerm 下载地址 https://hyper.is/ 3、安装create-react-app在命令行工具中使用查看版本的方式确保node与npm都安装好之后，我们就可以安装create-react-app了。 12345&gt; node -v// 输出node版本号&gt; npm -v// 输出npm版本号 使用npm全局安装create-react-app 1&gt; npm install create-react-app -g 然后我们就可以使用create-react-app来创建我们的第一个项目。 找到一个你要存放项目的根目录，假设叫做develop，运行以下指令。 1&gt; create-react-app es6app create-react-app会自动帮助我们在develop目录下创建一个叫做es6app的文件夹，这就是我们新创建的项目。 当项目创建完成之后，在命令行工具中，我们会看到如图所示的提示。这些提示告诉了我们如何运行项目npm start ，如何打包项目npm run build等，这里我就不再赘述。 项目创建完毕之后，进入该文件夹。 1234&gt; cd es6app// 查看文件夹里的内容&gt; ls 我们会发现里面有一个叫做package.json的文件，这个文件里包含了项目所需要的所有依赖。当我们第一次运行项目之前，还需要安装该文件里的依赖包。 1&gt; npm install 安装完毕之后，我们就可以启动该项目了。 1&gt; npm start 一般来说，启动之后会自动在浏览器中打开。 create-react-app已经自动帮助我们实现了热更新，因此当我们修改代码时，浏览器会自动更新。当然，如果我们仅仅只是修改页面样式时，热更新将会非常方便，但是如果你正在进行单页面的组件开发，可能热更新能够提供的帮助非常有限。 4、认识项目只要我们按照构建工具的规则进行开发，那么构建工具会自动帮助我们将代码进行整合，因此在该项目中开发时，我们并不需要自己来使用script或者link标签来引入js与css，所以认识create-react-app的规则就变得很重要。 初次创建的项目下，会有3个文件夹。 node_modules项目依赖包存放位置。当我们运行npm install安装package.json中的依赖包时，该文件夹会自动创建，所有的依赖包会安装到该文件夹里。 public主要的作用是html入口文件的存放。当然我们也可以存放其他公用的静态资源，如图片，css等。其中的index.html就是我们项目的入口html文件 src组件的存放目录。在create-react-app创建的项目中，每一个单独的文件都可以被看成一个单独的模块，单独的image，单独的css，单独js等，而所有的组件都存放于src目录中，其中index.js则是js的入口文件。虽然我们并没有在index.html中使用script标签引入他，但是他的作用就和此一样。 当然，如果我们要进一步进行react的学习，那么肯定需要了解多一点的规则，但是在学习react之前，我们还是先把ES6 modules的知识搞定在说吧，所以，接下来你要做的事情就是，删掉src目录里的除了index.js之外的所有文件，并清空index.js，我们从0开始学习ES6 modules。 为了确保程序仍然能够正常运行，我们在index.js中随便写点代码测试一下 12const app = document.querySelector('#root')app.innerHTML = '啊，全部被清空啦，准备工作终于做完了，可以开始学习ES6啦' 那么我们就可以在这个环境下学习ES6的所有知识了，当然也包括ES6 modules。 ES6 modules1. 引入模块首先在src目录下创建一个test.js，在test.js中我们随便干点什么简单的事情即可。 12// src/test.jsconsole.log('your first module'); 在index.js中通过import引入test.js，这是我们要学会的第一个语法 1234// src/index.jsimport test from './test'console.log(test); import表示引入一个模块， test 我们暂时理解为引入模块的名字， from表示从哪里引入 ./test为./test.js的简写，表示将要引入模块的路径 引入这个动作执行时，test.js中的代码也执行了。由于在test.js中并没有对外暴露任何接口，因此index.js中的test为一个空对象，那么对外暴露接口的方式，则是我们要学习的第二个语法。 2. 对外提供接口ES6 modules使用export关键字对外提供接口，在我们刚才创建的test.js中，我们添加如下代码 12345678910111213141516171819// test.jsconst num = 20;const arr = [1, 2, 3, 4];const obj = &#123; a: 0, b: function() &#123;&#125;&#125;const foo = () =&gt; &#123; const a = 0; const b = 20; return a + b;&#125;export default &#123; num, arr, obj, foo&#125; 在test.js中，我们使用export default对包暴露了一个对象。他的意思就是当我们使用import test from &#39;./test&#39;时，这个test对象就默认等于export default暴露的对象。 我们还可以在test.js中，仅仅通过export暴露几个方法与属性，我们来看看index.js中test会变成什么样子。 123// src/test.jsexport const bar = () =&gt; &#123;&#125;export const zcar = 12345; 保存运行后，我们发现，index.js中的test对象并没有变化，因为它仅仅等于export default抛出的对象，因此，为了获得模块test.js暴露的所有接口，我们得通过如下的方式。 12// src/index.jsimport * as test from './test'; 其中的 * 表示所有，这是比较常用的通配符，as表示别名，* as test的意思是将test.js暴露的所有接口组成的对象，命名为test。那么我们在index.js中log出test，结果就如下。 如果大家还记得前面一篇文章里，我所讲的ES6解析结构的语法，那么对于如下的用法相信就不难理解。 123456// src/index.jsimport test, &#123; bar, zcar &#125; from './test';console.log(test);console.log('bar:', bar);console.log('zcar:', zcar); test，仍然表示为export default暴露的对象，而 { bar, zcar }则表示利用解析结构的语法，从整个返回对象中去取得对应的接口。输出结果也就很清晰了。 这种方式还是比较常见，比如我们在使用react时，常常这样使用： 1import React, &#123; Component &#125; from 'react' 它其实暗示了React的封装方式，也暗示了我们应该如何去封装我们的模块。 这里我们能够直接引入react的原因，是因为我们将它安装到了文件夹node_modules中，该文件夹中安装的所有模块都可以这样直接引用。例如我们安装一个jquery。 12// 安装jquery&gt; npm install jquery 然后在其他模块中就可以直接引入 1import $ from 'jquery' 这样，我们可以和往常一样使用jquery。通过这样方式，我们还可以扩展更多的库，这就使得我们这个开发环境不仅仅能够用于react的开发，怎么用，完全取决与你自己。 OK，ES6 模块的基础语法大概就这些吧，他告诉了我们在ES6中，一个模块应该如何对外暴露接口与如何引入其他模块暴露的接口，这个知识点在实际开发中非常常用，因此虽然简单，但是不得不掌握，这也是大家进一步学习react或者vue的基础，主要的难点大概在于本地开发环境的折腾，如果你是初次折腾这些，可能会遇到一些小问题，所以一定要有一点耐心。 通常来说，一个知识点，在完全理解之前还是有点难度的，但是理解之后就变得非常简单，所以如果你在学习这个知识点时感觉有点困难，也不要过于担心，多多动手尝试，并在实践中运用起来，相信很快就能掌握。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[摘抄浅析jQuery]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F17%2F%E6%91%98%E6%8A%84%E6%B5%85%E6%9E%90jQuery%2F</url>
    <content type="text"><![CDATA[早几年学习前端，大家都非常热衷于研究jQuery源码。我还记得当初从jQuery源码中学到一星半点应用技巧的时候常会有一种发自内心的惊叹，“原来JavaScript居然可以这样用！” 虽然随着前端的发展，另外几种前端框架的崛起，jQuery慢慢变得不再是必须。因此大家对于jQuery的热情低了很多。但是许多从jQuery中学到的技巧用在实际开发中仍然非常好用。简单的了解它也有助于我们更加深入的理解JavaScript。 这篇文章的主要目的就是跟大家分享一下，jquery对象是如何封装的。算是对于大家进一步学习jQuery源码的一个抛砖引玉。 使用jQuery对象时，我们这样写： 12345678// 声明一个jQuery对象$('.target')// 获取元素的css属性$('.target').css('width')// 获取元素的位置信息$('.target').offset() 在使用之初可能会有许多疑问，比如$是怎么回事？为什么不用new就可以直接声明一个对象等等。后来了解之后，才知道原来这正是jQuery对象创建的巧妙之处。 先直接用代码展示出来，再用图跟大家解释是怎么回事。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081;(function(ROOT) &#123; // 构造函数 var jQuery = function(selector) &#123; // 在jQuery中直接返回new过的实例，这里的init是jQuery的真正构造函数 return new jQuery.fn.init(selector) &#125; jQuery.fn = jQuery.prototype = &#123; constructor: jQuery, version: '1.0.0', init: function(selector) &#123; // 在jquery中这里有一个复杂的判断，但是这里我做了简化 var elem, selector; elem = document.querySelector(selector); this[0] = elem; // 在jquery中返回一个由所有原型属性方法组成的数组，我们这里简化，直接返回this即可 // return jQuery.makeArray(selector, this); return this; &#125;, // 在原型上添加一堆方法 toArray: function() &#123;&#125;, get: function() &#123;&#125;, each: function() &#123;&#125;, ready: function() &#123;&#125;, first: function() &#123;&#125;, slice: function() &#123;&#125; // ... ... &#125; jQuery.fn.init.prototype = jQuery.fn; // 实现jQuery的两种扩展方式 jQuery.extend = jQuery.fn.extend = function(options) &#123; // 在jquery源码中会根据参数不同进行很多判断，我们这里就直接走一种方式，所以就不用判断了 var target = this; var copy; for(name in options) &#123; copy = options[name]; target[name] = copy; &#125; return target; &#125; // jQuery中利用上面实现的扩展机制，添加了许多方法，其中 // 直接添加在构造函数上，被称为工具方法 jQuery.extend(&#123; isFunction: function() &#123;&#125;, type: function() &#123;&#125;, parseHTML: function() &#123;&#125;, parseJSON: function() &#123;&#125;, ajax: function() &#123;&#125; // ... &#125;) // 添加到原型上 jQuery.fn.extend(&#123; queue: function() &#123;&#125;, promise: function() &#123;&#125;, attr: function() &#123;&#125;, prop: function() &#123;&#125;, addClass: function() &#123;&#125;, removeClass: function() &#123;&#125;, val: function() &#123;&#125;, css: function() &#123;&#125; // ... &#125;) // $符号的由来，实际上它就是jQuery，一个简化的写法，在这里我们还可以替换成其他可用字符 ROOT.jQuery = ROOT.$ = jQuery;&#125;)(window); 在上面的代码中，我封装了一个简化版的jQuery对象。它向大家简单展示了jQuery的整体框架情况。如果了解了整体框架，那么大家去读jQuery源码，就会变得非常轻松。 我们在代码中可以看到，jQuery自身对于原型的处理使用了一些巧妙的语法，比如jQuery.fn = jQuery.prototype，jQuery.fn.init.prototype = jQuery.fn;等，这几句正式jQuery对象的关键所在，下面我用图给大家展示一下这中间的逻辑是怎么回事。 对象封装分析 在上面的实现中，代码首先在jQuery构造函数中声明了一个fn属性，并将其指向了原型jQuery.prototype。并在原型中添加了init方法。 123jQuery.fn = jQuery.prototype = &#123; init: &#123;&#125;&#125; 之后又将init的原型，指向了jQuery.prototype。 1jQuery.fn.init.prototype = jQuery.fn; 而在构造函数jQuery中，返回了init的实例对象。 12345var jQuery = function(selector) &#123; // 在jQuery中直接返回new过的实例，这里的init是jQuery的真正构造函数 return new jQuery.fn.init(selector)&#125; 最后对外暴露入口时，将字符$与jQuery对等起来。 1ROOT.jQuery = ROOT.$ = jQuery; 因此当我们直接使用$(&#39;#test&#39;)创建一个对象时，实际上是创建了一个init的实例，这里的正真构造函数是原型中的init方法。 注意：许多对jQuery内部实现不太了解的盆友，在使用jQuery时常常会毫无节制使用$()，比如对于同一个元素的不同操作： 1234var width = parseInt($('#test').css('width'));if(width &gt; 20) &#123; $('#test').css('backgroundColor', 'red');&#125; 通过我们上面的一系列分析，我们知道每当我们执行$()时，就会重新生成一个init的实例对象，因此当我们这样没有节制的使用jQuery时是非常不正确的，虽然看上去方便了一些，但是对于内存的消耗是非常大的。正确的做法是既然是同一个对象，那么就用一个变量保存起来后续使用即可。 12345var $test = $('#test');var width = parseInt($test.css('width'));if(width &gt; 20) &#123; $test.css('backgroundColor', 'red');&#125; 扩展方法分析 在上面的代码实现中，我还简单实现了两个扩展方法。 123456789101112jQuery.extend = jQuery.fn.extend = function(options) &#123; // 在jquery源码中会根据参数不同进行很多判断，我们这里就直接走一种方式，所以就不用判断了 var target = this; var copy; for(name in options) &#123; copy = options[name]; target[name] = copy; &#125; return target;&#125; 要理解它的实现，我们首先要明确的知道this的指向。如果你搞不清楚，可以回头去看看我们之前关于this指向的讲解。传入的参数options对象为一个key: value模式的对象，我通过for in遍历options，将key作为jQuery的新属性，value作为该新属性所对应的新方法，分别添加到jQuery方法和jQuery.fn中。 也就是说，当我们通过jQuery.extend扩展jQuery时，方法被添加到了jQuery构造函数中，而当我们通过jQuery.fn.extend扩展jQuery时，方法被添加到了jQuery原型中。 上面的例子中，我也简单展示了在jQuery内部，许多方法的实现都是通过这两个扩展方法来完成的。 当我们通过上面的知识了解了jQuery的大体框架之后，那么我们对于jQuery的学习就可以具体到诸如css/val/attr等方法是如何实现这样的程度，那么源码学习起来就会轻松很多，也会节约更多的时间。也给一些对于源码敬而远之的朋友提供了一个学习的可能。 有一个朋友留言给我，说她被静态方法，工具方法和实例方法这几个概念困扰了很久，到底他们有什么区别？ 其实在上一篇文章中，关于封装一个对象，我跟大家分享了一个非常非常干货，但是却只有少数几个读者老爷get到的知识，那就是在封装对象时，属性和方法可以具体放置的三个位置，并且对于这三个位置的不同做了一个详细的解读。 而在实现jQuery扩展方法的想法中，一部分方法需要扩展到jQuery构造函数中，一部分方法需要扩展到原型中，当我们通读jQuery源码，还发现有一些方法放在了模块作用域中，至于为什么会有这样的区别，建议大家回过头去读读前一篇文章。 而放在构造函数中的方法，因为我们在使用时，不需要声明一个实例对象就可以直接使用，因此这样的方法常常被叫做工具方法，或者所谓的静态方法。工具方法在使用时因为不用创建新的实例，因此相对而言效率会高很多，但是并不节省内存。 而工具方法的特性也和工具一词非常贴近，他们与实例的自身属性毫无关联，仅仅只是实现一些通用的功能，我们可以通过$.each与$(&#39;div&#39;).each这2个方法来体会工具方法与实例方法的不同之处。 在实际开发中，我们运用得非常多的一个工具库就是lodash.js，大家如果时间充裕一定要去学习一下他的使用。 1234$.ajax()$.isFunction()$.each()... ... 而放在原型中的方法，在使用时必须创建了一个新的实例对象才能访问，因此这样的方法叫做实例方法。也正是由于必须创建了一个实例之后才能访问，所以他的使用成本会比工具方法高很多。但是节省了内存。 123$('#test').css()$('#test').attr()$('div').each() 这样，那位同学的疑问就很简单的被搞定了。我们在学习的时候，一定不要过分去纠结一些概念，而要明白具体怎么回事儿，那么学习这件事情就不会在一些奇奇怪怪的地方卡住了。 所以通过$.extend扩展的方法，其实就是对工具方法的扩展，而通过$.fn.extend扩展的方法，就是对于实例方法的扩展。那么我们在使用的时候就知道如何准确的去使用自己扩展的方法了。 jQuery插件的实现 我在初级阶段的时候，觉得要自己编写一个jQuery插件是一件高大上的事情，可望不可即。但是通过对于上面的理解，我就知道扩展jQuery插件其实是一件我们自己也可以完成的事情。 在前面我跟大家分享了jQuery如何实现，以及他们的方法如何扩展，并且前一篇文章分享了拖拽对象的具体实现。所以建议大家暂时不要阅读下去，自己动手尝试将拖拽扩展成为jQuery的一个实例方法，那么这就是一个jQuery插件了。 具体也没有什么可多说的了，大家看了代码就可以明白一切。 12345678910111213141516171819202122232425262728293031323334353637383940414243// Drag对象简化代码，完整源码可在上一篇文章中查看;(function() &#123; // 构造 function Drag(selector) &#123;&#125; // 原型 Drag.prototype = &#123; constructor: Drag, init: function() &#123; // 初始时需要做些什么事情 this.setDrag(); &#125;, // 稍作改造，仅用于获取当前元素的属性，类似于getName getStyle: function(property) &#123;&#125;, // 用来获取当前元素的位置信息，注意与之前的不同之处 getPosition: function() &#123;&#125;, // 用来设置当前元素的位置 setPostion: function(pos) &#123;&#125;, // 该方法用来绑定事件 setDrag: function() &#123;&#125; &#125; // 一种对外暴露的方式 window.Drag = Drag;&#125;)();// 通过扩展方法将拖拽扩展为jQuery的一个实例方法(function ($) &#123; $.fn.extend(&#123; becomeDrag: function () &#123; new Drag(this[0]); return this; // 注意：为了保证jQuery所有的方法都能够链式访问，每一个方法的最后都需要返回this，即返回jQuery实例 &#125; &#125;)&#125;)(jQuery); 后续文章内容一个大概预想 去年年末的时候就有了想要将JavaScript基础知识总结一下的这样一个想法，可是JavaScript基础知识确实并非全部是层层递进的关系，有很多碎片化的东西，所以之前一直没有找到一个合适的整理方法。 直到在segmentfault中我在给题主建议如何快速学习一门诸如react/vue这样的流行框架时，找到了一个好一点的思路，于是就有了这样一系列文章，虽然它并不全面，很多知识没有涉及到，但是其实我是围绕最终通过模块化来构建自己代码这样一个思路来总结的，因此这系列文章能够解决大家最核心的问题。 也正因为如此，这系列的文章的终点将会是在ES6环境下掌握react的使用。虽然前面我多多少少都涉及到了模块的一些概念，但是还差一个实践。因此最终我会以ES6的模块跟大家分享如何使用。 那么后续的文章应该会涉及的内容，就大概包括： 事件循环机制 Promise ES6的基础语法 ES6下的常用设计模式 ES6模块 结合ES6的实例 React基础语法 React组件 React高阶组件 React实例 Redux 这系列文章，算是对于大家学习方向的一个具体的，切实可行的一个指引，而非简单的通过鸡汤的方式告诉你应该如何学习。所以，想要学习这些知识的朋友，赶紧来简书关注我吧！！！！]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[摘抄柯里化]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F17%2F%E6%91%98%E6%8A%84%E6%9F%AF%E9%87%8C%E5%8C%96%2F</url>
    <content type="text"><![CDATA[柯里化是函数的一个比较高级的应用，想要理解它并不简单。因此我一直在思考应该如何更加表达才能让大家理解起来更加容易。 以下是新版本讲解。高阶函数章节由于一些原因并未公开，大家可以自行搜索学习 通过上一个章节的学习我们知道，接收函数作为参数的函数，都可以叫做高阶函数。我们常常利用高阶函数来封装一些公共的逻辑。 这一章我们要学习的柯里化，其实就是高阶函数的一种特殊用法。 柯里化是指这样一个函数(假设叫做createCurry)，他接收函数A作为参数，运行后能够返回一个新的函数。并且这个新的函数能够处理函数A的剩余参数。 这样的定义可能不太好理解，我们可以通过下面的例子配合理解。 假如有一个接收三个参数的函数A。 123function A(a, b, c) &#123; // do something&#125; 又假如我们有一个已经封装好了的柯里化通用函数createCurry。他接收bar作为参数，能够将A转化为柯里化函数，返回结果就是这个被转化之后的函数。 1var _A = createCurry(A); 那么_A作为createCurry运行的返回函数，他能够处理A的剩余参数。因此下面的运行结果都是等价的。 12345_A(1, 2, 3);_A(1, 2)(3);_A(1)(2, 3);_A(1)(2)(3);A(1, 2, 3); 函数A被createCurry转化之后得到柯里化函数_A，_A能够处理A的所有剩余参数。因此柯里化也被称为部分求值。 在简单的场景下，我们可以不用借助柯里化通用式来转化得到柯里化函数，我们可以凭借眼力自己封装。 例如有一个简单的加法函数，他能够将自身的三个参数加起来并返回计算结果。 123function add(a, b, c) &#123; return a + b + c;&#125; 那么add函数的柯里化函数_add则可以如下： 1234567function _add(a) &#123; return function(b) &#123; return function(c) &#123; return a + b + c; &#125; &#125;&#125; 因此下面的运算方式是等价的。 12add(1, 2, 3);_add(1)(2)(3); 当然，柯里化通用式具备更加强大的能力，我们靠眼力自己封装的柯里化函数则自由度偏低。因此我们仍然需要知道自己如何去封装这样一个柯里化的通用式。 首先通过_add可以看出，柯里化函数的运行过程其实是一个参数的收集过程，我们将每一次传入的参数收集起来，并在最里层里面处理。因此我们在实现createCurry时，可以借助这个思路来进行封装。 封装如下: 12345678910111213141516171819// 简单实现，参数只能从右到左传递function createCurry(func, args) &#123; var arity = func.length; var args = args || []; return function() &#123; var _args = [].slice.call(arguments); [].push.apply(_args, args); // 如果参数个数小于最初的func.length，则递归调用，继续收集参数 if (_args.length &lt; arity) &#123; return createCurry.call(this, func, _args); &#125; // 参数收集完毕，则执行func return func.apply(this, _args); &#125;&#125; 尽管我已经做了足够详细的注解，但是我想理解起来也并不是那么容易，因此建议大家用点耐心多阅读几遍。这个createCurry函数的封装借助闭包与递归，实现了一个参数收集，并在收集完毕之后执行所有参数的一个过程。 因此聪明的读者可能已经发现，把函数经过createCurry转化为一个柯里化函数，最后执行的结果，不是正好相当于执行函数自身吗？柯里化是不是把简单的问题复杂化了？ 如果你能够提出这样的问题，那么说明你确实已经对柯里化有了一定的了解。柯里化确实是把简答的问题复杂化了，但是复杂化的同时，我们在使用函数时拥有了更加多的自由度。而这里对于函数参数的自由处理，正是柯里化的核心所在。 我们来举一个非常常见的例子。 如果我们想要验证一串数字是否是正确的手机号，那么按照普通的思路来做，大家可能是这样封装，如下： 123function checkPhone(phoneNumber) &#123; return /^1[34578]\d&#123;9&#125;$/.test(phoneNumber);&#125; 而如果我们想要验证是否是邮箱呢？这么封装： 123function checkEmail(email) &#123; return /^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/.test(email);&#125; 我们还可能会遇到验证身份证号，验证密码等各种验证信息，因此在实践中，为了统一逻辑，，我们就会封装一个更为通用的函数，将用于验证的正则与将要被验证的字符串作为参数传入。 123function check(targetString, reg) &#123; return reg.test(targetString);&#125; 但是这样封装之后，在使用时又会稍微麻烦一点，因为会总是输入一串正则，这样就导致了使用时的效率低下。 12check(/^1[34578]\d&#123;9&#125;$/, '14900000088');check(/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/, 'test@163.com'); 那么这个时候，我们就可以借助柯里化，在check的基础上再做一层封装，以简化使用。 1234var _check = createCurry(check);var checkPhone = _check(/^1[34578]\d&#123;9&#125;$/);var checkEmail = _check(/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/); 最后在使用的时候就会变得更加直观与简洁了。 12checkPhone('183888888');checkEmail('xxxxx@test.com'); 经过这个过程我们发现，柯里化能够应对更加复杂的逻辑封装。当情况变得多变，柯里化依然能够应付自如。 虽然柯里化确实在一定程度上将问题复杂化了，也让代码更加不容易理解，但是柯里化在面对复杂情况下的灵活性却让我们不得不爱。 当然这个案例本身情况还算简单，所以还不能够特别明显的凸显柯里化的优势，我们的主要目的在于借助这个案例帮助大家了解柯里化在实践中的用途。 我们继续来思考一个例子。这个例子与map有关。在高阶函数的章节中，我们分析了封装map方法的思考过程。由于我们没有办法确认一个数组在遍历时会执行什么操作，因此我们只能将调用for循环的这个统一逻辑封装起来，而具体的操作则通过参数传入的形式让使用者自定义。这就是map函数。 但是，这是针对了所有的情况我们才会这样想。 实践中我们常常会发现，在我们的某个项目中，针对于某一个数组的操作其实是固定的，也就是说，同样的操作，可能会在项目的不同地方调用很多次。 于是，这个时候，我们就可以在map函数的基础上，进行二次封装，以简化我们在项目中的使用。假如这个在我们项目中会调用多次的操作是将数组的每一项都转化为百分比 1 –&gt; 100%。 普通思维下我们可以这样来封装。 1234567function getNewArray(array) &#123; return array.map(function(item) &#123; return item * 100 + '%' &#125;)&#125;getNewArray([1, 2, 3, 0.12]); // ['100%', '200%', '300%', '12%']; 而如果借助柯里化来二次封装这样的逻辑，则会如下实现： 123456789101112function _map(func, array) &#123; return array.map(func);&#125;var _getNewArray = createCurry(_map);var getNewArray = _getNewArray(function(item) &#123; return item * 100 + '%'&#125;)getNewArray([1, 2, 3, 0.12]); // ['100%', '200%', '300%', '12%'];getNewArray([0.01, 1]); // ['1%', '100%'] 如果我们的项目中的固定操作是希望对数组进行一个过滤，找出数组中的所有Number类型的数据。借助柯里化思维我们可以这样做。 123456789101112131415161718192021222324252627282930function _filter(func, array) &#123; return array.filter(func);&#125;var _find = createCurry(_filter);var findNumber = _find(function(item) &#123; if (typeof item == 'number') &#123; return item; &#125;&#125;)findNumber([1, 2, 3, '2', '3', 4]); // [1, 2, 3, 4]// 当我们继续封装另外的过滤操作时就会变得非常简单// 找出数字为20的子项var find20 = _find(function(item, i) &#123; if (typeof item === 20) &#123; return i; &#125;&#125;)find20([1, 2, 3, 30, 20, 100]); // 4// 找出数组中大于100的所有数据var findGreater100 = _find(function(item) &#123; if (item &gt; 100) &#123; return item; &#125;&#125;)findGreater100([1, 2, 101, 300, 2, 122]); // [101, 300, 122] 我采用了与check例子不一样的思维方向来想大家展示我们在使用柯里化时的想法。目的是想告诉大家，柯里化能够帮助我们应对更多更复杂的场景。 当然不得不承认，这些例子都太简单了，简单到如果使用柯里化的思维来处理他们显得有一点多此一举，而且变得难以理解。因此我想读者朋友们也很难从这些例子中感受到柯里化的魅力。不过没关系，如果我们能够通过这些例子掌握到柯里化的思维，那就是最好的结果了。在未来你的实践中，如果你发现用普通的思维封装一些逻辑慢慢变得困难，不妨想一想在这里学到的柯里化思维，应用起来，柯里化足够强大的自由度一定能给你一个惊喜。 当然也并不建议在任何情况下以炫技为目的的去使用柯里化，在柯里化的实现中，我们知道柯里化虽然具有了更多的自由度，但同时柯里化通用式里调用了arguments对象，使用了递归与闭包，因此柯里化的自由度是以牺牲了一定的性能为代价换来的。只有在情况变得复杂时，才是柯里化大显身手的时候。 额外知识补充无限参数的柯里化。 该部分内容可忽略 在前端面试中，你可能会遇到这样一个涉及到柯里化的题目。 1234// 实现一个add方法，使计算结果能够满足如下预期：add(1)(2)(3) = 6;add(1, 2, 3)(4) = 10;add(1)(2)(3)(4)(5) = 15; 这个题目的目的是想让add执行之后返回一个函数能够继续执行，最终运算的结果是所有出现过的参数之和。而这个题目的难点则在于参数的不固定。我们不知道函数会执行几次。因此我们不能使用上面我们封装的createCurry的通用公式来转换一个柯里化函数。只能自己封装，那么怎么办呢？在此之前，补充2个非常重要的知识点。 一个是ES6函数的不定参数。假如我们有一个数组，希望把这个数组中所有的子项展开传递给一个函数作为参数。那么我们应该怎么做？ 12345// 大家可以思考一下，如果将args数组的子项展开作为add的参数传入function add(a, b, c, d) &#123; return a + b + c + d;&#125;var args = [1, 3, 100, 1]; 在ES5中，我们可以借助之前学过的apply来达到我们的目的。 1add.apply(null, args); // 105 而在ES6中，提供了一种新的语法来解决这个问题，那就是不定参。写法如下： 1add(...args); // 105 这两种写法是等效的。OK，先记在这里。在接下的实现中，我们会用到不定参数的特性。 第二个要补充的知识点是函数的隐式转换。当我们直接将函数参与其他的计算时，函数会默认调用toString方法，直接将函数体转换为字符串参与计算。 12function fn() &#123; return 20 &#125;console.log(fn + 10); // 输出结果 function fn() &#123; return 20 &#125;10 但是我们可以重写函数的toString方法，让函数参与计算时，输出我们想要的结果。 1234function fn() &#123; return 20; &#125;fn.toString = function() &#123; return 30 &#125;console.log(fn + 10); // 40 除此之外，当我们重写函数的valueOf方法也能够改变函数的隐式转换结果。 1234function fn() &#123; return 20; &#125;fn.valueOf = function() &#123; return 60 &#125;console.log(fn + 10); // 70 当我们同时重写函数的toString方法与valueOf方法时，最终的结果会取valueOf方法的返回结果。 12345function fn() &#123; return 20; &#125;fn.valueOf = function() &#123; return 50 &#125;fn.toString = function() &#123; return 30 &#125;console.log(fn + 10); // 60 补充了这两个知识点之后，我们可以来尝试完成之前的题目了。add方法的实现仍然会是一个参数的收集过程。当add函数执行到最后时，仍然返回的是一个函数，但是我们可以通过定义toString/valueOf的方式，让这个函数可以直接参与计算，并且转换的结果是我们想要的。而且它本身也仍然可以继续执行接收新的参数。实现方式如下。 1234567891011121314151617181920212223242526272829303132333435363738394041function add() &#123; // 第一次执行时，定义一个数组专门用来存储所有的参数 var _args = [].slice.call(arguments); // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值 var adder = function () &#123; var _adder = function() &#123; // [].push.apply(_args, [].slice.call(arguments)); _args.push(...arguments); return _adder; &#125;; // 利用隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回 _adder.toString = function () &#123; return _args.reduce(function (a, b) &#123; return a + b; &#125;); &#125; return _adder; &#125; // return adder.apply(null, _args); return adder(..._args);&#125;var a = add(1)(2)(3)(4); // f 10var b = add(1, 2, 3, 4); // f 10var c = add(1, 2)(3, 4); // f 10var d = add(1, 2, 3)(4); // f 10// 可以利用隐式转换的特性参与计算console.log(a + 10); // 20console.log(b + 20); // 30console.log(c + 30); // 40console.log(d + 40); // 50// 也可以继续传入参数，得到的结果再次利用隐式转换参与计算console.log(a(10) + 100); // 120console.log(b(10) + 100); // 120console.log(c(10) + 100); // 120console.log(d(10) + 100); // 120 1234// 其实上栗中的add方法，就是下面这个函数的柯里化函数，只不过我们并没有使用通用式来转化，而是自己封装function add(...args) &#123; return args.reduce((a, b) =&gt; a + b);&#125; 以下为老版本讲解，请勿阅读学习，因为部分思维并不完全正确。 一、补充知识点之函数的隐式转换JavaScript作为一种弱类型语言，它的隐式转换是非常灵活有趣的。当我们没有深入了解隐式转换的时候可能会对一些运算的结果会感动困惑，比如4 + true = 5。当然，如果对隐式转换了解足够深刻，肯定是能够很大程度上提高对js的使用能力。只是我没有打算将所有的隐式转换规则分享给大家，这里暂时只分享一下，函数在隐式转换中的一些规则。 来一个简单的思考题。 12345function fn() &#123; return 20;&#125;console.log(fn + 10); // 输出结果是多少？ 稍微修改一下，再想想输出结果会是什么？ 123456789function fn() &#123; return 20;&#125;fn.toString = function() &#123; return 10;&#125;console.log(fn + 10); // 输出结果是多少？ 还可以继续修改一下。 12345678910111213function fn() &#123; return 20;&#125;fn.toString = function() &#123; return 10;&#125;fn.valueOf = function() &#123; return 5;&#125;console.log(fn + 10); // 输出结果是多少？ 12345678// 输出结果分别为function fn() &#123; return 20;&#125;102015 当使用console.log，或者进行运算时，隐式转换就可能会发生。从上面三个例子中我们可以得出一些关于函数隐式转换的结论。 当我们没有重新定义toString与valueOf时，函数的隐式转换会调用默认的toString方法，它会将函数的定义内容作为字符串返回。而当我们主动定义了toString/vauleOf方法时，那么隐式转换的返回结果则由我们自己控制了。其中valueOf会比toString后执行 因此上面例子的结论就很容易理解了。建议大家动手尝试一下。 二、补充知识点之利用call/apply封数组的map方法 map(): 对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 通俗来说，就是遍历数组的每一项元素，并且在map的第一个参数（回调函数）中进行运算处理后返回计算结果。返回一个由所有计算结果组成的新数组。 12345678910// 回调函数中有三个参数// 第一个参数表示newArr的每一项，第二个参数表示该项在数组中的索引值// 第三个表示数组本身// 除此之外，回调函数中的this，当map不存在第二参数时，this指向丢失，当存在第二个参数时，指向改参数所设定的对象var newArr = [1, 2, 3, 4].map(function(item, i, arr) &#123; console.log(item, i, arr, this); // 可运行试试看 return item + 1; // 每一项加1&#125;, &#123; a: 1 &#125;)console.log(newArr); // [2, 3, 4, 5] 在上面例子的注释中详细阐述了map方法的细节。现在要面临一个难题，就是如何封装map。 可以先想想for循环。我们可以使用for循环来实现一个map，但是在封装的时候，我们会考虑一些问题。我们在使用for循环的时候，一个循环过程确实很好封装，但是我们在for循环里面要对每一项做的事情却很难用一个固定的东西去把它封装起来。因为每一个场景，for循环里对数据的处理肯定都是不一样的。 于是大家就想了一个很好的办法，将这些不一样的操作单独用一个函数来处理，让这个函数成为map方法的第一个参数，具体这个回调函数中会是什么样的操作，则由我们自己在使用时决定。因此，根据这个思路的封装实现如下。 12345678910111213141516171819202122Array.prototype._map = function(fn, context) &#123; var temp = []; if(typeof fn == &apos;function&apos;) &#123; var k = 0; var len = this.length; // 封装for循环过程 for(; k &lt; len; k++) &#123; // 将每一项的运算操作丢进fn里，利用call方法指定fn的this指向与具体参数 temp.push(fn.call(context, this[k], k, this)) &#125; &#125; else &#123; console.error(&apos;TypeError: &apos;+ fn +&apos; is not a function.&apos;); &#125; // 返回每一项运算结果组成的新数组 return temp;&#125;var newArr = [1, 2, 3, 4]._map(function(item) &#123; return item + 1;&#125;)// [2, 3, 4, 5] 在上面的封装中，我首先定义了一个空的temp数组，该数组用来存储最终的返回结果。在for循环中，每循环一次，就执行一次参数fn函数，fn的参数则使用call方法传入。 在理解了map的封装过程之后，我们就能够明白为什么我们在使用map时，总是期望能够在第一个回调函数中有一个返回值了。在eslint的规则中，如果我们在使用map时没有设置一个返回值，就会被判定为错误。 ok，明白了函数的隐式转换规则与call/apply在这种场景的使用方式，我们就可以尝试通过简单的例子来了解一下柯里化了。 三、由浅入深的柯里化在前端面试中有一个关于柯里化的面试题，流传甚广。 实现一个add方法，使计算结果能够满足如下预期：add(1)(2)(3) = 6add(1, 2, 3)(4) = 10add(1)(2)(3)(4)(5) = 15 很明显，计算结果正是所有参数的和，add方法每运行一次，肯定返回了一个同样的函数，继续计算剩下的参数。 我们可以从最简单的例子一步一步寻找解决方案。 当我们只调用两次时，可以这样封装。 1234567function add(a) &#123; return function(b) &#123; return a + b; &#125;&#125;console.log(add(1)(2)); // 3 如果只调用三次： 123456789function add(a) &#123; return function(b) &#123; return function (c) &#123; return a + b + c; &#125; &#125;&#125;console.log(add(1)(2)(3)); // 6 上面的封装看上去跟我们想要的结果有点类似，但是参数的使用被限制得很死，因此并不是我们想要的最终结果，我们需要通用的封装。应该怎么办？总结一下上面2个例子，其实我们是利用闭包的特性，将所有的参数，集中到最后返回的函数里进行计算并返回结果。因此我们在封装时，主要的目的，就是将参数集中起来计算。 来看看具体实现。 123456789101112131415161718192021222324252627function add() &#123; // 第一次执行时，定义一个数组专门用来存储所有的参数 var _args = [].slice.call(arguments); // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值 var adder = function () &#123; var _adder = function() &#123; [].push.apply(_args, [].slice.call(arguments)); return _adder; &#125;; // 利用隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回 _adder.toString = function () &#123; return _args.reduce(function (a, b) &#123; return a + b; &#125;); &#125; return _adder; &#125; return adder.apply(null, [].slice.call(arguments));&#125;// 输出结果，可自由组合的参数console.log(add(1, 2, 3, 4, 5)); // 15console.log(add(1, 2, 3, 4)(5)); // 15console.log(add(1)(2)(3)(4)(5)); // 15 上面的实现，利用闭包的特性，主要目的是想通过一些巧妙的方法将所有的参数收集在一个数组里，并在最终隐式转换时将数组里的所有项加起来。因此我们在调用add方法的时候，参数就显得非常灵活。当然，也就很轻松的满足了我们的需求。 那么读懂了上面的demo，然后我们再来看看柯里化的定义，相信大家就会更加容易理解了。 柯里化（英语：Currying），又称为部分求值，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回一个新的函数的技术，新函数接受余下参数并返回运算结果。 接收单一参数，因为要携带不少信息，因此常常以回调函数的理由来解决。 将部分参数通过回调函数等方式传入函数中 返回一个新函数，用于处理所有的想要传入的参数 在上面的例子中，我们可以将add(1, 2, 3, 4)转换为add(1)(2)(3)(4)。这就是部分求值。每次传入的参数都只是我们想要传入的所有参数中的一部分。当然实际应用中，并不会常常这么复杂的去处理参数，很多时候也仅仅只是分成两部分而已。 咱们再来一起思考一个与柯里化相关的问题。 假如有一个计算要求，需要我们将数组里面的每一项用我们自己想要的字符给连起来。我们应该怎么做？想到使用join方法，就很简单。 1234567891011var arr = [1, 2, 3, 4, 5];// 实际开发中并不建议直接给Array扩展新的方法// 只是用这种方式演示能够更加清晰一点Array.prototype.merge = function(chars) &#123; return this.join(chars);&#125;var string = arr.merge(&apos;-&apos;)console.log(string); // 1-2-3-4-5 增加难度，将每一项加一个数后再连起来。那么这里就需要map来帮助我们对每一项进行特殊的运算处理，生成新的数组然后用字符连接起来了。实现如下： 1234567891011var arr = [1, 2, 3, 4, 5];Array.prototype.merge = function(chars, number) &#123; return this.map(function(item) &#123; return item + number; &#125;).join(chars);&#125;var string = arr.merge(&apos;-&apos;, 1);console.log(string); // 2-3-4-5-6 但是如果我们又想要让数组每一项都减去一个数之后再连起来呢？当然和上面的加法操作一样的实现。 1234567891011var arr = [1, 2, 3, 4, 5];Array.prototype.merge = function(chars, number) &#123; return this.map(function(item) &#123; return item - number; &#125;).join(chars);&#125;var string = arr.merge(&apos;~&apos;, 1);console.log(string); // 0~1~2~3~4 机智的小伙伴肯定发现困惑所在了。我们期望封装一个函数，能同时处理不同的运算过程，但是我们并不能使用一个固定的套路将对每一项的操作都封装起来。于是问题就变成了和封装map的时候所面临的问题一样了。我们可以借助柯里化来搞定。 与map封装同样的道理，既然我们事先并不确定我们将要对每一项数据进行怎么样的处理，我只是知道我们需要将他们处理之后然后用字符连起来，所以不妨将处理内容保存在一个函数里。而仅仅固定封装连起来的这一部分需求。 于是我们就有了以下的封装。 123456789101112131415161718192021222324252627282930313233343536// 封装很简单，一句话搞定Array.prototype.merge = function(fn, chars) &#123; return this.map(fn).join(chars);&#125;var arr = [1, 2, 3, 4];// 难点在于，在实际使用的时候，操作怎么来定义，利用闭包保存于传递num参数var add = function(num) &#123; return function(item) &#123; return item + num; &#125;&#125;var red = function(num) &#123; return function(item) &#123; return item - num; &#125;&#125;// 每一项加2后合并var res1 = arr.merge(add(2), &apos;-&apos;);// 每一项减2后合并var res2 = arr.merge(red(1), &apos;-&apos;);// 也可以直接使用回调函数，每一项乘2后合并var res3 = arr.merge((function(num) &#123; return function(item) &#123; return item * num &#125;&#125;)(2), &apos;-&apos;)console.log(res1); // 3-4-5-6console.log(res2); // 0-1-2-3console.log(res3); // 2-4-6-8 大家能从上面的例子，发现柯里化的特征吗？ 四、柯里化通用式通用的柯里化写法其实比我们上边封装的add方法要简单许多。 12345678910111213141516171819var currying = function(fn) &#123; var args = [].slice.call(arguments, 1); return function() &#123; // 主要还是收集所有需要的参数到一个数组中，便于统一计算 var _args = args.concat([].slice.call(arguments)); return fn.apply(null, _args); &#125;&#125;var sum = currying(function() &#123; var args = [].slice.call(arguments); return args.reduce(function(a, b) &#123; return a + b; &#125;)&#125;, 10)console.log(sum(20, 10)); // 40console.log(sum(10, 5)); // 25 五、柯里化与bind12345678Object.prototype.bind = function(context) &#123; var _this = this; var args = [].slice.call(arguments, 1); return function() &#123; return _this.apply(context, args) &#125;&#125; 这个例子利用call与apply的灵活运用，实现了bind的功能。 在前面的几个例子中，我们可以总结一下柯里化的特点： 接收单一参数，将更多的参数通过回调函数来搞定？ 返回一个新函数，用于处理所有的想要传入的参数； 需要利用call/apply与arguments对象收集参数； 返回的这个函数正是用来处理收集起来的参数。 希望大家读完之后都能够大概明白柯里化的概念，如果想要熟练使用它，就需要我们掌握更多的实际经验才行。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>柯里化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[摘抄执行上下文]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F17%2F%E6%91%98%E6%8A%84%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%2F</url>
    <content type="text"><![CDATA[我们在JS学习初期或者面试的时候常常会遇到考核变量提升的思考题。比如先来一个简单一点的。 12console.log(a); // 这里会打印出什么？var a = 20; 暂时先不管这个例子，我们先引入一个JavaScript中最基础，但同时也是最重要的一个概念执行上下文（Execution Context）。 每次当控制器转到可执行代码的时候，就会进入一个执行上下文。执行上下文可以理解为当前代码的执行环境，它会形成一个作用域。JavaScript中的运行环境大概包括三种情况。 全局环境：JavaScript代码运行起来会首先进入该环境 函数环境：当函数被调用执行时，会进入当前函数中执行代码 eval（不建议使用，可忽略） 因此在一个JavaScript程序中，必定会产生多个执行上下文，在我的上一篇文章中也有提到，JavaScript引擎会以栈的方式来处理它们，这个栈，我们称其为函数调用栈(call stack)。栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。 当代码在执行过程中，遇到以上三种情况，都会生成一个执行上下文，放入栈中，而处于栈顶的上下文执行完毕之后，就会自动出栈。为了更加清晰的理解这个过程，根据下面的例子，结合图示给大家展示。 执行上下文可以理解为函数执行的环境，每一个函数执行时，都会给对应的函数创建这样一个执行环境。 123456789101112131415var color = 'blue';function changeColor() &#123; var anotherColor = 'red'; function swapColors() &#123; var tempColor = anotherColor; anotherColor = color; color = tempColor; &#125; swapColors();&#125;changeColor(); 我们用ECStack来表示处理执行上下文组的堆栈。我们很容易知道，第一步，首先是全局上下文入栈。 全局上下文入栈之后，其中的可执行代码开始执行，直到遇到了changeColor()，这一句激活函数changeColor创建它自己的执行上下文，因此第二步就是changeColor的执行上下文入栈。 changeColor的上下文入栈之后，控制器开始执行其中的可执行代码，遇到swapColors()之后又激活了一个执行上下文。因此第三步是swapColors的执行上下文入栈。 在swapColors的可执行代码中，再没有遇到其他能生成执行上下文的情况，因此这段代码顺利执行完毕，swapColors的上下文从栈中弹出。 swapColors的执行上下文弹出之后，继续执行changeColor的可执行代码，也没有再遇到其他执行上下文，顺利执行完毕之后弹出。这样，ECStack中就只身下全局上下文了。 全局上下文在浏览器窗口关闭后出栈。 注意：函数中，遇到return能直接终止可执行代码的执行，因此会直接将当前上下文弹出栈。 详细了解了这个过程之后，我们就可以对执行上下文总结一些结论了。 单线程 同步执行，只有栈顶的上下文处于执行中，其他上下文需要等待 全局上下文只有唯一的一个，它在浏览器关闭时出栈 函数的执行上下文的个数没有限制 每次某个函数被调用，就会有个新的执行上下文为其创建，即使是调用的自身函数，也是如此。 为了巩固一下执行上下文的理解，我们再来绘制一个例子的演变过程，这是一个简单的闭包例子。 123456789function f1()&#123; var n=999; function f2()&#123; alert(n); &#125; return f2;&#125;var result=f1();result(); // 999 因为f1中的函数f2在f1的可执行代码中，并没有被调用执行，因此执行f1时，f2不会创建新的上下文，而直到result执行时，才创建了一个新的。具体演变过程如下。 如果你在某公众号看到我的文章，然后发现下面的评论说最后一个例子错了，请不要管他们，他们把函数调用栈和作用域链没有分清楚就跑出来质疑，真的很有问题。建议大家读一读这系列的第六篇文章，教你如何自己拥有判断对错的能力。 最后留一个简单的例子，大家可以自己脑补一下这个例子在执行过程中执行上下文的变化情况。 1234567891011121314151617var name = "window";var p = &#123; name: 'Perter', getName: function() &#123; // 利用变量保存的方式保证其访问的是p对象 var self = this; return function() &#123; return self.name; &#125; &#125;&#125;var getName = p.getName();var _name = getName();console.log(_name);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>执行上下文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[摘抄在chrome中观察函数调用]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F17%2F%E6%91%98%E6%8A%84%E5%9C%A8chrome%E4%B8%AD%E8%A7%82%E5%AF%9F%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在前端开发中，有一个非常重要的技能，叫做断点调试。 在chrome的开发者工具中，通过断点调试，我们能够非常方便的一步一步的观察JavaScript的执行过程，直观感知函数调用栈，作用域链，变量对象，闭包，this等关键信息的变化。因此，断点调试对于快速定位代码错误，快速了解代码的执行过程有着非常重要的作用，这也是我们前端开发者必不可少的一个高级技能。 当然如果你对JavaScript的这些基础概念（执行上下文，变量对象，闭包，this等）了解还不够的话，想要透彻掌握断点调试可能会有一些困难。但是好在在前面几篇文章，我都对这些概念进行了详细的概述，因此要掌握这个技能，对大家来说，应该是比较轻松的。 这篇文章的主要目的在于借助对于断点调试的学习，来进一步加深对闭包的理解。 一、基础概念回顾函数在被调用执行时，会创建一个当前函数的执行上下文。在该执行上下文的创建阶段，变量对象、作用域链、闭包、this指向会分别被确定。而一个JavaScript程序中一般来说会有多个函数，JavaScript引擎使用函数调用栈来管理这些函数的调用顺序。函数调用栈的调用顺序与栈数据结构一致。 二、认识断点调试工具在尽量新版本的chrome浏览器中（不确定你用的老版本与我的一致），调出chrome浏览器的开发者工具。 1浏览器右上角竖着的三点 -&gt; 更多工具 -&gt; 开发者工具 -&gt; Sources 界面如图。 在我的demo中，我把代码放在app.js中，在index.html中引入。我们暂时只需要关注截图中红色箭头的地方。在最右侧上方，有一排图标。我们可以通过使用他们来控制函数的执行顺序。从左到右他们依次是： resume/pause script execution恢复/暂停脚本执行 step over next function call跨过，实际表现是不遇到函数时，执行下一步。遇到函数时，不进入函数直接执行下一步。 step into next function call跨入，实际表现是不遇到函数时，执行下一步。遇到到函数时，进入函数执行上下文。 step out of current function跳出当前函数 deactivate breakpoints停用断点 don‘t pause on exceptions不暂停异常捕获 其中跨过，跨入，跳出是我使用最多的三个操作。 上图右侧第二个红色箭头指向的是函数调用栈（call Stack），这里会显示代码执行过程中，调用栈的变化。 右侧第三个红色箭头指向的是作用域链（Scope），这里会显示当前函数的作用域链。其中Local表示当前的局部变量对象，Closure表示当前作用域链中的闭包。借助此处的作用域链展示，我们可以很直观的判断出一个例子中，到底谁是闭包，对于闭包的深入了解具有非常重要的帮助作用。 三、断点设置在显示代码行数的地方点击，即可设置一个断点。断点设置有以下几个特点： 在单独的变量声明(如果没有赋值)，函数声明的那一行，无法设置断点。 设置断点后刷新页面，JavaScript代码会执行到断点位置处暂停执行，然后我们就可以使用上边介绍过的几个操作开始调试了。 当你设置多个断点时，chrome工具会自动判断从最早执行的那个断点开始执行，因此我一般都是设置一个断点就行了。 四、实例接下来，我们借助一些实例，来使用断点调试工具，看一看，我们的demo函数，在执行过程中的具体表现。 12345678910111213141516// demo01var fn;function foo() &#123; var a = 2; function baz() &#123; console.log( a ); &#125; fn = baz;&#125;function bar() &#123; fn();&#125;foo();bar(); // 2 在向下阅读之前，我们可以停下来思考一下，这个例子中，谁是闭包？ 这是来自《你不知道的js》中的一个例子。由于在使用断点调试过程中，发现chrome浏览器理解的闭包与该例子中所理解的闭包不太一致，因此专门挑出来，供大家参考。我个人更加倾向于chrome中的理解。 第一步：设置断点，然后刷新页面。 第二步：点击上图红色箭头指向的按钮（step into），该按钮的作用会根据代码执行顺序，一步一步向下执行。在点击的过程中，我们要注意观察下方call stack 与 scope的变化，以及函数执行位置的变化。 一步一步执行，当函数执行到上例子中 我们可以看到，在chrome工具的理解中，由于在foo内部声明的baz函数在调用时访问了它的变量a，因此foo成为了闭包。这好像和我们学习到的知识不太一样。我们来看看在《你不知道的js》这本书中的例子中的理解。 书中的注释可以明显的看出，作者认为fn为闭包。即baz，这和chrome工具中明显是不一样的。 而在备受大家推崇的《JavaScript高级编程》一书中，是这样定义闭包。 这里chrome中理解的闭包，与我所阅读的这几本书中的理解的闭包不一样。其实在之前对于闭包分析的文章中，我已经有对这种情况做了一个解读。闭包详解 闭包是一个特殊对象，它由执行上下文(代号A)与在该执行上下文中创建的函数(代号B)共同组成。 当B执行时，如果访问了A中变量对象中的值，那么闭包就会产生。 那么在大多数理解中，包括许多著名的书籍，文章里都以函数B的名字代指这里生成的闭包。而在chrome中，则以执行上下文A的函数名代指闭包。 我们修改一下demo01中的例子，来看看一个非常有意思的变化。 12345678910111213141516// demo02var fn;var m = 20;function foo() &#123; var a = 2; function baz(a) &#123; console.log(a); &#125; fn = baz;&#125;function bar() &#123; fn(m);&#125;foo();bar(); // 20 这个例子在demo01的基础上，我在baz函数中传入一个参数，并打印出来。在调用时，我将全局的变量m传入。输出结果变为20。在使用断点调试看看作用域链。 是不是结果有点意外，闭包没了，作用域链中没有包含foo了。我靠，跟我们理解的好像又有点不一样。所以通过这个对比，我们可以确定闭包的形成需要两个条件。 在函数内部创建新的函数； 新的函数在执行时，访问了函数的变量对象； 还有更有意思的。 我们继续来看看一个例子。 1234567891011121314151617// demo03function foo() &#123; var a = 2; return function bar() &#123; var b = 9; return function fn() &#123; console.log(a); &#125; &#125;&#125;var bar = foo();var fn = bar();fn(); 在这个例子中，fn只访问了foo中的a变量，因此它的闭包只有foo。 修改一下demo03，我们在fn中也访问bar中b变量试试看。 1234567891011121314151617// demo04function foo() &#123; var a = 2; return function bar() &#123; var b = 9; return function fn() &#123; console.log(a, b); &#125; &#125;&#125;var bar = foo();var fn = bar();fn(); 这个时候，闭包变成了两个。分别是bar，foo。 我们知道，闭包在模块中的应用非常重要。因此，我们来一个模块的例子，也用断点工具来观察一下。 1234567891011121314151617181920212223242526272829// demo05(function() &#123; var a = 10; var b = 20; var test = &#123; m: 20, add: function(x) &#123; return a + x; &#125;, sum: function() &#123; return a + b + this.m; &#125;, mark: function(k, j) &#123; return k + j; &#125; &#125; window.test = test;&#125;)();test.add(100);test.sum();test.mark();var _mark = test.mark;_mark(); 注意：这里的this指向显示为Object或者Window，大写开头，他们表示的是实例的构造函数，实际上this是指向的具体实例 test.mark能形成闭包，跟下面的补充例子（demo07）情况是一样的。 我们还可以结合点断调试的方式，来理解那些困扰我们很久的this指向。随时观察this的指向，在实际开发调试中非常有用。 123456789101112// demo06var a = 10;var obj = &#123; a: 20&#125;function fn () &#123; console.log(this.a);&#125;fn.call(obj); // 20 最后继续补充一个例子。 12345678910111213141516// demo07function foo() &#123; var a = 10; function fn1() &#123; return a; &#125; function fn2() &#123; return 10; &#125; fn2();&#125;foo(); 这个例子，和其他例子不太一样。虽然fn2并没有访问到foo的变量，但是foo执行时仍然变成了闭包。而当我将fn1的声明去掉时，闭包便不会出现了。 那么结合这个特殊的例子，我们可以这样这样定义闭包。 闭包是指这样的作用域(foo)，它包含有一个函数(fn1)，这个函数(fn1)可以调用被这个作用域所封闭的变量(a)、函数、或者闭包等内容。通常我们通过闭包所对应的函数来获得对闭包的访问。 更多的例子，大家可以自行尝试，总之，学会了使用断点调试之后，我们就能够很轻松的了解一段代码的执行过程了。这对快速定位错误，快速了解他人的代码都有非常巨大的帮助。大家一定要动手实践，把它给学会。 最后，根据以上的摸索情况，再次总结一下闭包： 闭包是在函数被调用执行的时候才被确认创建的。 闭包的形成，与作用域链的访问顺序有直接关系。 只有内部函数访问了上层作用域链中的变量对象时，才会形成闭包，因此，我们可以利用闭包来访问函数内部的变量。 大家也可以根据我提供的这个方法，对其他的例子进行更多的测试，如果发现我的结论有不对的地方，欢迎指出，大家相互学习进步，谢谢大家。]]></content>
      <categories>
        <category>chrome</category>
      </categories>
      <tags>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[摘抄变量对象]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F17%2F%E6%91%98%E6%8A%84%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[开年之后工作热情一直不是很高，这几天一直处于消极怠工状态。早上不想起床，起床了不想上班。明明放假之前工作热情还一直很高，一直心心念念的想把小程序项目怼出来，结果休假回来之后画风完全不一样了。我感觉自己得了严重了节后综合征。还好撸了几篇文章，勉强表示这一周的时间没有完全浪费。这篇文章要给大家介绍的是变量对象。 在JavaScript中，我们肯定不可避免的需要声明变量和函数，可是JS解析器是如何找到这些变量的呢？我们还得对执行上下文有一个进一步的了解。 在上一篇文章中，我们已经知道，当调用一个函数时（激活），一个新的执行上下文就会被创建。而一个执行上下文的生命周期可以分为两个阶段。 创建阶段在这个阶段中，执行上下文会分别创建变量对象，建立作用域链，以及确定this的指向。 代码执行阶段创建完成之后，就会开始执行代码，这个时候，会完成变量赋值，函数引用，以及执行其他代码。 从这里我们就可以看出详细了解执行上下文极为重要，因为其中涉及到了变量对象，作用域链，this等很多人没有怎么弄明白，但是却极为重要的概念，它关系到我们能不能真正理解JavaScript。在后面的文章中我们会一一详细总结，这里我们先重点了解变量对象。 变量对象（Variable Object）变量对象的创建，依次经历了以下几个过程。 建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。 检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。 检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。 许多读者在阅读到这的时候会因为下面的这样场景对于“跳过”一词产生疑问。既然变量声明的foo遇到函数声明的foo会跳过，可是为什么最后foo的输出结果仍然是被覆盖了？ 1234function foo() &#123; console.log('function foo') &#125;var foo = 20;console.log(foo); // 20 其实只是大家在阅读的时候不够仔细，因为上面的三条规则仅仅适用于变量对象的创建过程。也就是执行上下文的创建过程。而foo = 20是在执行上下文的执行过程中运行的，输出结果自然会是20。对比下例。 123console.log(foo); // function foofunction foo() &#123; console.log('function foo') &#125;var foo = 20; 1234567891011// 上栗的执行顺序为// 首先将所有函数声明放入变量对象中function foo() &#123; console.log('function foo') &#125;// 其次将所有变量声明放入变量对象中，但是因为foo已经存在同名函数，因此此时会跳过undefined的赋值// var foo = undefined;// 然后开始执行阶段代码的执行console.log(foo); // function foofoo = 20; 根据这个规则，理解变量提升就变得十分简单了。在很多文章中虽然提到了变量提升，但是具体是怎么回事还真的很多人都说不出来，以后在面试中用变量对象的创建过程跟面试官解释变量提升，保证瞬间提升逼格。 在上面的规则中我们看出，function声明会比var声明优先级更高一点。为了帮助大家更好的理解变量对象，我们结合一些简单的例子来进行探讨。 123456789101112// demo01function test() &#123; console.log(a); console.log(foo()); var a = 1; function foo() &#123; return 2; &#125;&#125;test(); 在上例中，我们直接从test()的执行上下文开始理解。全局作用域中运行test()时，test()的执行上下文开始创建。为了便于理解，我们用如下的形式来表示 123456789101112131415// 创建过程testEC = &#123; // 变量对象 VO: &#123;&#125;, scopeChain: &#123;&#125;&#125;// 因为本文暂时不详细解释作用域链，所以把变量对象专门提出来说明// VO 为 Variable Object的缩写，即变量对象VO = &#123; arguments: &#123;...&#125;, //注：在浏览器的展示中，函数的参数可能并不是放在arguments对象中，这里为了方便理解，我做了这样的处理 foo: &lt;foo reference&gt; // 表示foo的地址引用 a: undefined&#125; 未进入执行阶段之前，变量对象中的属性都不能访问！但是进入执行阶段之后，变量对象转变为了活动对象，里面的属性都能被访问了，然后开始进行执行阶段的操作。 这样，如果再面试的时候被问到变量对象和活动对象有什么区别，就又可以自如的应答了，他们其实都是同一个对象，只是处于执行上下文的不同生命周期。不过只有处于函数调用栈栈顶的执行上下文中的变量对象，才会变成活动对象。 12345678// 执行阶段VO -&gt; AO // Active ObjectAO = &#123; arguments: &#123;...&#125;, foo: &lt;foo reference&gt;, a: 1, this: Window&#125; 因此，上面的例子demo1，执行顺序就变成了这样 1234567891011function test() &#123; function foo() &#123; return 2; &#125; var a; console.log(a); console.log(foo()); a = 1;&#125;test(); 再来一个例子，巩固一下我们的理解。 1234567891011121314151617// demo2function test() &#123; console.log(foo); console.log(bar); var foo = 'Hello'; console.log(foo); var bar = function () &#123; return 'world'; &#125; function foo() &#123; return 'hello'; &#125;&#125;test(); 1234567// 创建阶段VO = &#123; arguments: &#123;...&#125;, foo: &lt;foo reference&gt;, bar: undefined&#125;// 这里有一个需要注意的地方，因为var声明的变量当遇到同名的属性时，会跳过而不会覆盖 12345678// 执行阶段VO -&gt; AOVO = &#123; arguments: &#123;...&#125;, foo: 'Hello', bar: &lt;bar reference&gt;, this: Window&#125; 需要结合上面的知识，仔细对比这个例子中变量对象从创建阶段到执行阶段的变化，如果你已经理解了，说明变量对象相关的东西都已经难不倒你了。 全局上下文的变量对象以浏览器中为例，全局对象为window。全局上下文有一个特殊的地方，它的变量对象，就是window对象。而这个特殊，在this指向上也同样适用，this也是指向window。 1234567// 以浏览器中为例，全局对象为window// 全局上下文windowEC = &#123; VO: Window, scopeChain: &#123;&#125;, this: Window&#125; 除此之外，全局上下文的生命周期，与程序的生命周期一致，只要程序运行不结束，比如关掉浏览器窗口，全局上下文就会一直存在。其他所有的上下文环境，都能直接访问全局上下文的属性。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>变量对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[摘抄函数与函数式编程]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F17%2F%E6%91%98%E6%8A%84%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[纵观JavaScript中所有必须需要掌握的重点知识中，函数是我们在初学的时候最容易忽视的一个知识点。在学习的过程中，可能会有很多人、很多文章告诉你面向对象很重要，原型很重要，可是却很少有人告诉你，面向对象中所有的重点难点，几乎都与函数息息相关。 包括我之前几篇文章介绍的执行上下文，变量对象，闭包，this等，都是围绕函数的细节来展开。 我知道很多人在学习中，很急切的希望自己快一点开始学习面向对象，学习模块，学习流行框架，然后迅速成为高手。但是我可以很负责的告诉你，关于函数的这些基础东西没理解到一定程度，那么你的学习进展一定是举步维艰的。 所以，大家一定要重视函数！ 当然，关于函数的重点，难点在前面几篇文章都已经说得差不多了，这篇文章主要总结一下函数的基础知识，并初步学习函数式编程的思维。 一、函数声明、函数表达式、匿名函数与自执行函数关于函数在实际开发中的应用，大体可以总结为函数声明、函数表达式、匿名函数、自执行函数。 函数声明 我们知道，JavaScript中，有两种声明方式，一个是使用var的变量声明，另一个是使用function的函数声明。 在前端基础进阶（三）：变量对象详解中我有提到过，变量对象的创建过程中，函数声明比变量声明具有更为优先的执行顺序，即我们常常提到的函数声明提前。因此我们在执行上下文中，无论在什么位置声明了函数，我们都可以在同一个执行上下文中直接使用该函数。 12345fn(); // functionfunction fn() &#123; console.log('function');&#125; 函数表达式 与函数声明不同，函数表达式使用了var进行声明，那么我们在确认他是否可以正确使用的时候就必须依照var的规则进行判断，即变量声明。我们知道使用var进行变量声明，其实是进行了两步操作。 123456// 变量声明var a = 20;// 实际执行顺序var a = undefined; // 变量声明，初始值undefined，变量提升，提升顺序次于function声明a = 20; // 变量赋值，该操作不会提升 同样的道理，当我们使用变量声明的方式来声明函数时，就是我们常常说的函数表达式。函数表达的提升方式与变量声明一致。 1234fn(); // 报错var fn = function() &#123; console.log('function');&#125; 上例子的执行顺序为： 12345var fn = undefined; // 变量声明提升fn(); // 执行报错fn = function() &#123; // 赋值操作，此时将后边函数的引用赋值给fn console.log('function');&#125; 因此，由于声明方式的不同，导致了函数声明与函数表达式在使用上的一些差异需要我们注意，除此之外，这两种形式的函数在使用上并无不同。 关于上面例子中，函数表达式中的赋值操作，在其他一些地方也会被经常使用，我们清楚其中的关系即可。 12345678910111213141516171819202122在构造函数中添加方法function Person(name) &#123; this.name = name; this.age = age; // 在构造函数内部中添加方法 this.getAge = function() &#123; return this.age; &#125; this.&#125;// 给原型添加方法Person.prototype.getName = function() &#123; return this.name;&#125;// 在对象中添加方法var a = &#123; m: 20, getM: function() &#123; return this.m; &#125;&#125; 匿名函数 在上面我们大概讲述了函数表达式中的赋值操作。而匿名函数，顾名思义，就是指的没有被显示进行赋值操作的函数。它的使用场景，多作为一个参数传入另一个函数中。 12345678var a = 10;var fn = function(bar, num) &#123; return bar() + num;&#125;fn(function() &#123; return a;&#125;, 20) 在上面的例子中，fn的第一个参数传入了一个匿名函数。虽然该匿名函数没有显示的进行赋值操作，我们没有办法在外部执行上下文中引用到它，但是在fn函数内部，我们将该匿名函数赋值给了变量bar，保存在了fn变量对象的arguments对象中。 1234567891011121314151617181920// 变量对象在fn上下文执行过程中的创建阶段VO(fn) = &#123; arguments: &#123; bar: undefined, num: undefined, length: 2 &#125;&#125;// 变量对象在fn上下文执行过程中的执行阶段// 变量对象变为活动对象，并完成赋值操作与执行可执行代码VO -&gt; AOAO(fn) = &#123; arguments: &#123; bar: function() &#123; return a &#125;, num: 20, length: 2 &#125;&#125; 由于匿名函数传入另一个函数之后，最终会在另一个函数中执行，因此我们也常常称这个匿名函数为回调函数。关于匿名函数更多的内容，我会在下一篇深入探讨柯里化的文章中进行更加详细讲解。 匿名函数的这个应用场景几乎承担了函数的所有难以理解的知识点，因此我们一定要对它的这些细节了解的足够清楚，如果对于变量对象的演变过程你还看不太明白，一定要回过头去看这篇文章：前端基础进阶（三）：变量对象详解 函数自执行与块级作用域 在ES5中，没有块级作用域，因此我们常常使用函数自执行的方式来模仿块级作用域，这样就提供了一个独立的执行上下文，结合闭包，就为模块化提供了基础。而函数自执行，其实是匿名函数的一种应用。 123(function() &#123; // ...&#125;)(); 一个模块往往可以包括：私有变量、私有方法、公有变量、公有方法。 根据作用域链的单向访问，外面可能很容易知道在这个独立的模块中，外部执行环境是无法访问内部的任何变量与方法的，因此我们可以很容易的创建属于这个模块的私有变量与私有方法。 12345678910(function() &#123; // 私有变量 var age = 20; var name = 'Tom'; // 私有方法 function getName() &#123; return `your name is ` + name; &#125;&#125;)(); 但是共有方法和变量应该怎么办？大家还记得我们前面讲到过的闭包的特性吗？没错，利用闭包，我们可以访问到执行上下文内部的变量和方法，因此，我们只需要根据闭包的定义，创建一个闭包，将你认为需要公开的变量和方法开放出来即可。 如果你对闭包了解不够，前端基础进阶（四）：详细图解作用域链与闭包应该可以帮到你。 123456789101112131415161718(function() &#123; // 私有变量 var age = 20; var name = 'Tom'; // 私有方法 function getName() &#123; return `your name is ` + name; &#125; // 共有方法 function getAge() &#123; return age; &#125; // 将引用保存在外部执行环境的变量中，形成闭包，防止该执行环境被垃圾回收 window.getAge = getAge;&#125;)(); 当然，闭包在模块中的重要作用，我们也在讲解闭包的时候已经强调过，但是这个知识点真的太重要，需要我们反复理解并且彻底掌握，因此为了帮助大家进一步理解闭包，我们来看看jQuery中，是如何利用我们模块与闭包的。 123456789101112131415161718192021222324// 使用函数自执行的方式创建模块(function(window, undefined) &#123; // 声明jQuery构造函数 var jQuery = function(name) &#123; // 主动在构造函数中，返回一个jQuery实例 return new jQuery.fn.init(name); &#125; // 添加原型方法 jQuery.prototype = jQuery.fn = &#123; constructor: jQuery, init:function() &#123; ... &#125;, css: function() &#123; ... &#125; &#125; jQuery.fn.init.prototype = jQuery.fn; // 将jQuery改名为$，并将引用保存在window上，形成闭包，对外开发jQuery构造函数，这样我们就可以访问所有挂载在jQuery原型上的方法了 window.jQuery = window.$ = jQuery; &#125;)(window);// 在使用时，我们直接执行了构造函数，因为在jQuery的构造函数中通过一些手段，返回的是jQuery的实例，所以我们就不用再每次用的时候在自己new了$('#div1'); 在这里，我们只需要看懂闭包与模块的部分就行了，至于内部的原型链是如何绕的，为什么会这样写，我在讲面向对象的时候会为大家慢慢分析。举这个例子的目的所在，就是希望大家能够重视函数，因为在实际开发中，它无处不在。 接下来我要分享一个高级的，非常有用的模块的应用。当我们的项目越来越大，那么需要保存的数据与状态就越来越多，因此，我们需要一个专门的模块来维护这些数据，这个时候，有一个叫做状态管理器的东西就应运而生。对于状态管理器，最出名的，我想非redux莫属了。虽然对于还在学习中的大家来说，redux是一个有点高深莫测的东西，但是在我们学习之前，可以先通过简单的方式，让大家大致了解状态管理器的实现原理，为我们未来的学习奠定坚实的基础。 先来直接看代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// 自执行创建模块(function() &#123; // states 结构预览 // states = &#123; // a: 1, // b: 2, // m: 30, // o: &#123;&#125; // &#125; var states = &#123;&#125;; // 私有变量，用来存储状态与数据 // 判断数据类型 function type(elem) &#123; if(elem == null) &#123; return elem + ''; &#125; return toString.call(elem).replace(/[\[\]]/g, '').split(' ')[1].toLowerCase(); &#125; /** * @Param name 属性名 * @Description 通过属性名获取保存在states中的值 */ function get(name) &#123; return states[name] ? states[name] : ''; &#125; function getStates() &#123; return states; &#125; /* * @param options &#123;object&#125; 键值对 * @param target &#123;object&#125; 属性值为对象的属性，只在函数实现时递归中传入 * @desc 通过传入键值对的方式修改state树，使用方式与小程序的data或者react中的setStates类似 */ function set(options, target) &#123; var keys = Object.keys(options); var o = target ? target : states; keys.map(function(item) &#123; if(typeof o[item] == 'undefined') &#123; o[item] = options[item]; &#125; else &#123; type(o[item]) == 'object' ? set(options[item], o[item]) : o[item] = options[item]; &#125; return item; &#125;) &#125; // 对外提供接口 window.get = get; window.set = set; window.getStates = getStates;&#125;)()// 具体使用如下set(&#123; a: 20 &#125;); // 保存 属性aset(&#123; b: 100 &#125;); // 保存属性bset(&#123; c: 10 &#125;); // 保存属性c// 保存属性o, 它的值为一个对象set(&#123; o: &#123; m: 10, n: 20 &#125;&#125;)// 修改对象o 的m值set(&#123; o: &#123; m: 1000 &#125;&#125;)// 给对象o中增加一个c属性set(&#123; o: &#123; c: 100 &#125;&#125;)console.log(getStates()) demo实例在线地址 我之所以说这是一个高级应用，是因为在单页应用中，我们很可能会用到这样的思路。根据我们提到过的知识，理解这个例子其实很简单，其中的难点估计就在于set方法的处理上，因为为了具有更多的适用性，因此做了很多适配，用到了递归等知识。如果你暂时看不懂，没有关系，知道如何使用就行了，上面的代码可以直接运用于实际开发。记住，当你需要保存的状态太多的时候，你就想到这一段代码就行了。 函数自执行的方式另外还有其他几种写法，诸如!function(){}()，+function(){}() 二、函数参数传递方式：按值传递还记得基本数据类型与引用数据类型在复制上的差异吗？基本数据类型复制，是直接值发生了复制，因此改变后，各自相互不影响。但是引用数据类型的复制，是保存在变量对象中的引用发生了复制，因此复制之后的这两个引用实际访问的实际是同一个堆内存中的值。当改变其中一个时，另外一个自然也被改变。如下例。 123456789var a = 20;var b = a;b = 10;console.log(a); // 20var m = &#123; a: 1, b: 2 &#125;var n = m;n.a = 5;console.log(m.a) // 5 当值作为函数的参数传递进入函数内部时，也有同样的差异。我们知道，函数的参数在进入函数后，实际是被保存在了函数的变量对象中，因此，这个时候相当于发生了一次复制。如下例。 12345678var a = 20;function fn(a) &#123; a = a + 10; return a;&#125;fn(a);console.log(a); // 20 12345678var a = &#123; m: 10, n: 20 &#125;function fn(a) &#123; a.m = 20; return a;&#125;fn(a);console.log(a); // &#123; m: 20, n: 20 &#125; 正是由于这样的不同，导致了许多人在理解函数参数的传递方式时，就有许多困惑。到底是按值传递还是按引用传递？实际上结论仍然是按值传递，只不过当我们期望传递一个引用类型时，真正传递的，只是这个引用类型保存在变量对象中的引用而已。为了说明这个问题，我们看看下面这个例子。 123456789101112var person = &#123; name: 'Nicholas', age: 20&#125;function setName(obj) &#123; // 传入一个引用 obj = &#123;&#125;; // 将传入的引用指向另外的值 obj.name = 'Greg'; // 修改引用的name属性&#125;setName(person);console.log(person.name); // Nicholas 未被改变 在上面的例子中，如果person是按引用传递，那么person就会自动被修改为指向其name属性值为Gerg的新对象。但是我们从结果中看到，person对象并未发生任何改变，因此只是在函数内部引用被修改而已。 四、函数式编程虽然JavaScript并不是一门纯函数式编程的语言，但是它使用了许多函数式编程的特性。因此了解这些特性可以让我们更加了解自己写的代码。 当我们想要使用一个函数时，通常情况下其实就是想要将一些功能，逻辑等封装起来。相信大家对于封装这个概念并不陌生。 我们通常通过函数封装来完成一件事情。例如，我想要计算任意三个数的和，我们就可以将这三个数作为参数，封装一个简单的函数。 123function add(a, b, c) &#123; return a + b + c;&#125; 当我们想要计算三个数的和时，直接调用该方法即可。 1add(1, 2, 3); // 6 当然，当我们想要做的事情比较简单的时候，可能还看不出来封装成为函数之后带来的便利。如果我们想要做的事情稍微复杂一点呢。例如我想要计算一个数组中的所有子项目的和。 12345function mergeArr(arr) &#123; var result = 0; for(var i = 0; i &lt; arr.length; i++) &#123; result += arr[i] &#125; return result;&#125; 如果我们不通过函数封装的方式，那么再每次想要实现这个功能时，就不得不重新使用一次for循环，这样的后果就是我们的代码中充斥着越来越多的重复代码。而封装之后，当我们想要再次做这件事情的时候，只需要一句话就可以了。 1mergeArr([1, 2, 3, 4, 5]); 当然，我相信大家对于函数封装的意义都应该有非常明确的认知，但是我们要面临的问题是，当我们想要去封装一个函数时，如何做才是最佳实践呢？ 函数式编程能给我们答案。 我们在初学时，往往会不由自主的使用命令式编程的风格来完成我们想要干的事情。因为命令式编程更加的简单，直白。例如我们现在有一个数组，array = [1, 3, &#39;h&#39;, 5, &#39;m&#39;, &#39;4&#39;]，现在想要找出这个数组中的所有类型为number的子项。当我们使用命令式编程思维时，可能就会直接这样做。 1234567var array = [1, 3, 'h', 5, 'm', '4'];var res = [];for(var i = 0; i &lt; array.length; i ++) &#123; if (typeof array[i] === 'number') &#123; res.push(array[i]); &#125;&#125; 在这种实现方式中，我们平铺直叙的实现了我们的目的。这样做的问题在于，当我们在另外的时刻，想要找出另外一个数组中所有的子项时，我们不得不把同样的逻辑再写一次。当出现次数变多时，我们的代码也变得更加糟糕且难以维护。 而函数式编程的思维则建议我们将这种会多次出现的功能封装起来以备调用。 123456789101112131415function getNumbers(array) &#123; var res = []; array.forEach(function(item) &#123; if (typeof item === 'number') &#123; res.push(item); &#125; &#125;) return res;&#125;// 以上是我们的封装，以下是功能实现var array = [1, 3, 'h', 5, 'm', '4'];var res = getNumbers(array); 因此当我们将功能封装之后，我们实现同样的功能时，只需要写一行代码。而如果未来需求变动，或者稍作修改，我们只需要对getNumbers方法进行调整就可以了。而且我们在使用时，只需要关心这个方法能做什么，而不用关心他具体是怎么实现的。这也是函数式编程思维与命令式不同的地方之一。 函数式编程思维还具有以下几个特征。 函数是第一等公民 所谓”第一等公民”（first class），指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。这些场景，我们应该见过很多。 123456789var a = function foo() &#123;&#125; // 赋值function fn(function() &#123;&#125;, num) &#123;&#125; // 函数作为参数// 函数作为返回值function var() &#123; return function() &#123; ... ... &#125;&#125; 当然，这都是JavaScript的基本概念。但是我想很多人，甚至包括正在阅读的你自己都可能会无视这些概念。可以用一个简单的例子来验证一下。 我们先自定义这样一个函数。 123function delay() &#123; console.log('5000ms之后执行该方法.');&#125; 现在要做的是，如果要求你结合setTimeout方法，让delay方法延迟5000ms执行，应该怎么做？ 其实很简单，对不对，直接这样就可以了。 123var timer = setTimeout(function() &#123; delay();&#125;, 5000); 那么现在问题来了，如果你对函数是一等公民有一个深刻的认知，我想你会发现上面这种写法其实是有一些问题的。所以思考一下，问题出在哪里？ 函数既然能够作为一个参数传入另外一个函数，那么我们是不是可以直接将delay作为setTimeout的第一个参数，而不用额外的多加一层匿名函数呢？ 因此，其实最正确的解法应该这样写。 1var timer = setTimeout(delay, 5000); 当然，如果你已经提前想到这样做了，那么恭喜你，说明你在JavaScript上比普通人更有天赋。其实第一种糟糕的方式很多人都在用，包括有多年工作经验的人也没有完全避免。而他们甚至还不知道自己问题出在什么地方。 在未来的实践中，你还会遇到更多类似的场景。为了验证读者朋友们的理解，我们不妨来思考一下如何优化下面的代码。 12345678910function getUser(path, callback) &#123; return $.get(path, function(info) &#123; return callback(info); &#125;)&#125;getUser('/api/user', function(resp) &#123; // resp为成功请求之后返回的数据 console.log(resp);&#125;) 优化的原理和setTimeout的例子一模一样，我这里卖个关子，不打算告诉大家结论，仅提示一句，getUser优化之后，仅有一句代码。考验大家学习成果的时候到了 ^ ^。 只用”表达式”，不用”语句” “表达式”（expression）是一个单纯的运算过程，总是有返回值；”语句”（statement）是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。 假如我们的项目中，多处需要改变某个元素的背景色。因此我们可以这样封装一下。 12345678var ele = document.querySelector('.test');function setBackgroundColor(color) &#123; ele.style.backgroundColor = color;&#125;// 多处使用setBackgroundColor('red');setBackgroundColor('#ccc'); 我们可以很明显的感受到，setBackgroundColor封装的仅仅只是一条语句。这并不是理想的效果。函数式编程期望一个函数有输入，也有输出。因此良好的习惯应该如下做。 123456789function setBackgroundColor(ele, color) &#123; ele.style.backgroundColor = color; return color;&#125;// 多处使用var ele = document.querySelector('.test');setBackgroundColor(ele, 'red');setBackgroundColor(ele, '#ccc'); 了解这一点，可以让我们自己在封装函数的时候养成良好的习惯。 纯函数 相同的输入总会得到相同的输出，并且不会产生副作用的函数，就是纯函数。 所谓”副作用”（side effect），指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。 函数式编程强调没有”副作用”，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。 即所谓的只要是同样的参数传入，返回的结果一定是相等的。 例如我们期望封装一个函数，能够得到传入数组的最后一项。那么可以通过下面两种方式来实现。 123456789101112function getLast(arr) &#123; return arr[arr.length];&#125;function getLast_(arr) &#123; return arr.pop();&#125;var source = [1, 2, 3, 4];var last = getLast(source); // 返回结果4 原数组不变var last_ = getLast_(source); // 返回结果4 原数据最后一项被删除 getLast与getLast_虽然同样能够获得数组的最后一项值，但是getLast_改变了原数组。而当原始数组被改变，那么当我们再次调用该方法时，得到的结果就会变得不一样。这样不可预测的封装方式，在我们看来是非常糟糕的。它会把我们的数据搞得非常混乱。在JavaScript原生支持的数据方法中，也有许多不纯的方法，我们在使用时需要非常警惕，我们要清晰的知道原始数据的改变是否会留下隐患。 12345678910111213141516var source = [1, 2, 3, 4, 5];source.slice(1, 3); // 纯函数 返回[2, 3] source不变source.splice(1, 3); // 不纯的 返回[2, 3, 4] source被改变source.pop(); // 不纯的source.push(6); // 不纯的source.shift(); // 不纯的source.unshift(1); // 不纯的source.reverse(); // 不纯的// 我也不能短时间知道现在source被改变成了什么样子，干脆重新约定一下source = [1, 2, 3, 4, 5];source.concat([6, 7]); // 纯函数 返回[1, 2, 3, 4, 5, 6, 7] source不变source.join('-'); // 纯函数 返回1-2-3-4-5 source不变 闭包 闭包是函数式编程语言的重要特性，我也在前面几篇文章中说了很多关于闭包的内容。这里不再赘述。 柯里化 略]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>function</tag>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[摘抄内存空间详解]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F17%2F%E6%91%98%E6%8A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1234var a = 20;var b = 'abc';var c = true;var d = &#123; m: 20 &#125; 因为JavaScript具有自动垃圾回收机制，所以对于前端开发来说，内存空间并不是一个经常被提及的概念，很容易被大家忽视。特别是很多不是计算机专业的朋友在进入到前端之后，会对内存空间的认知比较模糊，甚至有些人干脆就是一无所知。 当然也包括我自己。在很长一段时间里认为内存空间的概念在JS的学习中并不是那么重要。可是后我当我回过头来重新整理JS基础时，发现由于对它们的模糊认知，导致了很多东西我都理解得并不明白。比如最基本的引用数据类型和引用传递到底是怎么回事儿？比如浅复制与深复制有什么不同？还有闭包，原型等等。 因此后来我才渐渐明白，想要对JS的理解更加深刻，就必须对内存空间有一个清晰的认知。 在学习内存空间之前，我们需要对三种数据结构有一个直观的认知。他们分别是堆(heap)，栈(stack)与队列(queue)。 一、栈数据结构与C/C++不同，JavaScript中并没有严格意义上区分栈内存与堆内存。因此我们可以简单粗暴的理解为JavaScript的所有数据都保存在堆内存中。但是在某些场景，我们仍然需要基于堆栈数据结构的思维来实现一些功能，比如JavaScript的执行上下文（关于执行上下文我会在下一篇文章中总结）。执行上下文的执行顺序借用了栈数据结构的存取方式。(也就是后面我们会经常提到的函数调用栈)。因此理解栈数据结构的原理与特点十分重要。 要简单理解栈的存取方式，我们可以通过类比乒乓球盒子来分析。如下图左侧。 这种乒乓球的存放方式与栈中存取数据的方式如出一辙。处于盒子中最顶层的乒乓球5，它一定是最后被放进去，但可以最先被使用。而我们想要使用底层的乒乓球1，就必须将上面的4个乒乓球取出来，让乒乓球1处于盒子顶层。这就是栈空间先进后出，后进先出的特点。图中已经详细的表明了栈空间的存储原理。 二、堆数据结构堆数据结构是一种树状结构。它的存取数据的方式，则与书架与书非常相似。 书虽然也整齐的存放在书架上，但是我们只要知道书的名字，我们就可以很方便的取出我们想要的书，而不用像从乒乓球盒子里取乒乓一样，非得将上面的所有乒乓球拿出来才能取到中间的某一个乒乓球。好比在JSON格式的数据中，我们存储的key-value是可以无序的，因为顺序的不同并不影响我们的使用，我们只需要关心书的名字。 三、队列在JavaScript中，理解队列数据结构的目的主要是为了清晰的明白事件循环（Event Loop）的机制到底是怎么回事。在后续的章节中我会详细分析事件循环机制。 队列是一种先进先出（FIFO）的数据结构。正如排队过安检一样，排在队伍前面的人一定是最先过检的人。用以下的图示可以清楚的理解队列的原理。 四、变量对象与基础数据类型JavaScript的执行上下文生成之后，会创建一个叫做变量对象的特殊对象（具体会在下一篇文章与执行上下文一起总结），JavaScript的基础数据类型往往都会保存在变量对象中。 严格意义上来说，变量对象也是存放于堆内存中，但是由于变量对象的特殊职能，我们在理解时仍然需要将其于堆内存区分开来。 基础数据类型都是一些简单的数据段，JavaScript中有5中基础数据类型，分别是Undefined、Null、Boolean、Number、String。基础数据类型都是按值访问，因为我们可以直接操作保存在变量中的实际的值。 ES6中新加了一种基础数据类型Symbol，可以先不用考虑他 五、引用数据类型与堆内存与其他语言不同，JS的引用数据类型，比如数组Array，它们值的大小是不固定的。引用数据类型的值是保存在堆内存中的对象。JavaScript不允许直接访问堆内存中的位置，因此我们不能直接操作对象的堆内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。因此，引用类型的值都是按引用访问的。这里的引用，我们可以理解为保存在变量对象中的一个地址，该地址与堆内存的实际值相关联。 为了更好的搞懂变量对象与堆内存，我们可以结合以下例子与图解进行理解。 123456var a1 = 0; // 变量对象var a2 = 'this is string'; // 变量对象var a3 = null; // 变量对象var b = &#123; m: 20 &#125;; // 变量b存在于变量对象中，&#123;m: 20&#125; 作为对象存在于堆内存中var c = [1, 2, 3]; // 变量c存在于变量对象中，[1, 2, 3] 作为对象存在于堆内存中 因此当我们要访问堆内存中的引用数据类型时，实际上我们首先是从变量对象中获取了该对象的地址引用（或者地址指针），然后再从堆内存中取得我们需要的数据。 理解了JS的内存空间，我们就可以借助内存空间的特性来验证一下引用类型的一些特点了。 在前端面试中我们常常会遇到这样一个类似的题目 123456// demo01.jsvar a = 20;var b = a;b = 30;// 这时a的值是多少？ 123456// demo02.jsvar m = &#123; a: 10, b: 20 &#125;var n = m;n.a = 15;// 这时m.a的值是多少 在变量对象中的数据发生复制行为时，系统会自动为新的变量分配一个新值。var b = a执行之后，a与b虽然值都等于20，但是他们其实已经是相互独立互不影响的值了。具体如图。所以我们修改了b的值以后，a的值并不会发生变化。 在demo02中，我们通过var n = m执行一次复制引用类型的操作。引用类型的复制同样也会为新的变量自动分配一个新的值保存在变量对象中，但不同的是，这个新的值，仅仅只是引用类型的一个地址指针。当地址指针相同时，尽管他们相互独立，但是在变量对象中访问到的具体对象实际上是同一个。如图所示。 因此当我改变n时，m也发生了变化。这就是引用类型的特性。 通过内存的角度来理解，是不是感觉要轻松很多？除此之外，我们还可以以此为基础，一步一步的理解JavaScript的执行上下文，作用域链，闭包，原型链等重要概念。其他的我会在以后的文章慢慢总结，敬请期待。 六、内存空间管理因为JavaScript具有自动垃圾收集机制，所以我们在开发时好像不用关心内存的使用问题，内存的分配与回收都完全实现了自动管理。但是根据我自己的开发经验，了解内存机制有助于自己清晰的认识到自己写的代码在执行过程中发生过什么，从而写出性能更加优秀的代码。因此关心内存是一件非常重要的事情。 JavaScript的内存生命周期 1231. 分配你所需要的内存2. 使用分配到的内存（读、写）3. 不需要时将其释放、归还 为了便于理解，我们使用一个简单的例子来解释这个周期。 123var a = 20; // 在内存中给数值变量分配空间alert(a + 100); // 使用内存a = null; // 使用完毕之后，释放内存空间 第一步和第二步我们都很好理解，JavaScript在定义变量时就完成了内存分配。第三步释放内存空间则是我们需要重点理解的一个点。 JavaScript有自动垃圾收集机制，那么这个自动垃圾收集机制的原理是什么呢？其实很简单，就是找出那些不再继续使用的值，然后释放其占用的内存。垃圾收集器会每隔固定的时间段就执行一次释放操作。 在JavaScript中，最常用的是通过标记清除的算法来找到哪些对象是不再继续使用的，因此a = null其实仅仅只是做了一个释放引用的操作，让 a 原本对应的值失去引用，脱离执行环境，这个值会在下一次垃圾收集器执行操作时被找到并释放。而在适当的时候解除引用，是为页面获得更好性能的一个重要方式。 在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。但是全局变量什么时候需要自动释放内存空间则很难判断，因此在我们的开发中，需要尽量避免使用全局变量。 要详细了解垃圾收集机制，建议阅读《JavaScript高级编程》中的4.3节]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>内存空间</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[摘抄作用域链与闭包]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F17%2F%E6%91%98%E6%8A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E4%B8%8E%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[初学JavaScript的时候，我在学习闭包上，走了很多弯路。而这次重新回过头来对基础知识进行梳理，要讲清楚闭包，也是一个非常大的挑战。 闭包有多重要？如果你是初入前端的朋友，我没有办法直观的告诉你闭包在实际开发中的无处不在，但是我可以告诉你，前端面试，必问闭包。面试官们常常用对闭包的了解程度来判定面试者的基础水平，保守估计，10个前端面试者，至少5个都死在闭包上。 可是为什么，闭包如此重要，还是有那么多人没有搞清楚呢？是因为大家不愿意学习吗？还真不是，而是我们通过搜索找到的大部分讲解闭包的中文文章，都没有清晰明了的把闭包讲解清楚。要么浅尝辄止，要么高深莫测，要么干脆就直接乱说一通。包括我自己曾经也写过一篇关于闭包的总结，回头一看，不忍直视[捂脸]。 因此本文的目的就在于，能够清晰明了得把闭包说清楚，让读者朋友们看了之后，就把闭包给彻底学会了，而不是似懂非懂。 一、作用域与作用域链在详细讲解作用域链之前，我默认你已经大概明白了JavaScript中的下面这些重要概念。这些概念将会非常有帮助。 基础数据类型与引用数据类型 内存空间 垃圾回收机制 执行上下文 变量对象与活动对象 如果你暂时还没有明白，可以去看本系列的前三篇文章，本文文末有目录链接。为了讲解闭包，已经为大家做好了基础知识的铺垫哦。 作用域 在JavaScript中，我们可以将作用域定义为一套规则,这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。 这里的标识符，指的是变量名或者函数名 JavaScript中只有全局作用域与函数作用域(因为eval我们平时开发中几乎不会用到它，这里不讨论)。 作用域与执行上下文是完全不同的两个概念。我知道很多人会混淆他们，但是一定要仔细区分。 JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建。 作用域链 回顾一下上一篇文章我们分析的执行上下文的生命周期，如下图。 我们知道函数在调用激活时，会开始创建对应的执行上下文，在执行上下文生成的过程中，变量对象，作用域链，以及this的值会分别被确定。之前一篇文章我们详细说明了变量对象，而这里，我们将详细说明作用域链。 作用域链，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。 为了帮助大家理解作用域链，我我们先结合一个例子，以及相应的图示来说明。 1234567891011121314var a = 20;function test() &#123; var b = a + 10; function innerTest() &#123; var c = 10; return b + c; &#125; return innerTest();&#125;test(); 在上面的例子中，全局，函数test，函数innerTest的执行上下文先后创建。我们设定他们的变量对象分别为VO(global)，VO(test), VO(innerTest)。而innerTest的作用域链，则同时包含了这三个变量对象，所以innerTest的执行上下文可如下表示。 1234innerTestEC = &#123; VO: &#123;...&#125;, // 变量对象 scopeChain: [VO(innerTest), VO(test), VO(global)], // 作用域链&#125; 我们可以直接用一个数组来表示作用域链，数组的第一项scopeChain[0]为作用域链的最前端，而数组的最后一项，为作用域链的最末端，所有的最末端都为全局变量对象。 很多人会误解为当前作用域与上层作用域为包含关系，但其实并不是。以最前端为起点，最末端为终点的单方向通道我认为是更加贴切的形容。如图。 注意，因为变量对象在执行上下文进入执行阶段时，就变成了活动对象，这一点在上一篇文章中已经讲过，因此图中使用了AO来表示。Active Object 是的，作用域链是由一系列变量对象组成，我们可以在这个单向通道中，查询变量对象中的标识符，这样就可以访问到上一层作用域中的变量了。 二、闭包对于那些有一点 JavaScript 使用经验但从未真正理解闭包概念的人来说，理解闭包可以看作是某种意义上的重生，突破闭包的瓶颈可以使你功力大增。 闭包是一种特殊的对象。 它由两部分组成。执行上下文(代号A)，以及在该执行上下文中创建的函数（代号B）。 当B执行时，如果访问了A中变量对象中的值，那么闭包就会产生。 在大多数理解中，包括许多著名的书籍，文章里都以函数B的名字代指这里生成的闭包。而在chrome中，则以执行上下文A的函数名代指闭包。 因此我们只需要知道，一个闭包对象，由A、B共同组成，在以后的篇幅中，我将以chrome的标准来称呼。 1234567891011121314// demo01function foo() &#123; var a = 20; var b = 30; function bar() &#123; return a + b; &#125; return bar;&#125;var bar = foo();bar(); 上面的例子，首先有执行上下文foo，在foo中定义了函数bar，而通过对外返回bar的方式让bar得以执行。当bar执行时，访问了foo内部的变量a，b。因此这个时候闭包产生。 在基础进阶（一）中，我总结了JavaScript的垃圾回收机制。JavaScript拥有自动的垃圾回收机制，关于垃圾回收机制，有一个重要的行为，那就是，当一个值，在内存中失去引用时，垃圾回收机制会根据特殊的算法找到它，并将其回收，释放内存。 而我们知道，函数的执行上下文，在执行完毕之后，生命周期结束，那么该函数的执行上下文就会失去引用。其占用的内存空间很快就会被垃圾回收器释放。可是闭包的存在，会阻止这一过程。 先来一个简单的例子。 123456789101112131415var fn = null;function foo() &#123; var a = 2; function innnerFoo() &#123; console.log(a); &#125; fn = innnerFoo; // 将 innnerFoo的引用，赋值给全局变量中的fn&#125;function bar() &#123; fn(); // 此处的保留的innerFoo的引用&#125;foo();bar(); // 2 在上面的例子中，foo()执行完毕之后，按照常理，其执行环境生命周期会结束，所占内存被垃圾收集器释放。但是通过fn = innerFoo，函数innerFoo的引用被保留了下来，复制给了全局变量fn。这个行为，导致了foo的变量对象，也被保留了下来。于是，函数fn在函数bar内部执行时，依然可以访问这个被保留下来的变量对象。所以此刻仍然能够访问到变量a的值。 这样，我们就可以称foo为闭包。 下图展示了闭包foo的作用域链。 我们可以在chrome浏览器的开发者工具中查看这段代码运行时产生的函数调用栈与作用域链的生成情况。如下图。 关于如何在chrome中观察闭包，以及更多闭包的例子，请阅读基础系列（六） 在上面的图中，红色箭头所指的正是闭包。其中Call Stack为当前的函数调用栈，Scope为当前正在被执行的函数的作用域链，Local为当前的局部变量。 所以，通过闭包，我们可以在其他的执行上下文中，访问到函数的内部变量。比如在上面的例子中，我们在函数bar的执行环境中访问到了函数foo的a变量。个人认为，从应用层面，这是闭包最重要的特性。利用这个特性，我们可以实现很多有意思的东西。 不过读者朋友们需要注意的是，虽然例子中的闭包被保存在了全局变量中，但是闭包的作用域链并不会发生任何改变。在闭包中，能访问到的变量，仍然是作用域链上能够查询到的变量。 对上面的例子稍作修改，如果我们在函数bar中声明一个变量c，并在闭包fn中试图访问该变量，运行结果会抛出错误。 1234567891011121314151617var fn = null;function foo() &#123; var a = 2; function innnerFoo() &#123; console.log(c); // 在这里，试图访问函数bar中的c变量，会抛出错误 console.log(a); &#125; fn = innnerFoo; // 将 innnerFoo的引用，赋值给全局变量中的fn&#125;function bar() &#123; var c = 100; fn(); // 此处的保留的innerFoo的引用&#125;foo();bar(); 关于这一点，很多同学把函数调用栈与作用域链没有分清楚，所以有的大神看了我关于介绍执行上下文的文章时就义正言辞的说我的例子有问题，而这些评论有很大的误导作用，为了帮助大家自己拥有能够辨别的能力，所以我写了基础（六），教大家如何在chrome中观察闭包，作用域链，this等。当然我也不敢100%保证我文中的例子就一定正确，所以教大家如何去辨认我认为才是最重要的。 闭包的应用场景 除了面试，在实践中，闭包有两个非常重要的应用场景。分别是模块化与柯里化。 柯里化 在函数式编程中，利用闭包能够实现很多炫酷的功能，柯里化便是其中很重要的一种。点击了解更多关于柯里化的知识 模块 在我看来，模块是闭包最强大的一个应用场景。如果你是初学者，对于模块的了解可以暂时不用放在心上，因为理解模块需要更多的基础知识。但是如果你已经有了很多JavaScript的使用经验，在彻底了解了闭包之后，不妨借助本文介绍的作用域链与闭包的思路，重新理一理关于模块的知识。这对于我们理解各种各样的设计模式具有莫大的帮助。 123456789101112131415(function () &#123; var a = 10; var b = 20; function add(num1, num2) &#123; var num1 = !!num1 ? num1 : a; var num2 = !!num2 ? num2 : b; return num1 + num2; &#125; window.add = add;&#125;)();add(10, 20); 在上面的例子中，我使用函数自执行的方式，创建了一个模块。add是模块对外暴露的一个公共方法。而变量a，b被作为私有变量。在面向对象的开发中，我们常常需要考虑是将变量作为私有变量，还是放在构造函数中的this中，因此理解闭包，以及原型链是一个非常重要的事情。模块十分重要，因此我会在以后的文章专门介绍，这里就暂时不多说啦。 为了验证自己有没有搞懂作用域链与闭包，这里留下一个经典的思考题，常常也会在面试中被问到。 利用闭包，修改下面的代码，让循环输出的结果依次为1， 2， 3， 4， 5 12345for (var i=1; i&lt;=5; i++) &#123; setTimeout( function timer() &#123; console.log(i); &#125;, i*1000 );&#125; 点此查看关于此题的详细解读 关于作用域链的与闭包我就总结完了，虽然我自认为我是说得非常清晰了，但是我知道理解闭包并不是一件简单的事情，所以如果你有什么问题，可以在评论中问我。你也可以带着从别的地方没有看懂的例子在评论中留言。大家一起学习进步。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>闭包</tag>
        <tag>作用域链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[摘抄事件循环机制]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F17%2F%E6%91%98%E6%8A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[JavaScript的学习零散而庞杂，因此很多时候我们学到了一些东西，但是却没办法感受到自己的进步，甚至过了不久，就把学到的东西给忘了。为了解决自己的这个困扰，在学习的过程中，我一直试图在寻找一条核心的线索，只要我根据这条线索，我就能够一点一点的进步。 前端基础进阶正是围绕这条线索慢慢展开，而事件循环机制(Event Loop)，则是这条线索的最关键的知识点。所以，我就马不停蹄的去深入的学习了事件循环机制，并总结出了这篇文章跟大家分享。 事件循环机制从整体上的告诉了我们所写的JavaScript代码的执行顺序。但是在我学习的过程中，找到的许多国内博客文章对于它的讲解浅尝辄止，不得其法，很多文章在图中画个圈就表示循环了，看了之后也没感觉明白了多少。但是他又如此重要，以致于当我们想要面试中高级岗位时，事件循环机制总是绕不开的话题。特别是ES6中正式加入了Promise对象之后，对于新标准中事件循环机制的理解就变得更加重要。这就很尴尬了。 最近有两篇比较火的文章也表达了这个问题的重要性。 这个前端面试在搞事80% 应聘者都不及格的 JS 面试题 但是很遗憾的是，大神们告诉了大家这个知识点很重要，却并没有告诉大家为什么会这样。所以当我们在面试时遇到这样的问题时，就算你知道了结果，面试官再进一步问一下，我们依然懵逼。 在学习事件循环机制之前，我默认你已经懂得了如下概念，如果仍然有疑问，可以回过头去看看我以前的文章。 执行上下文(Execution context) 函数调用栈(call stack) 队列数据结构(queue) Promise(我会在下一篇文章专门总结Promise的详细使用) 因为chrome浏览器中新标准中的事件循环机制与nodejs类似，因此此处就整合nodejs一起来理解，其中会介绍到几个nodejs有，但是浏览器中没有的API，大家只需要了解就好，不一定非要知道她是如何使用。比如process.nextTick，setImmediate OK，那我就先抛出结论，然后以例子与图示详细给大家演示事件循环机制。 我们知道JavaScript的一大特点就是单线程，而这个线程中拥有唯一的一个事件循环。 当然新标准中的web worker涉及到了多线程，我对它了解也不多，这里就不讨论了。 JavaScript代码的执行过程中，除了依靠函数调用栈来搞定函数的执行顺序外，还依靠任务队列(task queue)来搞定另外一些代码的执行。 一个线程中，事件循环是唯一的，但是任务队列可以拥有多个。 任务队列又分为macro-task（宏任务）与micro-task（微任务），在最新标准中，它们被分别称为task与jobs。 macro-task大概包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。 micro-task大概包括: process.nextTick, Promise, Object.observe(已废弃), MutationObserver(html5新特性) setTimeout/Promise等我们称之为任务源。而进入任务队列的是他们指定的具体执行任务。 123456// setTimeout中的回调函数才是进入任务队列的任务setTimeout(function() &#123; console.log('xxxx');&#125;)// 非常多的同学对于setTimeout的理解存在偏差。所以大概说一下误解：// setTimeout作为一个任务分发器，这个函数会立即执行，而它所要分发的任务，也就是它的第一个参数，才是延迟执行 来自不同任务源的任务会进入到不同的任务队列。其中setTimeout与setInterval是同源的。 事件循环的顺序，决定了JavaScript代码的执行顺序。它从script(整体代码)开始第一次循环。之后全局上下文进入函数调用栈。直到调用栈清空(只剩全局)，然后执行所有的micro-task。当所有可执行的micro-task执行完毕之后。循环再次从macro-task开始，找到其中一个任务队列执行完毕，然后再执行所有的micro-task，这样一直循环下去。 其中每一个任务的执行，无论是macro-task还是micro-task，都是借助函数调用栈来完成。 纯文字表述确实有点干涩，因此，这里我们通过2个例子，来逐步理解事件循环的具体顺序。 1234567891011121314151617// demo01 出自于上面我引用文章的一个例子，我们来根据上面的结论，一步一步分析具体的执行过程。// 为了方便理解，我以打印出来的字符作为当前的任务名称setTimeout(function() &#123; console.log('timeout1');&#125;)new Promise(function(resolve) &#123; console.log('promise1'); for(var i = 0; i &lt; 1000; i++) &#123; i == 99 &amp;&amp; resolve(); &#125; console.log('promise2');&#125;).then(function() &#123; console.log('then1');&#125;)console.log('global1'); 首先，事件循环从宏任务队列开始，这个时候，宏任务队列中，只有一个script(整体代码)任务。每一个任务的执行顺序，都依靠函数调用栈来搞定，而当遇到任务源时，则会先分发任务到对应的队列中去，所以，上面例子的第一步执行如下图所示。 第二步：script任务执行时首先遇到了setTimeout，setTimeout为一个宏任务源，那么他的作用就是将任务分发到它对应的队列中。 123setTimeout(function() &#123; console.log('timeout1');&#125;) 第三步：script执行时遇到Promise实例。Promise构造函数中的第一个参数，是在new的时候执行，因此不会进入任何其他的队列，而是直接在当前任务直接执行了，而后续的.then则会被分发到micro-task的Promise队列中去。 因此，构造函数执行时，里面的参数进入函数调用栈执行。for循环不会进入任何队列，因此代码会依次执行，所以这里的promise1和promise2会依次输出。 script任务继续往下执行，最后只有一句输出了globa1，然后，全局任务就执行完毕了。 第四步：第一个宏任务script执行完毕之后，就开始执行所有的可执行的微任务。这个时候，微任务中，只有Promise队列中的一个任务then1，因此直接执行就行了，执行结果输出then1，当然，他的执行，也是进入函数调用栈中执行的。 第五步：当所有的micro-tast执行完毕之后，表示第一轮的循环就结束了。这个时候就得开始第二轮的循环。第二轮循环仍然从宏任务macro-task开始。 这个时候，我们发现宏任务中，只有在setTimeout队列中还要一个timeout1的任务等待执行。因此就直接执行即可。 这个时候宏任务队列与微任务队列中都没有任务了，所以代码就不会再输出其他东西了。 那么上面这个例子的输出结果就显而易见。大家可以自行尝试体会。 这个例子比较简答，涉及到的队列任务并不多，因此读懂了它还不能全面的了解到事件循环机制的全貌。所以我下面弄了一个复杂一点的例子，再给大家解析一番，相信读懂之后，事件循环这个问题，再面试中再次被问到就难不倒大家了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// demo02console.log('golb1');setTimeout(function() &#123; console.log('timeout1'); process.nextTick(function() &#123; console.log('timeout1_nextTick'); &#125;) new Promise(function(resolve) &#123; console.log('timeout1_promise'); resolve(); &#125;).then(function() &#123; console.log('timeout1_then') &#125;)&#125;)setImmediate(function() &#123; console.log('immediate1'); process.nextTick(function() &#123; console.log('immediate1_nextTick'); &#125;) new Promise(function(resolve) &#123; console.log('immediate1_promise'); resolve(); &#125;).then(function() &#123; console.log('immediate1_then') &#125;)&#125;)process.nextTick(function() &#123; console.log('glob1_nextTick');&#125;)new Promise(function(resolve) &#123; console.log('glob1_promise'); resolve();&#125;).then(function() &#123; console.log('glob1_then')&#125;)setTimeout(function() &#123; console.log('timeout2'); process.nextTick(function() &#123; console.log('timeout2_nextTick'); &#125;) new Promise(function(resolve) &#123; console.log('timeout2_promise'); resolve(); &#125;).then(function() &#123; console.log('timeout2_then') &#125;)&#125;)process.nextTick(function() &#123; console.log('glob2_nextTick');&#125;)new Promise(function(resolve) &#123; console.log('glob2_promise'); resolve();&#125;).then(function() &#123; console.log('glob2_then')&#125;)setImmediate(function() &#123; console.log('immediate2'); process.nextTick(function() &#123; console.log('immediate2_nextTick'); &#125;) new Promise(function(resolve) &#123; console.log('immediate2_promise'); resolve(); &#125;).then(function() &#123; console.log('immediate2_then') &#125;)&#125;) 这个例子看上去有点复杂，乱七八糟的代码一大堆，不过不用担心，我们一步一步来分析一下。 第一步：宏任务script首先执行。全局入栈。glob1输出。 第二步，执行过程遇到setTimeout。setTimeout作为任务分发器，将任务分发到对应的宏任务队列中。 123456789101112setTimeout(function() &#123; console.log('timeout1'); process.nextTick(function() &#123; console.log('timeout1_nextTick'); &#125;) new Promise(function(resolve) &#123; console.log('timeout1_promise'); resolve(); &#125;).then(function() &#123; console.log('timeout1_then') &#125;)&#125;) 第三步：执行过程遇到setImmediate。setImmediate也是一个宏任务分发器，将任务分发到对应的任务队列中。setImmediate的任务队列会在setTimeout队列的后面执行。 123456789101112setImmediate(function() &#123; console.log('immediate1'); process.nextTick(function() &#123; console.log('immediate1_nextTick'); &#125;) new Promise(function(resolve) &#123; console.log('immediate1_promise'); resolve(); &#125;).then(function() &#123; console.log('immediate1_then') &#125;)&#125;) 第四步：执行遇到nextTick，process.nextTick是一个微任务分发器，它会将任务分发到对应的微任务队列中去。 123process.nextTick(function() &#123; console.log('glob1_nextTick');&#125;) 第五步：执行遇到Promise。Promise的then方法会将任务分发到对应的微任务队列中，但是它构造函数中的方法会直接执行。因此，glob1_promise会第二个输出。 123456new Promise(function(resolve) &#123; console.log('glob1_promise'); resolve();&#125;).then(function() &#123; console.log('glob1_then')&#125;) 第六步：执行遇到第二个setTimeout。 123456789101112setTimeout(function() &#123; console.log('timeout2'); process.nextTick(function() &#123; console.log('timeout2_nextTick'); &#125;) new Promise(function(resolve) &#123; console.log('timeout2_promise'); resolve(); &#125;).then(function() &#123; console.log('timeout2_then') &#125;)&#125;) 第七步：先后遇到nextTick与Promise 123456789process.nextTick(function() &#123; console.log('glob2_nextTick');&#125;)new Promise(function(resolve) &#123; console.log('glob2_promise'); resolve();&#125;).then(function() &#123; console.log('glob2_then')&#125;) 第八步：再次遇到setImmediate。 123456789101112setImmediate(function() &#123; console.log('immediate2'); process.nextTick(function() &#123; console.log('immediate2_nextTick'); &#125;) new Promise(function(resolve) &#123; console.log('immediate2_promise'); resolve(); &#125;).then(function() &#123; console.log('immediate2_then') &#125;)&#125;) 这个时候，script中的代码就执行完毕了，执行过程中，遇到不同的任务分发器，就将任务分发到各自对应的队列中去。接下来，将会执行所有的微任务队列中的任务。 其中，nextTick队列会比Promie先执行。nextTick中的可执行任务执行完毕之后，才会开始执行Promise队列中的任务。 当所有可执行的微任务执行完毕之后，这一轮循环就表示结束了。下一轮循环继续从宏任务队列开始执行。 这个时候，script已经执行完毕，所以就从setTimeout队列开始执行。 setTimeout任务的执行，也依然是借助函数调用栈来完成，并且遇到任务分发器的时候也会将任务分发到对应的队列中去。 只有当setTimeout中所有的任务执行完毕之后，才会再次开始执行微任务队列。并且清空所有的可执行微任务。 setTiemout队列产生的微任务执行完毕之后，循环则回过头来开始执行setImmediate队列。仍然是先将setImmediate队列中的任务执行完毕，再执行所产生的微任务。 当setImmediate队列执行产生的微任务全部执行之后，第二轮循环也就结束了。 大家需要注意这里的循环结束的时间节点。 当我们在执行setTimeout任务中遇到setTimeout时，它仍然会将对应的任务分发到setTimeout队列中去，但是该任务就得等到下一轮事件循环执行了。例子中没有涉及到这么复杂的嵌套，大家可以动手添加或者修改他们的位置来感受一下循环的变化。 OK，到这里，事件循环我想我已经表述得很清楚了，能不能理解就看读者老爷们有没有耐心了。我估计很多人会理解不了循环结束的节点。 当然，这些顺序都是v8的一些实现。我们也可以根据上面的规则，来尝试实现一下事件循环的机制。 1234567891011121314151617181920212223242526272829303132333435363738// 用数组模拟一个队列var tasks = [];// 模拟一个事件分发器var addFn1 = function(task) &#123; tasks.push(task);&#125;// 执行所有的任务var flush = function() &#123; tasks.map(function(task) &#123; task(); &#125;)&#125;// 最后利用setTimeout/或者其他你认为合适的方式丢入事件循环中setTimeout(function() &#123; flush();&#125;)// 当然，也可以不用丢进事件循环，而是我们自己手动在适当的时机去执行对应的某一个方法var dispatch = function(name) &#123; tasks.map(function(item) &#123; if(item.name == name) &#123; item.handler(); &#125; &#125;)&#125;// 当然，我们把任务丢进去的时候，多保存一个name即可。// 这时候，task的格式就如下demoTask = &#123; name: 'demo', handler: function() &#123;&#125;&#125;// 于是，一个订阅-通知的设计模式就这样轻松的被实现了 这样，我们就模拟了一个任务队列。我们还可以定义另外一个队列，利用上面的各种方式来规定他们的优先级。 需要注意的是，这里的执行顺序，或者执行的优先级在不同的场景里由于实现的不同会导致不同的结果，包括node的不同版本，不同浏览器等都有不同的结果。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>事件循环机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[摘抄this]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F17%2F%E6%91%98%E6%8A%84this%2F</url>
    <content type="text"><![CDATA[我们在学习JavaScript的过程中，由于对一些概念理解得不是很清楚，但是又想要通过一些方式把它记下来，于是就很容易草率的给这些概念定下一些方便自己记忆的有偏差的结论。 危害比较大的是，有的不准确的结论在网上还广为流传。 比如对于this指向的理解中，有这样一种说法：谁调用它，this就指向谁。在我刚开始学习this的时候，我是非常相信这句话的。因为在一些情况下，这样理解也还算说得通。可是我常常会在开发中遇到一些不一样的情况，一个由于this的错误调用，可以让我懵逼一整天。那个时候我也查资料，在群里问大神，可是我仍然搞不清楚“我特么到底错哪里了”。其实只是因为我心中有一个不太准确的结论。 所以，我认为需要有这样一篇文章，来帮助大家全方位的解读this。让大家对this，有一个正确的，全面的认知。 在这之前，我们需要来回顾一下执行上下文。 在前面几篇文章中，我有好几个地方都提到执行上下文的生命周期，为了防止大家没有记住，再次来回顾一下，如下图。 在执行上下文的创建阶段，会分别生成变量对象，建立作用域链，确定this指向。其中变量对象与作用域链我们都已经仔细总结过了，而这里的关键，就是确定this指向。 首先我们需要得出一个非常重要一定要牢记于心的结论，this的指向，是在函数被调用的时候确定的。也就是执行上下文被创建时确定的。因此，一个函数中的this指向，可以是非常灵活的。比如下面的例子中，同一个函数由于调用方式的不同，this指向了不一样的对象。 1234567891011var a = 10;var obj = &#123; a: 20&#125;function fn () &#123; console.log(this.a);&#125;fn(); // 10fn.call(obj); // 20 除此之外，在函数执行过程中，this一旦被确定，就不可更改了。 1234567891011var a = 10;var obj = &#123; a: 20&#125;function fn () &#123; this = obj; // 这句话试图修改this，运行后会报错 console.log(this.a);&#125;fn(); 一、全局对象中的this 关于全局对象的this，我之前在总结变量对象的时候提到过，它是一个比较特殊的存在。全局环境中的this，指向它本身。因此，这也相对简单，没有那么多复杂的情况需要考虑。 12345678910111213// 通过this绑定到全局对象this.a2 = 20;// 通过声明绑定到变量对象，但在全局环境中，变量对象就是它自身var a1 = 10;// 仅仅只有赋值操作，标识符会隐式绑定到全局对象a3 = 30;// 输出结果会全部符合预期console.log(a1);console.log(a2);console.log(a3); 二、函数中的this在总结函数中this指向之前，我想我们有必要通过一些奇怪的例子，来感受一下函数中this的捉摸不定。 123456// demo01var a = 20;function fn() &#123; console.log(this.a);&#125;fn(); 123456789// demo02var a = 20;function fn() &#123; function foo() &#123; console.log(this.a); &#125; foo();&#125;fn(); 123456789101112// demo03var a = 20;var obj = &#123; a: 10, c: this.a + 20, fn: function () &#123; return this.a; &#125;&#125;console.log(obj.c);console.log(obj.fn()); 这几个例子需要花点时间仔细感受一下，如果你暂时没想明白怎么回事，也不用着急，我们一点一点来分析。 分析之前，我们先直接了当抛出结论。 在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined。但是在非严格模式中，当this指向undefined时，它会被自动指向全局对象。 从结论中我们可以看出，想要准确确定this指向，找到函数的调用者以及区分他是否是独立调用就变得十分关键。 12345678// 为了能够准确判断，我们在函数内部使用严格模式，因为非严格模式会自动指向全局function fn() &#123; 'use strict'; console.log(this);&#125;fn(); // fn是调用者，独立调用window.fn(); // fn是调用者，被window所拥有 在上面的简单例子中，fn()作为独立调用者，按照定义的理解，它内部的this指向就为undefined。而window.fn()则因为fn被window所拥有，内部的this就指向了window对象。 那么掌握了这个规则，现在回过头去看看上面的三个例子，通过添加/去除严格模式，那么你就会发现，原来this已经变得不那么虚无缥缈，已经有迹可循了。 但是我们需要特别注意的是demo03。在demo03中，对象obj中的c属性使用this.a + 20来计算。这里我们需要明确的一点是，单独的{}是不会形成新的作用域的，因此这里的this.a，由于并没有作用域的限制，所以它仍然处于全局作用域之中。所以这里的this其实是指向的window对象。 那么我们修改一下demo03的代码，大家可以思考一下会发生什么变化。 12345678910111213141516'use strict';var a = 20;function foo () &#123; var a = 1; var obj = &#123; a: 10, c: this.a + 20, fn: function () &#123; return this.a; &#125; &#125; return obj.c;&#125;console.log(foo()); // ？console.log(window.foo()); // ? 实际开发中，并不推荐这样使用this； 上面多次提到的严格模式，需要大家认真对待，因为在实际开发中，现在基本已经全部采用严格模式了，而最新的ES6，也是默认支持严格模式。 再来看一些容易理解错误的例子，加深一下对调用者与是否独立运行的理解。 1234567891011var a = 20;var foo = &#123; a: 10, getA: function () &#123; return this.a; &#125;&#125;console.log(foo.getA()); // 10var test = foo.getA;console.log(test()); // 20 foo.getA()中，getA是调用者，他不是独立调用，被对象foo所拥有，因此它的this指向了foo。而test()作为调用者，尽管他与foo.getA的引用相同，但是它是独立调用的，因此this指向undefined，在非严格模式，自动转向全局window。 稍微修改一下代码，大家自行理解。 123456789var a = 20;function getA() &#123; return this.a;&#125;var foo = &#123; a: 10, getA: getA&#125;console.log(foo.getA()); // 10 灵机一动，再来一个。如下例子。 123456789101112131415function foo() &#123; console.log(this.a)&#125;function active(fn) &#123; fn(); // 真实调用者，为独立调用&#125;var a = 20;var obj = &#123; a: 10, getA: foo&#125;active(obj.getA); 三、使用call，apply显示指定thisJavaScript内部提供了一种机制，让我们可以自行手动设置this的指向。它们就是call与apply。所有的函数都具有着两个方法。它们除了参数略有不同，其功能完全一样。它们的第一个参数都为this将要指向的对象。 如下例子所示。fn并非属于对象obj的方法，但是通过call，我们将fn内部的this绑定为obj，因此就可以使用this.a访问obj的a属性了。这就是call/apply的用法。 12345678function fn() &#123; console.log(this.a);&#125;var obj = &#123; a: 20&#125;fn.call(obj); 而call与applay后面的参数，都是向将要执行的函数传递参数。其中call以一个一个的形式传递，apply以数组的形式传递。这是他们唯一的不同。 123456789function fn(num1, num2) &#123; console.log(this.a + num1 + num2);&#125;var obj = &#123; a: 20&#125;fn.call(obj, 100, 10); // 130fn.apply(obj, [20, 10]); // 50 因为call/apply的存在，这让JavaScript变得十分灵活。因此就让call/apply拥有了很多有用处的场景。简单总结几点，也欢迎大家补充。 将类数组对象转换为数组 12345678910111213141516171819function exam(a, b, c, d, e) &#123; // 先看看函数的自带属性 arguments 什么是样子的 console.log(arguments); // 使用call/apply将arguments转换为数组, 返回结果为数组，arguments自身不会改变 var arg = [].slice.call(arguments); console.log(arg);&#125;exam(2, 8, 9, 10, 3);// result:// &#123; '0': 2, '1': 8, '2': 9, '3': 10, '4': 3 &#125;// [ 2, 8, 9, 10, 3 ]//// 也常常使用该方法将DOM中的nodelist转换为数组// [].slice.call( document.getElementsByTagName('li') ); 根据自己的需要灵活修改this指向 12345678910var foo = &#123; name: 'joker', showName: function() &#123; console.log(this.name); &#125;&#125;var bar = &#123; name: 'rose'&#125;foo.showName.call(bar); 实现继承 1234567891011121314151617181920212223// 定义父级的构造函数var Person = function(name, age) &#123; this.name = name; this.age = age; this.gender = ['man', 'woman'];&#125;// 定义子类的构造函数var Student = function(name, age, high) &#123; // use call Person.call(this, name, age); this.high = high;&#125;Student.prototype.message = function() &#123; console.log('name:'+this.name+', age:'+this.age+', high:'+this.high+', gender:'+this.gender[0]+';');&#125;new Student('xiaom', 12, '150cm').message();// result// ----------// name:xiaom, age:12, high:150cm, gender:man; 简单给有面向对象基础的朋友解释一下。在Student的构造函数中，借助call方法，将父级的构造函数执行了一次，相当于将Person中的代码，在Sudent中复制了一份，其中的this指向为从Student中new出来的实例对象。call方法保证了this的指向正确，因此就相当于实现了继承。Student的构造函数等同于下。 1234567var Student = function(name, age, high) &#123; this.name = name; this.age = age; this.gender = ['man', 'woman']; // Person.call(this, name, age); 这一句话，相当于上面三句话，因此实现了继承 this.high = high;&#125; 在向其他执行上下文的传递中，确保this的指向保持不变 如下面的例子中，我们期待的是getA被obj调用时，this指向obj，但是由于匿名函数的存在导致了this指向的丢失，在这个匿名函数中this指向了全局，因此我们需要想一些办法找回正确的this指向。 12345678910var obj = &#123; a: 20, getA: function() &#123; setTimeout(function() &#123; console.log(this.a) &#125;, 1000) &#125;&#125;obj.getA(); 常规的解决办法很简单，就是使用一个变量，将this的引用保存起来。我们常常会用到这方法，但是我们也要借助上面讲到过的知识，来判断this是否在传递中被修改了，如果没有被修改，就没有必要这样使用了。 123456789var obj = &#123; a: 20, getA: function() &#123; var self = this; setTimeout(function() &#123; console.log(self.a) &#125;, 1000) &#125;&#125; 另外就是借助闭包与apply方法，封装一个bind方法。 12345678910111213141516function bind(fn, obj) &#123; return function() &#123; return fn.apply(obj, arguments); &#125;&#125;var obj = &#123; a: 20, getA: function() &#123; setTimeout(bind(function() &#123; console.log(this.a) &#125;, this), 1000) &#125;&#125;obj.getA(); 当然，也可以使用ES5中已经自带的bind方法。它与我上面封装的bind方法是一样的效果。 12345678var obj = &#123; a: 20, getA: function() &#123; setTimeout(function() &#123; console.log(this.a) &#125;.bind(this), 1000) &#125;&#125; 四、构造函数与原型方法上的this在封装对象的时候，我们几乎都会用到this，但是，只有少数人搞明白了在这个过程中的this指向，就算我们理解了原型，也不一定理解了this。所以这一部分，我认为将会为这篇文章最重要最核心的部分。理解了这里，将会对你学习JS面向对象产生巨大的帮助。 结合下面的例子，我在例子抛出几个问题大家思考一下。 1234567891011121314151617function Person(name, age) &#123; // 这里的this指向了谁? this.name = name; this.age = age; &#125;Person.prototype.getName = function() &#123; // 这里的this又指向了谁？ return this.name;&#125;// 上面的2个this，是同一个吗，他们是否指向了原型对象？var p1 = new Person('Nick', 20);p1.getName(); 我们已经知道，this，是在函数调用过程中确定，因此，搞明白new的过程中到底发生了什么就变得十分重要。 通过new操作符调用构造函数，会经历以下4个阶段。 创建一个新的对象； 将构造函数的this指向这个新对象； 指向构造函数的代码，为这个对象添加属性，方法等； 返回新对象。 因此，当new操作符调用构造函数时，this其实指向的是这个新创建的对象，最后又将新的对象返回出来，被实例对象p1接收。因此，我们可以说，这个时候，构造函数的this，指向了新的实例对象，p1。 而原型方法上的this就好理解多了，根据上边对函数中this的定义，p1.getName()中的getName为调用者，他被p1所拥有，因此getName中的this，也是指向了p1。 好啦，我所知道的，关于this的一切，已经总结完了，希望大家在阅读之后，能够真正学到东西，然后给我点个赞^_^。如果你发现有什么错误，请在评论中指出，我会尽快修改。先谢过了。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[摘抄setTimeout]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F17%2F%E6%91%98%E6%8A%84setTimeout%2F</url>
    <content type="text"><![CDATA[我在详细图解作用域链与闭包一文中的结尾留下了一个关于setTimeout与循环闭包的思考题。 利用闭包，修改下面的代码，让循环输出的结果依次为1， 2， 3， 4， 5 12345for (var i=1; i&lt;=5; i++) &#123; setTimeout( function timer() &#123; console.log(i); &#125;, i*1000 );&#125; 值得高兴的是很多朋友在读了文章之后确实对闭包有了更加深刻的了解，并准确的给出了几种写法。一些朋友能够认真的阅读我的文章并且一个例子一个例子的上手练习，这种认可对我而言真的非常感动。但是也有一些基础稍差的朋友在阅读了之后，对于这题的理解仍然感到困惑，因此应一些读者老爷的要求，借此文章专门对setTimeout进行一个相关的知识分享，愿大家读完之后都能够有新的收获。 在最初学习setTimeout的时候，我们很容易知道setTimeout有两个参数，第一个参数为一个函数，我们通过该函数定义将要执行的操作。第二个参数为一个时间毫秒数，表示延迟执行的时间。 123setTimeout(function() &#123; console.log(&apos;一秒钟之后我将被打印出来&apos;)&#125;, 1000) 可能不少人对于setTimeout的理解止步于此，但还是有不少人发现了一些其他的东西，并在评论里提出了疑问。比如上图中的这个数字7，是什么？ 每一个setTimeout在执行时，会返回一个唯一ID，上图中的数字7，就是这个唯一ID。我们在使用时，常常会使用一个变量将这个唯一ID保存起来，用以传入clearTimeout，清除定时器。 12345var timer = setTimeout(function() &#123; console.log(&apos;如果不清除我，我将会一秒之后出现。&apos;);&#125;, 1000)clearTimeout(timer); // 清除之后，通过setTimeout定义的操作并不会执行 接下来，我们还需要考虑另外一个重要的问题，那就是setTimeout中定义的操作，在什么时候执行？为了引起大家的重视，我们来看看下面的例子。 1234567var timer = setTimeout(function() &#123; console.log(&apos;setTimeout actions.&apos;);&#125;, 0);console.log(&apos;other actions.&apos;);// 思考一下，当我将setTimeout的延迟时间设置为0时，上面的执行顺序会是什么？ 在浏览器中的console中运行试试看，很容易就能够知道答案，如果你没有猜中答案，那么我这篇文章就值得你点一个赞了，因为接下来我分享的小知识，可能会在笔试中救你一命。 在对于执行上下文的介绍中，我与大家分享了函数调用栈这种特殊数据结构的调用特性。在这里，将会介绍另外一个特殊的队列结构，页面中所有由setTimeout定义的操作，都将放在同一个队列中依次执行。 我用下图跟大家展示一下队列数据结构的特点。 而这个队列执行的时间，需要等待到函数调用栈清空之后才开始执行。即所有可执行代码执行完毕之后，才会开始执行由setTimeout定义的操作。而这些操作进入队列的顺序，则由设定的延迟时间来决定。 因此在上面这个例子中，即使我们将延迟时间设置为0，它定义的操作仍然需要等待所有代码执行完毕之后才开始执行。这里的延迟时间，并非相对于setTimeout执行这一刻，而是相对于其他代码执行完毕这一刻。所以上面的例子执行结果就非常容易理解了。 为了帮助大家理解，再来一个结合变量提升的更加复杂的例子。如果你能够正确看出执行顺序，那么你对于函数的执行就有了比较正确的认识了，如果还不能，就回过头去看看其他几篇文章。 12345678910111213141516171819202122232425262728setTimeout(function() &#123; console.log(a);&#125;, 0);var a = 10;console.log(b);console.log(fn);var b = 20;function fn() &#123; setTimeout(function() &#123; console.log(&apos;setTImeout 10ms.&apos;); &#125;, 10);&#125;fn.toString = function() &#123; return 30;&#125;console.log(fn);setTimeout(function() &#123; console.log(&apos;setTimeout 20ms.&apos;);&#125;, 20);fn(); OK，关于setTimeout就暂时先介绍到这里，我们回过头来看看那个循环闭包的思考题。 12345for (var i=1; i&lt;=5; i++) &#123; setTimeout( function timer() &#123; console.log(i); &#125;, i*1000 );&#125; 如果我们直接这样写，根据setTimeout定义的操作在函数调用栈清空之后才会执行的特点，for循环里定义了5个setTimeout操作。而当这些操作开始执行时，for循环的i值，已经先一步变成了6。因此输出结果总为6。而我们想要让输出结果依次执行，我们就必须借助闭包的特性，每次循环时，将i值保存在一个闭包中，当setTimeout中定义的操作执行时，则访问对应闭包保存的i值即可。 而我们知道在函数中闭包判定的准则，即执行时是否在内部定义的函数中访问了上层作用域的变量。因此我们需要包裹一层自执行函数为闭包的形成提供条件。 因此，我们只需要2个操作就可以完成题目需求，一是使用自执行函数提供闭包条件，二是传入i值并保存在闭包中。 12345678for (var i=1; i&lt;=5; i++) &#123; (function(i) &#123; setTimeout( function timer() &#123; console.log(i); &#125;, i*1000 ); &#125;)(i)&#125; 当然，也可以在setTimeout的第一个参数处利用闭包。 1234567for (var i=1; i&lt;=5; i++) &#123; setTimeout( (function(i) &#123; return function() &#123; console.log(i); &#125; &#125;)(i), i*1000 );&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>setTimeout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[摘抄Promise]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F17%2F%E6%91%98%E6%8A%84Promise%2F</url>
    <content type="text"><![CDATA[Promise的重要性我认为我没有必要多讲，概括起来说就是必须得掌握，而且还要掌握透彻。这篇文章的开头，主要跟大家分析一下，为什么会有Promise出现。 在实际的使用当中，有非常多的应用场景我们不能立即知道应该如何继续往下执行。最重要也是最主要的一个场景就是ajax请求。通俗来说，由于网速的不同，可能你得到返回值的时间也是不同的，这个时候我们就需要等待，结果出来了之后才知道怎么样继续下去。 1234567891011121314// 简单的ajax原生实现var url = &apos;https://hq.tigerbrokers.com/fundamental/finance_calendar/getType/2017-02-26/2017-06-10&apos;;var result;var XHR = new XMLHttpRequest();XHR.open(&apos;GET&apos;, url, true);XHR.send();XHR.onreadystatechange = function() &#123; if (XHR.readyState == 4 &amp;&amp; XHR.status == 200) &#123; result = XHR.response; console.log(result); &#125;&#125; 在ajax的原生实现中，利用了onreadystatechange事件，当该事件触发并且符合一定条件时，才能拿到我们想要的数据，之后我们才能开始处理数据。 这样做看上去并没有什么麻烦，但是如果这个时候，我们还需要做另外一个ajax请求，这个新的ajax请求的其中一个参数，得从上一个ajax请求中获取，这个时候我们就不得不如下这样做： 12345678910111213141516171819202122var url = &apos;https://hq.tigerbrokers.com/fundamental/finance_calendar/getType/2017-02-26/2017-06-10&apos;;var result;var XHR = new XMLHttpRequest();XHR.open(&apos;GET&apos;, url, true);XHR.send();XHR.onreadystatechange = function() &#123; if (XHR.readyState == 4 &amp;&amp; XHR.status == 200) &#123; result = XHR.response; console.log(result); // 伪代码 var url2 = &apos;http:xxx.yyy.com/zzz?ddd=&apos; + result.someParams; var XHR2 = new XMLHttpRequest(); XHR2.open(&apos;GET&apos;, url, true); XHR2.send(); XHR2.onreadystatechange = function() &#123; ... &#125; &#125;&#125; 当出现第三个ajax(甚至更多)仍然依赖上一个请求的时候，我们的代码就变成了一场灾难。这场灾难，往往也被称为回调地狱。 因此我们需要一个叫做Promise的东西，来解决这个问题。 当然，除了回调地狱之外，还有一个非常重要的需求：为了我们的代码更加具有可读性和可维护性，我们需要将数据请求与数据处理明确的区分开来。上面的写法，是完全没有区分开，当数据变得复杂时，也许我们自己都无法轻松维护自己的代码了。这也是模块化过程中，必须要掌握的一个重要技能，请一定重视。 从前面几篇文中的知识我们可以知道，当我们想要确保某代码在谁谁之后执行时，我们可以利用函数调用栈，将我们想要执行的代码放入回调函数中。 12345678910111213// 一个简单的封装function want() &#123; console.log(&apos;这是你想要执行的代码&apos;);&#125;function fn(want) &#123; console.log(&apos;这里表示执行了一大堆各种代码&apos;); // 其他代码执行完毕，最后执行回调函数 want &amp;&amp; want();&#125;fn(want); 利用回调函数封装，是我们在初学JavaScript时常常会使用的技能。 确保我们想要的代码压后执行，除了利用函数调用栈的执行顺序之外，我们还可以利用上一篇文章所述的队列机制。 1234567891011function want() &#123; console.log(&apos;这是你想要执行的代码&apos;);&#125;function fn(want) &#123; // 将想要执行的代码放入队列中，根据事件循环的机制，我们就不用非得将它放到最后面了，由你自由选择 want &amp;&amp; setTimeout(want, 0); console.log(&apos;这里表示执行了一大堆各种代码&apos;);&#125;fn(want); 如果浏览器已经支持了原生的Promise对象，那么我们就知道，浏览器的js引擎里已经有了Promise队列，这样就可以利用Promise将任务放在它的队列中去。 123456789101112131415161718192021222324function want() &#123; console.log(&apos;这是你想要执行的代码&apos;);&#125;function fn(want) &#123; console.log(&apos;这里表示执行了一大堆各种代码&apos;); // 返回Promise对象 return new Promise(function(resolve, reject) &#123; if (typeof want == &apos;function&apos;) &#123; resolve(want); &#125; else &#123; reject(&apos;TypeError: &apos;+ want +&apos;不是一个函数&apos;) &#125; &#125;)&#125;fn(want).then(function(want) &#123; want();&#125;)fn(&apos;1234&apos;).catch(function(err) &#123; console.log(err);&#125;) 看上去变得更加复杂了。可是代码变得更加健壮，处理了错误输入的情况。 为了更好的往下扩展Promise的应用，这里需要先跟大家介绍一下Promsie的基础知识。 一、 Promise对象有三种状态，他们分别是： pending: 等待中，或者进行中，表示还没有得到结果 resolved(Fulfilled): 已经完成，表示得到了我们想要的结果，可以继续往下执行 rejected: 也表示得到结果，但是由于结果并非我们所愿，因此拒绝执行 这三种状态不受外界影响，而且状态只能从pending改变为resolved或者rejected，并且不可逆。在Promise对象的构造函数中，将一个函数作为第一个参数。而这个函数，就是用来处理Promise的状态变化。 1234new Promise(function(resolve, reject) &#123; if(true) &#123; resolve() &#125;; if(false) &#123; reject() &#125;;&#125;) 上面的resolve和reject都为一个函数，他们的作用分别是将状态修改为resolved和rejected。 二、 Promise对象中的then方法，可以接收构造函数中处理的状态变化，并分别对应执行。then方法有2个参数，第一个函数接收resolved状态的执行，第二个参数接收reject状态的执行。 12345678910111213141516function fn(num) &#123; return new Promise(function(resolve, reject) &#123; if (typeof num == &apos;number&apos;) &#123; resolve(); &#125; else &#123; reject(); &#125; &#125;).then(function() &#123; console.log(&apos;参数是一个number值&apos;); &#125;, function() &#123; console.log(&apos;参数不是一个number值&apos;); &#125;)&#125;fn(&apos;hahha&apos;);fn(1234); then方法的执行结果也会返回一个Promise对象。因此我们可以进行then的链式执行，这也是解决回调地狱的主要方式。 123456789101112131415161718function fn(num) &#123; return new Promise(function(resolve, reject) &#123; if (typeof num == &apos;number&apos;) &#123; resolve(); &#125; else &#123; reject(); &#125; &#125;) .then(function() &#123; console.log(&apos;参数是一个number值&apos;); &#125;) .then(null, function() &#123; console.log(&apos;参数不是一个number值&apos;); &#125;)&#125;fn(&apos;hahha&apos;);fn(1234); then(null, function() {}) 就等同于catch(function() {}) 三、Promise中的数据传递 大家自行从下面的例子中领悟吧。 123456789101112131415161718192021222324252627var fn = function(num) &#123; return new Promise(function(resolve, reject) &#123; if (typeof num == &apos;number&apos;) &#123; resolve(num); &#125; else &#123; reject(&apos;TypeError&apos;); &#125; &#125;)&#125;fn(2).then(function(num) &#123; console.log(&apos;first: &apos; + num); return num + 1;&#125;).then(function(num) &#123; console.log(&apos;second: &apos; + num); return num + 1;&#125;).then(function(num) &#123; console.log(&apos;third: &apos; + num); return num + 1;&#125;);// 输出结果first: 2second: 3third: 4 OK，了解了这些基础知识之后，我们再回过头，利用Promise的知识，对最开始的ajax的例子进行一个简单的封装。看看会是什么样子。 123456789101112131415161718192021222324252627var url = &apos;https://hq.tigerbrokers.com/fundamental/finance_calendar/getType/2017-02-26/2017-06-10&apos;;// 封装一个get请求的方法function getJSON(url) &#123; return new Promise(function(resolve, reject) &#123; var XHR = new XMLHttpRequest(); XHR.open(&apos;GET&apos;, url, true); XHR.send(); XHR.onreadystatechange = function() &#123; if (XHR.readyState == 4) &#123; if (XHR.status == 200) &#123; try &#123; var response = JSON.parse(XHR.responseText); resolve(response); &#125; catch (e) &#123; reject(e); &#125; &#125; else &#123; reject(new Error(XHR.statusText)); &#125; &#125; &#125; &#125;)&#125;getJSON(url).then(resp =&gt; console.log(resp)); 为了健壮性，处理了很多可能出现的异常，总之，就是正确的返回结果，就resolve一下，错误的返回结果，就reject一下。并且利用上面的参数传递的方式，将正确结果或者错误信息通过他们的参数传递出来。 现在所有的库几乎都将ajax请求利用Promise进行了封装，因此我们在使用jQuery等库中的ajax请求时，都可以利用Promise来让我们的代码更加优雅和简单。这也是Promise最常用的一个场景，因此我们一定要非常非常熟悉它，这样才能在应用的时候更加灵活。 四、Promise.all 当有一个ajax请求，它的参数需要另外2个甚至更多请求都有返回结果之后才能确定，那么这个时候，就需要用到Promise.all来帮助我们应对这个场景。 Promise.all接收一个Promise对象组成的数组作为参数，当这个数组所有的Promise对象状态都变成resolved或者rejected的时候，它才会去调用then方法。 1234567891011var url = &apos;https://hq.tigerbrokers.com/fundamental/finance_calendar/getType/2017-02-26/2017-06-10&apos;;var url1 = &apos;https://hq.tigerbrokers.com/fundamental/finance_calendar/getType/2017-03-26/2017-06-10&apos;;function renderAll() &#123; return Promise.all([getJSON(url), getJSON(url1)]);&#125;renderAll().then(function(value) &#123; // 建议大家在浏览器中看看这里的value值 console.log(value);&#125;) 五、 Promise.race 与Promise.all相似的是，Promise.race都是以一个Promise对象组成的数组作为参数，不同的是，只要当数组中的其中一个Promsie状态变成resolved或者rejected时，就可以调用.then方法了。而传递给then方法的值也会有所不同，大家可以再浏览器中运行下面的例子与上面的例子进行对比。 1234567function renderRace() &#123; return Promise.race([getJSON(url), getJSON(url1)]);&#125;renderRace().then(function(value) &#123; console.log(value);&#125;) 嗯，我所知道的，关于Promise的基础知识就这些了，如果还有别的，欢迎大家补充。 那么接下来，我们要结合三个不同的应用场景来让大家感受一下Promise在模块系统中如何使用。 这里选择requirejs是因为学习成本最低，能够快速上手进行简单的运用。接下来的这些例子，会涉及到很多其他的知识，因此如果想要彻底掌握，一定要动手实践，自己试着完成一遍。 我在github上创建了对应的项目，大家可以直接clone下来进行学习。这样学习效果会更好。 项目地址： https://github.com/yangbo5207/promiseApps 往下阅读例子之前，请一定要对requirejs有一个简单的了解。 requirejs中文文档 http://www.requirejs.cn/ 项目的代码结果如上图所示，所有的html文件都放在根目录下。 pages: html直接引入的js libs: 常用的库 components: 针对项目自定义的模块 首先为了能够让require起作用，我们需要在html中引入require.js，写法如下： 12// index.js为入口文件&lt;script data-main=&quot;./pages/index.js&quot; src=&quot;./libs/require.js&quot;&gt;&lt;/script&gt; 在入口的index.js中，我们可以对常用的模块进行映射配置，这样在引入时就可以少写一些代码。 123456789101112// 具体的配置项的含义，请参阅require的中文文档requirejs.config(&#123; baseUrl: &apos;./&apos;, paths: &#123; jquery: &quot;./libs/jquery-3.2.0&quot;, API: &apos;./libs/API&apos;, request: &apos;./libs/request&apos;, calendar: &apos;./components/calendar&apos;, imageCenter: &apos;./components/imageCenter&apos;, dialog: &apos;./components/Dialog&apos; &#125;&#125;) 配置之后，那么我们在其他模块中，引入配置过的模块，就可以简单的这样写： 1var $ = require(&apos;jquery&apos;); 如果不进行配置，也可以这样引入模块： 1require(&apos;./components/button&apos;); 我们可以使用define定义一个模块： 1234// 其他方式请参阅文档define(function(require) &#123;&#125;) 使用return可以直接对外提供方法： 123456// 在其他模块通过require引入时得到的值，就是这里返回的值define(function(require) &#123; return &#123; a: 1 &#125;&#125;) OK，了解上面这些，应付基础的使用已经没有问题了。我们接下来重点总结第一个常用的应用场景：ajax。 关于ajax的简单使用和简单封装，我们在上面都已经讲过了，这里就不再多说，直接使用jquery封装好的方法即可。而我们需要处理的问题在于，如何有效的将ajax的数据请求和数据处理分别放在不同的模块中进行管理，这样做的主要目的在于降低后期维护成本，便于管理。 来看看怎么样简单操作的。 首先，将所有的url放在一个模块中统一处理。 1234567// libs/API.jsdefine(function() &#123; return &#123; dayInfo: &apos;https://hq.tigerbrokers.com/fundamental/finance_calendar/get_day/2017-04-03&apos;, typeInfo: &apos;https://hq.tigerbrokers.com/fundamental/finance_calendar/getType/2017-03-26/2017-04-15&apos; &#125;&#125;) 在实际开发中，url并不是直接通过字符串就能直接确认的，某些url还需要通过参数拼接等，这个时候需要我们灵活处理。 第二步，将所有的数据请求这个动作放在同一个模块中统一管理。 12345678910111213141516171819202122// libs/request.jsdefine(function(require) &#123; var API = require(&apos;API&apos;); // 因为jQuery中的get方法也是通过Promise进行了封装，最终返回的是一个Promise对象，因此这样我们就可以将数据请求与数据处理放在不同的模块 // 这样我们就可以使用一个统一的模块来管理所有的数据请求 // 获取当天的信息 getDayInfo = function() &#123; return $.get(API.dayInfo); &#125; // 获取type信息 getTypeInfo = function() &#123; return $.get(API.typeInfo); &#125;; return &#123; getDayInfo: getDayInfo, getTypeInfo: getTypeInfo &#125;&#125;); 在这个模块中，我们还可以对拿到的数据进行一些你需要的过滤处理，确保最终返回给下一个模块的数据是能够直接使用的。 第三步：就是拿到数据并且处理数据了。 12345678910111213141516// components/calendar.jsdefine(function(require) &#123; var request = require(&apos;request&apos;); // 拿到数据之后，需要处理的组件，可以根据数据渲染出需求想要的样式 // 当然这里为了简化，就仅仅只是输出数据就行了，在实际中，拿到数据之后还要进行相应的处理 request.getTypeInfo() .then(function(resp) &#123; // 拿到数据，并执行处理操作 console.log(resp); &#125;) // 这样，我们就把请求数据，与处理数据分离开来，维护起来就更加方便了，代码结构也足够清晰&#125;) 这就是我所了解的处理ajax的比较好的一个方式，如果你有其他更好的方式也欢迎分享。 第二个应用场景就是图片加载的问题。在一些实际应用中，常常会有一些图片需要放置在某一个块中，比如头像，比如某些图片列表。可是源图片的尺寸可能很难保证长宽比例都是一致的，如果我们直接给图片设定宽高，就有可能导致图片变形。变形之后高大上的页面就直接垮掉了。 因此为了解决这个问题，我们需要一个定制的image组件来解决这个问题。我们期望图片能够根据自己的宽高比，合理的缩放，保证在这个块中不变形的情况下尽可能的显示更多的内容。 假如有一堆图片，如下： 1234567891011121314151617&lt;section class=&quot;img-wrap&quot;&gt; &lt;div class=&quot;img-center&quot;&gt; ![](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1491191204817&amp;di=48ea9cde3319576ed6e0b6dc6c6b75b4&amp;imgtype=0&amp;src=http%3A%2F%2Fa.hiphotos.baidu.com%2Fzhidao%2Fpic%2Fitem%2F342ac65c103853438b3c5f8b9613b07ecb8088ad.jpg) &lt;/div&gt; &lt;div class=&quot;img-center&quot;&gt; ![](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1491191241712&amp;di=9dbd9c614b82f0b02c92c6e60875983a&amp;imgtype=0&amp;src=http%3A%2F%2Fpic5.qiyipic.com%2Fcommon%2F20130524%2F7dc5679567cd4243a0a41e5bf626ad77.jpg%3Fsrc%3Dfocustat_4_20130527_7) &lt;/div&gt; &lt;div class=&quot;img-center&quot;&gt; ![](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1491191271233&amp;di=0c9dd2677413beadcccd66b9d4598c6b&amp;imgtype=0&amp;src=http%3A%2F%2Fb.zol-img.com.cn%2Fdesk%2Fbizhi%2Fimage%2F4%2F960x600%2F1390442684896.jpg) &lt;/div&gt; &lt;div class=&quot;img-center&quot;&gt; ![](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1491191294538&amp;di=6474f3b560f2c100e62f118dde7e8d6c&amp;imgtype=0&amp;src=http%3A%2F%2Ff.hiphotos.baidu.com%2Fzhidao%2Fpic%2Fitem%2Fc9fcc3cec3fdfc03dfdfafcad23f8794a4c22618.jpg) &lt;/div&gt;&lt;/section&gt; 每一张图片都有一个包裹的div，这些div的宽高，就是我们期望图片能保持的宽高。 当图片宽度值过大时，我们期望图片的高度为100%，并且左右居中。当图片高度值过大时，我们期望图片的宽度为100%，并且上下居中。 根据这一点，我们来看看具体怎么实现。 首先是样式的定义很重要。 123456789101112131415161718192021222324.img-center &#123; width: 200px; height: 150px; margin: 20px; overflow: hidden; position: relative;&#125;.img-center img &#123; display: block; position: absolute;&#125;.img-center img.aspectFill-x &#123; width: 100%; top: 50%; transform: translateY(-50%);&#125;.img-center img.aspectFill-y &#123; height: 100%; left: 50%; transform: translateX(-50%);&#125; 我分别定义了aspectFill-x与aspectFill-y，通过判断不同的宽高比，来决定将他们中的其中一个加入到img标签的class中去即可。 获取图片的原始宽高，需要等到图片加载完毕之后才能获取。而当图片已经存在缓存时，则有一个compete属性变成true。那么我们就可以根据这些基础知识，定义一个模块来处理这件事情。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// components/imageCenter.jsdefine(function(require) &#123; // 利用Promise封装一个加载函数，这里也是可以单独放在一个功能模块中进一步优化 var imageLoad = function(img) &#123; return new Promise(function(resolve, reject) &#123; if (img.complete) &#123; resolve(); &#125; else &#123; img.onload = function(event) &#123; resolve(event); &#125; img.onerror = function(err) &#123; reject(err); &#125; &#125; &#125;) &#125; var imageCenter = function(domList, mode) &#123; domList.forEach(function(item) &#123; var img = item.children[0]; var itemW = item.offsetWidth; var itemH = item.offsetHeight; var itemR = itemW / itemH; imageLoad(img).then(function() &#123; var imgW = img.naturalWidth; var imgH = img.naturalHeight; var imgR = imgW / imgH; var resultMode = null; switch (mode) &#123; // 这样写是因为期待未来可以扩展其他的展示方式 case &apos;aspectFill&apos;: resultMode = imgR &gt; 1 ? &apos;aspectFill-x&apos; : &apos;aspectFill-y&apos;; break; case &apos;wspectFill&apos;: resultMode = itemR &gt; imgR ? &apos;aspectFill-x&apos; : &apos;aspectFill-y&apos; break; default: &#125; $(img).addClass(resultMode); &#125;) &#125;) &#125; return imageCenter;&#125;) 那么在使用时，直接引入这个模块并调用imageCenter方法即可。 1234// index.jsvar imageCenter = require(&apos;imageCenter&apos;);var imageWrapList = document.querySelectorAll(&apos;.img-center&apos;);imageCenter(imageWrapList, &apos;wspectFill&apos;); 第三个应用场景，则是自定义弹窗的处理。 因此自己专门定义一个常用的弹窗就变得非常有必要，这对于我们开发效率的提高非常有帮助。当然，我这里只是简单的写了一个简陋的，仅供参考。 我们期望的是利用Promise，当我们点击确认时，状态变成resolved，点击取消时，状态变成rejected。这样也方便将弹窗生成与后续的操作处理区分开来。 先定义一个Dialog模块。使用的是最简单的方式定义，应该不会有什么理解上的困难。主要提供了show和hide2个方法，用于展示和隐藏。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// components/Dialog.jsdefine(function(require) &#123; // 利用闭包的特性，判断是否已经存在实例 var instance; function Dialog(config) &#123; this.title = config.title ? config.title : &apos;这是标题&apos;; this.content = config.content ? config.content : &apos;这是提示内容&apos;; this.html = &apos;&lt;div class=&quot;dialog-dropback&quot;&gt;&apos; + &apos;&lt;div class=&quot;container&quot;&gt;&apos; + &apos;&lt;div class=&quot;head&quot;&gt;&apos;+ this.title +&apos;&lt;/div&gt;&apos; + &apos;&lt;div class=&quot;content&quot;&gt;&apos;+ this.content +&apos;&lt;/div&gt;&apos; + &apos;&lt;div class=&quot;footer&quot;&gt;&apos; + &apos;&lt;button class=&quot;cancel&quot;&gt;取消&lt;/button&gt;&apos; + &apos;&lt;button class=&quot;confirm&quot;&gt;确认&lt;/button&gt;&apos; + &apos;&lt;/div&gt;&apos; + &apos;&lt;/div&gt;&apos; + &apos;&lt;/div&gt;&apos; &#125; Dialog.prototype = &#123; constructor: Dialog, show: function() &#123; var _this = this; if (instance) &#123; this.destory(); &#125; $(this.html).appendTo($(document.body)); instance = this; return new Promise(function(resolve, reject) &#123; $(&apos;.dialog-dropback .cancel&apos;).on(&apos;click&apos;, function(e) &#123; _this.hide(); reject(e); &#125;) $(&apos;.dialog-dropback .confirm&apos;).on(&apos;click&apos;, function(e) &#123; _this.hide(); resolve(e); &#125;) &#125;) &#125;, destory: function() &#123; instance = null; $(&apos;.dialog-dropback .cancel&apos;).off(&apos;click&apos;); $(&apos;.dialog-dropback .confirm&apos;).off(&apos;click&apos;); $(&apos;.dialog-dropback&apos;).remove(); &#125;, hide: function() &#123; this.destory(); &#125; &#125; return function(config) &#123; return new Dialog(config); &#125;&#125;) 那么在另外一个模块中需要使用它时： 1234567891011121314define(function(require) &#123; var Dialog = require(&apos;dialog&apos;); $(&apos;button.aspect&apos;).on(&apos;click&apos;, function() &#123; Dialog(&#123; title: &apos;友情提示&apos;, content: &apos;外面空气不太好，你确定你要出门逛逛吗？&apos; &#125;).show().then(function() &#123; console.log(&apos;你点击了确认按钮.&apos;); &#125;).catch(function() &#123; console.log(&apos;你点击了取消按钮.&apos;); &#125;) &#125;)&#125;) 这三种场景就介绍完了，主要是需要大家通过源码来慢慢理解和揣摩。真正掌握之后，相信大家对于Promise在另外的场景中的使用也会变得得心应手。 最后总结一下，这篇文章，涉及到的东西，有点多。大概包括Promise基础知识，ajax基础知识，如何利用Promise封装ajax，如何使用require模块系统，如何在模块中使用Promise，并且对应的三个应用场景又各自有许多需要了解的知识，因此对于基础稍差的朋友来说，理解透彻了肯定会有一个比较大的进步。当然也会花费你更多的时间。 另外在我们的工作中还有一件非常重要的事情是需要我们持续去做的。那就是将常用的场景封装成为可以共用的模块，等到下次使用时，就可以直接拿来使用而节省非常多的开发时间。比如我这里对于img的处理，对于弹窗的处理，都是可以扩展成为一个通用的模块的。慢慢积累多了，你的开发效率就可以得到明显的提高，这些积累，也将会变成你的优势所在。 后续的文章我会分享如何利用react与es6模块系统封装的共用组件，大家也可以学习了之后，根据自己的需求，封装最适合你自己的一套组件。 最后，最近问我怎么学习的人越来越多，我真的有点回答不过来了，我想把我这些文章里的知识都掌握了，应付毕业之后的第一份工作应该不是什么问题的吧？而且为了你们能够掌握Promise的使用，我还专门给读者老爷们创建了一个项目，列举了整整三个实例，还有源代码供你们学习，我学Promise的时候，找好久都没找到一个稍微接近实际应用的案例，学了好久才知道怎么使用，效率之低可想而知。所以静下心来慢慢学习吧，花点时间是值得的 ~ ~ 。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[摘抄ES6常用知识合集]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F17%2F%E6%91%98%E6%8A%84ES6%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E5%90%88%E9%9B%86%2F</url>
    <content type="text"><![CDATA[在实际开发中，ES6已经非常普及了。掌握ES6的知识变成了一种必须。尽管我们在使用时仍然需要经过babel编译。 ES6彻底改变了前端的编码风格，可以说对于前端的影响非常巨大。值得高兴的是，如果你熟悉ES5，学习ES6并不需要花费太多的时间就可以掌握，因为常用的基础语法并不多，花少量的时间，就可以开始我们的ES6之旅了。 这篇文章不会详细的告诉你ES6的每一个细节知识，只会根据我自己的开发经验，将我在实际开发中常常用到的知识点分享给大家，给大家学习ES6一个方向的指引。这是因为考虑到很多同学虽然知道ES6的重要性，但是不知道自己需要掌握那些ES6的知识，也不知道这些知识需要掌握到什么程度，这给新手朋友带来了许多困惑，因此这篇文章就算是一个划重点吧，掌握这些，就可以轻轻松松得进行进一步学习了。 在学习之前，推荐大家使用babel官方提供的在线编译工具，编写自己的demo，会在右侧实时显示出编译之后的代码，以供参考学习 http://babeljs.io/repl/ 一、新的变量声明方式 let/const与var不同，新的变量声明方式带来了一些不一样的特性，其中最重要的两个特性就是提供了块级作用域与不再具备变量提升。 通过2个简单的例子来说明这两点。 12345&#123; let a = 20;&#125;console.log(a); // a is not defined 而这个简单的例子，会被编译为： 12345&#123; let _a = 20;&#125;console.log(a); // a is not defined 1234567// ES5console.log(a); // undefinedvar a = 20;// ES6console.log(a); // a is not definedlet a = 20; 当然，你的代码编译成为了ES5之后，仍然会存在变量提升，这一点只需要我们记住即可。在实际使用中，也需要尽量避免使用变量提升的特性带来的负面影响。只有在面试题中，才会对变量提升不停的滥用。 使用ES6，我们需要全面使用let/const替换var，那么什么时候用let，什么时候用const就成为了一个大家要熟练区分的一个知识点。 我们常常使用let来声明一个值会被改变的变量，而使用const来声明一个值不会被改变的变量，也可以称之为常量。 当值为基础数据类型时，那么这里的值，就是指值本身。而当值对应的为引用数据类型时，那么我这里说的值，则表示指向该对象的引用。这里需要注意，正因为该值为一个引用，只需要保证引用不变就可以，我们仍然可以改变该引用所指向的对象。 当我们试图改变const声明的变量时，则会报错。 写几个例子，大家可以仔细揣摩一下： 12let a = null;a = 20; 12345678const obDev = &#123; a: 20, b: 30&#125;obDev.a = 30;console.log(obDev); // Object &#123;a: 30, b: 30&#125; 123const fn = function() &#123;&#125;const a = obDev.a;... ... 只要抓住上面我说的特性，那么在使用let/const时就会显得游刃有余。根据我自己的经验，使用const的场景要比使用let的场景多很多。 二、 箭头函数的使用之前我说ES6颠覆了js的编码习惯，箭头函数的使用占了很大一部分。 首先是写法上的不同: 123456789101112131415161718192021// es5var fn = function(a, b) &#123; return a + b;&#125;// es6 箭头函数写法，当函数直接被return时，可以省略函数体的括号const fn = (a, b) =&gt; a + b;// es5var foo = function() &#123; var a = 20； var b = 30; return a + b;&#125;// es6const foo = () =&gt; &#123; const a = 20; const b = 30; return a + b;&#125; 箭头函数可以替换函数表达式，但是不能替换函数声明 其次还有一个至关重要的一点，那就是箭头函数中，没有this。如果你在箭头函数中使用了this，那么该this一定就是外层的this。 也正是因为箭头函数中没有this，因此我们也就无从谈起用call/apply/bind来改变this指向。记住这个特性，能让你在react组件之间传值时少走无数弯路。 1234567891011121314151617181920var person = &#123; name: 'tom', getName: function() &#123; return this.name; &#125;&#125;// 我们试图用ES6的写法来重构上面的对象const person = &#123; name: 'tom', getName: () =&gt; this.name&#125;// 但是编译结果却是var person = &#123; name: 'tom', getName: function getName() &#123; return undefined.name; &#125;&#125;; 在ES6中，会默认采用严格模式，因此this也不会自动指向window对象了，而箭头函数本身并没有this，因此this就只能是undefined，这一点，在使用的时候，一定要慎重慎重再慎重，不然踩了坑你都不知道自己错在哪！这种情况，如果你还想用this，就不要用使用箭头函数的写法。 12345678910111213141516171819// 可以稍做改动const person = &#123; name: 'tom', getName: function() &#123; return setTimeout(() =&gt; this.name, 1000); &#125;&#125;// 编译之后变成var person = &#123; name: 'tom', getName: function getName() &#123; var _this = this; // 使用了我们在es5时常用的方式保存this引用 return setTimeout(function () &#123; return _this.name; &#125;, 1000); &#125;&#125;; 先记住箭头函数的写法，并留意箭头函数中关于this的特殊性，更过实践与注意事项我们在封装react组件时再慢慢来感受。 除此之外，箭头函数中无法访问arguments对象。 三、模板字符串模板字符串是为了解决使用+号拼接字符串的不便利而出现的。它的功能非常强大，但是我们大多数时候使用它则非常简单。看一个例子大家就明白怎么使用了。 123456789// es6const a = 20;const b = 30;const string = `$&#123;a&#125;+$&#123;b&#125;=$&#123;a+b&#125;`;// es5var a = 20;var b = 30;var string = a + "+" + b + "=" + (a + b); 使用 将整个字符串包裹起来，而在其中使用 ${} 来包裹一个变量或者一个表达式。 当然模板字符串还支持换行等强大的功能，更多的大家可通过参考资料进一步学习。 四、 解析结构解析结构是一种全新的写法，我们只需要使用一个例子，大家就能够明白解析结构到底是怎么一回事儿。 1234567// 首先有这么一个对象const props = &#123; className: 'tiger-button', loading: false, clicked: true, disabled: 'disabled'&#125; 当我们想要取得其中的2个值：loading与clicked时： 123456789// es5var loading = props.loading;var clicked = props.clicked;// es6const &#123; loading, clicked &#125; = props;// 给一个默认值，当props对象中找不到loading时，loading就等于该默认值const &#123; loading = false, clicked &#125; = props; 是不是简单了许多？正是由于解析结构大大减少了代码量，因此它大受欢迎，在很多代码中它的影子随处可见。 123456789101112// 比如// section1import React, &#123; Component &#125; from 'react';// section2export &#123; default &#125; from './Button';// section3const &#123; click, loading &#125; = this.props;const &#123; isCheck &#125; = this.state;// more 任何获取对象属性值的场景都可以使用解析结构来减少我们的代码量 另外，数组也有属于自己的解析结构。 123456789// es6const arr = [1, 2, 3];const [a, b, c] = arr;// es5var arr = [1, 2, 3];var a = arr[0];var b = arr[1];var c = arr[2]; 数组以序列号一一对应，这是一个有序的对应关系。而对象根据属性名一一对应，这是一个无序的对应关系。根据这个特性，使用解析结构从对象中获取属性值更加具有可用性。 五、 函数默认参数之前我们不能直接为函数指定默认参数，因此很多时候为了保证传入的参数具备一个默认值，我们常常使用如下的方法： 1234567function add(x, y) &#123; var x = x || 20; var y = y || 30; return x + y;&#125;console.log(add()); // 50 这种方式并不是没有缺点，比如当我传入一个x值为false，这个时候任然会取到默认值，就不是我们的本意了。 来看看ES6的默认值写法： 12345function add(x = 20, y = 30) &#123; return x + y;&#125;console.log(add()); 在实际开发中给参数添加适当的默认值，可以让我们对函数的参数类型有一个直观的认知。 123456789const ButtonGroupProps = &#123; size: 'normal', className: 'xxxx-button-group', borderColor: '#333'&#125;export default function ButtonGroup(props = ButtonGroupProps) &#123; ... ...&#125; 六、 展开运算符在ES6中用...来表示展开运算符，它可以将数组方法或者对象进行展开。先来看一个例子它是如何使用的。 1234const arr1 = [1, 2, 3];const arr2 = [...arr1, 10, 20, 30];// 这样，arr2 就变成了[1, 2, 3, 10, 20, 30]; 当然，展开对象数据也是可以得到类似的结果 1234567891011121314const obj1 = &#123; a: 1, b: 2, c: 3&#125;const obj2 = &#123; ...obj1, d: 4, e: 5, f: 6&#125;// 结果类似于 const obj2 = Object.assign(&#123;&#125;, obj1, &#123;d: 4&#125;) 展开运算符还常常运用在解析结构之中，例如我们在Raect封装组件的时候常常不确定props到底还有多少数据会传进来，就会利用展开运算符来处理剩余的数据。 1234567891011121314// 这种方式在react中十分常用const props = &#123; size: 1, src: 'xxxx', mode: 'si'&#125;const &#123; size, ...others &#125; = props;console.log(others)// 然后再利用暂开运算符传递给下一个元素，再以后封装react组件时会大量使用到这种方式，正在学习react的同学一定要搞懂这种使用方式&lt;button &#123;...others&#125; size=&#123;size&#125; /&gt; 展开运算符还用在函数的参数中，来表示函数的不定参。只有放在最后才能作为函数的不定参，否则会报错。 123456// 所有参数之和const add = (a, b, ...more) =&gt; &#123; return more.reduce((m, n) =&gt; m + n) + a + b&#125;console.log(add(1, 23, 1, 2, 3, 4, 5)) // 39 展开运算符的运用可以大大提高我们的代码效率，但是在刚开始使用的时候比较绕脑，掌握好了用起来还是非常爽的，记住这些使用场景，平时在用的时候可以刻意多运用就行了。 七、对象字面量 与 classES6针对对象字面量做了许多简化语法的处理。 当属性与值的变量同名时。 1234567891011121314const name = 'Jane';const age = 20// es6const person = &#123; name, age&#125;// es5var person = &#123; name: name, age: age&#125;; 那么这种方式在任何地方都可以使用，比如在一个模块对外提供接口时 12345678const getName = () =&gt; person.name;const getAge = () =&gt; person.age;// commonJS的方式module.exports = &#123; getName, getAge &#125;// ES6 modules的方式export default &#123; getName, getAge &#125; 除了属性之外，对象字面量写法中的方法也可以有简写方式。 1234567891011121314151617// es6const person = &#123; name, age, getName() &#123; // 只要不使用箭头函数，this就还是我们熟悉的this return this.name &#125;&#125;// es5var person = &#123; name: name, age: age, getName: function getName() &#123; return this.name; &#125;&#125;; 在对象字面量中可以使用中括号作为属性，表示属性名也能是一个变量了。 1234567const name = 'Jane';const age = 20const person = &#123; [name]: true, [age]: true&#125; 在ant-design的源码实现中，就大量使用了这种方式来拼接当前元素的className，例如: 1234567let alertCls = classNames(prefixCls, &#123; [`$&#123;prefixCls&#125;-$&#123;type&#125;`]: true, [`$&#123;prefixCls&#125;-close`]: !this.state.closing, [`$&#123;prefixCls&#125;-with-description`]: !!description, [`$&#123;prefixCls&#125;-no-icon`]: !showIcon, [`$&#123;prefixCls&#125;-banner`]: !!banner, &#125;, className); ant-design是一个认可度非常高的UI组件库，官方使用react的方式进行了实现，除此之外，还有vue也有对应的实现，有兴趣的同学可以去他们的官网了解学习。https://ant.design/index-cn class ES6为我们创建对象提供了新的语法糖，这就是Class语法。如果你对ES5中面向对象的方式比较熟悉的话，Class掌握起来也是非常迅速的，因为除了写法的不同，它并不会增加新的难以理解的知识点。我们先利用一个简单的例子来看看写法的不同。 1234567891011121314151617181920212223// ES5// 构造函数function Person(name, age) &#123; this.name = name; this.age = age;&#125;// 原型方法Person.prototype.getName = function() &#123; return this.name&#125;// ES6class Person &#123; constructor(name, age) &#123; // 构造函数 this.name = name; this.age = age; &#125; getName() &#123; // 原型方法 return this.name &#125;&#125; babel会将ES6的写法编译成为利用Object.defineProperty实现的方式，这个方法的具体用处大家可以在《JavaScript高级编程3》中学习了解，包括get，set，等都有详细的说明 除此之外，我们还需要特别注意在实际使用中的几种写法方式的不同，在下面的例子注释中，我说明了他们分别对应的ES5中的含义。 123456789101112131415161718class Person &#123; constructor(name, age) &#123; // 构造函数 this.name = name; this.age = age; &#125; getName() &#123; // 这种写法表示将方法添加到原型中 return this.name &#125; static a = 20; // 等同于 Person.a = 20 c = 20; // 表示在构造函数中添加属性 在构造函数中等同于 this.c = 20// 箭头函数的写法表示在构造函数中添加方法，在构造函数中等同于this.getAge = function() &#123;&#125; getAge = () =&gt; this.age &#125; 箭头函数需要注意的仍然是this的指向问题，因为箭头函数this指向不能被改变的特性，因此在react组件中常常利用这个特性来在不同的组件进行传值会更加方便。 继承 extends 相比ES5，ES6的继承就要简单很多，我们直接来看一个例子。 1234567891011121314151617181920212223class Person &#123; constructor(name, age) &#123; this.name = name; this.age = age; &#125; getName() &#123; return this.name &#125;&#125;// Student类继承Person类class Student extends Person &#123; constructor(name, age, gender, classes) &#123; super(name, age); this.gender = gender; this.classes = classes; &#125; getGender() &#123; return this.gender; &#125;&#125; 我们只需要一个extends关键字，就可以实现继承了，不用像ES5那样去担心构造函数继承和原型继承，除此之外，我们还需要关注一个叫做super的方法。 在继承的构造函数中，我们必须如上面的例子那么调用一次super方法，它表示构造函数的继承，与ES5中利用call/apply继承构造函数是一样的功能。 123456// 构造函数中// es6super(name, age);// es5Person.call(this); super还可以直接调用父级的原型方法，super.getName，但是我自己从来没这样用过，也就不扩展说了。 继承在react中有大量的使用场景，许多组件都利用继承来创建。 12345678910111213import React, &#123; Component &#125; from 'react';class App extends Component &#123; defaultProps = &#123;&#125; state = &#123;&#125; componentWillMount() &#123;&#125; componentDidMount() &#123;&#125; btnClick = e =&gt; &#123;&#125; render() &#123;&#125;&#125; 只要根据我们上面所学到的知识，明确的知道哪些属性方法是放在构造函数中，哪些属性方法是放到了原型中，那么我们自己在编写react组件的时候就要简单和清晰很多。 其实只要我们ES5面向对象的知识足够扎实，ES6和react掌握起来也没有太多的难度，所有的学习难点，并不在ES6这些不同的语法糖上，而在于ES5中的原理，因此我在前面分享ES5的核心知识的时候，很多读者老爷都迫不及待的希望我能够更多的说一说ES6的知识。其实我们都没有必要那么着急，只要前面10多篇文章的知识足够扎实，这篇文章所涉及到的常用的ES6知识，最多花30分钟也就掌握了。这些写法上的不同并不会造成大家理解上的困难，只需要有一个熟悉过程就行了。所以大家的重点，还是要回归到基础上来。 八、Promisehttp://www.jianshu.com/p/fe5f173276bd 九、 模块 Modules因为学习模块需要一个学习场景，因此我决定在下一篇文章中结合create-react-app一起分享给大家。 深入学习ES6推荐 http://es6.ruanyifeng.com/]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[摘抄async和await]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F17%2F%E6%91%98%E6%8A%84async%E5%92%8Cawait%2F</url>
    <content type="text"><![CDATA[在实际开发中总会遇到许多异步的问题，最常见的场景便是接口请求之后一定要等一段时间才能得到结果，如果遇到多个接口前后依赖，那么问题就变得复杂。大家都一直在尝试使用更好的方案来解决这些问题。最开始只能利用回调函数，后来开始有人使用Promise的思维来搞定。到ES6中开始支持原生的Promise，引入Generator函数。 直到ES7，有了async/await。 这是一个用同步的思维来解决异步问题的方案。 我想很多人可能还不太分得清同步与异步的区别。如果你已经彻底了解了事件循环，那么想必对异步的概念应该非常了解。当我们发出了请求，并不会等待响应结果，而是会继续执行后面的代码，响应结果的处理在之后的事件循环中解决。那么同步的意思，就是等结果出来之后，代码才会继续往下执行。 我们可以用一个两人问答的场景来比喻异步与同步。A向B问了一个问题之后，不等待B的回答，接着问下一个问题，这是异步。A向B问了一个问题之后，然后就笑呵呵的等着B回答，B回答了之后他才会接着问下一个问题，这是同步。 那么我们先记住这个特点，async/await使用同步的思维，来解决异步的问题。 在继续分析它的语法与使用之前，我们先介绍一下如何在我们的开发环境中支持该语法。 如果你已经知道如何配置，可跳过 一、如何在自己的开发环境中支持async/await语法这里主要介绍两种方式。 1. webpack中支持该语法首先在当前项目中使用npm下载babel-loader。 1&gt; npm install babel-loader --save-dev 然后在配置文件webpack.confing.dev.js中配置，在module.exports.module.rules中添加如下配置元素即可。 12345678&#123; test: /\.(js|jsx)$/, include: paths.appSrc, loader: require.resolve('babel-loader'), options: &#123; cacheDirectory: true, &#125;,&#125;, 如果你使用最新版本的create-react-app或者vue-cli来构建你的代码，那么它们应该已经支持了该配置。 2. gulp中支持该语法首先安装gulp插件 1&gt; npm install gulp-babel --save-dev 然后编写任务 12345678var gulp = require('gulp');var babel = require('gulp-babel');gulp.task('babel', function() &#123; return gulp.src('src/app.js') .pipe(babel()) .pipe(gulp.dest('dist'));&#125;); 二、如何使用async函数是Generator的一个语法糖。如果你不知道Generator是什么函数也没有关系，我们只需要知道async函数实际上返回的是一个Promise对象即可。 12345678async function fn() &#123; return 30;&#125;// 或者const fn = async () =&gt; &#123; return 30;&#125; 在声明函数时，前面加上关键字async，这就是async的用法。当我们用console.log打印出上面声明的函数fn，我们可以看到如下结果： 12345678console.log(fn());// resultPromise = &#123; __proto__: Promise, [[PromiseStatus]]: "resolved", [[PromiseValue]]: 30&#125; 很显然，fn的运行结果其实就是一个Promise对象。因此我们也可以使用then来处理后续逻辑。 123fn().then(res =&gt; &#123; console.log(res); // 30&#125;) await的含义为等待。意思就是代码需要等待await后面的函数运行完并且有了返回结果之后，才继续执行下面的代码。这正是同步的效果。 但是我们需要注意的是，await关键字只能在async函数中使用。并且await后面的函数运行后必须返回一个Promise对象才能实现同步的效果。 当我们使用一个变量去接收await的返回值时，该返回值为Promise中resolve出来的值（也就是PromiseValue）。 123456789101112131415161718192021// 定义一个返回Promise对象的函数function fn() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(30); &#125;, 1000); &#125;)&#125;// 然后利用async/await来完成代码const foo = async () =&gt; &#123; const t = await fn(); console.log(t); console.log('next code');&#125;foo();// result:// 30// next code 运行这个例子我们可以看出，当在async函数中，运行遇到await时，就会等待await后面的函数运行完毕，而不会直接执行next code。 如果我们直接使用then方法的话，想要达到同样的结果，就不得不把后续的逻辑写在then方法中。 12345678const foo = () =&gt; &#123; return fn().then(t =&gt; &#123; console.log(t); console.log('next code'); &#125;)&#125;foo(); 很显然如果使用async/await的话，代码结构会更加简洁，逻辑也更加清晰。 异常处理在Promise中，我们知道是通过catch的方式来捕获异常。而当我们使用async时，则通过try/catch来捕获异常。 1234567891011121314151617function fn() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject('some error.'); &#125;, 1000); &#125;)&#125;const foo = async () =&gt; &#123; try &#123; await fn(); &#125; catch (e) &#123; console.log(e); // some error &#125;&#125;foo(); 如果有多个await函数，那么只会返回第一个捕获到的异常。 12345678910111213141516171819202122232425function fn1() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject('some error fn1.'); &#125;, 1000); &#125;)&#125;function fn2() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject('some error fn2.'); &#125;, 1000); &#125;)&#125;const foo = async () =&gt; &#123; try &#123; await fn1(); await fn2(); &#125; catch (e) &#123; console.log(e); // some error fn1. &#125;&#125;foo(); 实践在实践中我们遇到异步场景最多的就是接口请求，那么这里就以jquery中的$.get为例简单展示一下如何配合async/await来解决这个场景。 1234567891011121314// 先定义接口请求的方法，由于jquery封装的几个请求方法都是返回Promise实例，因此可以直接使用await函数实现同步const getUserInfo = () =&gt; $.get('xxxx/api/xx');const clickHandler = async () =&gt; &#123; try &#123; const resp = await getUserInfo(); // resp为接口返回内容，接下来利用它来处理对应的逻辑 console.log(resp); // do something &#125; catch (e) &#123; // 处理错误逻辑 &#125;&#125; 为了保证逻辑的完整性，在实践中try/catch必不可少。总之，不处理错误逻辑的程序员不是好程序员。 与Promise相比，个人认为async/await有一定的简洁性，但也并非就比Promise有绝对的优势，因此只能算是提供了另外一种同样很棒的方式，至于大家学习之后选择哪种方式来解决自己的问题，我认为这仅仅只是个人的喜好问题。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>async</tag>
        <tag>await</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Axios是什么]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F17%2FAxios%E6%98%AF%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[1. Axios是什么 Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。(一看是基于promise是不是就对它的API有了大概的了解？哈哈哈) 2. Axios的特点 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 （就是有interceptor） 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF ps: 可能大家对interceptor（拦截器）并不是很熟悉，在这里作下介绍，拦截器可以在请求发送前和发送请求后做一些处理。有一张图可以清晰的了解它在一次HTTP请求中做了什么，如下图 image.png 3.兼容性 image.png 4.安装 使用 npm: $ npm install axios 使用 bower: $ bower install axios 使用 cdn: &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; 5.基本用法 12345678910111213141516171819//执行get请求// Make a request for a user with a given IDaxios.get('/user?ID=12345') .then(function (response) &#123; console.log(response); &#125;).catch(function (error) &#123; console.log(error); &#125;);// Optionally the request above could also be done asaxios.get('/user', &#123; params: &#123; ID: 12345 &#125; &#125;).then(function (response) &#123; console.log(response); &#125;).catch(function (error) &#123; console.log(error); &#125;); 是不是都在then,catch里处理response，感觉fetch差不多，写起来很方便 6.使用流程 本来想在这贴Axios API,这跟大家读api文档无异，所以在这里贴一下我们是如何使用的吧，或许对你更有帮助 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159//首先我们来创建一个Axios实例var axiosIns = axios.create(&#123; baseURL: 'https://some-domain.com/api/', timeout: 1000, headers: &#123;'X-product': 'h5'&#125;&#125;);//设置request拦截器axiosIns.interceptors.request.use((request) =&gt; &#123;//在这里处理request，可以对所有请求统一处理请求头等&#125;)//设置response拦截器axiosIns.interceptors.response.use((response) =&gt; &#123; //在这里处理response，这是全局的，对所有使用axios的请求起作用 &#125;);//可以将上边的创建实例和设置的拦截器封装成函数，之后直接调用就Ok//实例方法//以下是可用的实例方法。指定的配置将与实例的配置合并axios#request(config)axios#get(url[, config])axios#delete(url[, config])axios#head(url[, config])axios#post(url[, data[, config]])axios#put(url[, data[, config]])axios#patch(url[, data[, config]])//请求配置&#123; // `url` 是用于请求的服务器 URL url: '/user', // `method` 是创建请求时使用的方法 method: 'get', // 默认是 get // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL baseURL: 'https://some-domain.com/api/', // `transformRequest` 允许在向服务器发送前，修改请求数据 // 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法 // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream transformRequest: [function (data) &#123; // 对 data 进行任意转换处理 return data; &#125;], // `transformResponse` 在传递给 then/catch 前，允许修改响应数据 transformResponse: [function (data) &#123; // 对 data 进行任意转换处理 return data; &#125;], // `headers` 是即将被发送的自定义请求头 headers: &#123;'X-Requested-With': 'XMLHttpRequest'&#125;, // `params` 是即将与请求一起发送的 URL 参数 // 必须是一个无格式对象(plain object)或 URLSearchParams 对象 params: &#123; ID: 12345 &#125;, // `paramsSerializer` 是一个负责 `params` 序列化的函数 // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function(params) &#123; return Qs.stringify(params, &#123;arrayFormat: 'brackets'&#125;) &#125;, // `data` 是作为请求主体被发送的数据 // 只适用于这些请求方法 'PUT', 'POST', 和 'PATCH' // 在没有设置 `transformRequest` 时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属：FormData, File, Blob // - Node 专属： Stream data: &#123; firstName: 'Fred' &#125;, // `timeout` 指定请求超时的毫秒数(0 表示无超时时间) // 如果请求话费了超过 `timeout` 的时间，请求将被中断 timeout: 1000, // `withCredentials` 表示跨域请求时是否需要使用凭证 withCredentials: false, // 默认的 // `adapter` 允许自定义处理请求，以使测试更轻松 // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)). adapter: function (config) &#123; /* ... */ &#125;, // `auth` 表示应该使用 HTTP 基础验证，并提供凭据 // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头 auth: &#123; username: 'janedoe', password: 's00pers3cret' &#125;, // `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream' responseType: 'json', // 默认的 // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称 xsrfCookieName: 'XSRF-TOKEN', // default // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称 xsrfHeaderName: 'X-XSRF-TOKEN', // 默认的 // `onUploadProgress` 允许为上传处理进度事件 onUploadProgress: function (progressEvent) &#123; // 对原生进度事件的处理 &#125;, // `onDownloadProgress` 允许为下载处理进度事件 onDownloadProgress: function (progressEvent) &#123; // 对原生进度事件的处理 &#125;, // `maxContentLength` 定义允许的响应内容的最大尺寸 maxContentLength: 2000, // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte validateStatus: function (status) &#123; return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认的 &#125;, // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目 // 如果设置为0，将不会 follow 任何重定向 maxRedirects: 5, // 默认的 // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项： // `keepAlive` 默认没有启用 httpAgent: new http.Agent(&#123; keepAlive: true &#125;), httpsAgent: new https.Agent(&#123; keepAlive: true &#125;), // 'proxy' 定义代理服务器的主机名称和端口 // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据 // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。 proxy: &#123; host: '127.0.0.1', port: 9000, auth: : &#123; username: 'mikeymike', password: 'rapunz3l' &#125; &#125;, // `cancelToken` 指定用于取消请求的 cancel token // （查看后面的 Cancellation 这节了解更多） cancelToken: new CancelToken(function (cancel) &#123; &#125;)&#125;]]></content>
      <categories>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
        <tag>Axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue过度]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F17%2Fvue%E8%BF%87%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[vue过度 过度的概念 在那些场景下适合使用 怎么用 涉及的知识点 组件的封装 Slot—组件 组件的通讯 父子通讯:props down,event,up 兄弟通讯:全局事件管理bus vuex: slot PC端:fullPage满屏滚动插件移动端:swiper完整代码静态数据:mounted异步数据:this.$nextTick()12345678910111213141516171819202122232425/*index.html*/&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1.0" /&gt; &lt;title&gt;CodeSandbox Vue&lt;/title&gt; &lt;/head&gt; &lt;style&gt; body &#123; margin: 0; padding: 0; overflow: hidden; &#125; #app &#123; height: 100%; width: 100%; &#125; &lt;/style&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;fullpage v-bind:bg-color="bgColor" v-bind:page="8"&gt;&lt;/fullpage&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213/*main.js*/import Vue from "vue";import Fullpage from "@/components/Fullpage.vue";new Vue(&#123; el: "#app", data: &#123; bgColor: ["red", "blue", "yellow", "green"] &#125;, components: &#123; Fullpage &#125;&#125;); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145/*components/Fullpage.vue*/&lt;template&gt; &lt;div v-on:wheel=&quot;wheelEvent($event);&quot;&gt; &lt;transition-group tag=&quot;div&quot; v-bind:name=&quot;name&quot; class=&quot;content&quot;&gt; &lt;div class=&quot;block&quot; v-for=&quot;(list, index) in page&quot; v-bind:key=&quot;list&quot; v-bind:style=&quot;&#123; &apos;background-color&apos;: bgColor[index] &amp;&amp; bgColor ? bgColor[index] : baseBgc[Math.floor(Math.random() * 4)] &#125;&quot; v-show=&quot;index === curIndex&quot; v-on:transitionend=&quot;end&quot; &gt; &#123;&#123; list &#125;&#125; &lt;/div&gt; &lt;/transition-group&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;.content &#123; height: 100%; width: 100%;&#125;.block &#123; height: 100%; width: 100%; position: absolute;&#125;/*进入过程到结束状态*/.down-enter-active &#123; transition: all 0.85s ease; transform: translateY(0);&#125;/*开始初始化状态*/.down-enter &#123; transform: translateY(100%);&#125;/*离开初始化状态*/.down-leave &#123; transform: translateY(0);&#125;/*脱离过程到结束状态*/.down-leave-active &#123; transform: translateY(-100%); transition: all 1s ease;&#125;/*进入过程到结束状态*/.up-enter-active &#123; transform: translateY(0); transition: all 1s ease;&#125; /*脱离过程到结束状态*/.up-leave-active &#123; transform: translateY(100%); transition: all 1s ease;&#125; /*开始初始化状态*/.up-enter &#123; transform: translateY(-100%);&#125; /*离开初始化状态*/.up-leave &#123; transform: translateY(0);&#125;&lt;/style&gt;&lt;script&gt;export default &#123; props: &#123; bgColor: &#123; type: Array &#125;, page: &#123; type: Number, required: true &#125; &#125;, data() &#123; return &#123; curIndex: 0, name: &quot;&quot;, canWheel: true, endCount: 0, baseBgc: [], addColors: null &#125;; &#125;, methods: &#123; wheelEvent(e) &#123; if (this.canWheel === true) &#123; if (e.deltaY &gt; 0) &#123; if (this.curIndex === this.page - 1) &#123; this.canWheel = true; return; &#125; this.name = &quot;down&quot;; this.curIndex++; &#125; if (e.deltaY &lt; 0) &#123; if (this.curIndex === 0) &#123; this.canWheel = true; return; &#125; this.name = &quot;up&quot;; this.curIndex--; &#125; this.canWheel = false; &#125; else &#123; return; &#125; &#125;, end() &#123; this.endCount++; if (this.endCount === 2) &#123; this.canWheel = true; this.endCount = 0; &#125; &#125;, randomColor() &#123; this.addColors = this.page - this.bgColor.length; function getRandColor() &#123; var str = &quot;0123456789abcdef&quot;; var arr = []; for (var i = 0; i &lt; 6; i++) &#123; var random = Math.floor(Math.random() * 16); arr.push(str[random]); &#125; return &quot;#&quot; + arr.join(&quot;&quot;); &#125; if (this.addColors &gt; 0) &#123; for (let i = 0; i &lt; this.addColors; i++) &#123; this.baseBgc.push(getRandColor()); &#125; &#125; &#125; &#125;, mounted() &#123; this.randomColor(); &#125;&#125;;&lt;/script&gt; transition-group必须在vue实例内,内联中tag值是希望最终渲染html标签,name值是标记这个组件的名称 transition-group是通过v-show或者v-if进行过度动画实现的. 基于vue过渡实现全屏滚动效果 参数 参数 说明 类型 是否必要 默认值 pages 需要几屏 Number 必要 bgColor 每一屏对应的背景色，如果当前屏不设置背景色可传空字符串 Array 不必要 baseBgc 默认背景色 String 不必要 #fff slot123&lt;template slot=&quot;slot2&quot; scope=&quot;props&quot;&gt; &lt;page1 :state=&quot;props.state&quot; :page=&quot;props.page&quot; :index=&quot;props.index&quot;&gt;&lt;/page1&gt;&lt;/template&gt; 必须按如下格式传递对应组件：对应屏的slot属性必须为slot+对应下标(从1开始)，要向slot分发的组件传递三个参数：state、index、page 参数 说明 值 state 对应过渡或动画的状态 enter、leave、transitionend index 当前slot对应的下标 page 焦点屏对应的下标 123watch: &#123; //监听page或state,并做相应的业务逻辑处理 &#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>fullPage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-cli中引入jQuery]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F17%2FVue-cli%E4%B8%AD%E5%BC%95%E5%85%A5jQuery%2F</url>
    <content type="text"><![CDATA[vue-cli中引入jquery的方法 以前写vue项目都没有引入过jquery，今天群里面的一位小伙伴问了我这个问题，我就自己捣鼓了一下，方法如下： 我们先进入webpack.base.conf.js文件，开始顶部是这样的，我们需要加一行代码 变成这样 12345var path = require(&apos;path&apos;)var utils = require(&apos;./utils&apos;)var webpack = require(&quot;webpack&quot;) //这是我们添加的var config = require(&apos;../config&apos;)var vueLoaderConfig = require(&apos;./vue-loader.conf&apos;) 然后到下面的module.exports内部加入 1234567plugins: [ new webpack.optimize.CommonsChunkPlugin(&apos;common.js&apos;), new webpack.ProvidePlugin(&#123; jQuery: &quot;jquery&quot;, $: &quot;jquery&quot; &#125;) ], 我们在上面引入webpack就是为了在此使用webpack对象； 然后在package.json里的dependencies加入”jquery” : “^1.8.0”；或者你可以使用npm install xxx -save去生成 然后我们就可以在main.js里面去导入jquery了 最后，重启项目 最最后，骚年，去浪吧]]></content>
      <categories>
        <category>jQuery</category>
        <category>Vue</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>Vue</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli npm run build]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F17%2Fvue-cli-npm-run-build%2F</url>
    <content type="text"><![CDATA[vue-cli npm run build如果是提交到github展示那么就必须修改config&gt;index.js&gt;build:{assetsPublicPath:&#39;./&#39;}源代码是assetsPublicPath:&#39;/&#39; 还需要修改src&gt;main.js将import 中CSS样式放到一起移动到上边(第三方ui库放到最后自己修改的样式放在前边) ,让import App 在最下边. 修改.gitignore中将/dist/删除就可以提交代码到github上了,接着url地址后边加/dist 如果是公司项目那么上边的修改都不用啦,直接npm run build 后将dist里所有文件提交到服务器就可以了.]]></content>
      <categories>
        <category>Vue</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue计算属性的秘密]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F17%2Fvue%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84%E7%A7%98%E5%AF%86%2F</url>
    <content type="text"><![CDATA[Vue.js 计算属性的秘密​ 计算属性是一个很邪门的东西，只要在它的函数里引用了 data 中的某个属性，当这个属性发生变化时，函数仿佛可以嗅探到这个变化，并自动重新执行。 ) ​ 上述代码会源源不断的打印出 b 的值。如果希望 a 依赖 data 中的 x 而变化，只需保证 a 函数中有 this.x 即可。如果函数中没有出现 data 中的属性，那么无论 data 中的属性怎么变，a 对应的函数一次也不会执行。 ​ Vue 怎么知道计算属性在函数中引用了哪个 data 属性？这个函数又是怎么知道 data 属性变了，而且只关心它内部引用的那个属性，别的都不管？ ​ 官方文档对计算属性的描述是： ​ 文档的描述让我的困惑更加困惑，还有这种操作？这特么是怎么做到的？ ​ Google 了一把，看了一篇三哥的博文（见文末），豁然开朗。 ​ 我们简单模拟实现一个计算属性：a 变化时，b 自动跟着变化。 ​ 由于涉及 Vue 的响应式绑定的原理，如果你对此不熟，最好先看看《Vue.js 双向绑定的实现原理》[ ](http://www.cnblogs.com/kidney/p/6052935.html) ​ 少啰嗦，先看过程： 首先 b 属性会被处理为存取器属性，访问 b 就会触发其 get 函数 处理计算属性 a 时，会执行 a 的函数，从而会执行 this.b，于是触发 b 的 get 函数 b 的 get 函数会添加 b 属性的依赖项，而刚才在处理计算属性过程中，a 已经作为依赖项被传给了一个全局变量，b 的 get 函数会检测到这个全局变量，并将其添加到自身的订阅者列表中 对 b 赋予新的值时，会触发其 set 函数，set 函数中会遍历执行订阅者，a 的值就是在这个时候更新的 ​ 再看代码： （注：图中数字仅作思路引导，并非与前文过程描述对应） ​ 测试一下，完美打印出 1, 2, 3, 4 ​ console.log(obj.b) ​ obj.a += 1; ​ console.log(obj.b); ​ obj.a += 1; ​ console.log(obj.b); ​ obj.a += 1; ​ console.log(obj.b); ​ ​ 通过对存取器属性、闭包和观察者模式的综合运用，Vue 巧妙的实现了计算属性。现在再看官方文档描述，是不是更通透了呢。 ​ 可以看出，Vue 响应式系统的核心理念是“依赖”，DOM 节点之所以随数据而变化，是因为节点依赖于数据，计算属性之所以随数据而变化，是因为计算属性依赖于数据。做好响应式的关键就在于处理好依赖关系。 参考文章：https://skyronic.com/blog/vuejs-internals-computed-properties ​ : https://www.cnblogs.com/kidney/p/7384835.html]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>computed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[瀑布流]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F17%2F%E7%80%91%E5%B8%83%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Waterfall Flow实现瀑布流的三种方法，我目前知晓的有 1、绝对定位布局：关键是取得图片的高度，然后依次绝对定位每张图片(top、left)，这种方法是目前用的比较多，因为要一直算定位，所以性能不高； 2、固定列数的浮动布局：加载页面时取页面宽度，算出可以有的列数，然后依次给每列插入图片，像发扑克牌一样，这种方法不用知道高度，比上一种方法简易； 3、利用CSS3列(column)布局：这个最省事，不过兼容是个问题； 绝对定位布局 1.先计算当前屏幕最多能容纳几列瀑布，其值为 “取整(屏幕可见区域宽度/(格子外宽度) 2.为了保证容器的居中，将容器的宽度设置为 列数* (格子外宽度)，这里需要注意的是 当容器的宽度计算出来之后再显示，否则会造成页面宽度的抖动，影响体验。 3.排序开始，然后每次寻找高度最小的一列，把格子放进去（left值为列序号*格子外宽度，top值为 列序号的高度），并刷新列的高度，遍历所有格子直到所有的格子都被排序。再将事件句柄绑定到window.onload和window.onresize 注意点 1.当缩放浏览器窗口时会不断地触发事件，如果每次都响应的话会狂耗性能，需要在缩放动作结束后再执行重排方法。 用setTimeout和clearTimeout解决 2.页面滚动到底部请求数据成功之后只对新增的节点重排。 在于如果每次有新的数据加载，都要对整个容器内的节点进行重排，非常消耗性能。解决思路：1.将列保存在全局数组中，每次重排或者新增格子之后更新数组的数据，这样下次执行排序算法的时候可以直接调用。2.将新增格子保存在数组中作为参数传递给排序算法，仅对新格子进行遍历和操作。 3.如果服务器无法给出图片高度，需要在图片加载完毕之后再进行重排。 只能遍历所有图片，每张图片加载成功后执行一个回调函数，将加载成功的图片数量+1，当加载成功的图片数量等于图片总数的时候执行排序方法。缺点是有一张图片加载不成功就无法看到所有的，真正项目中还是需要在异步加载数据的时候获取图片尺寸。 项目代码]]></content>
      <categories>
        <category>JavaScript</category>
        <category>布局</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深拷贝-递归]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F17%2F%E6%B7%B1%E6%8B%B7%E8%B4%9D-%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[本文主要讲一下 js 的基本数据类型以及一些堆和栈的知识和什么是深拷贝、什么是浅拷贝、深拷贝与浅拷贝的区别，以及怎么进行深拷贝和怎么进行浅拷贝。 本文思维导图如下： 本文思维导图 本文首发于我的个人博客：cherryblog.site/ 堆和栈的区别其实深拷贝和浅拷贝的主要区别就是其在内存中的存储类型不同。 堆和栈都是内存中划分出来用来存储的区域。 栈（stack）为自动分配的内存空间，它由系统自动释放；而堆（heap）则是动态分配的内存，大小不定也不会自动释放。 ECMAScript 的数据类型在将深拷贝和浅拷贝之前，我们先来重新回顾一下 ECMAScript 中的数据类型。主要分为 基本数据类型（undefined，boolean，number，string，null）基本数据类型主要是：undefined，boolean，number，string，null。 基本数据类型存放在栈中存放在栈内存中的简单数据段，数据大小确定，内存空间大小可以分配，是直接按值存放的，所以可以直接访问。 基本数据类型值不可变 javascript中的原始值（undefined、null、布尔值、数字和字符串）与对象（包括数组和函数）有着根本区别。原始值是不可更改的：任何方法都无法更改（或“突变”）一个原始值。对数字和布尔值来说显然如此 —— 改变数字的值本身就说不通，而对字符串来说就不那么明显了，因为字符串看起来像由字符组成的数组，我们期望可以通过指定索引来假改字符串中的字符。实际上，javascript 是禁止这样做的。字符串中所有的方法看上去返回了一个修改后的字符串，实际上返回的是一个新的字符串值。 基本数据类型的值是不可变的，动态修改了基本数据类型的值，它的原始值也是不会改变的，例如： 12345var str = &quot;abc&quot;;console.log(str[1]=&quot;f&quot;); // fconsole.log(str); // abc 这一点其实开始我是比较迷惑的，总是感觉 js 是一个灵活的语言，任何值应该都是可变的，真是图样图森破，我们通常情况下都是对一个变量重新赋值，而不是改变基本数据类型的值。就如上述引用所说的那样，在 js 中没有方法是可以改变布尔值和数字的。倒是有很多操作字符串的方法，但是这些方法都是返回一个新的字符串，并没有改变其原有的数据。 所以，记住这一点：基本数据类型值不可变。 基本类型的比较是值的比较基本类型的比较是值的比较，只要它们的值相等就认为他们是相等的，例如： 123var a = 1;var b = 1;console.log(a === b);//true 比较的时候最好使用严格等，因为 == 是会进行类型转换的，比如： 123var a = 1;var b = true;console.log(a == b);//true 引用类型引用类型存放在堆中引用类型（object）是存放在堆内存中的，变量实际上是一个存放在栈内存的指针，这个指针指向堆内存中的地址。每个空间大小不一样，要根据情况开进行特定的分配，例如。 123var person1 = &#123;name:&apos;jozo&apos;&#125;;var person2 = &#123;name:&apos;xiaom&apos;&#125;;var person3 = &#123;name:&apos;xiaoq&apos;&#125;; 堆内存 引用类型值可变引用类型是可以直接改变其值的，例如： 123var a = [1,2,3];a[1] = 5;console.log(a[1]); // 5 引用类型的比较是引用的比较所以每次我们对 js 中的引用类型进行操作的时候，都是操作其对象的引用（保存在栈内存中的指针），所以比较两个引用类型，是看其的引用是否指向同一个对象。例如： 123var a = [1,2,3];var b = [1,2,3];console.log(a === b); // false 虽然变量 a 和变量 b 都是表示一个内容为 1，2，3 的数组，但是其在内存中的位置不一样，也就是说变量 a 和变量 b 指向的不是同一个对象，所以他们是不相等的。 引用类型在内存中的存储 传值与传址了解了基本数据类型与引用类型的区别之后，我们就应该能明白传值与传址的区别了。在我们进行赋值操作的时候，基本数据类型的赋值（=）是在内存中新开辟一段栈内存，然后再把再将值赋值到新的栈中。例如： 123456var a = 10;var b = a;a ++ ;console.log(a); // 11console.log(b); // 10 基本数据类型的赋值 所以说，基本类型的赋值的两个变量是两个独立相互不影响的变量。 但是引用类型的赋值是传址。只是改变指针的指向，例如，也就是说引用类型的赋值是对象保存在栈中的地址的赋值，这样的话两个变量就指向同一个对象，因此两者之间操作互相有影响。例如： 123456789101112var a = &#123;&#125;; // a保存了一个空对象的实例var b = a; // a和b都指向了这个空对象a.name = &apos;jozo&apos;;console.log(a.name); // &apos;jozo&apos;console.log(b.name); // &apos;jozo&apos;b.age = 22;console.log(b.age);// 22console.log(a.age);// 22console.log(a == b);// true 引用类型的赋值 浅拷贝在深入了解之前，我认为上面的赋值就是浅拷贝，哇哈哈，真的是图样图森破。上面那个应该只能算是“引用”，并不算是真正的浅拷贝。一下部分参照知乎中的提问： javascript中的深拷贝和浅拷贝 赋值（=）和浅拷贝的区别那么赋值和浅拷贝有什么区别呢，我们看下面这个例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var obj1 = &#123; &apos;name&apos; : &apos;zhangsan&apos;, &apos;age&apos; : &apos;18&apos;, &apos;language&apos; : [1,[2,3],[4,5]],&#125;;var obj2 = obj1;var obj3 = shallowCopy(obj1);function shallowCopy(src) &#123; var dst = &#123;&#125;; for (var prop in src) &#123; if (src.hasOwnProperty(prop)) &#123; dst[prop] = src[prop]; &#125; &#125; return dst;&#125;obj2.name = &quot;lisi&quot;;obj3.age = &quot;20&quot;;obj2.language[1] = [&quot;二&quot;,&quot;三&quot;];obj3.language[2] = [&quot;四&quot;,&quot;五&quot;];console.log(obj1); //obj1 = &#123;// &apos;name&apos; : &apos;lisi&apos;,// &apos;age&apos; : &apos;18&apos;,// &apos;language&apos; : [1,[&quot;二&quot;,&quot;三&quot;],[&quot;四&quot;,&quot;五&quot;]],//&#125;;console.log(obj2);//obj2 = &#123;// &apos;name&apos; : &apos;lisi&apos;,// &apos;age&apos; : &apos;18&apos;,// &apos;language&apos; : [1,[&quot;二&quot;,&quot;三&quot;],[&quot;四&quot;,&quot;五&quot;]],//&#125;;console.log(obj3);//obj3 = &#123;// &apos;name&apos; : &apos;zhangsan&apos;,// &apos;age&apos; : &apos;20&apos;,// &apos;language&apos; : [1,[&quot;二&quot;,&quot;三&quot;],[&quot;四&quot;,&quot;五&quot;]],//&#125;; 先定义个一个原始的对象 obj1，然后使用赋值得到第二个对象 obj2，然后通过浅拷贝，将 obj1 里面的属性都赋值到 obj3 中。也就是说： obj1：原始数据 obj2：赋值操作得到 obj3：浅拷贝得到 然后我们改变 obj2 的 name 属性和 obj3 的 name 属性，可以看到，改变赋值得到的对象 obj2 同时也会改变原始值 obj1，而改变浅拷贝得到的的 obj3 则不会改变原始对象 obj1。这就可以说明赋值得到的对象 obj2 只是将指针改变，其引用的仍然是同一个对象，而浅拷贝得到的的 obj3 则是重新创建了新对象。 然而，我们接下来来看一下改变引用类型会是什么情况呢，我又改变了赋值得到的对象 obj2 和浅拷贝得到的 obj3 中的 language 属性的第二个值和第三个值（language 是一个数组，也就是引用类型）。结果见输出，可以看出来，无论是修改赋值得到的对象 obj2 和浅拷贝得到的 obj3 都会改变原始数据。 这是因为浅拷贝只复制一层对象的属性，并不包括对象里面的为引用类型的数据。所以就会出现改变浅拷贝得到的 obj3 中的引用类型时，会使原始数据得到改变。 深拷贝：将 B 对象拷贝到 A 对象中，包括 B 里面的子对象， 浅拷贝：将 B 对象拷贝到 A 对象中，但不包括 B 里面的子对象 – 和原数据是否指向同一对象 第一层数据为基本数据类型 原数据中包含子对象 赋值 是 改变会使原数据一同改变 改变会使原数据一同改变 浅拷贝 否 改变不会使原数据一同改变 改变会使原数据一同改变 深拷贝 否 改变不会使原数据一同改变 改变不会使原数据一同改变 深拷贝看了这么半天，你也应该清楚什么是深拷贝了吧，如果还不清楚，我就剖腹自尽(ಥ_ಥ) 深拷贝是对对象以及对象的所有子对象进行拷贝。 那么问题来了，怎么进行深拷贝呢？ 思路就是递归调用刚刚的浅拷贝，把所有属于对象的属性类型都遍历赋给另一个对象即可。我们直接来看一下 Zepto 中深拷贝的代码： 12345678910111213141516171819202122232425262728293031323334353637// 内部方法：用户合并一个或多个对象到第一个对象// 参数：// target 目标对象 对象都合并到target里// source 合并对象// deep 是否执行深度合并function extend(target, source, deep) &#123; for (key in source) if (deep &amp;&amp; (isPlainObject(source[key]) || isArray(source[key]))) &#123; // source[key] 是对象，而 target[key] 不是对象， 则 target[key] = &#123;&#125; 初始化一下，否则递归会出错的 if (isPlainObject(source[key]) &amp;&amp; !isPlainObject(target[key])) target[key] = &#123;&#125; // source[key] 是数组，而 target[key] 不是数组，则 target[key] = [] 初始化一下，否则递归会出错的 if (isArray(source[key]) &amp;&amp; !isArray(target[key])) target[key] = [] // 执行递归 extend(target[key], source[key], deep) &#125; // 不满足以上条件，说明 source[key] 是一般的值类型，直接赋值给 target 就是了 else if (source[key] !== undefined) target[key] = source[key]&#125;// Copy all but undefined properties from one or more// objects to the `target` object.$.extend = function(target)&#123; var deep, args = slice.call(arguments, 1); //第一个参数为boolean值时，表示是否深度合并 if (typeof target == &apos;boolean&apos;) &#123; deep = target; //target取第二个参数 target = args.shift() &#125; // 遍历后面的参数，都合并到target上 args.forEach(function(arg)&#123; extend(target, arg, deep) &#125;) return target&#125; 在 Zepto 中的 $.extend 方法判断的第一个参数传入的是一个布尔值，判断是否进行深拷贝。 在 $.extend 方法内部，只有一个形参 target，这个设计你真的很巧妙。因为形参只有一个，所以 target 就是传入的第一个参数的值，并在函数内部设置一个变量 args 来接收去除第一个参数的其余参数，如果该值是一个布尔类型的值的话，说明要启用深拷贝，就将 deep 设置为 true，并将 target 赋值为 args 的第一个值（也就是真正的 target）。如果该值不是一个布尔类型的话，那么传入的第一个值仍为 target 不需要进行处理，只需要遍历使用 extend 方法就可以。 这里有点绕，但是真的设计的很精妙，建议自己打断点试一下，会有意外收获（玩转 js 的大神请忽略）。 而在 extend 的内部，是拷贝的过程。 递归 123456789101112131415161718192021222324252627282930var obj=&#123; name: &quot;nanyang&quot;, age: 21, friend:&#123; name:&quot;kobe&quot;, age: 38 &#125;&#125;function deepClone(obj) &#123; var newObj = &#123;&#125;; for (var key in obj)&#123; if (obj.hasOwnProperty(key))&#123; if(typeof obj[key] === &quot;string&quot; ||typeof obj[key] === &quot;number&quot; ||typeof obj[key] === &quot;boolean&quot; ||obj[key] === undefined ||obj[key] === null) &#123; newObj[key] = obj[key]; &#125;else &#123; newObj[key] = deepClone(obj[key]) &#125; &#125; &#125; return newObj;&#125;var obj2 = deepClone(obj);console.log(obj2);obj.friend.name = &quot;james&quot;;console.log(obj);console.log(obj2); json 123456789101112131415161718var obj=&#123; name: &quot;nanyang&quot;, age: 21, friend:&#123; name:&quot;kobe&quot;, age: 38 &#125;&#125;function deepClone(obj) &#123; var newObj = JSON.parse(JSON.stringify(obj));//stringify将obj对象转化成字符串，parse将字符串重新生成对象 return newObj;&#125;var obj2 = deepClone(obj);obj.name = &quot;yangnan&quot;;obj.friend.name= &quot;james&quot;;console.log(obj2);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>深拷贝</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解call,apply,bind]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F17%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3call-apply-bind%2F</url>
    <content type="text"><![CDATA[深入理解 call、apply 和 bind在JavaScript 中，call、apply 和 bind 是 Function 对象自带的三个方法，这三个方法的主要作用是改变函数中的 this 指向，从而可以达到接花移木的效果。本文将对这三个方法进行详细的讲解，并列出几个经典应用场景。 1、call(thisArgs [,args…])该方法可以传递一个thisArgs参数和一个参数列表，thisArgs 指定了函数在运行期的调用者，也就是函数中的 this 对象，而参数列表会被传入调用函数中。thisArgs 的取值有以下4种情况： 不传，或者传null,undefined， 函数中的 this 指向 window 对象 传递另一个函数的函数名，函数中的 this 指向这个函数的引用 传递字符串、数值或布尔类型等基础类型，函数中的 this 指向其对应的包装对象，如 String、Number、Boolean 传递一个对象，函数中的 this 指向这个对象 123456789101112131415function a()&#123; console.log(this); //输出函数a中的this对象&#125;function b()&#123;&#125; //定义函数b var obj = &#123;name:'onepixel'&#125;; //定义对象obj a.call(); //windowa.call(null); //windowa.call(undefined);//windowa.call(1); //Numbera.call(''); //Stringa.call(true); //Booleana.call(b);// function b()&#123;&#125;a.call(obj); //Object 这是call 的核心功能，它允许你在一个对象上调用该对象没有定义的方法，并且这个方法可以访问该对象中的属性，至于这样做有什么好处，我待会再讲，我们先看一个简单的例子： 1234567891011121314151617181920var a = &#123; name:'onepixel', //定义a的属性 say:function()&#123; //定义a的方法 console.log("Hi,I'm function a!"); &#125;&#125;; function b(name)&#123; console.log("Post params: "+ name); console.log("I'm "+ this.name); this.say();&#125; b.call(a,'test');&gt;&gt;Post params: testI'm onepixelI'm function a! 当执行b.call 时，字符串test作为参数传递给了函数b,由于call的作用，函数b中的this指向了对象a, 因此相当于调用了对象a上的函数b,而实际上a中没有定义b 。 2、apply(thisArgs[,args[]])apply 和 call 的唯一区别是第二个参数的传递方式不同，apply 的第二个参数必须是一个数组，而 call 允许传递一个参数列表。值得你注意的是，虽然 apply 接收的是一个参数数组，但在传递给调用函数时，却是以参数列表的形式传递，我们看个简单的例子： 12345function b(x,y,z)&#123; console.log(x,y,z);&#125; b.apply(null,[1,2,3]); // 1 2 3 apply 的这个特性很重要，我们会在下面的应用场景中提到这个特性。 3、bind(thisArgs [,args…])bind是ES5 新增的一个方法，它的传参和call类似，但又和 call/apply 有着显著的不同，即调用 call 或 apply 都会自动执行对应的函数，而 bind 不会执行对应的函数，只是返回了对函数的引用。粗略一看，bind 似乎比call/apply 要落后一些，那ES5为什么还要引入bind 呢？ 其实，ES5引入 bind 的真正目的是为了弥补 call/apply 的不足，由于 call/apply 会对目标函数自动执行，从而导致它无法在事件绑定函数中使用，因为事件绑定函数不需要我们手动执行，它是在事件被触发时由JS 内部自动执行的。而 bind 在实现改变函数 this 的同时又不会自动执行目标函数，因此可以完美的解决上述问题，看一个例子就能明白： 12345678910111213141516var obj = &#123;name:'onepixel'&#125;; /** * 给document添加click事件监听，并绑定onClick函数 * 通过bind方法设置onClick的this为obj，并传递参数p1,p2 */document.addEventListener('click',onClick.bind(obj,'p1','p2'),false); //当点击网页时触发并执行function onClick(a,b)&#123; console.log( this.name, //onepixel a, //p1 b //p2 )&#125; 当点击网页时，onClick 被触发执行，输出onepixel p1 p2, 说明 onClick 中的 this 被 bind 改变成了obj 对象，为了对 bind 进行深入的理解，我们来看一下 bind 的 polyfill 实现 (this篇也有此内容，简化版polyfill) ： 12345678910111213141516171819202122if (!Function.prototype.bind) &#123; Function.prototype.bind = function (oThis) &#123; var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, //this在这里指向的是目标函数 fBound = function () &#123; return fToBind.apply( //如果外部执行var obj = new fBound(),则将obj作为最终的this，放弃使用oThis this instanceof fToBind ? this //此时的this就是new出的obj : oThis || this, //如果传递的oThis无效，就将fBound的调用者作为this //将通过bind传递的参数和调用时传递的参数进行合并，并作为最终的参数传递 aArgs.concat(Array.prototype.slice.call(arguments))); &#125;; //将目标函数的原型对象拷贝到新函数中，因为目标函数有可能被当作构造函数使用 fBound.prototype = this.prototype; //返回fBond的引用，由外部按需调用 return fBound; &#125;;&#125; 一旦函数通过bind传递了有效的this对象，则该函数在运行期的this将指向这个对象，即使通过call或apply来试图改变this的指向也是徒劳的。 123456789101112131415161718192021222324//实现数组的去重功能Array.prototype.unique = function(fn) &#123; var rst = []; var tmp = &#123;&#125;; this.forEach(function(val) &#123; //使用call来改变fn的this指向，这里传window var key = 'uniq' + (typeof fn === 'function' ? fn.call(window, val) : val); if (!tmp.hasOwnProperty(key)) &#123; rst.push(val); tmp[key] = null; &#125; &#125;, this); return rst;&#125; //对象数组去重var arr = [ &#123; id: 2 &#125;, &#123; id: 4 &#125;, &#123; id: 3 &#125;, &#123; id: 3 &#125;, &#123; id: 4 &#125;, &#123; id: 6 &#125;]arr.unique(function(v) &#123; console.log(this) //使用bind传递了Array,则this一定是Array,而不会是window return v.id&#125;.bind(Array)); 4、应用场景一：继承大家知道，JavaScript中没有诸如Java、C# 等高级语言中的extend 关键字，因此JS 中没有继承的概念，如果一定要继承的话，call 和 apply 可以实现这个功能： 12345678910111213141516function Animal(name,weight)&#123; this.name = name; this.weight = weight;&#125; function Cat()&#123; Animal.call(this,'cat','50'); //Animal.apply(this,['cat','50']); this.say = function()&#123; console.log("I am " + this.name+",my weight is " + this.weight); &#125;&#125; var cat = new Cat();cat.say();//I am cat,my weight is 50 当通过new 运算符产生了cat 时，Cat中的 this 就指向了cat对象(关于new运算符的讲解，请参考JS构造函数和new运算符，而继承的关键是在于Cat中执行了Animal.call(this,’cat’,’50’) 这句话，在call中将this作为thisArgs参数传递，于是Animal 方法中的 this 就指向了Cat中的 this，而 cat 中的 this 指向的是 cat 对象，所以Animal 中的 this 指向的就是 cat 对象，在 Animal 中定义了name 和 weight 属性，就相当于在 cat 中定义了这些属性，因此 cat 对象便拥有了Animal 中定义的属性，从而达到了继承的目的。 5、应用场景二：移花接木在讲下面的内容之前，我们首先来认识一下JavaScript 中的一个非标准专业术语：ArrayLike (类数组/伪数组) ArrayLike 对象即拥有数组的一部分行为，在DOM 中早已表现出来，而jQuery 的崛起让ArrayLike 在JavaScript 中大放异彩。ArrayLike 对象的精妙在于它和JS 原生的 Array 类似，但是它是自由构建的，它来自开发者对JavaScript 对象的扩展，也就是说：对于它的原型(prototype)我们可以自由定义，而不会污染到JS原生的Array。 ArrayLike 对象在JS中被广泛使用，比如DOM 中的NodeList, 函数中的arguments 都是类数组对象，这些对象像数组一样存储着每一个元素，但它没有操作数组的方法，而我们可以通过call 将数组的某些方法移接到ArrayLike 对象，从而达到操作其元素的目的。比如我们可以这样遍历函数中的arguments: 12345678910111213141516function test()&#123; //检测arguments是否为Array的实例 console.log( arguments instanceof Array, //false Array.isArray(arguments) //false ); //判断arguments是否有forEach方法 console.log(arguments.forEach); //undefined // 将数组中的forEach应用到arguments上 Array.prototype.forEach.call(arguments,function(item)&#123; console.log(item); // 1 2 3 4 &#125;); &#125;test(1,2,3,4); 除此之外，对于apply 而言，我们上面提到了它独有的一个特性，即apply 接收的是数组，在传递给调用函数的时候是以参数列表传递的。 这个特性让apply 看起来比call 略胜一筹，比如有这样一个场景：给定一个数组[1,3,4,7]，然后求数组中的最大元素，而我们知道，数组中并没有获取最大值的方法，一般情况下，你需要通过编写代码来实现。而我们知道，Math 对象中有一个获取最大值的方法，即Math.max()， max方法需要传递一个参数列表，然后返回这些参数中的最大值。而apply 不仅可以将Math 对象的max 方法应用到其他对象上，还可以将一个数组转化为参数列表传递给max,看代码就能一目了然： 123var arr = [2,3,1,5,4]; Math.max.apply(null,arr); // 5 以上便是call 和apply 比较经典的几个应用场景，]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>call</tag>
        <tag>apply</tag>
        <tag>bind</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web前端知识体系精简]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F17%2Fweb%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E7%AE%80%2F</url>
    <content type="text"><![CDATA[Web前端知识体系精简Web前端技术由 html、css 和 javascript 三大部分构成，是一个庞大而复杂的技术体系，其复杂程度不低于任何一门后端语言。而我们在学习它的时候往往是先从某一个点切入，然后不断地接触和学习新的知识点，因此对于初学者很难理清楚整个体系的脉络结构。本文将对Web前端知识体系进行简单的梳理，对应的每个知识点点到为止，不作详细介绍。目的是帮助大家审查自己的知识结构是否完善，如有遗漏或不正确的地方，希望共勉。 JAVASCRIPT 篇0、基础语法Javascript 基础语法包括：变量声明、数据类型、函数、控制语句、内置对象等。 在ES5 中，变量声明有两种方式，分别是 var 和 function ，var 用于声明普通的变量，接收任意类型，function用于声明函数。另外，ES6 新增了 let、const、import 和 class 等四个命令，分别用以声明 普通变量、静态变量、模块 和 类 。 JS数据类型共有六种，分别是 String、Number、Boolean、Null、Undefined 和 Object 等， 另外，ES6 新增了 Symbol 类型。其中，Object 是引用类型，其他的都是原始类型(Primitive Type)。 原始类型也称为基本类型或简单类型，因为其占据空间固定，是简单的数据段，为了便于提升变量查询速度，将其存储在栈（stack）中（按值访问）。为了便于操作这类数据，ECMAScript 提供了 3 个基本包装类型：Boolean、Number 和 String 。基本包装类型是一种特殊的引用类型，每当读取一个基本类型值的时候，JS内部就会创建一个对应的包装对象，从而可以调用一些方法来操作这些数据。 引用类型由于其值的大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度，因此其存储在堆(heap)中，存储在变量处的值是一个指针，指向存储对象的内存处(按址访问)，对于引用类型的值，可以为其添加属性和方法，也可以改变和删除其属性和方法；但基本类型不可以添加属性和方法。关于更多介绍请参考：详解 ECMAScript 数据类型 JavaScript 可以通过 typeof 来判断原始数据类型，但不能判断引用类型，要知道引用类型的具体类型，需要通过 Object 原型上的 toString 方法来判断，关于数据类型判断可以参考：判断JS数据类型的4种方法 在 JavaScript 中，函数有三种角色，即普通函数、构造函数 和 对象方法。同一个函数，调用方式不同，函数的作用不一样，所扮演的角色也不一样。直接调用时就是普通函数，通过new创建对象时就是构造函数，通过对象调用时就是方法。 JavaScript 常用的内置对象有 Date、Array、JSON、RegExp 等等，Date 和 Array 使用场景最多，JSON主要用于对象的序列化和反序列化，还有一个作用就是实现对象的深拷贝。RegExp 即正则表达式，是处理字符串的利器。 关于更多介绍请参考：数组常用操作方法总结 ， 正则表达式基础知识 1、函数原型链JS是一种基于对象的语言，但在 ES6 之前是不支持继承的，为了具备继承的能力，JavaScript 在函数对象上建立了原型对象 prototype，并以函数对象为主线，从上至下，在JS内部构建了一条原型链。原型链把一个个独立的对象联系在一起，Object 则是所有对象的祖宗， 任何对象所建立的原型链最终都指向了 Object，并以 Object 终结。 简单来说，就是建立了变量查找机制，当访问一个对象的属性时，先查找对象本身是否存在，如果不存在就去该对象所在的原型连上去找，直到 Object 对象为止，如果都没有找到该属性才会返回 undefined。因此，我们可以通过原型链来实现继承机制。关于函数原型链请参考：认识原型对象和原型链 2、函数作用域函数作用域就是变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。通俗来讲就是，在一个函数里，有些变量可以访问，有些不可以访问。那些能访问的变量所形成的范围，就是这个函数的作用域。 在 JavaScript 中，没有块级作用域，只有函数作用域，也就是说 if、while、for 语句不会形成独立的作用域。但有一个特殊情况，即 with 语句和 catch 语句会形成临时作用域，语句执行结束后，该作用域就会被释放。关于函数作用域请参考：函数作用域和作用域链 3、this 指针this 指针存在于函数中，用以标识函数运行时所处的上下文。函数的类型不同，this 指向规则也不一样：对于普通函数，this 始终指向全局对象window；对于构造函数，this则指向新创建的对象；对于方法，this指向调用该方法的对象。另外，Function 对象也提供了call、apply 和 bind 等方法来改变函数的 this 指向，其中，call 和 apply 主动执行函数，bind 一般在事件回调中使用，而 call 和 apply 的区别只是参数的传递方式不同。关于更多介绍请参考：深入理解 call,apply和 bind 如果往深的去理解，无论什么函数，this 是否被改变， 本质上，this 均指向触发函数运行时的那个对象。而在函数运行时，this 的值是不能被改变的。 4、new 操作符函数的创建有三种方式，即 显式声明、匿名定义 和 new Function() 。前面提到，JS 中的函数即可以是函数，也可以是方法，还可以是构造函数。 当使用 new 来创建对象时，该函数就是构造函数，JS 将新对象的原型链指向了构造函数的原型对象，于是就在新对象和函数对象之间建立了一条原型链，通过新对象可以访问到函数对象原型 prototype 中的方法和属性。关于构造函数和 new 操作符请参考： 深入理解 new 操作符 5、闭包闭包不是一个孤立的概念，需要从函数作用域的角度来理解。 每个函数都有自己的作用域，如果在一个函数里定义了另一个函数，那么对应的就有两个作用域，这两个作用域就会形成一个链条，俗称作用域链。本质上讲，作用域链是一个自上而下的链表， 链表的最顶端是内部函数作用域，链表的最底端是全局作用域。内部函数有权访问整个作用域链上的变量。正常情况下，每当一个函数执行完毕，对应的作用域就会从该链表上移除，然后销毁。 但如果函数 A 把函数 B 作为返回值返回时，情况又不一样。 首先，函数 A 返回的是函数 B 的引用，也就是说，B 可能会在其他地方被调用。上面提到，函数 B 的定义是位于函数 A 内部，因此 A 和 B 会形成一条作用域链，函数 B 有可能会读取 A 中的变量 。为了保证函数 B 能够在其他地方正确执行，函数 B 所在的这条作用域链就不能被破坏。所以，即使函数 A 执行返回后，A 的作用域也不能释放，需要一直保存在内存中，以确保函数 B 能够正常读取里面的变量。函数 B 具有永久访问 A 作用域的特权，确切说，函数 B 就是闭包 。 总而言之，闭包就是一个有权访问另一个函数作用域的函数。 6、单线程与事件循环JavaScript 是单线程语言。在浏览器中，当JS代码被加载时，浏览器会为其分配一个主线程来执行任务，主线程会在栈中创建一个全局执行环境 （全局作用域）。每当有一个函数进入执行流时，就会形成一个对应的执行环境（函数作用域），并将该执行环境压入栈中。每当一个函数执行完毕以后，对应的执行环境就会从栈中弹出，然后被销毁。这就是执行环境栈，执行环境栈的作用就是保证所有的函数能按照正确的顺序被执行。 但在浏览器中，有一些任务是非常耗时的，比如 ajax请求、定时器、事件等。为了保证主线程上的任务不被阻塞，JavaScript 内部维护了一个任务队列， 当这些耗时任务结束时（Ajax 请求返回、定时器超时、事件被触发），就将对应的回调函数插入队列中进行等待。这些任务的执行时机并不确定，只有当所有同步任务执行完毕后，执行环境栈被清空（栈底的全局执行环境会一直存在，直到进程退出）以后，然后再从任务队列中依次读取回调函数，并将其压入执行环境栈中。于是，主线程开始执行新的同步任务，执行完毕后再从栈中弹出，栈被清空。 主线程从任务队列中读取任务是不断循环的，每当栈被清空后，主线程就会从任务队列中读取新的任务并执行，如果没有新的任务，就会一直等待，直到有新的任务。JavaScript 的这种执行机制就叫做任务循环。因为每个任务都由一个事件所触发，所以也叫 “事件循环”。 7、Ajax 和 跨域技术Ajax 是浏览器专门用来和服务器进行交互的异步通讯技术，其核心对象是 XMLHttpRequest，通过该对象可以创建一个 Ajax 请求。Ajax 请求是一个耗时的异步操作，当请求发出以后，Ajax 提供了两个状态位来描述请求在不同阶段的状态，这两个状态位分别是 readyState 和 status ，readyState 通过 5个状态码来描述一个请求的 5 个阶段： 0 - 请求未发送，初始化阶段 1 - 请求发送中，服务器还未收到请求 2 - 请求发送成功，服务器已收到请求 3 - 服务器处理完成，开始响应请求，传输数据 4 - 客户端收到请求，并完成了数据下载，生成了响应对象 status 用于描述服务端对请求处理的情况，200 表示正确响应了请求，404 表示服务器找不到资源，500 代表服务器内部异常等等。 Ajax 对象还可以设置一个 timeout 值，代表超时时间。切记：timeout 只会影响 readyState，而不会影响 status，因为超时只会中断数据传输，但不会影响服务器的处理结果。 如果 timeout 设置的不合理，就会导致响应码 status 是 200，但 response里却没有数据，这种情况就是服务器正确响应了请求，但数据的下载被超时中断了。 为了保证用户信息的安全，浏览器引入了同源策略，对脚本请求做了限制，不允许 Ajax 跨域请求服务器 ，只允许请求和当前地址同域的服务器资源。但不限制 HTML 标签发送跨域请求，比如 script、img、a 标签等，因此可以利用标签跨域能力来实现跨域请求，这就是 JSONP 能够跨域的原理。 JSONP 虽然可以解决跨域问题，但只能发送 GET 请求，并且没有有效的错误捕获机制 。为了解决这个问题，W3C 在 XMLHttpRequest Level2 中提出了 CORS 规范，即 “跨域资源共享”。它不是一个新的 API，而是一个标准规范 。当浏览器发现该请求需要跨域时，就会自动在头信息中添加一个 Origin 字段，用以说明本次请求来自哪个源。服务器根据这个值，决定是否同意这次请求。 关于 CORS 的详细介绍请参考：跨域资源共享 CORS 详解 随着移动端的快速发展，Web 技术的应用场景正在变得越来越复杂，“关注点分离” 原则在系统设计层面就显得越来越重要，而 XMLHttpRequest 是 Ajax 最古老的一个接口，因而不太符合现代化的系统设计理念。因此，浏览器提供了一个新的 Ajax 接口，即 Fetch，Fetch 是基于 ES6 的 Promise 思想设计的，更符合关注点分离原则。关于 Fetch 的更多介绍请参考：传统 Ajax 已死，Fetch 永生 8、模块化历史上，JavaScript 规范一直没有模块（Module）体系，即无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。在 ES6 之前，为了实现 JS 模块化编程，社区制定了一些模块加载方案，最主要有 CMD 和 AMD 两种，分别以 commonjs 和 requirejs 为代表。ES6 在语言标准的层面上，实现了模块化编程，其设计思想是，尽量静态化，使得编译时就能确定模块的依赖关系，即编译时加载，而 CMD 和 AMD 是在运行时确定依赖关系，即运行时加载。关于 ES6 模块化请参考：ES6模块化 9、Node.jsNode.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，它的运行不依赖于浏览器作为宿主环境，而是和服务端程序一样可以独立的运行，这使得 JavaScript 编程第一次从客户端被带到了服务端，Node.js 在服务端的优势是，它采用单线程和异步 I/O 模型，实现了一个高并发、高性能的运行时环境。相比传统的多线程模型，Node.js 实现简单，并且可以减少资源开销。关于 Node.js单线程模型请参考：Node.js 事件循环机制 10、ES6ES6 是 ECMAScript 6.0 的简写，即 JavaScript 语言的下一代标准，已经在 2015年6月正式发布了，它的目标是让JS能够方便的开发企业级大型应用程序，因此，ES6的一些规范正在逐渐向Java、C# 等后端语言标准靠近。在 ES6 规范中，比较重大的变化有以下几个方面： 新增 let、const 命令 来声明变量，和var 相比，let 声明的变量不存在变量提升问题，但没有改变JS弱类型的特点，依然可以接受任意类型变量的声明；const 声明的变量不允许在后续逻辑中改变，提高了JS语法的严谨性。 新增解构赋值、rest 语法、箭头函数等，这些都是为了让代码看起来更简洁，而包装的语法糖。 新增模块化机制，这是 JavaScript 走向规范比较重要的一步，让前端更方便的实现工程化。 新增类和继承的概念，配合模块化，JavaScript 也可以实现高复用、高扩展的系统架构。 新增模板字符串功能，高效简洁，结束拼接字符串的时代。 新增 Promise 机制，解决异步回调多层嵌套的问题。 CSS 篇1、CSS选择器CSS 选择器即通过某种规则来匹配相应的标签，并为其设置 CSS 样式，常用的有类选择器、标签选择器、ID选择器、后代选择器、群组选择器、伪类选择器(before/after)、兄弟选择器(+~)、属性选择器等等。 2、CSS ResetHTML 标签在不设置任何样式的情况下，也会有一个默认的 CSS 样式，而不同内核浏览器对于这个默认值的设置则不尽相同，这样可能会导致同一套代码在不同浏览器上的显示效果不一致，而出现兼容性问题。因此，在初始化时，需要对常用标签的样式进行初始化，使其默认样式统一，这就是 CSS Reset ，即 CSS 样式重置，比如： 1`*&#123; margin:0; padding:0; &#125;` 就是最简单 CSS Reset。 关于 CSS 重置请参考：Neat.css 3、盒子布局盒子模型是CSS比较重要的一个概念，也是CSS 布局的基石。 常见的盒子模型有块级盒子(block)和行内盒子(inline-block)，与盒子相关的几个属性有：margin、border、padding和content 等，这些属性的作用是设置盒子与盒子之间的关系以及盒子与内容之间的关系，而 box-sizing 属性会影响盒子大小的计算方式。 需要注意的是： 只有普通文档流中块级盒子的垂直外边距才会发生合并，而具有 BFC 特性盒子的外边距不会合并。 4、浮动布局设置元素的 float 属性值为 left 或 right，就能使该元素脱离普通文档流，向左或向右浮动。一般在做宫格布局时会用到，如果子元素全部设置为浮动，则父元素是塌陷的，这时就需要清除浮动，清除浮动的方法也很多，常用的方法是在元素末尾加空元素设置 clear: both，更高级一点的就给父容器设置 before/after 来模拟一个空元素，还可以直接设置 overflow 属性为 auto/hidden 来清除浮动。除浮动可以实现宫格布局，行内盒子(inline-block) 和 table 也可以实现同样的效果。 5、定位布局设置元素的 position 属性值为 relative/absolute/fixed，就可以使该元素脱离文档流，并以某种参照坐标进行偏移。其中，releave 是相对定位，它以自己原来的位置进行偏移，偏移后，原来的空间不会被其他元素占用；absolute 是绝对定位，它以离自己最近的定位父容器作为参照进行偏移；为了对某个元素进行定位，常用的方式就是设置父容器的 poistion:relative，因为相对定位元素在不设置 top 和 left 值时，不会对元素位置产生影响；fixed 即固定定位，它则以浏览器窗口为参照物，PC网页底部悬停的banner一般都可以通过fixed定位来实现，但fixed属性在移动端有兼容性问题，因此不推荐使用，可替代的方案是：绝对定位+内部滚动。 6、弹性布局弹性布局即 Flex 布局，定义了 flex 的容器一个可伸缩容器，首先容器本身会根据容器中的元素动态设置自身大小；然后当Flex容器被应用一个大小时（width和height），将会自动调整容器中的元素适应新大小。Flex容器也可以设置伸缩比例和固定宽度，还可以设置容器中元素的排列方向（横向和纵向）和是否支持元素的自动换行。有了这个神器，做页面布局的可以方便很多了。注意，设为Flex 布局以后，子元素的 float、clear、inline-block 和 vertical-align 属性将失效。关于 flexbox 请参考：图解CSS3 Flexbox属性 7、CSS3 动画CSS3 中规范引入了两种动画，分别是 transition 和 animation，transition 可以让元素的 CSS 属性值的变化在一段时间内平滑的过渡，形成动画效果，为了使元素的变换更加丰富多彩，CSS3 还引入了 transfrom 属性，它可以通过对元素进行 平移(translate)、旋转(rotate)、放大缩小(scale)、倾斜(skew) 等操作，来实现 2D 和 3D 变换效果。transiton 还有一个结束事件 transitionEnd，该事件是在 CSS 完成过渡后触发，但如果过渡在完成之前被移除，则不会触发 transitionEnd 。 animation 需要设置一个 @keyframes，来定义元素以哪种形式进行变换， 然后再通过动画函数让这种变换平滑的进行，从而达到动画效果，动画可以被设置为永久循环演示。设置 animation-play-state:paused 可以暂停动画，设置 animation-fill-mode:forwards 可以让动画完成后定格在最后一帧。 另外，还可以通过JS 监听 animation 的“开始”、“结束” 和 “重复播放” 状态，分别对应三个事件，即 animationStart、animationEnd、animationIteration 。需要注意的是： 当播放次数设置为1时，不会触发 animationIteration 。 和 transition相比，animation 设置动画效果更灵活更丰富，二者还有一个区别是：transition 只能通过主动改变元素的 css 值才能触发动画效果，而 animation 一旦被应用，就开始执行动画。 另外，HTML5 还新增了一个动画API，即 requestAnimationFrame，它通过JS来调用，并按照屏幕的绘制频率来改变元素的CSS属性，从而达到动画效果，关于这个API的介绍请参考：requestAnimationFrame 知多少？ 8、BFCBFC 是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素。比如：内部滚动就是一个 BFC，当一个父容器的 overflow-y 设置为 auto 时，并且子容器的长度大于父容器时，就会出现内部滚动，无论内部的元素怎么滚动，都不会影响父容器以外的布局，这个父容器的渲染区域就叫 BFC。满足下列条件之一就可触发 BFC： 根元素，即 HTML 元素 float 的值不为 none overflow 的值不为 visible display 的值为 inline-block、table-cell、table-caption position 的值为 absolute 或 fixed 9、Sprite，Iconfont，font-face对于大型站点，为了减少 http 请求的次数，一般会将常用的小图标排到一个大图中，页面加载时只需请求一次网络， 然后在 css 中通过设置 background-position 来控制显示所需要的小图标，这就是 Sprite 图。 Iconfont，即字体图标，就是将常用的图标转化为字体资源存在文件中，通过在 CSS 中引用该字体文件，然后可以直接用控制字体的css属性来设置图标的样式，字体图标的好处是节省网络请求、其大小不受屏幕分辨率的影响，并且可以任意修改图标的颜色。 font-face 是 CSS3 中的一个模块，通过 font-face 可以定义一种全新的字体，然后就可以通过 css 属性 font-family 来使用这个字体了，即使操作系统没有安装这种字体，网页上也会正常显示出来。 10、CSS HACK早期，不同内核浏览器对CSS属性的解析存在着差异，导致显示效果不一致，比如 margin 属性在 ie6 中显示的距离会比其他浏览器中显示的距离宽 2 倍，也就是说 margin-left:20px; 在ie6中距左侧元素的实际显示距离是 40px，而在非 ie6 的浏览器上显示正常。因此，如果要想让所有浏览器中都显示是 20px 的宽度，就需要在CSS样式中加入一些特殊的符号，让不同的浏览器识别不同的符号，以达到应用不同的CSS样式的目的，这种方式就是 “css hack”， 对于 ie6 中的 margin 应用 hack 就会变成这样： 1`.el &#123;`` margin-left: 20px; ``// 其他`` _margin-left: 10px;``// ie6``&#125;` 兼容各大浏览器的 css hack 如下： 1`.element &#123;`` ``color: #000; ``// W3c标准`` ``[;color:#f00;]; ``// Webkit(Chrome/Safari)`` ``color: #666\9; ``// IE8`` ``*color: #999; ``// IE7`` ``_color: #333; ``// IE6 ``&#125;``:root .element &#123;color: #0f0\9;&#125; ``// IE9``// Opera``@media all and (-webkit-min-device-pixel-ratio:10000),``not all and (-webkit-min-device-pixel-ratio:0) &#123;`` ``.element &#123;color:#336699;&#125;``&#125;``// Firefox``@-moz-document url-prefix() &#123;`` ``.element &#123;color: #f1f1f1&#125;``&#125; ` HTML 篇1、BOMBOM 是 Browser Object Model 的缩写，即浏览器对象模型，当一个浏览器页面初始化时，会在内存创建一个全局的对象，用以描述当前窗口的属性和状态，这个全局对象被称为浏览器对象模型，即BOM。BOM的核心对象就是 window，window 对象也是BOM的顶级对象，其包含了浏览器的六个核心模块： document - 即文档对象，渲染引擎在解析HTML代码时，会为每一个元素生成对应的DOM对象，由于元素之间有层级关系，因此整个HTML代码解析完以后，会生成一个由不同节点组成的树形结构，俗称DOM树，document 用于描述DOM树的状态和属性，并提供了很多操作DOM的API。 frames - HTML 子框架，即在浏览器里嵌入另一个窗口，父框架和子框架拥有独立的作用域和上下文。 history - 以栈(FIFO)的形式保存着页面被访问的历史记录，页面前进即入栈，页面返回即出栈。 location - 提供了当前窗口中加载的文档相关信息以及一些导航功能。 navigator - 用来描述浏览器本身，包括浏览器的名称、版本、语言、系统平台、用户特性字符串等信息。 screen - 提供了浏览器显示屏幕的相关属性，比如显示屏幕的宽度和高度，可用宽度和高度。 2、DOM 系统 DOM 是 Document Object Model 的缩写，即 文档对象模型，是所有浏览器公共遵守的标准，DOM 将HTML和XML文档映射成一个由不同节点组成的树型结构，俗称DOM树。其核心对象是document，用于描述DOM树的状态和属性，并提供对应的DOM操作API。随着历史的发展，DOM 被划分为1级、2级、3级，共3个级别： 1级DOM - 在1998年10月份成为W3C的提议，由 DOM 核心与 DOM HTML 两个模块组成。DOM核心能映射以XML为基础的文档结构，允许获取和操作文档的任意部分。DOM HTML通过添加HTML专用的对象与函数对DOM核心进行了扩展。 2级DOM - 鉴于1级DOM仅以映射文档结构为目标，DOM 2级面向更为宽广。通过对原有DOM的扩展，2级DOM通过对象接口增加了对鼠标和用户界面事件（DHTML长期支持鼠标与用户界面事件）、范围、遍历（重复执行DOM文档）和层叠样式表（CSS）的支持。同时也对DOM 1的核心进行了扩展，从而可支持XML命名空间。 3级DOM - 通过引入统一方式载入和保存文档和文档验证方法对DOM进行进一步扩展，DOM3包含一个名为“DOM载入与保存”的新模块，DOM核心扩展后可支持XML1.0的所有内容，包括XML Infoset、 XPath、和XML Base。 浏览器对不同级别DOM的支持情况如下所示： 从图中可以看出，移动端常用的 webkit 内核浏览器目前只支持 DOM2，而不支持 DOM3 。 3、事件系统事件是用户与页面交互的基础，到目前为止，DOM事件从PC端的 鼠标事件(mouse) 发展到了 移动端的 触摸事件(touch) 和 手势事件(guesture)，touch事件描述了手指在屏幕操作的每一个细节，guesture 则是描述多手指操作时更为复杂的情况，总结如下： 第一根手指放下，触发 touchstart，除此之外什么都不会发生 手指滑动时，触发touchmove 第二根手指放下，触发 gesturestart 触发第二根手指的 touchstart 立即触发 gesturechange 任意手指移动，持续触发 gesturechange 第二根手指弹起时，触发 gestureend，以后将不会再触发 gesturechange 触发第二根手指的 touchend 触发touchstart (多根手指在屏幕上，提起一根，会刷新一次全局touch) 弹起第一根手指，触发 touchend 更多关于手势事件的介绍请参考：gesture事件处理复杂手势 DOM2.0 模型将事件处理流程分为三个阶段，即 事件捕获阶段、事件处理阶段、事件冒泡阶段，如图所示： 事件捕获：当用户触发点击事件后，顶层对象 document 就会发出一个事件流，从最外层的 DOM 节点向目标元素节点传递，最终到达目标元素。 事件处理：当到达目标元素之后，执行目标元素绑定的处理函数。如果没有绑定监听函数，则不做任何处理。 事件冒泡：事件流从目标元素开始，向最外层DOM节点传递，途中如果有节点绑定了事件处理函数，这些函数就会被执行。 利用事件冒泡原理可以实现 “事件委托”。 所谓事件委托，就是在父元素上添加事件监听器，用以监听和处理子元素的事件，避免重复为子元素绑定相同的事件。当目标元素的事件被触发以后，这个事件就从目标元素开始，向最外层元素传递，最终冒泡到父元素上，父元素再通过 event.target 获取到这个目标元素，这样做的好处是，父元素只需绑定一个事件监听，就可以对所有子元素的事件进行处理了，从而减少了不必要的事件绑定，对页面性能有一定的提升。 4、HTML 渲染流程渲染引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。 然后进行如下所示的基本流程： HTML Parser 解析 HTML 文档，并将各标记逐个转化为 DOM 节点，生成 “DOM树”。 CSS Parser 解析外部 CSS 文件以及样式元素中的样式数据，生成 “CSSOM树”。 “DOM树” 和 “CSSOM树” 通过 “附着” 将创建另一个树结构：“渲染树”。 渲染树包含多个带有视觉属性（如颜色和尺寸）的矩形，这些矩形的排列顺序就是它们将在屏幕上显示的顺序。 渲染树构建完毕之后，进入“布局” 处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。 下一个阶段是 “绘制”，渲染引擎会遍历渲染树，由用户界面后端层将每个节点绘制出来。 需要注意的是： 这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。 5、重绘与回流当渲染树中的一部分(或全部)因为元素的规模尺寸、布局、隐藏等改变而需要重新构建，就称为 “回流”。 当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局，就称为 “重绘”。 回流必将引起重绘，而重绘不一定会引起回流。 引起重绘和回流的操作如下： 添加、删除元素（回流+重绘） 隐藏元素，display: none（回流+重绘），visibility:hidden（只重绘，不回流） 移动元素，比如改变 top、left 的值，或者移动元素到另外一个父元素中。（重绘+回流） 对 style 的操作（对不同的属性操作，影响不一样） 还有一种是用户的操作，比如改变浏览器大小，改变浏览器的字体大小等（回流+重绘） 注意问题： transform 操作不会引起重绘和回流，是一种高效率的渲染。这是因为transform属于合成属性，对合成属性进行transition/animation 动画时将会创建一个合成层，这使得动画元素在一个独立的层中进行渲染，当元素的内容没有发生改变，就没必要进行重绘，浏览器会通过重新复合来创建动画帧。 6、本地存储本地存储最原始的方式就是 cookie,cookie 是存放在本地浏览器的一段文本，数据以键值对的形式保存，可以设置过期时间。 但是 cookie 不适合大量数据的存储，因为每请求一次页面，cookie 都会发送给服务器，这使得 cookie 速度很慢而且效率也不高。因此cookie的大小被限制为4k左右(不同浏览器可能不同,分HOST)，如下所示： Firefox 和 Safari 允许 cookie 多达 4097 个字节，包括名(name)、值(value) 和 等号。 Opera 允许 cookie 多达 4096 个字节，包括：名(name)、值(value) 和 等号。 Internet Explorer 允许 cookie 多达4095个字节，包括：名(name)、值(value) 和 等号。 在所有浏览器中，任何 cookie 大小超过限制都被忽略，且永远不会被设置。 html5 提供了两种在客户端存储数据的新方法：localStorage 和 sessionStorage, 它们都是以 key/value 的形式来存储数据，前者是永久存储，后者的存储期限仅限于浏览器会话(session)，即当浏览器窗口关闭后，sessionStorage中的数据被清除。 localStorage 的存储空间大约5M左右(不同浏览器可能不同，分 HOST)，这个相当于一个5M大小的前端数据库，相比于cookie，可以节约带宽，但localStorage在浏览器隐私模式下是不可读取的，当存储数据超过了localStorage 的存储空间后会抛出异常。 此外，H5还提供了 websql 和 indexedDB，允许前端以关系型数据库的方式来存储本地数据，相对来说，这个功能目前应用的场景比较少，此处不作介绍。 7、浏览器缓存机制浏览器缓存机制是指通过 HTTP 协议头里的 Cache-Control (或 Expires) 和 Last-Modified (或 Etag) 等字段来控制文件缓存的机制。 Cache-Control 用于控制文件在本地缓存有效时长。最常见的，比如服务器回包：Cache-Control:max-age=600 表示文件在本地应该缓存，且有效时长是600秒 (从发出请求算起)。在接下来600秒内，如果有请求这个资源，浏览器不会发出 HTTP 请求，而是直接使用本地缓存的文件。 Last-Modified 是标识文件在服务器上的最新更新时间。下次请求时，如果文件缓存过期，浏览器通过 If-Modified-Since 字段带上这个时间，发送给服务器，由服务器比较时间戳来判断文件是否有修改。如果没有修改，服务器返回304告诉浏览器继续使用缓存；如果有修改，则返回200，同时返回最新的文件。 Cache-Control 通常与 Last-Modified 一起使用。一个用于控制缓存有效时间，一个在缓存失效后，向服务查询是否有更新。 Cache-Control 还有一个同功能的字段：Expires。Expires 的值一个绝对的时间点，如：Expires: Thu, 10 Nov 2015 08:45:11 GMT，表示在这个时间点之前，缓存都是有效的。 Expires 是 HTTP1.0 标准中的字段，Cache-Control 是 HTTP1.1 标准中新加的字段，功能一样，都是控制缓存的有效时间。当这两个字段同时出现时，Cache-Control 是高优化级的。 Etag 也是和 Last-Modified 一样，对文件进行标识的字段。不同的是，Etag 的取值是一个对文件进行标识的特征字串。在向服务器查询文件是否有更新时，浏览器通过 If-None-Match 字段把特征字串发送给服务器，由服务器和文件最新特征字串进行匹配，来判断文件是否有更新。没有更新回包304，有更新回包200。Etag 和 Last-Modified 可根据需求使用一个或两个同时使用。两个同时使用时，只要满足基中一个条件，就认为文件没有更新。 浏览缓存的基本框架如下图所示： 关于更多浏览器缓存介绍请参考：H5 缓存机制浅析 移动端 Web 加载性能优化 8、History用户访问网页的历史记录通常会被保存在一个类似于栈的对象中，即 history 对象，点击返回就出栈，跳下一页就入栈。 它提供了以下方法来操作页面的前进和后退： window.history.back( ) 返回到上一个页面 window.history.forward( ) 进入到下一个页面 window.history.go( [delta] ) 跳转到指定页面 HTML5 对History Api 进行了增强，新增了两个Api 和一个事件，分别是 pushState、replaceState 和 onpopstate： pushState 是往 history 对象里添加一个新的历史记录。 replaceState 是替换 history 对象中的当前历史记录。 onpopstate 当点击浏览器后退按钮或JS调用 history.back 都会触发该事件。 onpopstate 和 onhashchange 的区别： onhashchange 本来是用来监听hash变化的，但可以被利用来做客户端前进和后退事件的监听，而 onpopstate 是专门用来监听浏览器前进后退的，不仅可以支持 hash，非 hash 的同源 url 也支持。 9、HTML5 离线缓存HTML5离线缓存又叫Application Cache，是从浏览器的缓存中分出来的一块缓存区，如果要在这个缓存中保存数据，可以使用一个描述文件（manifest file），列出要下载和缓存的资源。 manifest 文件是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容）。manifest 文件可分为三个部分： CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存 NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存 FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面） 离线缓存为应用带来三个优势： 离线浏览 - 用户可在应用离线时使用它们 速度 - 已缓存资源加载得更快 减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。 10、Web语义化与SEO Web语义化是指使用语义恰当的标签，使页面有良好的结构，页面元素有含义，能够让人和搜索引擎都容易理解。 SEO是指在了解搜索引擎自然排名机制的基础之上，对网站进行内部及外部的调整优化，改进网站在搜索引擎中关键词的自然排名，获得更多的展现量，吸引更多目标客户点击访问网站，从而达到互联网营销及品牌建设的目标。 搜索引擎通过爬虫技术获取的页面就是由一堆 html 标签组成的代码，人可以通过可视化的方式来判断页面上哪些内容是重点，而机器做不到。 但搜索引擎会根据标签的含义来判断内容的权重，因此，在合适的位置使用恰当的标签，使整个页面的语义明确，结构清晰，搜索引擎才能正确识别页面中的重要内容，并予以较高的权值。比如h1~h6这几个标签在SEO中的权值非常高，用它们作页面的标题就是一个简单的SEO优化。 本文转载地址]]></content>
      <categories>
        <category>HTML</category>
        <category>CSS</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
        <tag>HTML</tag>
        <tag>JavaScript</tag>
        <tag>CSS</tag>
        <tag>ES6</tag>
        <tag>Nodejs</tag>
        <tag>BOM</tag>
        <tag>DOM</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F17%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[十大经典排序算法（动图演示）0、算法概述0.1 算法分类十种常见排序算法可以分为两大类： 比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 0.2 算法复杂度 0.3 相关概念 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。 不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。 时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。 空间复杂度：是指算法在计算机 内执行时所需存储空间的度量，它也是数据规模n的函数。 1、冒泡排序（Bubble Sort）冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 1.1 算法描述 比较相邻的元素。如果第一个比第二个大，就交换它们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数； 针对所有的元素重复以上的步骤，除了最后一个； 重复步骤1~3，直到排序完成。 1.2 动图演示 1.3 代码实现1`function bubbleSort(arr) &#123;`` ``var` `len = arr.length;`` ``for` `(``var` `i = 0; i &lt; len - 1; i++) &#123;`` ``for` `(``var` `j = 0; j &lt; len - 1 - i; j++) &#123;`` ``if` `(arr[j] &gt; arr[j+1]) &#123; ``// 相邻元素两两对比`` ``var` `temp = arr[j+1]; ``// 元素交换`` ``arr[j+1] = arr[j];`` ``arr[j] = temp;`` ``&#125;`` ``&#125;`` ``&#125;`` ``return` `arr;``&#125;` 2、选择排序（Selection Sort）选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 2.1 算法描述n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下： 初始状态：无序区为R[1..n]，有序区为空； 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区； n-1趟结束，数组有序化了。 2.2 动图演示 2.3 代码实现1`function selectionSort(arr) &#123;`` ``var` `len = arr.length;`` ``var` `minIndex, temp;`` ``for` `(``var` `i = 0; i &lt; len - 1; i++) &#123;`` ``minIndex = i;`` ``for` `(``var` `j = i + 1; j &lt; len; j++) &#123;`` ``if` `(arr[j] &lt; arr[minIndex]) &#123; ``// 寻找最小的数`` ``minIndex = j; ``// 将最小数的索引保存`` ``&#125;`` ``&#125;`` ``temp = arr[i];`` ``arr[i] = arr[minIndex];`` ``arr[minIndex] = temp;`` ``&#125;`` ``return` `arr;``&#125; ` 2.4 算法分析表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。 3、插入排序（Insertion Sort）插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 3.1 算法描述一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下： 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2~5。 3.2 动图演示 3.2 代码实现1`function insertionSort(arr) &#123;`` ``var` `len = arr.length;`` ``var` `preIndex, current;`` ``for` `(``var` `i = 1; i &lt; len; i++) &#123;`` ``preIndex = i - 1;`` ``current = arr[i];`` ``while` `(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123;`` ``arr[preIndex + 1] = arr[preIndex];`` ``preIndex--;`` ``&#125;`` ``arr[preIndex + 1] = current;`` ``&#125;`` ``return` `arr;``&#125;` 3.4 算法分析插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 4、希尔排序（Shell Sort）1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。 4.1 算法描述先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述： 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1； 按增量序列个数k，对序列进行k 趟排序； 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 4.2 动图演示 4.3 代码实现1`// 修改于 2019-03-06``function shellSort(arr) &#123;`` ``var` `len = arr.length;`` ``for` `(``var` `gap = Math.floor(len / 2); gap &gt; 0; gap = Math.floor(gap / 2)) &#123;`` ``// 注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行`` ``for` `(``var` `i = gap; i &lt; len; i++) &#123;`` ``var` `j = i;`` ``var` `current = arr[i];`` ``while` `(j - gap &gt;= 0 &amp;&amp; current &lt; arr[j - gap]) &#123;`` ``arr[j] = arr[j - gap];`` ``j = j - gap;`` ``&#125;`` ``arr[j] = current;`` ``&#125;`` ``&#125;`` ``return` `arr;``&#125;` 4.4 算法分析希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的。 5、归并排序（Merge Sort）归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 5.1 算法描述 把长度为n的输入序列分成两个长度为n/2的子序列； 对这两个子序列分别采用归并排序； 将两个排序好的子序列合并成一个最终的排序序列。 5.2 动图演示 5.3 代码实现1`function mergeSort(arr) &#123;`` ``var` `len = arr.length;`` ``if` `(len &lt; 2) &#123;`` ``return` `arr;`` ``&#125;`` ``var` `middle = Math.floor(len / 2),`` ``left = arr.slice(0, middle),`` ``right = arr.slice(middle);`` ``return` `merge(mergeSort(left), mergeSort(right));``&#125;` `function merge(left, right) &#123;`` ``var` `result = [];` ` ``while` `(left.length&gt;0 &amp;&amp; right.length&gt;0) &#123;`` ``if` `(left[0] &lt;= right[0]) &#123;`` ``result.push(left.shift());`` ``&#125;``else` `&#123;`` ``result.push(right.shift());`` ``&#125;`` ``&#125;` ` ``while` `(left.length)`` ``result.push(left.shift());` ` ``while` `(right.length)`` ``result.push(right.shift());` ` ``return` `result;``&#125;` 5.4 算法分析归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。 6、快速排序（Quick Sort）快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 6.1 算法描述快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下： 从数列中挑出一个元素，称为 “基准”（pivot）； 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 6.2 动图演示 6.3 代码实现1`function quickSort(arr, left, right) &#123;`` ``var` `len = arr.length,`` ``partitionIndex,`` ``left =``typeof` `left !=``'number'` `? 0 : left,`` ``right =``typeof` `right !=``'number'` `? len - 1 : right;` ` ``if` `(left &lt; right) &#123;`` ``partitionIndex = partition(arr, left, right);`` ``quickSort(arr, left, partitionIndex-1);`` ``quickSort(arr, partitionIndex+1, right);`` ``&#125;`` ``return` `arr;``&#125;` `function partition(arr, left ,right) &#123; ``// 分区操作`` ``var` `pivot = left, ``// 设定基准值（pivot）`` ``index = pivot + 1;`` ``for` `(``var` `i = index; i &lt;= right; i++) &#123;`` ``if` `(arr[i] &lt; arr[pivot]) &#123;`` ``swap(arr, i, index);`` ``index++;`` ``&#125; `` ``&#125;`` ``swap(arr, pivot, index - 1);`` ``return` `index-1;``&#125;` `function swap(arr, i, j) &#123;`` ``var` `temp = arr[i];`` ``arr[i] = arr[j];`` ``arr[j] = temp;``&#125;` 7、堆排序（Heap Sort）堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 7.1 算法描述 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区； 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]； 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。 7.2 动图演示 7.3 代码实现1`var` `len; ``// 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量` `function buildMaxHeap(arr) &#123; ``// 建立大顶堆`` ``len = arr.length;`` ``for` `(``var` `i = Math.floor(len/2); i &gt;= 0; i--) &#123;`` ``heapify(arr, i);`` ``&#125;``&#125;` `function heapify(arr, i) &#123; ``// 堆调整`` ``var` `left = 2 * i + 1,`` ``right = 2 * i + 2,`` ``largest = i;` ` ``if` `(left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;`` ``largest = left;`` ``&#125;` ` ``if` `(right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;`` ``largest = right;`` ``&#125;` ` ``if` `(largest != i) &#123;`` ``swap(arr, i, largest);`` ``heapify(arr, largest);`` ``&#125;``&#125;` `function swap(arr, i, j) &#123;`` ``var` `temp = arr[i];`` ``arr[i] = arr[j];`` ``arr[j] = temp;``&#125;` `function heapSort(arr) &#123;`` ``buildMaxHeap(arr);` ` ``for` `(``var` `i = arr.length - 1; i &gt; 0; i--) &#123;`` ``swap(arr, 0, i);`` ``len--;`` ``heapify(arr, 0);`` ``&#125;`` ``return` `arr;``&#125;` 8、计数排序（Counting Sort）计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 8.1 算法描述 找出待排序的数组中最大和最小的元素； 统计数组中每个值为i的元素出现的次数，存入数组C的第i项； 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）； 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。 8.2 动图演示 8.3 代码实现1`function countingSort(arr, maxValue) &#123;`` ``var` `bucket =``new` `Array(maxValue + 1),`` ``sortedIndex = 0;`` ``arrLen = arr.length,`` ``bucketLen = maxValue + 1;` ` ``for` `(``var` `i = 0; i &lt; arrLen; i++) &#123;`` ``if` `(!bucket[arr[i]]) &#123;`` ``bucket[arr[i]] = 0;`` ``&#125;`` ``bucket[arr[i]]++;`` ``&#125;` ` ``for` `(``var` `j = 0; j &lt; bucketLen; j++) &#123;`` ``while``(bucket[j] &gt; 0) &#123;`` ``arr[sortedIndex++] = j;`` ``bucket[j]--;`` ``&#125;`` ``&#125;` ` ``return` `arr;``&#125;` 8.4 算法分析计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。 9、桶排序（Bucket Sort）桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。 9.1 算法描述 设置一个定量的数组当作空桶； 遍历输入数据，并且把数据一个一个放到对应的桶里去； 对每个不是空的桶进行排序； 从不是空的桶里把排好序的数据拼接起来。 9.2 图片演示 9.3 代码实现1`function bucketSort(arr, bucketSize) &#123;`` ``if` `(arr.length === 0) &#123;`` ``return` `arr;`` ``&#125;` ` ``var` `i;`` ``var` `minValue = arr[0];`` ``var` `maxValue = arr[0];`` ``for` `(i = 1; i &lt; arr.length; i++) &#123;`` ``if` `(arr[i] &lt; minValue) &#123;`` ``minValue = arr[i]; ``// 输入数据的最小值`` ``&#125;``else` `if` `(arr[i] &gt; maxValue) &#123;`` ``maxValue = arr[i]; ``// 输入数据的最大值`` ``&#125;`` ``&#125;` ` ``// 桶的初始化`` ``var` `DEFAULT_BUCKET_SIZE = 5; ``// 设置桶的默认数量为5`` ``bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;`` ``var` `bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1; `` ``var` `buckets =``new` `Array(bucketCount);`` ``for` `(i = 0; i &lt; buckets.length; i++) &#123;`` ``buckets[i] = [];`` ``&#125;` ` ``// 利用映射函数将数据分配到各个桶中`` ``for` `(i = 0; i &lt; arr.length; i++) &#123;`` ``buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);`` ``&#125;` ` ``arr.length = 0;`` ``for` `(i = 0; i &lt; buckets.length; i++) &#123;`` ``insertionSort(buckets[i]); ``// 对每个桶进行排序，这里使用了插入排序`` ``for` `(``var` `j = 0; j &lt; buckets[i].length; j++) &#123;`` ``arr.push(buckets[i][j]); `` ``&#125;`` ``&#125;` ` ``return` `arr;``&#125;` 9.4 算法分析桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 10、基数排序（Radix Sort）基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。 10.1 算法描述 取得数组中的最大数，并取得位数； arr为原始数组，从最低位开始取每个位组成radix数组； 对radix进行计数排序（利用计数排序适用于小范围数的特点）； 10.2 动图演示 10.3 代码实现1`var` `counter = [];``function radixSort(arr, maxDigit) &#123;`` ``var` `mod = 10;`` ``var` `dev = 1;`` ``for` `(``var` `i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123;`` ``for``(``var` `j = 0; j &lt; arr.length; j++) &#123;`` ``var` `bucket = parseInt((arr[j] % mod) / dev);`` ``if``(counter[bucket]==``null``) &#123;`` ``counter[bucket] = [];`` ``&#125;`` ``counter[bucket].push(arr[j]);`` ``&#125;`` ``var` `pos = 0;`` ``for``(``var` `j = 0; j &lt; counter.length; j++) &#123;`` ``var` `value =``null``;`` ``if``(counter[j]!=``null``) &#123;`` ``while` `((value = counter[j].shift()) !=``null``) &#123;`` ``arr[pos++] = value;`` ``&#125;`` ``&#125;`` ``&#125;`` ``&#125;`` ``return` `arr;``&#125;` 10.4 算法分析基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。 基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>排序</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F17%2F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var data = [5, 1, 9, 10, 3, 4, 6, 1]function _sort(data) &#123; function bubbleSort() &#123; let x for (let i = 0; i &lt; data.length; i++) &#123; // console.log(i,'i') for (x = 0; x &lt; data.length - 1; x++) &#123; // console.log(x,'x') // console.log(data[x],data[x+1]) if (data[x] &lt;= data[x + 1]) &#123; &#125; else &#123; swap(data, x, x + 1) &#125; &#125; &#125; return data &#125; function quickSort() &#123; let x let min for (let i = 0; i &lt; data.length; i++) &#123; min = i for (x = i + 1; x &lt; data.length; x++) &#123; if (data[x] &lt; data[min]) &#123; min = x &#125; swap(data, i, min) &#125; &#125; return data &#125; function swap(data, a, b) &#123; var newdata = data[a] data[a] = data[b] data[b] = newdata &#125; return &#123; bubbleSort: bubbleSort, quickSort: quickSort &#125;&#125;console.log(_sort(data).bubbleSort())console.log(_sort(data).quickSort())]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手写封装一个jQuery的Ajax]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F15%2F%E6%89%8B%E5%86%99%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AAjQuery%E7%9A%84Ajax%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445function ajax(options) &#123; var url = options.url; var method = options.type || "GET"; var datatype = options.dataType || "jSON"; var onsuccess = options.onsuccess || function() &#123;&#125;; var onerror = options.onerror || function() &#123;&#125;; var data = options.data || &#123;&#125;; var xhr = new XMLHttpRequest(); var dataStr = []; for (var key in data) &#123; dataStr.push(key + "=" + data[key]); &#125; dataStr.join("&amp;"); if (method === "GET") &#123; url = url + "?" + dataStr; &#125; xhr.open(method, url, true); xhr.onload = function(e) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 300) &#123; if (datatype === "json") &#123; onsuccess(JSON.parse(xhr.responseText)); &#125; &#125; else &#123; onerror(); &#125; &#125;; xhr.onerror = onerror; if (method === "POST") &#123; xhr.send(dataStr); &#125; else &#123; xhr.send(); &#125;&#125;ajax(&#123; url: "http://api.jirengu.com/weather.php", data: &#123; city: "北京" &#125;, onsuccess: function(ret) &#123; console.log(ret); &#125;, onerror: function() &#123; console.log("服务器异常"); &#125;&#125;);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
        <tag>JavaScirpt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[懒加载]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F15%2F%E6%87%92%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[懒加载懒加载也就是延迟加载。当访问一个页面的时候，先把img元素或是其他元素的背景图片路径替换成一张大小为1*1px图片的路径（这样就只需请求一次，俗称占位图），只有当图片出现在浏览器的可视区域内时，才设置图片正真的路径，让图片显示出来。这就是图片懒加载。 为什么要使用懒加载?很多页面，内容很丰富，页面很长，图片较多。比如说各种商城页面。这些页面图片数量多，而且比较大，少说百来K，多则上兆。要是页面载入就一次性加载完毕。估计大家都会等到黄花变成黄花菜了。 懒加载的原理是什么?页面中的img元素，如果没有src属性，浏览器就不会发出请求去下载图片，只有通过javascript设置了图片路径，浏览器才会发送请求。懒加载的原理就是先在页面中把所有的图片统一使用一张占位图进行占位，把正真的路径存在元素的“data-url”（这个名字起个自己认识好记的就行）属性里，要用的时候就取出来，再设置； 懒加载的实现步骤?1)首先，不要将图片地址放到src属性中，而是放到其它属性(data-original)中。2)页面加载完成后，根据scrollTop判断图片是否在用户的视野内，如果在，则将data-original属性中的值取出存放到src属性中。3)在滚动事件中重复判断图片是否进入视野，如果进入，则将data-original属性中的值取出存放到src属性中。 懒加载的优点是什么?页面加载速度快、可以减轻服务器的压力、节约了流量,用户体验好 题目1：如何判断一个元素是否出现在窗口可视范围（浏览器的上边缘和下边缘之间，肉眼可视）。写一个函数 isVisible实现123456789function isVisible($node)&#123; var scrollTop = $(window).scrollTop(); var windowHeight = $(window).height(); var offsetTop = $(this).offset().top; if (offsetTop &lt; scrollTop + windowHeight &amp;&amp; offsetTop &gt; scrollTop)&#123; return true; &#125; return false;&#125; 题目2：当窗口滚动时，判断一个元素是不是出现在窗口可视范围。每次出现都在控制台打印 true 。用代码实现12345$('div').on('scroll', function()&#123; if(isVisible($this))&#123; console.log(true) &#125;&#125;) 题目3：当窗口滚动时，判断一个元素是不是出现在窗口可视范围。在元素第一次出现时在控制台打印 true，以后再次出现不做任何处理。用代码实现1234567var flag = true;$('div').on('scroll', function()&#123; if(isVisible($this) &amp;&amp; flag === true)&#123; console.log(true); flag = false; &#125;&#125;) 题目4： 图片懒加载的原理是什么？为什么要懒加载（延迟）对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样子对于页面加载性能上会有很大的提升，也提高了用户体验。 原理页面中的img元素，如果没有src属性，浏览器就不会发出请求去下载图片，只有通过javascript设置了图片路径，浏览器才会发送请求。懒加载的原理就是先在页面中把所有的图片统一使用一张占位图进行占位，把正真的路径存在元素的“data-url”（这个名字起个自己认识好记的就行）属性里，要用的时候就取出来，再设置；1)首先，不要将图片地址放到src属性中，而是放到其它属性(data-original)中。2)页面加载完成后，根据scrollTop判断图片是否在用户的视野内，如果在，则将data-original属性中的值取出存放到src属性中。3)在滚动事件中重复判断图片是否进入视野，如果进入，则将data-original属性中的值取出存放到src属性中。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>image</tag>
        <tag>懒加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[完善的输入框监听方案]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F15%2F%E5%AE%8C%E5%96%84%E7%9A%84%E8%BE%93%E5%85%A5%E6%A1%86%E7%9B%91%E5%90%AC%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[文章分享了，如何一步步优化输入框的监听事件，以达到兼容、高效和组合输入友好等目标。 完善的输入框监听方案keyup监听输入框的输入，最原始的方法是使用keyup事件。不使用change事件，它只会在输入框失去焦点后被触发。此方式兼容性广，但效率较低，毕竟任意的按键都会触发该事件。 12345678&lt;input id=&quot;input&quot; type=&quot;text&quot; /&gt;&lt;script&gt; document.querySelector(&apos;#input&apos;) .addEventListener(&apos;keyup&apos;, function() &#123; console.log(&apos;value:&apos;, this.value); &#125;);&lt;/script&gt; input我们只希望当值发生变化后再触发监听，这样，input事件出现了。它只会在输入框的值发生变化后被触发，不过IE8及以下不支持该事件。 网上很多人使用IE独有的propertychange事件，作为替代input的方案，这里不推荐。一方面它会在任意属性值变化后被触发，没有专一性，不够语义，比较浪费。二方面网上都是用jQuery等工具库操作，比较简单，而我们的目的是用原生代码实现。三方面是不支持input事件的浏览器已经很少了，硬碰上了就用keyup对付。 12345678&lt;input id=&quot;input&quot; type=&quot;text&quot; /&gt;&lt;script&gt; document.querySelector(&apos;#input&apos;) .addEventListener(&apos;input&apos;, function() &#123; console.log(&apos;value:&apos;, this.value); &#125;);&lt;/script&gt; 接着上步，如何在不支持input事件时使用keyup事件呢？直接检测事件不太靠谱，可以利用input在keyup之前发生的性质，巧妙的实现此功能。 123456789101112131415161718&lt;input id=&quot;input&quot; type=&quot;text&quot; /&gt;&lt;script&gt; let inInputEvent = false; let input = document.querySelector(&apos;#input&apos;); input.addEventListener(&apos;keyup&apos;, function() &#123; if (inInputEvent) &#123; // You can remove keyup listener. &#125; else &#123; console.log(&apos;keyup:&apos;, this.value); &#125; &#125;); input.addEventListener(&apos;input&apos;, function() &#123; if (!inInputEvent) inInputEvent = true; console.log(&apos;input:&apos;, this.value); &#125;);&lt;/script&gt; 延迟函数在搜索功能中，理想化的情景是当用户全部输入后，再立即执行搜索。那么问题来了，如何在不需要用户点击搜索按钮的情况下，得知其过程的完成呢？没有办法。虽然没有办法，但有优化的方式：假定用户每个单词的输入间隔，以此时间延迟执行搜索功能。 12345678910111213141516171819202122英文一般为 300ms ，中文可设置成 500ms 。&lt;input id=&quot;input&quot; type=&quot;text&quot; /&gt;&lt;script&gt; let input = document.querySelector(&apos;#input&apos;); let trigger = createDelayFunction(console.log); input.addEventListener(&apos;input&apos;, function() &#123; trigger(this.value); &#125;); function createDelayFunction(fn, timeout = 300) &#123; let timeoutId = -1; return (...args) =&gt; &#123; clearTimeout(timeoutId); timeoutId = setTimeout(() =&gt; &#123; fn.apply(null, args); &#125;, timeout); &#125; &#125;&lt;/script&gt; composition中文、日文等需要借助输入法组合输入，即便是英文，现在也可借助组合输入进行选词等。实际中，我们希望将用户组合输入完的一段文字，而不是每输入一个字母，算做一次输入的完成。 组合输入事件应运而生，常用的是compositionstart（组输开始）和compositionend（组输结束）事件。结合组合事件不监听普通的输入，以及compositionstart发生在input事件之前，可以如此优化中文输入。 1234567891011121314151617&lt;input id=&quot;input&quot; type=&quot;text&quot; /&gt;&lt;script&gt; let inCompositionEvent = false; let input = document.querySelector(&apos;#input&apos;); input.addEventListener(&apos;input&apos;, function() &#123; !inCompositionEvent &amp;&amp; console.log(&apos;input&apos;, this.value); &#125;); input.addEventListener(&apos;compositionstart&apos;, function() &#123; inCompositionEvent = true; &#125;); input.addEventListener(&apos;compositionend&apos;, function() &#123; inCompositionEvent = false; console.log(&apos;composition&apos;, this.value); &#125;);&lt;/script&gt; 结合最后是结合以上几步生成一个融合方法，代码加示例：地址。 里面还做了些增强：比如监听函数返回的是一个，移除这一步所加的所有事件的方法。比如配置是否监听组合输入事件，因为好的搜索框会直接根据拼音开始搜索，无需等到汉字的形成。 代码使用ES6语法，需使用支持ES6的浏览器（Chrome最新版）或转码后才能使用，谅解。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768function listenInput(dom, callback, &#123; timeout = 300, useCompositionEvent = true&#125; = &#123;&#125;) &#123; let value = &apos;&apos;; let inInputEvent = false; let inCompositionEvent = false; let trigger = createDelayFunction(valueChanged, timeout); // Return a function that can remove listeners added here. return enabledEvent(dom); function valueChanged(val) &#123; if (val === value) &#123; return ; &#125; else &#123; value = val; &#125; callback(value, &#123; dom: dom &#125;); &#125; function enabledEvent(dom) &#123; dom.addEventListener(&apos;keyup&apos;, keyup); dom.addEventListener(&apos;input&apos;, input); useCompositionEvent &amp;&amp; dom.addEventListener(&apos;compositionstart&apos;, compositionstart); useCompositionEvent &amp;&amp; dom.addEventListener(&apos;compositionend&apos;, compositionend); return function() &#123; dom.removeEventListener(&apos;keyup&apos;, keyup); dom.removeEventListener(&apos;input&apos;, input); useCompositionEvent &amp;&amp; dom.removeEventListener(&apos;compositionstart&apos;, compositionstart); useCompositionEvent &amp;&amp; dom.removeEventListener(&apos;compositionend&apos;, compositionend); &#125;; function keyup() &#123; if (inInputEvent) &#123; dom.removeEventListener(&apos;keyup&apos;, keyup); &#125; else &#123; trigger(this.value); &#125; &#125; function input() &#123; if (!inInputEvent) inInputEvent = true; if (!inCompositionEvent) trigger(this.value); &#125; function compositionstart() &#123; inCompositionEvent = true; &#125; function compositionend() &#123; inCompositionEvent = false; trigger(this.value); &#125; &#125;&#125;function createDelayFunction(fn, timeout = 300) &#123; let timeoutId = -1; return (...args) =&gt; &#123; clearTimeout(timeoutId); timeoutId = setTimeout(() =&gt; &#123; fn.apply(null, args); &#125;, timeout); &#125;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>JavaScript</tag>
        <tag>input</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[去重计数]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F15%2F%E5%8E%BB%E9%87%8D%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[数组对象去重并且增加相同ID数量(购物车累积添加功能)123456789101112let usedCart = [&#123;id: 4, number: 2, data: &#123;&#125;&#125;, &#123;id: 4, number: 25, data: &#123;&#125;&#125;, &#123;id: 5, number: 2, data: &#123;&#125;&#125;,]for (let i = 0; i &lt; usedCart.length; i++) &#123; for (let j = i + 1; j &lt; usedCart.length; j++) &#123; if (usedCart[i].id === usedCart[j].id) &#123; usedCart[i].number += usedCart[j].number usedCart.splice(j, 1); j = j - 1; // 关键，因为splice()删除元素之后，会使得数组长度减小，此时如果没有j=j-1的话，会导致相同id项在重复两次以上之后无法进行去重，且会错误删除id没有重复的项。 &#125; &#125;&#125;console.log(usedCart)//[ &#123; id: 4, number: 27, data: &#123;&#125; &#125;,&#123; id: 5, number: 2, data: &#123;&#125; &#125; ] ES6去重计数方法123456789101112131415161718192021var arr = [1, 2, 3, 1, 2, 4];function arrayCnt(arr) &#123; var newArr = []; //使用set进行数组去重 newArr = [...new Set(arr)]; var newarr2 = new Array(newArr.length); for(var t = 0; t &lt; newarr2.length; t++) &#123; newarr2[t] = 0; &#125; for(var p = 0; p &lt; newArr.length; p++) &#123; for(var j = 0; j &lt; arr.length; j++) &#123; if(newArr[p] == arr[j]) &#123; newarr2[p]++; &#125; &#125; &#125; for(var m = 0; m &lt; newArr.length; m++) &#123; console.log(newArr[m] + "重复的次数为：" + newarr2[m]); &#125;&#125;arrayCnt(arr); ES5去重计数方法123456789101112131415161718192021222324var arr = [1, 2, 3, 1, 2, 4]; function arrayCnt(arr) &#123; var newArr = []; for(var i = 0; i &lt; arr.length; i++) &#123; if(newArr.indexOf(arr[i]) == -1) &#123; newArr.push(arr[i]) &#125; &#125; var newarr2 = new Array(newArr.length); for(var t = 0; t &lt; newarr2.length; t++) &#123; newarr2[t] = 0; &#125; for(var p = 0; p &lt; newArr.length; p++) &#123; for(var j = 0; j &lt; arr.length; j++) &#123; if(newArr[p] == arr[j]) &#123; newarr2[p]++; &#125; &#125; &#125; for(var m = 0; m &lt; newArr.length; m++) &#123; console.log(newArr[m] + "重复的次数为：" + newarr2[m]); &#125; &#125; arrayCnt(arr); 数组对象格式去重12345678910111213141516function arrayCnt(data) &#123; var arr = []; for (let val of data) &#123; arr.push(val.id) &#125; console.log(arr) var newArr = []; var newArr2 = []; for (let i= 0; i &lt; arr.length; i++) &#123; if (newArr.indexOf(arr[i]) === -1) &#123; newArr.push(arr[i]); newArr2.push(data[i]); &#125; &#125; return newArr2&#125; reduce去重标记12345678910111213141516let data = [ &#123; id: 201801, name: '张三', age: 15, &#125;, &#123; id: 201804, name: 'John', age: 18, &#125;, &#123; id: 201802, name: '李四', age: 18, &#125;, &#123; id: 201801, name: '张三', age: 15, &#125;, &#123; id: 201805, name: 'Jack', age: 18, &#125;, &#123; id: 201803, name: '王五', age: 10, &#125;, &#123; id: 201805, name: 'Jack', age: 18, &#125;, &#123; id: 201804, name: 'John', age: 18, &#125;, &#123; id: 201805, name: 'Jack', age: 18, &#125;, ];let hash = &#123;&#125;; data = data.reduce((preVal, curVal) =&gt; &#123; hash[curVal.id] ? '' : hash[curVal.id] = true &amp;&amp; preVal.push(curVal); return preVal &#125;, []) reduce实现原理]]></content>
      <categories>
        <category>JavaScript</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>去重</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型链]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F15%2F%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[原型链核心概念就是 利用原型让一个引用类型继承另一个引用类型的属性和方法 12345678910function Person(nick, age)&#123; this.nick = nick; this.age = age;&#125;Person.prototype.sayName = function()&#123; console.log(this.nick);&#125;var p1 = new Person();p1.sayName(); 大概过程是这样的 记当前对象为obj，查找obj属性、方法，找到后返回 没有找到，通过obj的proto属性，找到其类型Array的prototype属性（记为prop）继续查找，找到后返回 没有找到，把prop记为obj做递归重复步骤一，通过类似方法找到prop的类型Object的 prototype进行查找，找到返回 理一理原型链在Javascript中，大致存在两种对象：普通对象和函数对象。一般而言，通过new Function()创建的对象是函数对象，其他的是函数对象。 123456// afunction func1() &#123;&#125;// bvar func2 = function() &#123;&#125;// cvar func3 = new Function() a和b在创建的时候，JS会自动通过new Function()来创建对象，所以a，b，c都是通过new Function()创造的函数对象。 123456// o1var o1 = &#123;&#125;// o2var o2 = new Object();// o3var o3 = new func1(); o1, o2是使用对象字面量的形式创建的普通对象。o3不是通过new Function()的形式创建的对象，所以也是普通对象。 每当创建函数对象时，该对象中都会内置一些属性，其中包括prototype和[object Object]。prototype即为原型对象其内记录着函数对象的一些属性和方法。 1234function f1() &#123;&#125;f1.prototype.foo = "bar";console.log(f1.prototype); // Object &#123;foo: "bar", constructor: function&#125;console.log(f1.foo); // undefined prototype对f1不可见。也就是说，f1在调用自身属性或方法时不会查找prototype内的属性和方法。prototype的主要作用是继承。prototype内定义的属性和方法都是留给自己的后代使用的。说到后代，就必须说说js中的原型链。此时，另一个属性[object Object]就登场了。[object Object]的作用是保留父类的prototype对象。js在使用new表达式创建对象时，会将父类的prototype赋值给新对象的[object Object]（也可以理解为：新实例的 [object Object]属性指向了父类的 prototype）。这样就形成了代代继承。 那么f1的prototype的proto又是什么呢？ 12console.log(f1.prototype.__proto__ == Object.prototype); // trueconsole.log(Object.prototype.__proto__); // null 可以看出，f1的prototype的[object Object]指向了Object的prototype，而Object的prototype的[object Object]为null。 总结： 原型链真正的形成靠的是[object Object]而非prototype。js在执行对象方法时会查找对象自身是否有该方法，如果不存在，会在原型链上找而不会在自身的prototype上找。 如果[object Object]改变则整条原型链都会发生改变，等于改变了对象的数据类型。 函数的prototype不属于自身的原型链。 在原型对象(prototype)上定义方法和属性是为了被子类继承和调用。 参考 继承 继承是指一个对象直接使用另一对象的属性和方法。 JavaScript并不提供原生的继承机制，我们自己实现的方式很多，介绍一种最为通用的 通过上面定义，可以看出如果实现了 两点 的话就可以说实现了继承 得到一个类的属性 得到一个类的方法 我们分开讨论一下，先定义两个类 12345678910111213141516function Person(name, sex)&#123; this.name = name; this.sex = sex;&#125;Person.prototype.printName = function()&#123; console.log(this.name);&#125;;function Male(age)&#123; this.age = age;&#125;Male.prototype.printAge = function()&#123; console.log(this.age);&#125;; 属性获取对象属性的获取是通过构造函数的执行，我们在一个类中执行另外一个类的构造函数，就可以把属性赋值到自己内部，但是我们需要把环境改到自己的作用域内，这就要借助 call 了 改造一下 Male12345678function Male(name, sex, age)&#123; Person.call(this, name, sex); this.age = age;&#125;Male.prototype.printAge = function()&#123; console.log(this.age);&#125;; 实例化看看结果 12var m = new Male('Byron', 'male', 26);console.log(m.sex); // "male" 方法获取我们知道类的方法都定义在了prototype里面，所以只要我们把子类的 prototype 改为父类的 prototype的备份就好了 1Male.prototype.__proto__ = Person.prototype; 这样写可以达到效果，可是 [object Object]不是一个规范中的方法，所以我们用下面的方法。 1Male.prototype = Object.create(Person.prototype); 这里我们通过 Object.create clone了一个新的 prototype 而不是直接把 Person.prtotype 直接赋值。这是因为引用类型的关系，会导致后续修改子类的 prototype 也修改了父类的 prototype ，因为修改的是同一个值。 另外Object.create是ES5方法，兼容可以使用下面的方式实现 12345function object (o)&#123; function f()&#123;&#125;; f.prototype = o; return new f();&#125; 还有需要注意一点就是对子类添加方法，必须在修改其 prototype 之后，如果在之前会被覆盖掉 1234Male.prototype.printAge = function()&#123; console.log(this.age);&#125;;Male.prototype = Object.create(Person.prototype); 这样的话，printAge 方法在修改 prototype 后就没了，因此得这么写 12345678910function Male(name, sex, age)&#123; Person.call(this, name, sex); this.age = age;&#125;Male.prototype = Object.create(Person.prototype);Male.prototype.printAge = function()&#123; console.log(this.age);&#125;; 这样写貌似没问题了，但是还有个问题：就是我们知道 prototype 对象有一个属性 constructor 指向其类型，因为我们复制的父元素的prototype，这时候constructor属性指向是不对的，导致我们判断类型出错 1Male.prototype.constructor; //Person 因此我们需要再重新指定一下 constructor 属性到自己的类型 可以通过一个函数实现 12345function inherit(superType, subType)&#123; var _prototype = Object.create(superType.prototype); _prototype.constructor = subType; subType.prototype = _prototype;&#125; 最终方案学名为 寄生组合式继承 1234567891011121314151617181920212223function Person(name, sex)&#123; this.name = name; this.sex = sex;&#125;Person.prototype.printName = function()&#123; console.log(this.name);&#125;; function Male(name, sex, age)&#123; Person.call(this, name, sex); // 属性使用call来获取 this.age = age;&#125;inherit(Person, Male); // 方法通过修改 子类的原型 是 父类原型的备份// 在继承函数之后写自己的方法，否则会被覆盖Male.prototype.printAge = function()&#123; console.log(this.age);&#125;;var m = new Male('Byron', 'm', 26);m.printName(); 这样我们就在JavaScript中实现了继承 其实还有组合继承 12345678910111213141516171819202122function Mother (age) &#123; this.age = age; this.hobby = ['running','football']&#125;Mother.prototype.showAge = function () &#123; console.log(this.age);&#125;;function Person (name, age) &#123; Mother.call(this, age); //第二次执行 this.name = name;&#125;Person.prototype = new Mother(); //第一次执行Person.prototype.constructor = Person;Person.prototype.showName = function () &#123; console.log(this.name);&#125;var p1 = new Person('Jack', 20);p1.hobby.push('basketball'); //p1:'Jack'; __proto__:20,['running','football']var p2 = new Person('Mark', 18); //p2:'Mark'; __proto__:18,['running','football'] 通过第二次执行原型的构造函数 Mother()，我们在对象实例中复制了一份原型的属性，这样就做到了与原型属性的分离独立。细心的你会发现，我们第一次调用 Mother()，好像什么用都没有呢，能不调用他吗？可以，所以才有了上面介绍的寄生组合式继承 在寄生组合式继承里面，关键点在于 Object.create(o) ，它借用了一个临时对象来巧妙避免了调用 new Mother() ，然后将原型为 o 的新对象实例返回，从而完成了原型链的设置。很绕，对吧，那是因为我们不能直接设置 Person.prototype = Mother.prototype 啊。不然修改Person.prototype 也会影响Mother.prototype。 function hasOwnProperty() { [native code] }hasOwnPerperty是Object.prototype的一个方法，可以判断一个对象是否包含自定义属性而不是原型链上的属性，hasOwnProperty是JavaScript中唯一一个处理属性但是不查找原型链的函数 123m.hasOwnProperty('name'); // truem.hasOwnProperty('printName'); // falseMale.prototype.hasOwnProperty('printAge'); // true 获取原型对象方法的比较获取实例对象obj的原型对象，有三种方法。 obj.__proto__ obj.constructor.prototype Object.getPrototypeOf(obj) 上面三种方法之中，前两种都不是很可靠。最新的ES6标准规定，[object Object]属性只有浏览器才需要部署，其他环境可以不部署。而obj.constructor.prototype在手动改变原型对象时，可能会失效。所以，推荐使用第三种Object.getPrototypeOf方法，获取原型对象。 Array.prototype.slice vs [].slice 速度测试，明显前者快的多，尽量用前者https://jsperf.com/array-prototype-slice-vs-slice Array.prototype.slice可以被重写，[].slice实际用的是Array.prototype.slice，但不能显式修改[].slice，[]中ownpropertity只有length一个属性 原型链相关问题问题7：有如下代码，解释Person、 prototype、[object Object]、p、function Object() { [native code] }之间的关联。1234567891011121314151617function Person(name)&#123; this.name = name;&#125;Person.prototype.sayName = function()&#123; console.log('My name is :' + this.name);&#125;var p = new Person("若愚")p.sayName();p.__proto__ === Person.prototype//truep.constructor === Person//truep.constructor.prototype === Person.prototype//truep.sayName === Person.prototype.sayName//true 问题8： 上例中，对 对象 p可以这样调用 p.toString()。toString是哪里来的? 画出原型图?并解释什么是原型链。p的toString方法是从原型链上的 Object的原型 继承来的 问题9：对String做扩展，实现如下方式获取字符串中频率最高的字符1234567891011121314151617181920212223var str = 'ahbbccdeddddfg';String.prototype.getMostOften = function () &#123; var hash = &#123;&#125;; var max = 0; var maxChar for (var i=0; i&lt;this.length; i++)&#123; var key = this[i]; if (key in hash)&#123; hash[key] += 1; &#125;else &#123; hash[key] = 1; &#125; &#125; for (key in hash)&#123; if (hash[key] &gt; max)&#123; max = hash[key] maxChar = key; &#125; &#125; return maxChar&#125;var ch = str.getMostOften();console.log(ch); //d , 因为d 出现了5次 问题10： instanceOf有什么作用？内部逻辑是如何实现的？instanceOf方法判断一个对象是否为另一个对象的实例 12345678910function instanceOf(L, R) &#123; //L 表示左表达式，R 表示右表达式 var S = R.prototype; L = L.__proto__; while (true) &#123; if (L === null) return false; if (S === L) // 当 S 严格等于 L 时，返回 true return true; &#125;&#125; 继承相关问题问题11：继承有什么作用?子类可以拥有父类的属性和方法，也可以定义自身的属性和方法。子类可以重写和扩展继承父类的属性和方法，又不影响父类。 问题12： 下面两种写法有什么区别?123456789//方法1function People(name, sex)&#123; this.name = name; this.sex = sex; this.printName = function()&#123; console.log(this.name); &#125;&#125;var p1 = new People('饥人谷', 2) 12345678910//方法2function Person(name, sex)&#123; this.name = name; this.sex = sex;&#125;Person.prototype.printName = function()&#123; console.log(this.name);&#125;var p1 = new Person('若愚', 27); 方法1的printName方法是在函数Person实例对象里的，而方法2是在Person的prototype对象上的。当再创建一个Person实例对象的时候，方法1又将会再创建一个printName方法，占用新的内存。而方法2将一个公用的printName方法写在原型上，当对象要使用该方法只需到原型链里调用就可以了，达到节省内存的效果。 问题13： Object.create 有什么作用？兼容性如何？Object.create() 方法会创建一个 使用指定原型对象 的 新对象 可以使用 Object.create 实现类式继承 IE9 及其以上 问题14： hasOwnProperty有什么作用？ 如何使用？hasOwnProperty() 方法会返回一个布尔值，指示对象是否具有指定的属性作为自身（不继承）属性。 123456789101112function Person(sex,age)&#123; this.sex=sex; this.age=age;&#125;Person.prototype.say=function()&#123; console.log("I say");&#125;var p=new Person("man",11);p.hasOwnProperty("sex")//truep.hasOwnProperty("say")//falsePerson.prototype.hasOwnProperty("say")//true 问题15：如下代码中call的作用是什么?12345678function Person(name, sex)&#123; this.name = name; this.sex = sex;&#125;function Male(name, sex, age)&#123; Person.call(this, name, sex); //这里的 call 有什么作用 this.age = age;&#125; 通过 call，使 Male 实例也有了 Person 的属性(也可以方法） 问题16： 补全代码，实现继承12345678910111213141516171819function Person(name, sex)&#123; this.name = name; this.sex = sex;&#125;Person.prototype.getName = function()&#123; console.log(this.name)&#125;;function Male(name, sex, age)&#123; Person.call(this, name, sex); this.age = age;&#125;Male.prototype = Object.create(Person.prototype);Male.prototype.constructor = Male;Male.prototype.getAge = function()&#123; console.log(this.age)&#125;;var ruoyu = new Male('若愚', '男', 27);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Prototype</tag>
        <tag>原型链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数function]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F15%2F%E5%87%BD%E6%95%B0function%2F</url>
    <content type="text"><![CDATA[函数声明函数的三种方式 构造函数，使用new来创建一个函数对象 函数声明 //声明可以放在调用之前，任何地方 函数表达式 //声明必须放在调用之后。和变量声明没差别 声明函数是不执行的，调用才执行 返回值 有时候我们希望在函数执行后得到一个结果供别人使用，可以通过return来实现 执行完return语句之后停止并立即推出函数 如果不写，也会默认返回undefined 声明前置 var 和 function 的声明前置在同一个作用域下，var 声明的变量和function 声明的函数会前置 123456789console.log(a); //undefinedvar a = 3;console.log(a); //3sayHello();function sayHello()&#123; console.log('hello');&#125; 函数表达式函数表达式和 var 一个变量没什么区别 123console.log(fn); //undefinedfn(); //报错var fn = function()&#123;&#125; 作用域在 JS 中只有函数作用域，没有块作用域 执行环境 EC定义了变量或函数有权访问的其他数据，决定了它们各自的行为。 作用域链的作用是保证对执行环节有权访问的所有变量和函数的有序访问。 全局执行环境的变量对象始终的都是作用域链中的最后一个对象。 内部环境可以通过作用域链访问外部环境，但外部环境无法访问内部环境的任何变量和函数。 1. 函数声明和函数表达式有什么区别 函数声明可以放在任何地方 函数表达式的声明必须放在调用之前，和var一个变量没区别 2. 什么是变量的声明前置？什么是函数的声明前置 变量的声明前置：JavaScript引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，然后给他初始值undefined，然后才逐句执行程序，这就叫做“变量提升”，也即“变量的声明前置”。 函数的声明前置：如果使用函数表达式声明函数，前置类似变量的声明前置；如果使用函数声明，那么即使函数写在最后也可以在前面语句调用，前提是函数声明部分已经被下载到本地。 3. arguments 是什么argument类数组对象，可以用来获取函数传入的所有参数。 4. 函数的”重载”怎样实现一些强语言类型的语言，不同的函数声明方式，不同的传参类型声明的同名函数，调用时，会根据传参的类型自动匹配合适的函数，称为函数重载JS属于弱语言，没有重载，同名函数，后声明的会覆盖前面声明的；但是可以模拟重载，声明函数时，判断传入参数符合的条件，执行该条件下的函数体；以达到，函数调用时传入不同参数，得到不同的结果。 5. 立即执行函数表达式是什么？有什么作用 立即执行函数表达式有多种写法：(function(){})(); , 或 (function(){}()); ,或 !function(){}(); ,或 void function(){}(); , 如下图所示: 作用： 创建独立作用域,内部保存一些大量临时变量的代码防止命名冲突。 一些库的外层用这种形式包起来防止作用域污染。 运行一些只执行一次的代码。 6. 求n!，用递归来实现 自己调用自己 设定终止条件 优点: 算法简单 缺点: 效率低 12345678910111213141516171819function factorial (n) &#123; if (n &lt; 0 )&#123; return "负数没有阶乘" &#125; else if (n ===1 || n === 0)&#123; return 1; &#125; else return n*factorial(n-1);&#125;factorial(5)//120factorial(0)//1factorial(2)//2factorial(1)//1factorial(-1)//"负数没有阶乘" 7. 以下代码输出什么？12345678910111213141516171819202122232425262728 function getInfo(name, age, sex)&#123; console.log('name:',name); console.log('age:', age); console.log('sex:', sex); console.log(arguments); arguments[0] = 'valley'; console.log('name', name); &#125;getInfo('饥人谷', 2, '男');// name: 饥人谷 age: 2 sex: 男 ["饥人谷", 2, "男"] name valley getInfo('小谷', 3);// name: 小谷 age： 3 sex: undefined ["小谷"，3] name valleygetInfo('男');// name: 男 age:undefined sex:undefined ["男"] name valley 8. 写一个函数，返回参数的平方和？1234567891011function sumOfSquares()&#123; var sum = 0; for(i=0;i&lt;arguments.length;i++)&#123; sum += arguments[i]*arguments[i]; &#125; return sum ;&#125;var result = sumOfSquares(2,3,4)var result2 = sumOfSquares(1,3)console.log(result) //29console.log(result2) //10 9. 如下代码的输出？为什么123console.log(a);//undefined 变量a声明提前了，因此是undefinedvar a = 1;console.log(b); //b is not defined b没声明定义就直接用了 10. 如下代码的输出？为什么12345678sayName('world');//hello world函数声明的函数调用可以放在函数声明前sayAge(10);//报错 函数表达式声明的函数 必须是声明在前，调用在后function sayName(name)&#123; console.log('hello ', name);&#125;var sayAge = function(age)&#123; console.log(age);&#125;; 11. 如下代码输出什么? 写出作用域链查找过程伪代码123456789var x = 10bar() function foo() &#123; console.log(x)&#125;function bar()&#123; var x = 30 foo()&#125; 123456789101112131415161718192021222324//10//console.log(x)执行时，先在fooContext.AO里面查找X，没有；继续在Scope: foo.[[scope]] // 指向globalContext.AO中查找，得X=10；所以输出结果为10。1. globalContext = &#123; AO: &#123; x:10 bar: function foo: funciton &#125;, Scope: null&#125;bar.[[scope]]= globalContext.AOfoo.[[scope]]= globalContext.AO2. barContext = &#123; AO: &#123; x: 30 &#125;, Scope: bar.[[scope]] = globalContext.AO&#125;3. fooContext = &#123; AO: &#123;&#125;, Scope: foo.[[scope]] = globalContext.AO&#125; 12. 如下代码输出什么? 写出作用域链查找过程伪代码123456789var x = 10;bar() function bar()&#123; var x = 30; function foo()&#123; console.log(x) &#125; foo();&#125; 12345678910111213141516171819202122232425//30//console.log(x)执行时，先在fooContext.AO里面查找，没有；继续在Scope: foo.[[scope]] = barContext.AO里面查找，得到X=30，所以输出30.1. globalContext = &#123; AO: &#123; x: 10 bar: function &#125;, Scope: null&#125;bar.[[scope]] = globelContext.AO2. barContext = &#123; AO: &#123; x: 30 foo: function &#125;, Scope: bar.[[scope]] = globalContext.AO&#125;foo.[[scope]] = barContext.AO3. fooContext = &#123; AO: &#123;&#125;, scope: foo.[[scope]] = barContext.AO&#125; 13. 以下代码输出什么? 写出作用域链的查找过程伪代码12345678var x = 10;bar() function bar()&#123; var x = 30; (function ()&#123; console.log(x) &#125;)()&#125; 123456789101112131415161718192021222324//30//console.log(x)执行时，先在functionContext.AO里面查找，无X；继续在Scope: function.[[scope]] = barContext.AO里面查找，得X=30，所以输出结果为30。1. globalContext = &#123; AO: &#123; x:10 bar: function &#125;, Scope: null&#125;bar.[[scope]] = globalContext.AO2. barContext = &#123; AO: &#123; x: 30 function &#125;, Scope: bar.[[scope]]&#125;function.[[scope]] = barContext.AO3. functionContext = &#123; AO: &#123;&#125;, Scope: funcion.[[scope]] = barContext.AO&#125; 14. 以下代码输出什么？ 写出作用域链查找过程伪代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758var a = 1;function fn()&#123; console.log(a) var a = 5 console.log(a) a++ var a fn3() fn2() console.log(a) function fn2()&#123; console.log(a) a = 20 &#125;&#125;function fn3()&#123; console.log(a) a = 200&#125;fn()console.log(a)//undefined, 5, 1, 6, 20, 2001.globalContext = &#123; AO: &#123; a: 1 ==&gt;a: 200 fn: function fn3: function &#125;, Scope: null&#125;fn.[[scope]] = globalContext.AOfn3.[[scope]] = globalContext.AO2.fn()fnContext = &#123; AO: &#123; a: undefined(输出：undefined)==&gt;5(输出：5)==&gt;6 fn2: function &#125;, Scope: fn.[[scope]] = globalContext.AO&#125;fn2.[[scope]] = fnContext.AO3.fn3()fn3Context = &#123; AO: &#123;&#125;, Scope: fn3.[[scope]] = globalContext.AO&#125;输出：14.fn2()fn2Context = &#123; AO: &#123; a:输出：6 ==&gt;a: 20(输出：20) &#125;, Scope: fn2.[[scope]] = fnContext.AO&#125;5.console.log(a) 输出：200]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this关键字]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F15%2Fthis%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[this 关键字先看这几本相对权威的JS书籍关于 this 的描述 《Javascript权威指南》：如果嵌套函数作为函数调用，其this值是全局对象（非严格模式下）或是undefined（严格模式下）;如果嵌套函数作为方法调用，其this值指向调用它的对象。 《JavaScript高级程序设计》：在全局函数中，this等于window，而当函数被作为某个对象的方法调用时，this等于那个对象。另外，匿名函数的执行环境具有全局性，因此this对象通常指向window 《你不知道的JavaScript - 上卷》：this 的绑定类型分为了 默认绑定，隐式绑定，显式绑定，new绑定 对于this的理解分很多种以我的理解， 默认绑定： 就是 全局 &amp; 调用普通函数 隐式绑定： 就是 函数作为对象的一个属性，并且作为对象的一个属性被调用时 显式绑定： 就是 函数用call或者apply调用 new绑定： 就是 new构造函数 分别说明一下 默认绑定在代码中foo()是直接使用不带任何修饰的函数引用进行调用的，采用默认绑定。简单说就是 全局 &amp; 调用普通函数 在全局环境下，this永远是window，这个应该没有非议普通函数在调用时，其中的this也都是window。 12345var x = 10;function foo()&#123; console.log( this.x ) // 10&#125;foo() 以上代码很好理解。 不过下面的情况你需要注意一下： 1234567891011var obj = &#123; x: 10, foo: function()&#123; function fn()&#123; console.log( this ) //window console.log( this.x ) //undefined &#125; fn() &#125;&#125;obj.foo() 函数f虽然是在obj.fn内部定义的，但是它仍然是一个普通的函数，this仍然指向window。换个说法：函数嵌套产生的内部函数的this不是其父函数，仍然是全局变量 另外 创建了一个函数的间接引用，也会应用默认绑定 隐式绑定规则是 调用位置是否有上下文对象，或者说是被某个对象拥有或者包含。 简单地说就是 如果函数作为对象的一个属性时，并且 作为对象的一个属性被调用时，函数中的this指向该对象 12345678var obj =&#123; x: 10, foo: function () &#123; console.log(this) //obj console.log(this.x) //10 &#125;&#125;obj.foo() 以上代码中，fn不仅作为一个对象的一个属性，而且的确是作为对象的一个属性被调用。结果this就是obj对象。 注意，如果fn函数不作为obj的一个属性被调用，结果就不同了123456789var obj =&#123; x: 10, foo: function () &#123; console.log(this) //window console.log(this.x) //undefined &#125;&#125;var foo1 = obj.foofoo1() 以上代码，如果fn函数被赋值到了另一个变量中，并没有作为obj的一个属性被调用，它引用的是foo函数本身,内部的this就会指向foo运行时所在的对象（本例是顶层对象）。( 因此采用默认绑定，那么this的值就是window，this.x为undefined。（被称作隐式丢失）) 如果某个方法位于多层对象的内部，这时this只是指向当前一层的对象，而不会继承更上面的层12345678910var a = &#123; p: 'Hello', b: &#123; m: function() &#123; console.log(this.p); &#125; &#125;&#125;;a.b.m() // undefined 上面代码中，a.b.m方法在a对象的第二层，该方法内部的this不是指向a，而是指向a.b。这是因为实际执行的是下面的代码。 1234567891011var b = &#123; m: function() &#123; console.log(this.p);&#125;;var a = &#123; p: 'Hello', b: b&#125;;(a.b).m() // 等同于 b.m() 如果要达到预期效果，只有写成下面这样。 12345678var a = &#123; b: &#123; m: function() &#123; console.log(this.p); &#125;, p: 'Hello' &#125;&#125;; 如果这时将嵌套对象内部的方法赋值给一个变量，this依然会指向全局对象。 1234567891011var a = &#123; b: &#123; m: function() &#123; console.log(this.p); &#125;, p: 'Hello' &#125;&#125;;var hello = a.b.m;hello() // undefined 上面代码中，m是多层对象内部的一个方法。为求简便，将其赋值给hello变量，结果调用时，this指向了顶层对象。为了避免这个问题，可以只将m所在的对象赋值给hello，这样调用时，this的指向就不会变。 12var hello = a.b;hello.m() // Hello 另外说明一下 关于foo函数的声明方式1234567function foo()&#123; alert(this.x);&#125;var obj = &#123;&#125;;obj.x = 1;obj.m = foo;obj.m(); // 1 虽然严格意义上函数foo不属于obj对象。但是 调用位置会使用obj上下文来引用函数，因此可以说是函数被调用时，obj对象拥有它或者包含它 显式绑定JS提供了两个方法，call(..)和apply(..)它们的第一个参数是一个对象，是给this准备的，接着在调用函数时将其绑定到this。因为可以直接指定this的绑定对象，所以称之为this。 简单地说 当一个函数被call和apply调用时，this就是传入的对象 12345678var obj = &#123; x: 10&#125;;var fpo = function () &#123; console.log(this) //obj console.log(this.x) //10&#125;foo.call(obj) （如果传入了原始值来当做this的绑定对象，这个原始值会转化成它的对象形式，也就是new String()、new Boolean()、new Numbe()，通常被称为装箱） 另外 如果把 null 或 undefined 作为this的绑定对象传入 call、apply、bind ，这些值在调用时会忽略，实际应用的是默认绑定规则 new 绑定所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this就指这个新对象。其实严格来说，所有的函数都可以new一个对象，但是有些函数的定义是为了new一个对象，而有些函数则不是。另外注意，约定构造函数的函数名第一个字母大写。 使用new来调用函数，会自动执行下面的操作 创建（构造）一个全新的对象 这个新对象会被执行[[Prototype]] 这个新对象会绑定到函数调用的this 如果函数没有返回其他对象，那么new表达式的函数调用会自动返回这个新对象 优先级判断this根据四种规则的优先级，来判断函数在某个位置应用的是哪条规则 函数是否在 new 中调用，是的话this绑定的是新创建的对象 函数是否通过 call、apply 调用，是的话this绑定的是指定的对象 函数是否在某个上下文对象中调用，是的话this绑定的是哪个上下文对象 如果都不是的话，采用默认绑定，非严格模式下绑定到全局对象，严格模式是undefined 匿名函数的this指向请看下面的代码。 1234567var obj =&#123; foo: function () &#123; console.log(this); &#125;&#125;;obj.foo() // obj 上面代码中，obj.foo方法执行时，它内部的this指向obj。 但是，只有这一种用法（直接在obj对象上调用foo方法），this指向obj；其他用法时，this都指向代码块当前所在对象（浏览器为window对象）。 12345678// 情况一(obj.foo = obj.foo)() // window// 情况二(false || obj.foo)() // window// 情况三(1, obj.foo)() // window 上面代码中，obj.foo先运算再执行，即使值根本没有变化，this也不再指向obj了。这是因为这时它就脱离了运行环境obj，而是在全局环境执行。 可以这样理解，在 JavaScript 引擎内部，obj和obj.foo储存在两个内存地址，简称为M1和M2。只有obj.foo()这样调用时，是从M1调用M2，因此this指向obj。但是，上面三种情况，都是直接取出M2进行运算，然后就在全局环境执行运算结果（还是M2），因此this指向全局环境。 上面三种情况等同于下面的代码。 123456789101112131415161718// 情况一(obj.foo = function () &#123; console.log(this);&#125;)()// 等同于(function () &#123; console.log(this);&#125;)()// 情况二(false || function () &#123; console.log(this);&#125;)()// 情况三(1, function () &#123; console.log(this);&#125;)() 其实可以简单认为 匿名函数的this指向就是window DOM对象绑定事件在事件处理程序中this代表事件源DOM对象（低版本IE有bug，指向了window） ES6 箭头函数稍待补充 函数的执行环境JavaScript中的函数既可以被当作普通函数执行，也可以作为对象的方法执行，这是导致 this 含义如此丰富的主要原因 一个函数被执行时，会创建一个执行环境（ExecutionContext），函数的所有的行为均发生在此执行环境中，构建该执行环境时，JavaScript 首先会创建 arguments变量，其中包含调用函数时传入的参数 接下来创建作用域链，然后初始化变量。首先初始化函数的形参表，值为 arguments变量中对应的值，如果 arguments变量中没有对应值，则该形参初始化为 undefined。 如果该函数中含有内部函数，则初始化这些内部函数。如果没有，继续初始化该函数内定义的局部变量，需要注意的是此时这些变量初始化为 undefined，其赋值操作在执行环境（ExecutionContext）创建成功后，函数执行时才会执行，这点对于我们理解JavaScript中的变量作用域非常重要，最后为this变量赋值，会根据函数调用方式的不同，赋给this全局对象，当前对象等 至此函数的执行环境（ExecutionContext）创建成功，函数开始逐行执行，所需变量均从之前构建好的执行环境（ExecutionContext）中读取 三种变量 实例变量：（this）类的实例才能访问到的变量 静态变量：（属性）直接类型对象能访问到的变量 私有变量：（局部变量）当前作用域内有效的变量 看个例子 123456789101112131415function ClassA()&#123; var a = 1; //私有变量，只有函数内部可以访问 this.b = 2; //实例变量，只有实例可以访问&#125;ClassA.c = 3; // 静态变量，也就是属性，类型访问console.log(a); // errorconsole.log(ClassA.b) // undefinedconsole.log(ClassA.c) //3var classa = new ClassA();console.log(classa.a);//undefinedconsole.log(classa.b);// 2console.log(classa.c);//undefined call、apply、bind详解[《JavaScript 标准参考教程（alpha）》，by 阮一峰 ](http://javascript.ruanyifeng.com/oop/this.html#toc3) bind()的polyfill实现12345678910if (!Function.prototype.bind)&#123; Function.prototype.bind = function () &#123; var fn = this; var context = arguments[0]; var args = Array.prototype.slice.call(arguments, 1); return function () &#123; return fn.apply(context, args) &#125; &#125;&#125; 总结JavaScript 语言之中，一切皆对象，运行环境也是对象，所以函数都是在某个对象之中运行，this就是这个对象（环境）。但是 JavaScript 支持运行环境动态切换，也就是说，this的指向是动态的，没有办法事先确定到底指向哪个对象 参考资料书籍：《你不知道的JavaScript——上卷》[this 关键字 《JavaScript 标准参考教程（alpha）》，by 阮一峰 ](http://javascript.ruanyifeng.com/oop/this.html) this 相关问题问题1： apply、call 、bind有什么作用，什么区别 call:调用一个函数，传入第一个参数作为函数的this，随后的参数作为argumenst传入 apply:调用一个函数，传入第一个参数作为函数的this，第二个参数为一个数组，数组内为要传入的参数 bind:返回一个函数，传入第一个参数作为函数的this，第二个开始作为函数的参数 区别： apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文； apply 、 call 、bind 三者都可以利用后续参数传参； bind 是返回对应函数，便于稍后调用 ；apply 、call 则是立即调用 。即当你希望改变上下文环境之后并非立即执行，而是回调执行的时候，使用 bind() 方法，而 apply/call 则会立即执行函数。 问题2： 以下代码输出什么?123456789var john = &#123; firstName: "John" &#125;function func() &#123; alert(this.firstName + ": hi!")&#125;john.sayHi = funcjohn.sayHi()// John : hi! 问题3： 下面代码输出什么，为什么12345func() function func() &#123; alert(this)&#125;// window 问题4：下面代码输出什么12345678document.addEventListener('click', function(e)&#123; console.log(this); setTimeout(function()&#123; console.log(this); &#125;, 200);&#125;, false);//document//window 问题5：下面代码输出什么，why12345678910var john = &#123; firstName: "John" &#125;function func() &#123; alert( this.firstName )&#125;func.call(john)// John// call 传入函数执行上下文，this指向了john对象 问题6： 以下代码有什么问题，如何修改123456789101112var module= &#123; bind: function()&#123; $btn.on('click', function()&#123; console.log(this) //this指什么 this.showMsg(); &#125;) &#125;, showMsg: function()&#123; console.log('饥人谷'); &#125;&#125; 修改 12345678910111213var module= &#123; bind: function()&#123; var _this = this //_this = this,强制指向obj $btn.on('click', function()&#123; console.log(this) _this.showMsg(); &#125;) &#125;, showMsg: function()&#123; console.log('饥人谷'); &#125;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JavaScirpt</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PC阻止滚动事件]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F15%2FPC%E9%98%BB%E6%AD%A2%E6%BB%9A%E5%8A%A8%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[pc阻止滚动事件虽然这样可以阻止滚动事件但是无法删除滚动事件,原因是无法删除对应匿名函数12345678window.addEventListener("wheel",function(e)&#123; e.preventDefault(0;&#125;)window.addEventListener("keydown",function(e)&#123; if(e.key == "ArrowDown" || e.key == "ArrowUp")&#123; e.preventDefault(); &#125;&#125;) 正确添加删除阻止滚动事件1234567let cancelScroll = function (event) &#123; event.preventDefault()&#125; window.addEventListener('wheel',cancelScroll) window.addEventListener('keydown',cancelScroll) window.removeEventListener('wheel',cancelScroll) window.removeEventListener('keydown',cancelScroll) 移动端方法方案一：控制overflow禁止滚动（ios不兼容）要制作这个效果在PC端非常简单，只需要设置html的高度为100%占满屏幕，并且将html的overflow设置为hidden，即可保证页面不可滚动。但是同样的问题在移动端情况就有所区别。仅仅设置html的上列属性，在移动端仍然无法禁止页面超出部分的滚动，我们需要设置下面的代码才能在弹框出现的时候禁止页面滚动： html.style.overflow=”hidden”;html.style.height=”100%”;body.style.overflow=”hidden”;body.style.height=”100%”;1234原因是因为移动端是基于touch事件，要禁止基于touch事件的滚动，我们必须在对html禁止滚动的基础之上，再将需要禁止滚动的内容上再增加一个包裹层块级元素，然后将这个包裹层块级元素高度设置为100%并设置overflow:hidden;，那么在这里我们认为body包裹了整个页面，正是我们需要的块级元素，将他也设置为禁止滚动，就可以保证移动端页面的滑动时间不会触发页面滚动。当用户关闭了弹框，页面也就恢复正常，我们设置如下CSS样式属性来还原整个页面的滚动效果： html.style.overflow=”visible”;html.style.height=”auto”;body.style.overflow=”visible”;body.style.height=”auto”;1234这些样式正是对应CSS属性的默认样式。然而这个方案有一个缺陷，就是ios系统下不兼容，黑幕的效果没法阻止页面的滚动。下面介绍移动端的另一种解决方案。 方案二：绝对/固定布局阻止手势滚动事件冒泡（PC端无效）正是因为移动端的滚动基于屏幕的touch事件，因此诞生了方案二（手机淘宝就使用了这种方案）。首先我们需要知道两个前提知识点：1、重叠的两个页面元素，z-index值更高的会优先触发事件监听，从而可以在此控制是否让事件流继续；2、移动端滚动的touch事件，基于事件流。有了上面两个知识点的基础，我们就可以来理解这种方案的设计思路。方案二的原理是：不对原页面进行任何改动，仅仅只是用一个拥有更高z-index值的，布局为absolute或者fixed布局的黑幕（长宽100%）来挡住整个页面，并且监听黑幕的touchstart事件，在touchstart事件内结束事件流，从而阻挡事件流继续。这样，能够产生滚动效果的touch事件就传不到页面上，也就不会发生滚动。 下面贴上方案二的完整测试源代码： &lt;!DOCTYPE html&gt; .main-content{ position:relative; width:100%; background-color:#ccc; height:2000px; } 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 .main-content .trigger&#123; width:200px; height:100px; font-size:30px; color:#000; &#125; .main-content .bottom&#123; position:absolute; bottom:0; left:0; width:100%; height:200px; background-color:red; &#125; .black-shield&#123; position:fixed; top:0; left:0; width:100%; height:100%; background-color:rgba(10,10,10,0.4); z-index:10; &#125; .black-shield .info&#123; font-size:40px; color:#000; border:1px solid; z-index:20; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="main-content"&gt; &lt;button id="trigger" class="trigger"&gt;开/关&lt;/button&gt; &lt;div class="bottom"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id="shield" class="black-shield" style="display:none;"&gt; &lt;div id="info" class="info"&gt;当前黑幕弹出后，页面应该不可滑动，点击当前文本，关闭黑幕&lt;/div&gt; &lt;/div&gt; &lt;script&gt; function test2()&#123; var showShield=false; var shield=document.getElementById("shield"); var trigger=document.getElementById("trigger"); var info=document.getElementById("info"); var body=document.querySelector("body"); var html=document.querySelector("html"); //点击显示黑幕 trigger.addEventListener("click",function()&#123; shield.style.display="block"; &#125;,false); //点击关闭黑幕 info.addEventListener("touchstart",function()&#123; shield.style.display="none"; &#125;,false); //在黑幕层阻挡touch事件 shield.addEventListener("touchstart",function(e)&#123; e.stopPropagation(); e.preventDefault(); &#125;,false); &#125; test2(); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>滚动事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS的new到底是干什么的？]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F15%2FJS%E7%9A%84new%E5%88%B0%E5%BA%95%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[前言大部分讲 new 的文章会从面向对象的思路讲起，但是我始终认为，在解释一个事物的时候，不应该引入另一个更复杂的事物。 今天我从「省代码」的角度来讲 new。 -————————– 想象我们在制作一个策略类战争游戏，玩家可以操作一堆士兵攻击敌方。 我们着重来研究一下这个游戏里面的「制造士兵」环节。 一个士兵的在计算机里就是一堆属性，如下图： 我们只需要这样就可以制造一个士兵： 12345678910111213var 士兵 = &#123; ID: 1, // 用于区分每个士兵 兵种:"美国大兵", 攻击力:5, 生命值:42, 行走:function()&#123; /*走俩步的代码*/&#125;, 奔跑:function()&#123; /*狂奔的代码*/ &#125;, 死亡:function()&#123; /*Go die*/ &#125;, 攻击:function()&#123; /*糊他熊脸*/ &#125;, 防御:function()&#123; /*护脸*/ &#125;&#125;兵营.制造(士兵) 制造一百个士兵如果需要制造 100 个士兵怎么办呢？ 循环 100 次吧： 123456789101112131415161718var 士兵们 = []var 士兵for(var i=0; i&lt;100; i++)&#123; 士兵 = &#123; ID: i, // ID 不能重复 兵种:&quot;美国大兵&quot;, 攻击力:5, 生命值:42, 行走:function()&#123; /*走俩步的代码*/&#125;， 奔跑:function()&#123; /*狂奔的代码*/ &#125;, 死亡:function()&#123; /*Go die*/ &#125;, 攻击:function()&#123; /*糊他熊脸*/ &#125;, 防御:function()&#123; /*护脸*/ &#125; &#125; 士兵们.push(士兵)&#125;兵营.批量制造(士兵们) 哎呀好简单。 质疑上面的代码存在一个问题：浪费了很多内存。 行走、奔跑、死亡、攻击、防御这五个动作对于每个士兵其实是一样的，只需要各自引用同一个函数就可以了，没必要重复创建 100 个行走、100个奔跑…… 这些士兵的兵种和攻击力都是一样的，没必要创建 100 次。 只有 ID 和生命值需要创建 100 次，因为每个士兵有自己的 ID 和生命值。 改进看过我们的专栏以前文章（JS 原型链）的同学肯定知道，用原型链可以解决重复创建的问题：我们先创建一个「士兵原型」，然后让「士兵」的 proto 指向「士兵原型」 123456789101112131415161718192021222324var 士兵原型 = &#123; 兵种:&quot;美国大兵&quot;, 攻击力:5, 行走:function()&#123; /*走俩步的代码*/&#125;， 奔跑:function()&#123; /*狂奔的代码*/ &#125;, 死亡:function()&#123; /*Go die*/ &#125;, 攻击:function()&#123; /*糊他熊脸*/ &#125;, 防御:function()&#123; /*护脸*/ &#125;&#125;var 士兵们 = []var 士兵for(var i=0; i&lt;100; i++)&#123; 士兵 = &#123; ID: i, // ID 不能重复 生命值:42 &#125; /*实际工作中不要这样写，因为 __proto__ 不是标准属性*/ 士兵.__proto__ = 士兵原型 士兵们.push(士兵)&#125;兵营.批量制造(士兵们) 优雅？有人指出创建一个士兵的代码分散在两个地方很不优雅，于是我们用一个函数把这两部分联系起来： 12345678910111213141516171819202122function 士兵(ID)&#123; var 临时对象 = &#123;&#125; 临时对象.__proto__ = 士兵.原型 临时对象.ID = ID 临时对象.生命值 = 42 return 临时对象&#125;士兵.原型 = &#123; 兵种:&quot;美国大兵&quot;, 攻击力:5, 行走:function()&#123; /*走俩步的代码*/&#125;， 奔跑:function()&#123; /*狂奔的代码*/ &#125;, 死亡:function()&#123; /*Go die*/ &#125;, 攻击:function()&#123; /*糊他熊脸*/ &#125;, 防御:function()&#123; /*护脸*/ &#125;&#125;// 保存为文件：士兵.js 然后就可以愉快地引用「士兵」来创建士兵了： 123456var 士兵们 = []for(var i=0; i&lt;100; i++)&#123; 士兵们.push(士兵(i))&#125;兵营.批量制造(士兵们) JS 之父的关怀JS 之父创建了 new 关键字，可以让我们少写几行代码： 只要你在士兵前面使用 new 关键字，那么可以少做四件事情： 不用创建临时对象，因为 new 会帮你做（你使用「this」就可以访问到临时对象）； 不用绑定原型，因为 new 会帮你做（new 为了知道原型在哪，所以指定原型的名字为 prototype）； 不用 return 临时对象，因为 new 会帮你做； 不要给原型想名字了，因为 new 指定名字为 prototype。 这一次我们用 new 来写12345678910111213141516function 士兵(ID)&#123; this.ID = ID this.生命值 = 42&#125;士兵.prototype = &#123; 兵种:&quot;美国大兵&quot;, 攻击力:5, 行走:function()&#123; /*走俩步的代码*/&#125;, 奔跑:function()&#123; /*狂奔的代码*/ &#125;, 死亡:function()&#123; /*Go die*/ &#125;, 攻击:function()&#123; /*糊他熊脸*/ &#125;, 防御:function()&#123; /*护脸*/ &#125;&#125;// 保存为文件：士兵.js 然后是创建士兵（加了一个 new 关键字）： 123456var 士兵们 = []for(var i=0; i&lt;100; i++)&#123; 士兵们.push(new 士兵(i))&#125;兵营.批量制造(士兵们) new 的作用，就是省那么几行代码。（也就是所谓的语法糖） 注意 constructor 属性new 操作为了记录「临时对象是由哪个函数创建的」，所以预先给「士兵.prototype」加了一个 constructor 属性： 123士兵.prototype = &#123; constructor: 士兵&#125; 如果你重新对「士兵.prototype」赋值，那么这个 constructor 属性就没了，所以你应该这么写： 1234567士兵.prototype.兵种 = &quot;美国大兵&quot;士兵.prototype.攻击力 = 5士兵.prototype.行走 = function()&#123; /*走俩步的代码*/&#125;士兵.prototype.奔跑 = function()&#123; /*狂奔的代码*/ &#125;士兵.prototype.死亡 = function()&#123; /*Go die*/ &#125;士兵.prototype.攻击 = function()&#123; /*糊他熊脸*/ &#125;士兵.prototype.防御 = function()&#123; /*护脸*/ &#125; 或者你也可以自己给 constructor 重新赋值： 12345678910士兵.prototype = &#123; constructor: 士兵, 兵种:&quot;美国大兵&quot;, 攻击力:5, 行走:function()&#123; /*走俩步的代码*/&#125;, 奔跑:function()&#123; /*狂奔的代码*/ &#125;, 死亡:function()&#123; /*Go die*/ &#125;, 攻击:function()&#123; /*糊他熊脸*/ &#125;, 防御:function()&#123; /*护脸*/ &#125;&#125; 完。 本片文章转载自知乎方方]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>new</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Math应用]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F15%2FMath%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[生成一个随机的ip地址12345678910function getRandIp()&#123; var arr = [] for(var i = 0;i&lt;4;i++)&#123; var random = Math.floor(Math.random()*256) arr.push(random) &#125; return arr.join('.')&#125;var ip = getRandIp()console.log(ip) 写一个函数，生成一个随机颜色字符串，合法的颜色为#000000~ #ffffff123456789101112131415161718192021function getRandColor()&#123; var str = '0123456789abcdef' var arr = [] for(var i=0;i&lt;6;i++)&#123; var random = Math.floor((Math.random() * 16)) arr.push(str[random]) &#125; return '#' + arr.join('') &#125; var color = getRandColor() console.log(color) // #3e2f1b 写一个函数，返回从min到max之间的 随机整数，包括min不包括max 。123456789function random(min,max)&#123; var random = Math.floor(Math.random()*(max-min)+min) return random &#125; console.log(random(1,10)) 写一个函数，生成一个长度为 n 的随机字符串，字符串字符的取值范围包括0到9，a到 z，A到Z。123456789101112131415161718192021function getRandStr(len)&#123; var basics = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'+'abcdefghijklmnopqrstuvwxyz'+'0123456789' var string = '' for(var i = 0;i&lt;len;i++)&#123; var index = Math.floor(Math.random()*basics.length) string+=basics.slice(index,index+1) &#125; return string &#125; var str = getRandStr(10); console.log(str)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript设计模式]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F15%2FJavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[JS设计模式常见 设计模式有 构造函数模式 constructor 工厂模式 factory 混合模式 mixin 模块模式 module 单例模式 singleton 订阅发布模式 subscibe &amp; pulish 观察者模式 observer 构造函数模式 constructor1使用场景：创建一个复杂的对象，可以添加方法 new 函数调用，返回新的对象。每次都是新的引用方法放在原型链上 1234567891011//构造函数function Person(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.sayName = function () &#123; return this.name;&#125;;var student = new Person("若愚", 30);var student1 = new Person("slash", 30); 工厂模式 factory1使用场景：创建一个简单的对象 存在的意义是 每次创建新的引用，生产出来的数据结构一致 1234567891011121314//工厂模式function createPerson(name) &#123; var person = &#123; name: name, sayName: function () &#123; console.log(this.name); &#125; &#125;; return person;&#125;; // 开辟新内存// createPerson('a') // createPerson('b') 混合模式 mixin1使用场景：可继承的公用方法 通过继承来实现 将一些可重用的代码放在父类上，子类通过继承得到属性和方法，并能根据需要自身添加新的属性、方法 123456789101112131415161718192021222324// 混合模式 mixin == &gt; 实现继承 // 实例1js var Person = function (name, age) &#123; this.name = name; this.age = age;&#125;;Person.prototype.sayName = function () &#123; console.log(this.name);&#125;var Student = function (name, age, score) &#123; // 实例属性实现继承 Person.call(this, name, age); this.score = score;&#125;;// 将Person.prototype挂在Student.prototype的原型链第一层 // 原型链实现继承 Student.prototype = Object.create(Person.prototype);Student.prototype.getName = function () &#123; return this.name;&#125; 模块模式 module1使用场景：需要封装的组件 封闭作用域，通过闭包读取内部变量 暴露给外界的仅仅是return选择的内容 12345678910111213141516//模块模式//通过闭包，实现作用域的隔离来实现一个模块 var Person = (function () &#123; var name = 'ruoyu'; function sayName() &#123; console.log(name); &#125;; //词法作用域：一个函数可以访问到的上下文环境由它所定义的位置决定 // 词法作用域 return &#123; name: name, sayName: sayName &#125;&#125;)(); 单例模式 singleton1使用场景：只需出现一次，独一无二的组件 匿名函数（lambda函数）划分命名空间，避免全局污染 可以被实例化，且实例化一次。 指向同一个引用，只开辟一次内存空间 1234567891011121314151617181920212223//单例模式 singleton单例// 匿名函数 var People = (function () &#123; var instance; function init(name) &#123; return &#123; name: name &#125;; &#125;; //词法作用域 return &#123; createPeople: function (name) &#123; if (!instance) &#123; // 如果没有instance就初始化 instance = init(name); // 所以第一次调用就初始化，之后不再执行这段代码 &#125; return instance; //单例就是只开辟了一个内存空间 &#125; //第一次传入的值被储存下来 &#125;; //之后生成的实例全都指向同样的地方&#125;());People.createPeople('jirengu') === People.createPeople('hello') //true //&#123;name:'jirengu'&#125; &#123;name:'jirengu'&#125; 订阅发布模式 subscibe &amp; pulish123456789101112131415161718192021222324252627282930313233343536373839404142// 订阅发布模式 //逻辑： // subscribe publish $('.btn').on('click', function (event) &#123; // console.log('clicked') // &#125;); === &gt; &#123; // 'click': [fn] // &#125; // $('.btn').on('mouseover', function (event) &#123; // $('.btn').trigger('click',event); ====&gt; [fn].forEach(fn(event)); // &#125;) var EventCenter = (function () &#123; // 新建订阅中心 //我们如何去实现 var F = function () &#123; this.eventPool = &#123;&#125;; // 新建缓存列表，存储订阅者的回调函数 &#125;; F.prototype.on = function (name, callback) &#123; // 添加消息：绑定事件 this.eventPool[name] = this.eventPool[name] || []; //检查事件列表events&#123;&#125;里是否有这个key this.eventPool[name].push(callback); 在选定事件里增加一个函数 &#125;; F.prototype.trigger = function (name) &#123; if (!this.eventPool[name]) &#123; this.eventPool[name] = []; &#125; this.eventPool[name].forEach(function (fn) &#123; //如果存在，遍历列表events，依次执行处理程序 fn() &#125;) &#125;; return F;&#125;()); var e = new EventCenter(); e.on('hello', function () &#123; console.log('hello') &#125;); // === &gt; 存 &#123; 'hello': [fn] &#125; e.trigger('hello'); // hello ===&gt; 取后执行 观察者模式 observer123456789101112131415161718//观察者模式 observer$('input').change(function () &#123; $('input').observers.forEach(function (observer) &#123; observer(); &#125;)&#125;);$('input').observers = [];$('input').subscribe = function (fn) &#123; this.observers.push(fn);&#125;;// API使用方式 // $('.input').subscribe(fn) ==&gt; 记录日志 // $('input').subscribe(fn1) ==&gt; 发起请求 // $('input').subscribe(fn2) ==&gt; 改变UI 订阅发布 模式 与 观察者模式 的区别 很多的资料都认为二者是一样的其实仔细考虑，还是有很重要的不同点 观察者模式创建一个需要观察的事件时，要先到subscribe里面进行注册，这个函数将此事件推送到需要通知的数组里，然后，当订阅的内部状态发生变化时，把这个变化通知所有的观察者。随意注册事件，调用事件，不会对事情做区分 发布-订阅模式角色为发布者(publisher)和订阅者(subscriber)，pub和sub之间没有直接的耦合关系，pub发布一个消息事件(event)，sub订阅感兴趣的消息事件，sub也可以取消订阅。是对特定一系列的订阅事件进行统一管理 初步得出结论：观察者模式中的观察者是和主题对象紧耦合的。发布-订阅模式中的发布者和订阅者是松耦合的，发布者和订阅者是通过事件发生联系的。在开发大型项目的时候，订阅/发布模式会让业务更清晰。 JS设计模式漫谈Design-Patterns-Tutorial 使用发布订阅模式写一个事件管理器，可以实现如下方式调用12345Event.on('change', function(val)&#123; console.log('change... now val is ' + val); &#125;);Event.fire('change', '饥人谷');Event.off('changer'); 代码 123456789101112131415161718192021222324252627282930313233var eventCenter = (function () &#123; var e = function () &#123; this.eventPool = []; &#125; e.prototype = &#123; on: function (name, callback) &#123; this.eventPool[name] = this.eventPool[name] || []; this.eventPool[name].push(callback); &#125;, fire: function (name, value) &#123; if (!this.eventPool[name]) return; this.eventPool[name].forEach(function (e) &#123; e(value); &#125;); &#125;, off: function (name) &#123; delete this.eventPool[name]; &#125; &#125;; return e;&#125;)()//测试var Event = new eventCenter()Event.on('change', function (val) &#123; console.log('change... now val is ' + val);&#125;);Event.fire('change', 'aaaaaa');Event.off('change');Event.on('change1', function (val) &#123; console.log('第二次~' + val);&#125;);Event.fire('change1', 'bbbbbb');]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[new和Object,Prototype理解]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F15%2Fnew%E5%92%8CObject-Prototype%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[JavaScript 对象因为JavaScript是基于原型（prototype）的，没有类的概念（ES6有了，这个暂且不谈），我们能接触到的都是对象，真正做到了一切皆为对象 Object我们知道JavaScript有null、undefined、number、boolean、string五种简单类型，null和undefined分别表示没有声明和声明后没有初始化的变量、对象，是两个简单的值，其余三个有对应的包装对象Number、Boolean、String 其它的就都是object类型了，比如常用的Array、Date、RegExp等，我们最常用的Function也是个对象，虽然 1typeof function()&#123;&#125;; // &quot;function&quot; 但是Function实例和其它类型的实例没有什么区别，都是对象，只不过typeof操作符对其做了特殊处理 在JavaScript中使用对象很简单，使用new操作符执行Obejct函数就可以构建一个最基本的对象 1var obj = new Object(); 我们称new 调用的函数为构造函数，构造函数和普通函数区别仅仅在于是否使用了new来调用，它们的返回值也会不同 所谓“构造函数”，就是专门用来生成“对象”的函数。它提供模板，作为对象的基本结构。一个构造函数，可以生成多个对象，这些对象都有相同的结构 我们可以通过.来为对象添加属性和方法 12345//1.原始模式，Object构造函数方式obj.name = 'Byron';obj.printName = function()&#123; console.log(obj.name);&#125;; 这么写比较麻烦，我们可以使用字面量来创建一个对象，下面的写法和上面等价 1234567//1.原始模式，对象字面量方式var obj = &#123; name: 'Byron', printName: function()&#123; console.log(obj.name); &#125;&#125; 虽然Object构造函数和对象字面量都可以用来创建单个对象，但这两个方式有个明显缺点，就是使用同一接口会创建很多对象，产生大量重复代码。而且如果想个性化，只能通过手工赋值，使用者必须详细了解对象 除了最普通的字面量和Object构造函数创建对象，JS 中还有其他几种创建对象的方法，现在最常用的方法是组合模式工厂模式1234567891011121314//2.工厂模式，定义一个函数创建对象function createObj(nick, age)&#123; var obj = &#123; nick: nick, age: age, printName: function()&#123; console.log(this.nick); &#125; &#125;; return obj;&#125;var obj3 = createObj('Byron', 30);obj3.printName(); 工厂模式就是批量化生产，这种方法通过创建一个函数来实现自动创建对象的过程，至于个性化通过参数实现，开发者不必关注细节，只需要传入指定参数即可 问题： 构造出来的对象类型都是Object，没有解决对象识别的问题（对象的类型） 每次使用都要创建一个独立的对象，浪费内存。 构造函数 模式我们需要了解一些额外知识 function作为构造函数（通过new操作符调用）的时候会返回一个类型为function的name的对象 function可以接受参数，可以根据参数来创建相同类型不同值的对象 function实例作用域内有一个constructor属性，这个属性就可以指示其构造器 newnew 运算符接受一个函数 F 及其参数：new F(arguments…)。这一过程分为三步： 创建一个新实例。这步是把一个空的对象的 proto 属性设置为 F.prototype 。 初始化实例。函数 F 被传入参数并调用，关键字 this 指向了新实例。 返回实例。 12345678910// 3.构造函数模式，为对象定义一个构造函数function Person(nick, age)&#123; this.nick = nick; this.age = age; this.sayName = function()&#123; console.log(this.nick); &#125;&#125;var p1 = new Person('Byron', 25); instanceofinstanceof是一个操作符，可以判断对象是否为某个类型的实例 12p1 instanceof Person; // truep1 instanceof Object;// true instanceof判断的是对象 11 instanceof Number; // false 问题： 构造函数在解决了上面所有问题，同时为实例带来了类型但可以注意到每个实例printName方法实际上作用一样，但是每个实例要重复一遍，不同实例的方法其实是不同的函数，大量对象存在的时候是浪费内存 原型模式 任何函数使用new表达式就是构造函数 每个函数都自动添加一个名称为prototype属性，这是一个对象 每个实例都有一个内部属性 [object Object](规范中没有指定这个名称，但是浏览器都这么实现的) 指向其类型的prototype属性，类的实例也是对象，其[object Object]属性指向“类”的prototype prototype 通过图示我们可以看出一些端倪，实例可以通过__prop__访问到其类型的prototype属性，这就意味着类的prototype对象可以作为一个公共容器，供所有实例访问 抽象重复我们刚才的问题可以通过这个手段解决 所有实例都会通过原型链引用到类型的prototype prototype相当于特定类型所有实例都可以访问到的一个公共容器 重复的东西移动到公共容器里放一份就可以了 12345//4.原型模式，直接定义prototype属性function Person () &#123;&#125;Person.prototype.name = 'Jack';Person.prototype.age = 18;Person.prototype.sayName = function () &#123; alert(this.name); &#125;; 12345678910//4.原型模式，字面量定义方式function Person () &#123;&#125;Person.prototype = &#123; name: 'Jack', age: 18, sayName: function () &#123; alert(this.name); &#125;&#125;;var p1 = new Person(); //name='Jack'var p2 = new Person(); //name='Jack' 问题 需要注意的是原型属性和方法的共享，即所有实例中都只是引用原型中的属性方法，任何一个地方产生的改动会引起其他实例的变化。 混合模式（组合使用 构造函数 和 原型 模式）12345678910111213141516//5. 原型构造组合模式，function Person (name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype = &#123; hobby: ['running','football']; sayName: function () &#123; alert(this.name); &#125;, sayAge: function () &#123; alert(this.age); &#125;&#125;;var p1 = new Person('Jack', 20);//p1:'Jack',20; __proto__: ['running','football'],sayName,sayAgevar p2 = new Person('Mark', 18);//p1:'Mark',18;__proto__: ['running','football'],sayName,sayAge 问题 做法是将需要独立的属性方法放入构造函数中，而可以共享的部分则放入原型中，这样做可以最大限度节省内存而又保留对象实例的独立性。 是最常用的模式 问题1： OOP 指什么？有哪些特性Object-oriented programming的缩写，即面向对象程序设计，其中两个最重要的概念就是类和对象。类只是具备了某些功能和属性的抽象模型，类在实例化之后得到的实体就是对象。 特性： 继承性：子类自动继承其父级类中的属性和方法，并可以添加新的属性和方法或者对部分属性和方法进行重写。继承增加了代码的可重用性。 多态性：子类继承了来自父级类中的属性和方法，并对其中部分方法进行重写。 封装性：将一个类的使用和实现分开，只保留部分接口和方法与外部联系。 问题2： 如何通过构造函数的方式创建一个拥有属性和方法的对象?123456789function People(name, age)&#123; this.name = name; this.age = age; this.printName: function()&#123; console.log(this.name) &#125;&#125;var p1 = new People('ny', '22') 问题3： prototype 是什么？有什么特性每创建一个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。 所以也可以说prototype就是通过调用构造函数而创建的那个对象实例的原型对象，原型对象可以让所有对象实例共享它所包含的属性和方法 问题4：画出如下代码的原型图12345678910111213function People (name)&#123; this.name = name; this.sayName = function()&#123; console.log('my name is:' + this.name); &#125;&#125;People.prototype.walk = function()&#123; console.log(this.name + ' is walking'); &#125;var p1 = new People('饥人谷');var p2 = new People('前端'); 问题5： 创建一个 Car 对象，拥有属性name、color、status；拥有方法run，stop，getStatus1234567891011121314151617181920212223function Car(name, color, status) &#123; this.name = name; this.color = color; this.status = status; &#125; Car.prototype = &#123; run: function () &#123; this.status = 'run'; console.log(this.status) &#125;, stop: function () &#123; this.status = 'stop'; console.log(this.status) &#125;, gerStatus: function () &#123; console.log(this.status) &#125; &#125; var p1 = new Car('ny') p1.run() p1.stop() p1.gerStatus() 问题6： 创建一个 GoTop 对象，当 new 一个 GotTop 对象则会在页面上创建一个回到顶部的元素，点击页面滚动到顶部。拥有以下属性和方法 ct属性，GoTop 对应的 DOM 元素的容器 target属性， GoTop 对应的 DOM 元素 bindEvent 方法， 用于绑定事件 createNode 方法， 用于在容器内创建节点 效果预览源码 12345678910111213141516171819function GoTop($ct) &#123; this.ct = $ct; this.target = $('&lt;button class="btn"&gt;Go Top&lt;/button&gt;'); this.target.css(&#123;'padding': '20px'&#125;); this.bindEvent(); this.createNode() &#125; GoTop.prototype = &#123; bindEvent: function () &#123; this.target.on('click',function ()&#123; $('body').animate(&#123; scrollTop: 0 &#125;, 200); &#125;); &#125;, createNode: function () &#123; this.ct.append(this.target); &#125; &#125; var run = new GoTop($('.ct')) 问题7： 使用木桶布局实现一个图片墙效果预览]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>new</tag>
        <tag>Object</tag>
        <tag>Prototype</tag>
        <tag>原型</tag>
        <tag>混合模式</tag>
        <tag>工厂模式</tag>
        <tag>木桶布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5图片验证以及上传实例]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F15%2FHTML5%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E4%BB%A5%E5%8F%8A%E4%B8%8A%E4%BC%A0%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[HTML5图片验证及上传实例：学习FileReader/Image 转载地址:https://blog.csdn.net/Mynewclass/article/details/80254082]]></content>
      <categories>
        <category>JavaScript</category>
        <category>image</category>
      </categories>
      <tags>
        <tag>JavaScirpt</tag>
        <tag>image</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fetch]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F15%2Ffetch%2F</url>
    <content type="text"><![CDATA[前言在开发过程中,我们向服务端发送请求,一般会使用三种方式, XMLHttpRequest(XHR)，Fetch ，jQuery实现的AJAX。 其中, XMLHttpRequest(XHR)和Fetch是浏览器的原生API，jquery的ajax其实是封装了XHR。 让我们首先来比较一下这三者的使用示例。 XMLHttpRequest12345678910111213141516171819202122232425262728293031323334353637var xhr;if (window.XMLHttpRequest) &#123; // Mozilla, Safari... xhr = new XMLHttpRequest();&#125; else if (window.ActiveXObject) &#123; // IE try &#123; xhr = new ActiveXObject('Msxml2.XMLHTTP'); &#125; catch (e) &#123; try &#123; xhr = new ActiveXObject('Microsoft.XMLHTTP'); &#125; catch (e) &#123;&#125; &#125;&#125;if (xhr) &#123; xhr.onreadystatechange = onReadyStateChange; xhr.open('POST', '/api', true); // 设置 Content-Type 为 application/x-www-form-urlencoded // 以表单的形式传递数据 xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); xhr.send('username=admin&amp;password=root');&#125;// onreadystatechange 方法function onReadyStateChange() &#123; // 该函数会被调用四次 console.log(xhr.readyState); if (xhr.readyState === 4) &#123; // everything is good, the response is received if (xhr.status === 200) &#123; console.log(xhr.responseText); &#125; else &#123; console.log('There was a problem with the request.'); &#125; &#125; else &#123; // still not ready console.log('still not ready...'); &#125;&#125; 从上边的代码可以看出，XMLHttpRequest 是一个非常粗糙的API，不符合关注分离(Separation of Concerns)的原则，配置和调用方式非常混乱，前端程序员们不仅要做各个浏览器的兼容性，还饱受回调地狱的折磨，这显然不是一个好的选择。 jQuery实现AJAX12345678$.ajax(&#123; method: 'POST', url: '/api', data: &#123; username: 'admin', password: 'root' &#125;&#125;) .done(function(msg) &#123; alert( 'Data Saved: ' + msg ); &#125;); jQuery作为一个使用人数最多的库，其AJAX很好的封装了原生AJAX的代码，在兼容性和易用性方面都做了很大的提高，而且jQuery还把jsonp装在了AJAX里面，这样我们就可以开心的跨域了！！！！对比原生AJAX的实现，使用jQuery实现的AJAX就异常简单了． 但是，笔锋一转，我们仍然逃脱不了一个问题，回调地狱。。。。 Fetch1234fetch(...).then(fun2) .then(fun3) //各依赖有序执行 ..... .catch(fun) 从上边的代码可以看出，fetch用起来想jQuery一样简单，虽然还是有Callback的影子，但是看起来舒服多了 详解Fetch API兼容性 注意：由于Fetch API是基于Promise设计，旧浏览器不支持Promise，需要使用pollyfill es6-promise Fetch使用说明 12345fetch(url, options).then(function(response) &#123; // handle HTTP response&#125;, function(error) &#123; // handle network error&#125;) 说明： a. fetch api返回的是一个promise对象 b.Options: method(String): HTTP请求方法，默认为GET body(String): HTTP的请求参数 headers(Object): HTTP的请求头，默认为{} credentials(String): 默认为omit,忽略的意思，也就是不带cookie;还有两个参数，same-origin，意思就是同源请求带cookie；include,表示无论跨域还是同源请求都会带cookie c.第一个then函数里面处理的是response的格式，这里的response具体如下： image.png status(number): HTTP返回的状态码，范围在100-599之间 statusText(String): 服务器返回的状态文字描述，例如Unauthorized,上图中返回的是Ok ok(Boolean): 如果状态码是以2开头的，则为true headers: HTTP请求返回头 body: 返回体，这里有处理返回体的一些方法 text(): 将返回体处理成字符串类型 json()： 返回结果和 JSON.parse(responseText)一样 blob()： 返回一个Blob，Blob对象是一个不可更改的类文件的二进制数据 arrayBuffer() formData() Fetch常见坑 兼容性 image.png 如caniuse所示，IE浏览器完全不支持fetch，移动端的很多浏览器也不支持,所以，如果要在这些浏览器上使用Fetch，就必须使用fetch polyfill cookie传递必须在header参数里面加上credentials: &#39;include&#39;，才会如xhr一样将当前cookies带到请求中去 fetch和xhr的不同fetch虽然底层，但是还是缺少一些常用xhr有的方法，比如能够取消请求（abort）方法fetch在服务器返回4xx、5xx时是不会抛出错误的，这里需要手动通过，通过response中的ok字段和status字段来判断 实践总结我们在实际应用中虽然会因为它没有interceptor等原因还需要再封装一层，但fetch api仍然不失为一个非常赞的API。。。。]]></content>
  </entry>
  <entry>
    <title><![CDATA[ES6数据类型转换]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F15%2FES6%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[Map转为数组1234const map = new Map();map.set(1,"foo").set(2,"bar").set(3,"baz");const arr = [...map];console.log(arr); 数组 转为 Map123const arr = ["foo","bar","baz"];const arrChangeMap = (arr) =&gt; new Map(arr.map( (value,key) =&gt; [key,value]));console.log(arrChangeMap(arr)); Map 转为对象12345678910const map = new Map();map.set(1,"foo").set(2,"bar").set(3,"baz");const mapChangeObj = (map) =&gt; &#123; let obj = &#123;&#125;; for(let [k,v] of map) &#123; obj[k] = v; &#125; return obj;&#125;console.log(mapChangeObj(map)); 对象转为 Map12345678910111213const obj = &#123; "1" : "foo", "2": "bar", "3" : "baz",&#125;const objChangeMap = (obj) =&gt; &#123; let map = new Map(); for(let key in obj) &#123; map.set(key,obj[key]); &#125; return map;&#125;console.log(objChangeMap(obj)); Map 转为 JSON,借助Map转对象1234const map = new Map();map.set(1,"foo").set(2,"bar").set(3,"baz");const mapChangeJson = (map) =&gt; JSON.stringify(mapChangeObj(map));console.log(mapChangeJson(map)); JSON 转为 Map,借助对象转Map123let json = '&#123;"1":"foo","2":"bar","3":"baz"&#125;';const jsonChangeMap = (json) =&gt; objChangeMap(JSON.parse(json));console.log(jsonChangeMap(json)); 需求： 如何将输入的json字符串转换成一个map对象，传入到向后端的request中 ？ 具体问题描述： 项目需要从vue前端传一个Json对象到request中，而后端的接口参数类型是Map对象。所以需要先json解析转成Map,但ajax的序列化又会给Map对象外面套上一层数组，所以会与后端接口中的参数类型不匹配。具体解决方法如下。 1. 先判断输入的是否是合法的json字符串123456789101112131415161718192021222324252627282930 //判断是否是合法的Json字符串 isJSON(str) &#123;if (typeof str == 'string') &#123;try &#123;var obj=JSON.parse(str);if(typeof obj == 'object' &amp;&amp; obj )&#123;return true;&#125;else&#123;return false;&#125;&#125; catch(e) &#123;return false;&#125;&#125;return false;&#125;, 2.检验json字符串合法之后，再进行JSON -&gt; Map转换： (Json转换为Map不能直接转换，json转为对象，在转换为Map。) 123456789101112131415jsonStrToStrMap(jsonStr)&#123; let jsonObj = JSON.parse(jsonStr); let strMap = new Map(); for (let k of Object.keys(jsonObj)) &#123; strMap.set(k,jsonObj[k]); &#125; return strMap; &#125;, 3.解决序列化问题这里可以将json解析出来按照KV存在Map中，但塞进request中之后，传输到后端就变成了[MapObj]，这样的数组对象。所以想完美传送过去，就必须弱化类型，如下： 123456789101112131415jsonStrToStrMap(jsonStr)&#123; let jsonObj = JSON.parse(jsonStr); let strMap = &#123;&#125;; for(var k in jsonObj )&#123; strMap[k] = jsonObj[k]; &#125; return strMap;&#125;, 如上，传进去的只是Object类型，不会被强制类型转换，Map的数据和结构就可以传到后端啦。 注意：上面是json字符串转map,如果是json对象，那就将 let jsonObj = JSON.parse(jsonStr); 这一句去掉就好。 4.补充其他类型转换的方法Json和字符串之间的转换：Json转换成String: let jstr = JSON.stringify(JsonObj); String转换成Json: let jsonObj = JSON.parse(jsonStr); Map -&gt;Json :Map不能直接转换为Json，Map先要转换为Object，在转换为json。 123456789101112131415strMapToJson(strMap)&#123; let obj= Object.create(null); for (let[k,v] of strMap) &#123; obj[k] = v; &#125; let JsonStr = JSON.stringify(obj); return JsonStr; &#125; 主要传输的对象就是Json,Map,String比较多。 5.从jsonobject中取出整个数组的值1234JSONObject jsonObject = JSON.parseObject(s);//注意：array中的内容带有中括号[]，所以要转化为JSONArray类型的对象JSONArray family = jsonObject.getJSONArray("array")]]></content>
      <categories>
        <category>JavaScript</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES5继承与ES6继承]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F15%2FES5%E7%BB%A7%E6%89%BF%E4%B8%8EES6%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[ES5 继承 与 ES6 继承的区别ES5 继承假设在es5要实现继承,首先定义一个父类: 12345678//父类function sup(name) &#123; this.name = name&#125;//定义父类原型上的方法sup.prototype.printName = function ()&#123; console.log(this.name)&#125; 现在再定义他sup的子类，继承sup的属性和方法: 1234567891011function sub(name,age)&#123; sup.call(this,name) //调用call方法,继承sup超类属性 this.age = age&#125; sub.prototype = new sup //把子类sub的原型对象指向父类的实例化对象，这样即可以继承父类sup原型对象上的属性和方法sub.prototype.constructor = sub //这时会有个问题子类的constructor属性会指向sup，手动把constructor属性指向子类sub//这时就可以在父类的基础上添加属性和方法了sub.prototype.printAge = function ()&#123; console.log(this.age)&#125; 这时调用父类生成一个实例化对象: 123let jack = new sub('jack',20)jack.printName() //输出 : jackjack.printAge() //输出 : 20 这就是es5中实现继承的方法。 ES6 继承而在es6中实现继承: 12345678910111213141516171819202122232425 class sup &#123; constructor(name) &#123; this.name = name &#125; printName() &#123; console.log(this.name) &#125;&#125;class sub extends sup &#123; constructor(name, age) &#123; super(name) this.age = age &#125; printAge() &#123; console.log(this.age) &#125;&#125;let jack = new sub('jack', 20)jack.printName() //输出 : jackjack.printAge() //输出 : 20 调用 super 的原因：在ES6中，在子类的 function Object() { [native code] }中必须先调用 super 才能引用 this 对比es5和es6可以发现在es5实现继承: 首先得先调用函数的call方法把父类的属性给继承过来 通过new关键字继承父类原型的对象上的方法和属性 最后再通过手动指定constructor属性指向子类对象 而在es6中实现继承直接调用super(name)，就可以直接继承父类的属性和方法，所以super作用就相当于上述的实现继承的步骤，不过es6提供了super语法糖，简单化了继承的实现 React 中使用继承super(props) 的目的：在 function Object() { [native code] }中可以使用 this.props 最后，React文档，里面有一段 Class components should always call the base constructor with props.]]></content>
      <categories>
        <category>JavaScript</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array基础API]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F15%2FArray%E5%9F%BA%E7%A1%80API%2F</url>
    <content type="text"><![CDATA[Array基本常用API123456789101112131415161718192021var arr = [1, 2, 3, 'ab']var _push = arr.push(4, 5, 6) //length=7 console.log(arr) //[ 1, 2, 3, 'ab', 4, 5, 6 ]var _pop = arr.pop() //6console.log(arr) //[ 1, 2, 3, 'ab', 4, 5 ]var _shift = arr.shift() //1console.log(arr) //[ 2, 3, 'ab', 4, 5 ]var _unshift = arr.unshift('x') //length=6console.log(arr) //[ 'x', 2, 3, 'ab', 4, 5 ]var _join = arr.join('/') //x/2/3/ab/4/5 typeof _join = stringconsole.log(arr) //[ 'x', 2, 3, 'ab', 4, 5 ] 不改变原数组var _slice = arr.slice(1, 2) //[2]console.log(arr) //[ 'x', 2, 3, 'ab', 4, 5 ]var _splice = arr.splice(3, 1, 'hello') //[ 'ab' ] 如果只有一个数组将会拆分原数组 splice(3)===['ab',4,5]console.log(arr) //[ 'x', 2, 3, 'hello', 4, 5 ]var _sort = arr.sort() //[ 2, 3, 4, 5, 'hello', 'x' ] 改变原数组console.log(arr) //[ 2, 3, 4, 5, 'hello', 'x' ] var _reverse = arr.reverse() //[ 'x', 'hello', 5, 4, 3, 2 ]console.log(arr) //[ 'x', 'hello', 5, 4, 3, 2 ]var _concat = arr.concat([7, 8, 9]) //[ 'x', 'hello', 5, 4, 3, 2, 7, 8, 9 ] 不改变原数组console.log(arr) //[ 'x', 'hello', 5, 4, 3, 2 ] 这个方法会深拷贝数组 对类数组对象进行数组操作123456var string = 'hello'var a = Array.prototype.join.call(string,'-')console.log(a) //h-e-l-l-ovar b = Array.prototype.slice.call(&#123;0:'a',1:'b',length:2&#125;) //类数组转化数组console.log(b) //[ 'a', 'b' ]var person = [&#123;name:'che',age:22 &#125;] Array深拷贝.concat([])是利用拼接两个数组的方法去对数组进行深拷贝 1234567var arr3 =[&#123;age:1,name:'che'&#125;,&#123;age:2,name:'cz'&#125;]var arr4 = arr3.concat([])console.log(arr4)[ &#123; age: 1, name: 'che' &#125;, &#123; age: 2, name: 'cz' &#125; ] JSON深拷贝方法123var obj = &#123;name:'ch',age:2&#125;var newObj = JSON.parse(JSON.stringify(arr5))console.log(obj === newObj) //false 函数递归深拷贝方法12345678910111213141516171819var obj = &#123;name:'cheche',age:12,like:[1,2,&#123;name:'xiaopei',age:20&#125;]&#125;function deepCopy(obj)&#123; var obj2 = Array.isArray(obj)?[]:&#123;&#125;; if(typeof obj === 'object')&#123; for(var key in obj)&#123; if(typeof obj[key] === 'object')&#123; obj2[key] = deepCopy(obj[key]) &#125;else&#123; obj2[key] = obj[key] &#125; &#125; &#125; return obj2&#125;var x = deepCopy(obj)x.like[2].name = 'zhangteng'console.log(obj) //name: 'xiaopei'console.log(x) //name:'zhangteng'console.log(x === obj) //false 浅拷贝浅拷贝无法使得对象里引用数据类型不相干 12345678910111213var obj = &#123;name:'ccxzc',age:20,c:function()&#123;&#125;&#125;function shallowCopy(obj)&#123; var newObj =&#123;&#125; for(var key in obj)&#123; if(obj.hasOwnProperty(key))&#123; newObj[key] = obj[key] &#125; &#125; return newObj&#125;var sc = shallowCopy(obj)console.log(sc) //&#123; name: 'ccxzc', age: 20, c: [Function: c] &#125;console.log(sc === obj) //false reduce方法造轮子123456789101112131415161718192021var arr = [3, 4, 5, 6];function reduce(arr, fn, initValue) &#123; // var arr2 = arr.concat([]) //利用拼接原理 // if(initValue !== undefined)&#123; // arr2.unshift(initValue) // &#125; var arr2 = (initValue !== undefined ? [] : [initValue]); while (arr2.length &gt; 1) &#123; console.log(arr2); arr2.splice(0, 2, fn(arr2[0], arr2[1])); &#125; return arr2[0];&#125;var result = reduce( arr, function(v1, v2) &#123; return v1 + v2; &#125;, 10);console.log(result); 将数组平面化12345678910111213var arr = [1,2,3,[4,5,6],'dsa',[1,[4,5,[4,1]]]]function flat(arr)&#123; var newArr = [] arr.forEach((element,index) =&gt; &#123; if(Array.isArray(element))&#123; newArr = newArr.concat(flat(element)) &#125;else&#123; newArr.push(element) &#125; &#125;); return newArr&#125;console.log(flat(arr)) 实现一个reduce函数12345678910111213141516171819202122232425function reduce(arr, sum, initValue) &#123; var sumArr = (initValue === undefined ? [] : [initValue]).concat(arr); console.log(sumArr) while (sumArr.length &gt; 1) &#123; sumArr.splice(0, 2, sum(sumArr[0], sumArr[1])) console.log(sumArr) &#125; return sumArr[0]; &#125; var x = reduce([1, 2, 3, 4],function(numberA, numberB) &#123; return numberA + numberB; &#125;,10); console.log(x); 实现 flatten([1, [2], [3, [[4]]]]) =&gt; [1, 2, 3, 4];123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191function flatten(arr)&#123; var newArr = [] arr.forEach(function(e,index)&#123; if(typeof e === 'number')&#123; newArr.push(e) &#125;else if(Array.isArray(e))&#123; newArr = newArr.concat(flatten(e)) &#125; &#125;) return newArr &#125; var x = flatten([1, [2], [3, [[4]]]]) console.log(x) Array基本常用APIvar arr = [1, 2, 3, 'ab']var _push = arr.push(4, 5, 6) //length=7 console.log(arr) //[ 1, 2, 3, 'ab', 4, 5, 6 ]var _pop = arr.pop() //6console.log(arr) //[ 1, 2, 3, 'ab', 4, 5 ]var _shift = arr.shift() //1console.log(arr) //[ 2, 3, 'ab', 4, 5 ]var _unshift = arr.unshift('x') //length=6console.log(arr) //[ 'x', 2, 3, 'ab', 4, 5 ]var _join = arr.join('/') //x/2/3/ab/4/5 typeof _join = stringconsole.log(arr) //[ 'x', 2, 3, 'ab', 4, 5 ] 不改变原数组var _slice = arr.slice(1, 2) //[2]console.log(arr) //[ 'x', 2, 3, 'ab', 4, 5 ]var _splice = arr.splice(3, 1, 'hello') //[ 'ab' ] 如果只有一个数组将会拆分原数组 splice(3)===['ab',4,5]console.log(arr) //[ 'x', 2, 3, 'hello', 4, 5 ]var _sort = arr.sort() //[ 2, 3, 4, 5, 'hello', 'x' ] 改变原数组console.log(arr) //[ 2, 3, 4, 5, 'hello', 'x' ] var _reverse = arr.reverse() //[ 'x', 'hello', 5, 4, 3, 2 ]console.log(arr) //[ 'x', 'hello', 5, 4, 3, 2 ]var _concat = arr.concat([7, 8, 9]) //[ 'x', 'hello', 5, 4, 3, 2, 7, 8, 9 ] 不改变原数组console.log(arr) //[ 'x', 'hello', 5, 4, 3, 2 ] 这个方法会深拷贝数组对类数组对象进行数组操作var string = 'hello'var a = Array.prototype.join.call(string,'-')console.log(a) //h-e-l-l-ovar b = Array.prototype.slice.call(&#123;0:'a',1:'b',length:2&#125;) //类数组转化数组console.log(b) //[ 'a', 'b' ]var person = [&#123;name:'che',age:22 &#125;]Array深拷贝.concat([])是利用拼接两个数组的方法去对数组进行深拷贝var arr3 =[&#123;age:1,name:'che'&#125;,&#123;age:2,name:'cz'&#125;]var arr4 = arr3.concat([])console.log(arr4)[ &#123; age: 1, name: 'che' &#125;, &#123; age: 2, name: 'cz' &#125; ]JSON深拷贝方法var obj = &#123;name:'ch',age:2&#125;var newObj = JSON.parse(JSON.stringify(arr5))console.log(obj === newObj) //false函数递归深拷贝方法var obj = &#123;name:'cheche',age:12,like:[1,2,&#123;name:'xiaopei',age:20&#125;]&#125;function deepCopy(obj)&#123; var obj2 = Array.isArray(obj)?[]:&#123;&#125;; if(typeof obj === 'object')&#123; for(var key in obj)&#123; if(typeof obj[key] === 'object')&#123; obj2[key] = deepCopy(obj[key]) &#125;else&#123; obj2[key] = obj[key] &#125; &#125; &#125; return obj2&#125;var x = deepCopy(obj)x.like[2].name = 'zhangteng'console.log(obj) //name: 'xiaopei'console.log(x) //name:'zhangteng'console.log(x === obj) //false 浅拷贝浅拷贝无法使得对象里引用数据类型不相干var obj = &#123;name:'ccxzc',age:20,c:function()&#123;&#125;&#125;function shallowCopy(obj)&#123; var newObj =&#123;&#125; for(var key in obj)&#123; if(obj.hasOwnProperty(key))&#123; newObj[key] = obj[key] &#125; &#125; return newObj&#125;var sc = shallowCopy(obj)console.log(sc) //&#123; name: 'ccxzc', age: 20, c: [Function: c] &#125;console.log(sc === obj) //falsereduce方法造轮子var arr = [3, 4, 5, 6];function reduce(arr, fn, initValue) &#123; // var arr2 = arr.concat([]) //利用拼接原理 // if(initValue !== undefined)&#123; // arr2.unshift(initValue) // &#125; var arr2 = (initValue !== undefined ? [] : [initValue]); while (arr2.length &gt; 1) &#123; console.log(arr2); arr2.splice(0, 2, fn(arr2[0], arr2[1])); &#125; return arr2[0];&#125;var result = reduce( arr, function(v1, v2) &#123; return v1 + v2; &#125;, 10);console.log(result);将数组平面化var arr = [1,2,3,[4,5,6],'dsa',[1,[4,5,[4,1]]]]function flat(arr)&#123; var newArr = [] arr.forEach((element,index) =&gt; &#123; if(Array.isArray(element))&#123; newArr = newArr.concat(flat(element)) &#125;else&#123; newArr.push(element) &#125; &#125;); return newArr&#125;console.log(flat(arr))实现一个reduce函数function reduce(arr, sum, initValue) &#123; var sumArr = (initValue === undefined ? [] : [initValue]).concat(arr); console.log(sumArr) while (sumArr.length &gt; 1) &#123; sumArr.splice(0, 2, sum(sumArr[0], sumArr[1])) console.log(sumArr) &#125; return sumArr[0]; &#125; var x = reduce([1, 2, 3, 4],function(numberA, numberB) &#123; return numberA + numberB; &#125;,10); console.log(x); 实现 flatten([1, [2], [3, [[4]]]]) =&gt; [1, 2, 3, 4];function flatten(arr)&#123; var newArr = [] arr.forEach(function(e,index)&#123; if(typeof e === 'number')&#123; newArr.push(e) &#125;else if(Array.isArray(e))&#123; newArr = newArr.concat(flatten(e)) &#125; &#125;) return newArr &#125; var x = flatten([1, [2], [3, [[4]]]]) console.log(x) 一篇更加详细的博客]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax和XMLHttpRequest]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F15%2FAjax%E5%92%8CXMLHttpRequest%2F</url>
    <content type="text"><![CDATA[Ajax和XMLHttpRequest我们通常将Ajax等同于XMLHttpRequest，但细究起来它们两个是属于不同维度的2个概念。 以下是我认为对Ajax较为准确的解释：（摘自what is Ajax）AJAX stands for Asynchronous JavaScript and XML. AJAX is a new technique for creating better, faster, and more interactive web applications with the help of XML, HTML, CSS, and Java Script. AJAX is based on the following open standards: Browser-based presentation using HTML and Cascading Style Sheets (CSS). Data is stored in XML format and fetched from the server. Behind-the-scenes data fetches using XMLHttpRequest objects in the browser. JavaScript to make everything happen. 从上面的解释中可以知道：ajax是一种技术方案，但并不是一种新技术。它依赖的是现有的CSS/HTML/Javascript，而其中最核心的依赖是浏览器提供的XMLHttpRequest对象，是这个对象使得浏览器可以发出HTTP请求与接收HTTP响应。 所以我用一句话来总结两者的关系：我们使用XMLHttpRequest对象来发送一个Ajax请求。 XMLHttpRequest的发展历程XMLHttpRequest一开始只是微软浏览器提供的一个接口，后来各大浏览器纷纷效仿也提供了这个接口，再后来W3C对它进行了标准化，提出了XMLHttpRequest标准。XMLHttpRequest标准又分为Level 1和Level 2。XMLHttpRequest Level 1主要存在以下缺点： 受同源策略的限制，不能发送跨域请求； 不能发送二进制文件（如图片、视频、音频等），只能发送纯文本数据； 在发送和获取数据的过程中，无法实时获取进度信息，只能判断是否完成； 那么Level 2对Level 1 进行了改进，XMLHttpRequest Level 2中新增了以下功能： 可以发送跨域请求，在服务端允许的情况下； 支持发送和接收二进制数据； 新增formData对象，支持发送表单数据； 发送和获取数据时，可以获取进度信息； 可以设置请求的超时时间； 当然更详细的对比介绍，可以参考阮老师的这篇文章，文章中对新增的功能都有具体代码示例。 XMLHttpRequest兼容性关于xhr的浏览器兼容性，大家可以直接查看“Can I use”这个网站提供的结果XMLHttpRequest兼容性，下面提供一个截图。 从图中可以看到： IE8/IE9、Opera Mini 完全不支持xhr对象 IE10/IE11部分支持，不支持 xhr.responseType为json 部分浏览器不支持设置请求超时，即无法使用xhr.timeout 部分浏览器不支持xhr.responseType为blob 细说XMLHttpRequest如何使用先来看一段使用XMLHttpRequest发送Ajax请求的简单示例代码。 1234567891011121314151617181920212223242526function sendAjax() &#123; //构造表单数据 var formData = new FormData(); formData.append('username', 'johndoe'); formData.append('id', 123456); //创建xhr对象 var xhr = new XMLHttpRequest(); //设置xhr请求的超时时间 xhr.timeout = 3000; //设置响应返回的数据格式 xhr.responseType = "text"; //创建一个 post 请求，采用异步 xhr.open('POST', '/server', true); //注册相关事件回调处理函数 xhr.onload = function(e) &#123; if(this.status == 200||this.status == 304)&#123; alert(this.responseText); &#125; &#125;; xhr.ontimeout = function(e) &#123; ... &#125;; xhr.onerror = function(e) &#123; ... &#125;; xhr.upload.onprogress = function(e) &#123; ... &#125;; //发送数据 xhr.send(formData);&#125; 上面是一个使用xhr发送表单数据的示例，整个流程可以参考注释。 接下来我将站在使用者的角度，以问题的形式介绍xhr的基本使用。我对每一个问题涉及到的知识点都会进行比较细致地介绍，有些知识点可能是你平时忽略关注的。 如何设置request header在发送Ajax请求（实质是一个HTTP请求）时，我们可能需要设置一些请求头部信息，比如content-type、connection、cookie、accept-xxx等。xhr提供了setRequestHeader来允许我们修改请求 header。 void setRequestHeader(DOMString header, DOMString value); 注意点： 方法的第一个参数 header 大小写不敏感，即可以写成content-type，也可以写成Content-Type，甚至写成content-Type; Content-Type的默认值与具体发送的数据类型有关，请参考本文【可以发送什么类型的数据】一节； setRequestHeader必须在open()方法之后，send()方法之前调用，否则会抛错； setRequestHeader可以调用多次，最终的值不会采用覆盖override的方式，而是采用追加append的方式。下面是一个示例代码： 123456var client = new XMLHttpRequest();client.open('GET', 'demo.cgi');client.setRequestHeader('X-Test', 'one');client.setRequestHeader('X-Test', 'two');// 最终request header中"X-Test"为: one, twoclient.send(); 如何获取response headerxhr提供了2个用来获取响应头部的方法：getAllResponseHeaders和getResponseHeader。前者是获取 response 中的所有header 字段，后者只是获取某个指定 header 字段的值。另外，getResponseHeader(header)的header参数不区分大小写。 DOMString getAllResponseHeaders();DOMString getResponseHeader(DOMString header); 这2个方法看起来简单，但却处处是坑儿。 你是否遇到过下面的坑儿?——反正我是遇到了。。。 使用getAllResponseHeaders()看到的所有response header与实际在控制台 Network 中看到的 response header不一样 使用getResponseHeader()获取某个 header 的值时，浏览器抛错Refused to get unsafe header &quot;XXX&quot; 经过一番寻找最终在 Stack Overflow找到了答案。 原因1：W3C的 xhr 标准中做了限制，规定客户端无法获取 response 中的 Set-Cookie、Set-Cookie2这2个字段，无论是同域还是跨域请求； 原因2：W3C 的 cors 标准对于跨域请求也做了限制，规定对于跨域请求，客户端允许获取的response header字段只限于“simple response header”和“Access-Control-Expose-Headers” （两个名词的解释见下方）。 “simple response header“包括的 header 字段有：Cache-Control,Content-Language,Content-Type,Expires,Last-Modified,Pragma;“Access-Control-Expose-Headers“：首先得注意是”Access-Control-Expose-Headers“进行跨域请求时响应头部中的一个字段，对于同域请求，响应头部是没有这个字段的。这个字段中列举的 header 字段就是服务器允许暴露给客户端访问的字段。 所以getAllResponseHeaders()只能拿到限制以外（即被视为safe）的header字段，而不是全部字段；而调用getResponseHeader(header)方法时，header参数必须是限制以外的header字段，否则调用就会报Refused to get unsafe header的错误。 如何指定xhr.response的数据类型有些时候我们希望xhr.response返回的就是我们想要的数据类型。比如：响应返回的数据是纯JSON字符串，但我们期望最终通过xhr.response拿到的直接就是一个 js 对象，我们该怎么实现呢？有2种方法可以实现，一个是level 1就提供的overrideMimeType()方法，另一个是level 2才提供的xhr.responseType属性。 xhr.overrideMimeType()overrideMimeType是xhr level 1就有的方法，所以浏览器兼容性良好。这个方法的作用就是用来重写response的content-type，这样做有什么意义呢？比如：server 端给客户端返回了一份document或者是 xml文档，我们希望最终通过xhr.response拿到的就是一个DOM对象，那么就可以用xhr.overrideMimeType(&#39;text/xml; charset = utf-8&#39;)来实现。 再举一个使用场景，我们都知道xhr level 1不支持直接传输blob二进制数据，那如果真要传输 blob 该怎么办呢？当时就是利用overrideMimeType方法来解决这个问题的。 下面是一个获取图片文件的代码示例： 12345678910111213141516171819202122var xhr = new XMLHttpRequest();//向 server 端获取一张图片xhr.open('GET', '/path/to/image.png', true);// 这行是关键！//将响应数据按照纯文本格式来解析，字符集替换为用户自己定义的字符集xhr.overrideMimeType('text/plain; charset=x-user-defined');xhr.onreadystatechange = function(e) &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; //通过 responseText 来获取图片文件对应的二进制字符串 var binStr = this.responseText; //然后自己再想方法将逐个字节还原为二进制数据 for (var i = 0, len = binStr.length; i &lt; len; ++i) &#123; var c = binStr.charCodeAt(i); //String.fromCharCode(c &amp; 0xff); var byte = c &amp; 0xff; &#125; &#125;&#125;;xhr.send(); 代码示例中xhr请求的是一张图片，通过将 response 的 content-type 改为’text/plain; charset=x-user-defined’，使得 xhr 以纯文本格式来解析接收到的blob 数据，最终用户通过this.responseText拿到的就是图片文件对应的二进制字符串，最后再将其转换为 blob 数据。 xhr.responseTyperesponseType是xhr level 2新增的属性，用来指定xhr.response的数据类型，目前还存在些兼容性问题，可以参考本文的【XMLHttpRequest的兼容性】这一小节。那么responseType可以设置为哪些格式呢，我简单做了一个表，如下： 值 xhr.response 数据类型 说明 &quot;&quot; String字符串 默认值(在不设置responseType时) &quot;text&quot; String字符串 &quot;document&quot; Document对象 希望返回 XML 格式数据时使用 &quot;json&quot; javascript 对象 存在兼容性问题，IE10/IE11不支持 &quot;blob&quot; Blob对象 &quot;arrayBuffer&quot; ArrayBuffer对象 下面是同样是获取一张图片的代码示例，相比xhr.overrideMimeType,用xhr.response来实现简单得多。 1234567891011121314var xhr = new XMLHttpRequest();xhr.open('GET', '/path/to/image.png', true);//可以将`xhr.responseType`设置为`"blob"`也可以设置为`" arrayBuffer"`//xhr.responseType = 'arrayBuffer';xhr.responseType = 'blob';xhr.onload = function(e) &#123; if (this.status == 200) &#123; var blob = this.response; ... &#125;&#125;;xhr.send(); 小结虽然在xhr level 2中，2者是共同存在的。但其实不难发现，xhr.responseType就是用来取代xhr.overrideMimeType()的，xhr.responseType功能强大的多，xhr.overrideMimeType()能做到的xhr.responseType都能做到。所以我们现在完全可以摒弃使用xhr.overrideMimeType()了。 如何获取response数据xhr提供了3个属性来获取请求返回的数据，分别是：xhr.response、xhr.responseText、xhr.responseXML xhr.response 默认值：空字符串&quot;&quot; 当请求完成时，此属性才有正确的值 请求未完成时，此属性的值可能是&quot;&quot;或者 null，具体与 xhr.responseType有关：当responseType为&quot;&quot;或&quot;text&quot;时，值为&quot;&quot;；responseType为其他值时，值为 null xhr.responseText 默认值为空字符串&quot;&quot; 只有当 responseType 为&quot;text&quot;、&quot;&quot;时，xhr对象上才有此属性，此时才能调用xhr.responseText，否则抛错 只有当请求成功时，才能拿到正确值。以下2种情况下值都为空字符串&quot;&quot;：请求未完成、请求失败 xhr.responseXML 默认值为 null 只有当 responseType 为&quot;text&quot;、&quot;&quot;、&quot;document&quot;时，xhr对象上才有此属性，此时才能调用xhr.responseXML，否则抛错 只有当请求成功且返回数据被正确解析时，才能拿到正确值。以下3种情况下值都为null：请求未完成、请求失败、请求成功但返回数据无法被正确解析时 如何追踪ajax请求的当前状态在发一个ajax请求后，如果想追踪请求当前处于哪种状态，该怎么做呢？ 用xhr.readyState这个属性即可追踪到。这个属性是只读属性，总共有5种可能值，分别对应xhr不同的不同阶段。每次xhr.readyState的值发生变化时，都会触发xhr.onreadystatechange事件，我们可以在这个事件中进行相关状态判断。 123456789101112131415xhr.onreadystatechange = function () &#123; switch(xhr.readyState)&#123; case 1://OPENED //do something break; case 2://HEADERS_RECEIVED //do something break; case 3://LOADING //do something break; case 4://DONE //do something break; &#125; 值 状态 描述 0 UNSENT (初始状态，未打开) 此时xhr对象被成功构造，open()方法还未被调用 1 OPENED (已打开，未发送) open()方法已被成功调用，send()方法还未被调用。注意：只有xhr处于OPENED状态，才能调用xhr.setRequestHeader()和xhr.send(),否则会报错 2 HEADERS_RECEIVED(已获取响应头) send()方法已经被调用, 响应头和响应状态已经返回 3 LOADING (正在下载响应体) 响应体(response entity body)正在下载中，此状态下通过xhr.response可能已经有了响应数据 4 DONE (整个数据传输过程结束) 整个数据传输过程结束，不管本次请求是成功还是失败 如何设置请求的超时时间如果请求过了很久还没有成功，为了不会白白占用的网络资源，我们一般会主动终止请求。XMLHttpRequest提供了timeout属性来允许设置请求的超时时间。 xhr.timeout 单位：milliseconds 毫秒默认值：0，即不设置超时 很多同学都知道：从请求开始 算起，若超过 timeout 时间请求还没有结束（包括成功/失败），则会触发ontimeout事件，主动结束该请求。 【那么到底什么时候才算是请求开始 ？】——xhr.onloadstart事件触发的时候，也就是你调用xhr.send()方法的时候。因为xhr.open()只是创建了一个连接，但并没有真正开始数据的传输，而xhr.send()才是真正开始了数据的传输过程。只有调用了xhr.send()，才会触发xhr.onloadstart 。 【那么什么时候才算是请求结束 ？】—— xhr.loadend事件触发的时候。 另外，还有2个需要注意的坑儿： 可以在 send()之后再设置此xhr.timeout，但计时起始点仍为调用xhr.send()方法的时刻。 当xhr为一个sync同步请求时，xhr.timeout必须置为0，否则会抛错。原因可以参考本文的【如何发一个同步请求】一节。 如何发一个同步请求xhr默认发的是异步请求，但也支持发同步请求（当然实际开发中应该尽量避免使用）。到底是异步还是同步请求，由xhr.open（）传入的async参数决定。 open(method, url [, async = true [, username = null [, password = null]]]) method: 请求的方式，如GET/POST/HEADER等，这个参数不区分大小写 url: 请求的地址，可以是相对地址如example.php，这个相对是相对于当前网页的url路径；也可以是绝对地址如http://www.example.com/example.php async: 默认值为true，即为异步请求，若async=false，则为同步请求 在我认真研读W3C 的 xhr 标准前，我总以为同步请求和异步请求只是阻塞和非阻塞的区别，其他什么事件触发、参数设置应该是一样的，事实证明我错了。 W3C 的 xhr标准中关于open()方法有这样一段说明： Throws an “InvalidAccessError” exception if async is false, the JavaScript global environment is a document environment, and either the timeout attribute is not zero, the withCredentials attribute is true, or the responseType attribute is not the empty string. 从上面一段说明可以知道，当xhr为同步请求时，有如下限制： xhr.timeout必须为0 xhr.withCredentials必须为 false xhr.responseType必须为&quot;&quot;（注意置为&quot;text&quot;也不允许） 若上面任何一个限制不满足，都会抛错，而对于异步请求，则没有这些参数设置上的限制。 之前说过页面中应该尽量避免使用sync同步请求，为什么呢？因为我们无法设置请求超时时间（xhr.timeout为0，即不限时）。在不限制超时的情况下，有可能同步请求一直处于pending状态，服务端迟迟不返回响应，这样整个页面就会一直阻塞，无法响应用户的其他交互。 另外，标准中并没有提及同步请求时事件触发的限制，但实际开发中我确实遇到过部分应该触发的事件并没有触发的现象。如在 chrome中，当xhr为同步请求时，在xhr.readyState由2变成3时，并不会触发 onreadystatechange事件，xhr.upload.onprogress和 xhr.onprogress事件也不会触发。 如何获取上传、下载的进度在上传或者下载比较大的文件时，实时显示当前的上传、下载进度是很普遍的产品需求。我们可以通过onprogress事件来实时显示进度，默认情况下这个事件每50ms触发一次。需要注意的是，上传过程和下载过程触发的是不同对象的onprogress事件： 上传触发的是xhr.upload对象的 onprogress事件 下载触发的是xhr对象的onprogress事件 1234567xhr.onprogress = updateProgress;xhr.upload.onprogress = updateProgress;function updateProgress(event) &#123; if (event.lengthComputable) &#123; var completedPercent = event.loaded / event.total; &#125; &#125; 可以发送什么类型的数据 void send(data); xhr.send(data)的参数data可以是以下几种类型： ArrayBuffer Blob Document DOMString FormData null 如果是 GET/HEAD请求，send()方法一般不传参或传 null。不过即使你真传入了参数，参数也最终被忽略，xhr.send(data)中的data会被置为 null. xhr.send(data)中data参数的数据类型会影响请求头部content-type的默认值： 如果data是 Document 类型，同时也是HTML Document类型，则content-type默认值为text/html;charset=UTF-8;否则为application/xml;charset=UTF-8； 如果data是 DOMString 类型，content-type默认值为text/plain;charset=UTF-8； 如果data是 FormData 类型，content-type默认值为multipart/form-data; boundary=[xxx] 如果data是其他类型，则不会设置content-type的默认值 当然这些只是content-type的默认值，但如果用xhr.setRequestHeader()手动设置了中content-type的值，以上默认值就会被覆盖。 另外需要注意的是，若在断网状态下调用xhr.send(data)方法，则会抛错：Uncaught NetworkError: Failed to execute &#39;send&#39; on &#39;XMLHttpRequest&#39;。一旦程序抛出错误，如果不 catch 就无法继续执行后面的代码，所以调用 xhr.send(data)方法时，应该用 try-catch捕捉错误。 12345try&#123; xhr.send(data) &#125;catch(e) &#123; //doSomething... &#125;; xhr.withCredentials与 CORS 什么关系 我们都知道，在发同域请求时，浏览器会将cookie自动加在request header中。但大家是否遇到过这样的场景：在发送跨域请求时，cookie并没有自动加在request header中。 造成这个问题的原因是：在CORS标准中做了规定，默认情况下，浏览器在发送跨域请求时，不能发送任何认证信息（credentials）如”cookies“和”HTTP authentication schemes“。除非xhr.withCredentials为true（xhr对象有一个属性叫withCredentials，默认值为false）。 所以根本原因是cookies也是一种认证信息，在跨域请求中，client端必须手动设置xhr.withCredentials=true，且server端也必须允许request能携带认证信息（即response header中包含Access-Control-Allow-Credentials:true），这样浏览器才会自动将cookie加在request header中。 另外，要特别注意一点，一旦跨域request能够携带认证信息，server端一定不能将Access-Control-Allow-Origin设置为*，而必须设置为请求页面的域名。 xhr相关事件事件分类xhr相关事件有很多，有时记起来还挺容易混乱。但当我了解了具体代码实现后，就容易理清楚了。下面是XMLHttpRequest的部分实现代码： 1234567891011121314151617181920interface XMLHttpRequestEventTarget : EventTarget &#123; // event handlers attribute EventHandler onloadstart; attribute EventHandler onprogress; attribute EventHandler onabort; attribute EventHandler onerror; attribute EventHandler onload; attribute EventHandler ontimeout; attribute EventHandler onloadend;&#125;;interface XMLHttpRequestUpload : XMLHttpRequestEventTarget &#123;&#125;;interface XMLHttpRequest : XMLHttpRequestEventTarget &#123; // event handler attribute EventHandler onreadystatechange; readonly attribute XMLHttpRequestUpload upload;&#125;; 从代码中我们可以看出： XMLHttpRequestEventTarget接口定义了7个事件： onloadstart onprogress onabort ontimeout onerror onload onloadend 每一个XMLHttpRequest里面都有一个upload属性，而upload是一个XMLHttpRequestUpload对象 XMLHttpRequest和XMLHttpRequestUpload都继承了同一个XMLHttpRequestEventTarget接口，所以xhr和xhr.upload都有第一条列举的7个事件 onreadystatechange是XMLHttpRequest独有的事件 所以这么一看就很清晰了：xhr一共有8个相关事件：7个XMLHttpRequestEventTarget事件+1个独有的onreadystatechange事件；而xhr.upload只有7个XMLHttpRequestEventTarget事件。 事件触发条件下面是我自己整理的一张xhr相关事件触发条件表，其中最需要注意的是 onerror 事件的触发条件。 事件 触发条件 onreadystatechange 每当xhr.readyState改变时触发；但xhr.readyState由非0值变为0时不触发。 onloadstart 调用xhr.send()方法后立即触发，若xhr.send()未被调用则不会触发此事件。 onprogress xhr.upload.onprogress在上传阶段(即xhr.send()之后，xhr.readystate=2之前)触发，每50ms触发一次；xhr.onprogress在下载阶段（即xhr.readystate=3时）触发，每50ms触发一次。 onload 当请求成功完成时触发，此时xhr.readystate=4 onloadend 当请求结束（包括请求成功和请求失败）时触发 onabort 当调用xhr.abort()后触发 ontimeout xhr.timeout不等于0，由请求开始即onloadstart开始算起，当到达xhr.timeout所设置时间请求还未结束即onloadend，则触发此事件。 onerror 在请求过程中，若发生Network error则会触发此事件（若发生Network error时，上传还没有结束，则会先触发xhr.upload.onerror，再触发xhr.onerror；若发生Network error时，上传已经结束，则只会触发xhr.onerror）。注意，只有发生了网络层级别的异常才会触发此事件，对于应用层级别的异常，如响应返回的xhr.statusCode是4xx时，并不属于Network error，所以不会触发onerror事件，而是会触发onload事件。 事件触发顺序当请求一切正常时，相关的事件触发顺序如下： 触发xhr.onreadystatechange(之后每次readyState变化时，都会触发一次) 触发xhr.onloadstart//上传阶段开始： 触发xhr.upload.onloadstart 触发xhr.upload.onprogress 触发xhr.upload.onload 触发xhr.upload.onloadend//上传结束，下载阶段开始： 触发xhr.onprogress 触发xhr.onload 触发xhr.onloadend 发生abort/timeout/error异常的处理在请求的过程中，有可能发生 abort/timeout/error这3种异常。那么一旦发生这些异常，xhr后续会进行哪些处理呢？后续处理如下： 一旦发生abort或timeout或error异常，先立即中止当前请求 将 readystate 置为4，并触发 xhr.onreadystatechange事件 如果上传阶段还没有结束，则依次触发以下事件： xhr.upload.onprogress xhr.upload.[onabort或ontimeout或onerror] xhr.upload.onloadend 触发 xhr.onprogress事件 触发 xhr.[onabort或ontimeout或onerror]事件 触发xhr.onloadend 事件 在哪个xhr事件中注册成功回调？从上面介绍的事件中，可以知道若xhr请求成功，就会触发xhr.onreadystatechange和xhr.onload两个事件。 那么我们到底要将成功回调注册在哪个事件中呢？我倾向于 xhr.onload事件，因为xhr.onreadystatechange是每次xhr.readyState变化时都会触发，而不是xhr.readyState=4时才触发。 123456xhr.onload = function () &#123; //如果请求成功 if(xhr.status == 200)&#123; //do successCallback &#125; &#125; 上面的示例代码是很常见的写法：先判断http状态码是否是200，如果是，则认为请求是成功的，接着执行成功回调。这样的判断是有坑儿的，比如当返回的http状态码不是200，而是201时，请求虽然也是成功的，但并没有执行成功回调逻辑。所以更靠谱的判断方法应该是：当http状态码为2xx或304时才认为成功。 123456xhr.onload = function () &#123; //如果请求成功 if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; //do successCallback &#125;&#125; 结语终于写完了……看完那一篇长长的W3C的xhr 标准，我眼睛都花了……希望这篇总结能帮助刚开始接触XMLHttpRequest的你。 最后给点扩展学习资料，如果你： 想真正搞懂XMLHttpRequest，最靠谱的方法还是看 W3C的xhr 标准; 想结合代码学习如何用XMLHttpRequest发各种类型的数据，可以参考html5rocks上的这篇文章 想粗略的了解XMLHttpRequest的基本使用，可以参考MDN的XMLHttpRequest介绍； 想了解XMLHttpRequest 的发展历程，可以参考阮老师的文章； 想了解Ajax的基本介绍，可以参考AJAX Tutorial; 想了解跨域请求，则可以参考W3C的 cors 标准; 想了解http协议，则可以参考HTTP Tutorial;]]></content>
      <categories>
        <category>JavaScript</category>
        <category>HTML</category>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
        <tag>HTML</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery动画]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F15%2FjQuery%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[jQuery中的动画大致分为三类： 基本动画方法hide()和show()到fadeIn()和fadeOut(),然后到slideUp()和slideDown()方法。 自定义动画animate() 交互动画方法toggle()、slideToggle()、fadeTo()和fadeToggle()。 1、show()和hide()方法 hide()方法，会将该元素的display样式改为“none”。 hide()方法在将”内容“的display属性值设置为”none”之前，会记住原先得display属性值(“block”或”inline”)。 show()和hide()方法可以传入一个速度参数，这个参数可以是关键字”slow“，”fast“，”normal“，还可以具体的一个单位为毫秒的数字。 show()和hide()方法会同时改变”内容“的高度、宽度和不透明度。 2、fadeIn()和fadeOut()方法 与show()和hide()方法不同的地方是，只改变元素的不透明度。 3、slideUp()和slideDown()方法 与前面两类不同的是，只改变元素的高度。 4、自定义动画方式animate()1animate(params,speed,callback) (1)params：一个包含样式属性及值得映射，比如{property1:”value”}。(2)speed：速度参数，可选。(3)callback：在动画完成时执行的函数，可选。 为了让元素动起来，就要更改元素的”top”,”left”,”bottom”和”right”样式属性，必须先把元素的position样式设置为”relative”或”absolute”。 可以实现累加、累减动画效果 1$(this).animate(&#123;left:&quot;+=200px&quot;&#125;,300); 动画的回调函数适用于jQuery中所有的动画效果方法，可以对非动画方法，例如css()等，实现排队，不会立即执行。 5、停止动画和判断是否处于动画状态1stop([clearQueue],[gotoEnd]) 参数clearQueue和gotoEnd都是可选参数，为Boolean值。clearQueue代表是否清空未执行的动画队列，gotoEnd代表是否直接将正在执行的动画跳转到末状态。 如果直接使用stop()方法，则会立即停止当前正在进行的动画，如果接下来还有动画等待继续进行，则以当前状态开始接下来的动画。 经常会遇到一种情况，在为一个元素绑定hover事件之后，用户把光标移入元素时会触发动画效果，当这个动画效果还没结束时，用户就将光标移出这个元素了，那么光标移出的动画效果将会放进队列之中，等待光标移入的动画结束后再执行。如果光标移入移出得过快就会导致动画效果与光标的动作不一致。要解决这个问题，只需要在光标的移入、移出动画之前加入stop()方法、就能解决这个问题。 1234567$(function()&#123; $(&quot;.panel&quot;).hover(function()&#123; $(this).stop().animate(&#123;height:&quot;150px&quot;,width:&quot;300px&quot;&#125;,200); &#125;,function()&#123; $(this).stop().animate(&#123;height:&quot;22px&quot;,width:&quot;60px&quot;&#125;,300); &#125;) &#125;); 此时只用一个不带参数的stop()方法就显得力不从心了。因为stop()方法只会停止正在进行的动画，如果动画有几个阶段，还是会出现上述的不一致问题，所以可以把第一个参数(clearQueue)设置为true，此时程序会把当前元素接下来尚未执行完的动画队列都清空。 判断元素是否处于动画状态可以使用以下的方法： 1if($(element).is(&quot;:animated&quot;))&#123;&#125; 要想延迟动画的执行可以使用delay()方法，传入一个时间参数，值得注意的是，该方法只能用于位于队列中的动画方法。 6、交互式的动画方法 toggle()方法可以切换元素的可见状态。 slideToggle()方法通过高度变化来切换匹配元素的可见性。 fadeTo()方法可以把元素的不透明度以渐进方式调整到指定的值。 fadeToggle()方法通过不透明度改变来切换匹配元素的可见性。 本篇转载地址]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery事件]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F15%2FjQuery%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[鼠标事件1.click与dbclick事件$ele.click()$ele.click(handler(eventObject))$ele.click([eventData],handler(eventObject))2.mousedown,mouseover3.mouseover,mouseout4.mouseenter,mouseleave5.hover6.focusin,focusout 表单事件1.blur,focus2.change3.select4.submit 键盘事件1.keydown(),keyup()2.keypress() 多事件1.on()2.off()3.event4.event.type5.event.pageX,event.pageY6.event.preventDefault()7.event.stopPropagation()8.event.which9.this,event.target 自定义事件1.trigger2.triggerHandler jQuery鼠标事件之click与dbclick事件用交互操作中，最简单直接的操作就是点击操作。jQuery提供了两个方法一个是click方法用于监听用户单击操作，另一个方法是dbclick方法用于监听用户双击操作。这两个方法的用法是类似的，下面以click()事件为例使用上非常简单：方法一：$ele.click() 12345678绑定$ele元素，不带任何参数一般是用来指定触发一个事件，用的比较少&lt;div id="test"&gt;点击触发&lt;div&gt;$("ele").click(function()&#123; alert('触发指定事件')&#125;)$("#test").click(function()&#123; $("ele").click() //手动指定触发事件 &#125;); 方法二：$ele.click( handler(eventObject) )绑定$ele元素，每次$ele元素触发点击操作会执行回调 handler函数，这样可以针对事件的反馈做很多操作了，方法中的this是指向了绑定事件的元素 1234&lt;div id="test"&gt;点击触发&lt;div&gt;$("#test").click(function() &#123; //this指向 div元素&#125;); 方法三：$ele.click( [eventData ], handler(eventObject) )使用与方法二一致，不过可以接受一个数据参数，这样的处理是为了解决不同作用域下数据传递的问题 12345&lt;div id="test"&gt;点击触发&lt;div&gt;$("#test").click(11111,function(e) &#123; //this指向 div元素 //e.data =&gt; 11111 传递数据&#125;); dblclick()的用法和click()的用法是类似的，可以参考以上click()的用法。dbclick与click事件不同的是：click事件触发需要以下几点：• click事件其实是由mousedown与mouseup 2个动作构成，所以点击的动作只有在松手后才触发PS:mousedown和mouseup下一节会讲到dblclick事件触发需要以下几点：dblclick又是由2个click叠加而来的，所以dblclick事件只有在满足以下条件的情况下才能被触发• 鼠标指针在元素里面时点击。• 鼠标指针在元素里面时释放。• 鼠标指针在元素里面时再次点击，点击间隔时间，是系统而定。• 鼠标指针在元素里面时再次释放。注意：在同一元素上同时绑定 click 和 dblclick 事件是不可取的。各个浏览器事件触发的顺序是不同的，一些浏览器在dblclick之前接受两个 click 事件 ，而一些浏览器只接受一个 click 事件。用户往往可通过不同的操作系统和浏览器配置双击灵敏度例子： 1234$(“button:eq(0)”).click(function()&#123; alert(this)&#125;)结果：this指向button元素 12345678[object HTMLButtonElement]$(‘p’).click(function(e)&#123; alert(e.target.textContent)&#125;) //取了p元素的文字部分$(“button:eq(1)”).click(function()&#123; $(‘p’).click() //手动指定触发事件&#125;) 1234567function data(e) &#123; alert(e.data)&#125;function a() &#123; $(“button:eq(2)”).click(1111,data)&#125;a(); function a() {} 是自定义一个a()方法 , 如果在你上下文中不调用是不会执行a()中方法的， 结尾处写一个函数a()是调用a()方法体。 jQuery鼠标事件之mousedown与mouseup事件用户交互操作中，最简单直接的操作就是点击操作，因此jQuery提供了一个mousedown的快捷方法可以监听用户鼠标按下的操作，与其对应的还有一个方法mouseup快捷方法可以监听用户鼠标弹起的操作。两种方法用法类似，下面以mousedown()为例使用上非常简单：方法一：$ele.mousedown()绑定$ele元素，不带任何参数一般是用来指定触发一个事件，可能一般用的比较少 1234567&lt;div id="test"&gt;点击触发&lt;div&gt;$("ele").mousedown(function()&#123; alert('触发指定事件')&#125;)$("#test").mousedown(function()&#123; $("ele").mousedown() //手动指定触发事件 &#125;); 方法二：$ele.mousedown( handler(eventObject) )绑定$ele元素，每次$ele元素触发点击操作会执行回调 handler函数这样可以针对事件的反馈做很多操作了 1234&lt;div id="test"&gt;点击触发&lt;div&gt;$("#test").mousedown(function() &#123; //this指向 div元素&#125;); 方法三：$ele.mousedown( [eventData ], handler(eventObject) )使用与方法二一致，不过可以接受一个数据参数，这样的处理是为了解决不同作用域下数据传递的问题 12345&lt;div id="test"&gt;点击触发&lt;div&gt;$("#test").mousedown(11111,function(e) &#123; //this指向 div元素 //e.data =&gt; 11111 传递数据&#125;); mousedown事件触发需要以下几点：• mousedown强调是按下触发• 如果在一个元素按住了鼠标不放，并且拖动鼠标离开这个元素，并释放鼠标键，这仍然是算作mousedown事件• 任何鼠标按钮被按下时都能触发mousedown事件• 用event 对象的which区别按键，敲击鼠标左键which的值是1，敲击鼠标中键which的值是2，敲击鼠标右键which的值是3mouseup事件触发需要以下几点：• mouseup强调是松手触发，与mousedown是相反的• mouseup与mousedown组合起来就是click事件• 如果用户在一个元素上按下鼠标按键，并且拖动鼠标离开这个元素，然后释放鼠标键，这仍然是算作mouseup事件• 任何鼠标按钮松手时都能触发mouseup事件用event 对象的which区别按键，敲击鼠标左键which的值是1，敲击鼠标中键which的值是2，敲击鼠标右键which的值是3 123456&lt;script type="text/javascript"&gt; //this指向button元素 $("button:eq(0)").mousedown(function(e) &#123; alert('e.which: ' + e.which) &#125;) &lt;/script&gt; 另外需要注意的是：click与mousedown的区别：• click事件其实是由mousedown于mouseup 2个动作构成，所以点击的动作只有在松手后才触发 jQuery鼠标事件之mousemove事件用交互操作中，经常需要知道用户是否有移动的操作。基于移动的机制可以做出拖动、拖拽一系列的效果出来。针对移动事件，jQuery提供了一个mousemove的快捷方法可以监听用户移动的的操作使用上非常简单：方法一：$ele.mousemove()绑定$ele元素，不带任何参数一般是用来指定触发一个事件，用的比较少 1234567&lt;div id="test"&gt;点击触发&lt;div&gt;$("ele").mousemove(function()&#123; alert('触发指定事件')&#125;)$("#test").click(function()&#123; $("ele").mousemove() //指定触发事件 &#125;); 方法二：$ele.mousemove( handler(eventObject) )绑定$ele元素，每次$ele元素触发点击操作会执行回调 handler函数这样可以针对事件的反馈做很多操作了 1234&lt;div id="test"&gt;滑动触发&lt;div&gt;$("#test").mousemove(function() &#123; //this指向 div元素 &#125;); 方法三：$ele.mousemove( [eventData ], handler(eventObject) )使用与方法二一致，不过可以接受一个数据参数，这样的处理是为了解决不同作用域下数据传递的问题 12345&lt;div id="test"&gt;点击触发&lt;div&gt;$("#test").mousemove(11111,function(e) &#123; //this指向 div元素 //e.data =&gt; 11111 传递数据&#125;); mousemove事件触发需要以下几点：• mousemove事件是当鼠标指针移动时触发的，即使是一个像素• 如果处理器做任何重大的处理，或者如果该事件存在多个处理函数，这可能造成浏览器的严重的性能问题 1234567891011121314&lt;script type="text/javascript"&gt; //不同函数传递数据 function data(e) &#123; $(this).find('p:last').html('数据:' + e.data) &#125; function a() &#123; $(".right").mousemove(1111, data) &#125; a(); $(".aaron3").mousemove(function(e) &#123; $(this).find('p:last').html('数 据：' + e.pageX) &#125;) &lt;/script&gt;这里不显示$(“.aaron3”).mousemove结果，只显示1111 jQuery鼠标事件之mouseover与mouseout事件在学JS的时候，大家还记得有两个方法叫移入移出事件吗？onmouseover()与onmouseout()事件~jQuery当中同样提供了这样的事件来监听用户的移入移出操作，mouseover()与mouseout()事件，两者用法类似，下面一mouseover为例：方法一：$ele.mouseover()绑定$ele元素，不带任何参数一般是用来指定触发一个事件，用的比较少 1234567&lt;div id="test"&gt;点击触发&lt;div&gt;$("ele").mouseover(function()&#123; alert('触发指定事件')&#125;)$("#test").click(function()&#123; $("ele").mouseover() //指定触发事件 &#125;); 方法二：$ele.mouseover( handler(eventObject) )绑定$ele元素，每次$ele元素触发点击操作会执行回调 handler函数这样可以针对事件的反馈做很多操作了 1234&lt;div id="test"&gt;滑动触发&lt;div&gt;$("#test").mouseover(function() &#123; //this指向 div元素 &#125;); 方法三：$ele.mouseover( [eventData ], handler(eventObject) )使用与方法二一致，不过可以接受一个数据参数，这样的处理是为了解决不同作用域下数据传递的问题 12345&lt;div id="test"&gt;点击触发&lt;div&gt;$("#test").mouseover(11111,function(e) &#123; //this指向 div元素 //e.data =&gt; 11111 传递数据&#125;); 12345678910111213&lt;script type="text/javascript"&gt; var n = 0; //绑定一个mouseover事件 $(".aaron1 p:first").mouseover(function(e) &#123; $(".aaron1 a").html('进入元素内部,mouseover事件触发次数：' + (++n)) &#125;) /* $ele.mouseover(function(e)&#123; &#125;) */&lt;/script&gt; jQuery鼠标事件之mouseenter与mouseleave事件用交互操作中，经常需要知道用户操作鼠标是否有移到元素内部或是元素外部，因此jQuery提供了一个mouseenter和mouseleave的快捷方法可以监听用户移动到内部的操作使用上非常简单，三种参数传递方式与mouseover和mouseout是一模一样的，所以这里不再重复，主要讲讲区别，下面以mouseenter为例：mouseenter JavaScript事件是Internet Explorer专有的。由于该事件在平时很有用，jQuery的模拟这一事件，以便它可用于所有浏览器。该事件在鼠标移入到元素上时被触发。任何HTML元素都可以接受此事件。mouseenter事件和mouseover的区别关键点就是：冒泡的方式处理问题简单的例子： 1234mouseover为例：&lt;div class="aaron2"&gt; &lt;p&gt;鼠标离开此区域触发mouseleave事件&lt;/p&gt;&lt;/div&gt; 如果在p元素与div元素都绑定mouseover事件，鼠标在离开p元素，但是没有离开div元素的时候，触发的结果: p元素响应事件 div元素响应事件这里的问题是div为什么会被触发？ 原因就是事件冒泡的问题，p元素触发了mouseover，他会一直往上找父元素上的mouseover事件，如果父元素有mouseover事件就会被触发所以在这种情况下面，jQuery推荐我们使用 mouseenter事件mouseenter事件只会在绑定它的元素上被调用，而不会在后代节点上被触发 jQuery鼠标事件之hover事件学了mouseover、mouseout、mouseenter、mouseleave事件，也理解了四个事件的相同点与不同点，现在可以用来给元素做一个简单的切换效果在元素上移进移出切换其换色，一般通过2个事件配合就可以达到，这里用mouseenter与mouseleave，这样可以避免冒泡问题 123456$(ele).mouseenter(function()&#123; $(this).css("background", '#bbffaa'); &#125;)$(ele).mouseleave(function()&#123; $(this).css("background", 'red');&#125;) 这样目的是达到了，代码稍微有点多，对于这样的简单逻辑jQuery直接提供了一个hover方法，可以便捷处理只需要在hover方法中传递2个回调函数就可以了，不需要显示的绑定2个事件$(selector).hover(handlerIn, handlerOut)• handlerIn(eventObject)：当鼠标指针进入元素时触发执行的事件函数• handlerOut(eventObject)：当鼠标指针离开元素时触发执行的事件函数 jQuery鼠标事件之focusin事件当一个元素，或者其内部任何一个元素获得焦点的时候，例如：input元素，用户在点击聚焦的时候，如果开发者需要捕获这个动作的时候，jQuery提供了一个focusin事件使用上非常简单：方法一：$ele.focusin()绑定$ele元素，不带任何参数一般是用来指定触发一个事件，一般用的比较少 1234567&lt;div id="test"&gt;点击触发&lt;div&gt;$("ele").focusin(function()&#123; alert('触发指定事件')&#125;)$("#test").mouseup(function()&#123; $("ele").focusin() //指定触发事件 &#125;); 方法二：$ele.focusin( handler )绑定$ele元素，每次$ele元素触发点击操作会执行回调 handler函数这样可以针对事件的反馈做很多操作了 1234&lt;div id="test"&gt;点击触发&lt;div&gt;$("#test").focusin(function() &#123; //this指向 div元素&#125;); 方法三：$ele.focusin( [eventData ], handler )使用与方法二一致，不过可以接受一个数据参数，这样的处理是为了解决不同作用域下数据传递的问题 12345&lt;div id="test"&gt;点击触发&lt;div&gt;$("#test").focusin(11111,function(e) &#123; //this指向 div元素 //e.data =&gt; 11111 传递数据&#125;); jQuery鼠标事件之focusout事件当一个元素，或者其内部任何一个元素失去焦点的时候，比如input元素，用户在点击失去焦的时候，如果开发者需要捕获这个动作，jQuery提供了一个focusout事件使用上非常简单：方法一：$ele.focusout()绑定$ele元素，不带任何参数一般是用来指定触发一个事件，可能一般用的比较少 1234567&lt;div id="test"&gt;点击触发&lt;div&gt;$("ele").focusout(function()&#123; alert('触发指定事件')&#125;)$("#test").mouseup(function()&#123; $("ele").focusout() //指定触发事件 &#125;); 方法二：$ele.focusout( handler )绑定$ele元素，每次$ele元素触发点击操作会执行回调 handler函数这样可以针对事件的反馈做很多操作了 1234&lt;div id="test"&gt;点击触发&lt;div&gt;$("#test").focusout(function() &#123; //this指向 div元素&#125;); 方法三：$ele.focusout( [eventData ], handler )使用与方法二一致，不过可以接受一个数据参数，这样的处理是为了解决不同作用域下数据传递的问题 12345&lt;div id="test"&gt;点击触发&lt;div&gt;$("#test").focusout(11111,function(e) &#123; //this指向 div元素 //e.data =&gt; 11111 传递数据&#125;); 1234567891011121314151617181920 &lt;script type="text/javascript"&gt; function fn(e)&#123; $(this).val(e.data) &#125; function a() &#123; $("input:last").focusout("llll",fn) &#125; a();&lt;/script&gt; &lt;script type="text/javascript"&gt; //input失去焦点 //给input元素增加一个边框 $("input:first").focusout(function() &#123; $(this).css('border','2px solid red') &#125;) &lt;/script&gt; jQuery表单事件之blur与focus事件在之前2.8与2.9节我们学过了表单处理事件focusin事件与focusout事件，同样用于处理表单焦点的事件还有blur与focus事件它们之间的本质区别:是否支持冒泡处理举个简单的例子 123&lt;div&gt; &lt;input type="text" /&gt;&lt;/div&gt; 其中input元素可以触发focus()事件div是input的父元素，当它包含的元素input触发了focus事件时，它就产生了focusin()事件。focus()在元素本身产生，focusin()在元素包含的元素中产生blur与focusout也亦是如此 focusin 会影响到父元素，focus不会，focus只定位到本身 jQuery表单事件之change事件元素，和元素的值都是可以发生改变的，开发者可以通过change事件去监听这些改变的动作 input元素 监听value值的变化，当有改变时，失去焦点后触发change事件。对于单选按钮和复选框，当用户用鼠标做出选择时，该事件立即触发。 select元素 对于下拉选择框，当用户用鼠标作出选择时，该事件立即触发 textarea元素 多行文本输入框，当有改变时，失去焦点后触发change事件 $(‘.target1’).change(function(e) { $(“#result”).html(e.target.value) }); //result是要输出的值 jQuery表单事件之select事件 当 textarea 或文本类型的 input 元素中的文本被选择时，会发生 select 事件。 这个函数会调用执行绑定到select事件的所有函数，包括浏览器的默认行为。可以通过在某个绑定的函数中返回false来防止触发浏览器的默认行为。 select事件只能用于元素与元素使用上非常简单：方法一：.select()触发元素的select事件:$(“input”).select(); 方法二：$ele.select( handler(eventObject) )绑定$ele元素，每次$ele元素触发点击操作会执行回调 handler函数这样可以针对事件的反馈做很多操作了 1234&lt;input id="test" value="文字选中"&gt;&lt;/input&gt;$("#test").select(function() &#123; //响应文字选中回调 //this指向 input元素 &#125;); 方法三：$ele.select( [eventData ], handler(eventObject) )使用与方法二一致，不过可以接受一个数据参数，这样的处理是为了解决不同作用域下数据传递的问题 123456789&lt;input id="test" value="文字选中"&gt;&lt;/input&gt;$("#test").select(11111,function(e) &#123;//响应文字选中回调 //this指向 div元素 //e.data =&gt; 11111 传递数据&#125;); $("input").select(function(e)&#123; alert(e.target.value) &#125;) //选中input框中文字时弹出 123456789$('#bt1').click(function() &#123; $("input").select();&#125;)//单击按钮时弹出//监听textarea元素中value的选中$('textarea').select(function(e) &#123; alert(e.target.value);&#125;); jQuery表单事件之submit事件提交表单是一个最常见的业务需求，比如用户注册，一些信息的输入都是需要表单的提交。同样的有时候开发者需要在表单提交的时候过滤一些的数据、做一些必要的操作（例如：验证表单输入的正确性，如果错误就阻止提交，从新输入）此时可以通过submit事件，监听下提交表单的这个动作使用上非常简单，与基本事件参数处理保持一致方法一：$ele.submit()绑定$ele元素，不带任何参数一般是用来指定触发一个事件，用的比较少 1234567&lt;div id="test"&gt;点击触发&lt;div&gt;$("ele").submit(function()&#123; alert('触发指定事件')&#125;)$("#text").click(function()&#123; $("ele").submit() //指定触发事件 &#125;); 方法二：$ele.submit( handler(eventObject) )绑定$ele元素，每次$ele元素触发点击操作会执行回调 handler函数这样可以针对事件的反馈做很多操作了 123456&lt;form id="target" action="destination.html"&gt; &lt;input type="submit" value="Go" /&gt;&lt;/form&gt;$("#target").submit(function() &#123; //绑定提交表单触发 //this指向 from元素 &#125;); 方法三：$ele.submit( [eventData ], handler(eventObject) )使用与方法二一致，不过可以接受一个数据参数，这样的处理是为了解决不同作用域下数据传递的问题 123456&lt;form id="target" action="destination.html"&gt; &lt;input type="submit" value="Go" /&gt;&lt;/form&gt;$("#target").submit(11111,function(data) &#123; //绑定提交表单触发 //data =&gt; 1111 //传递的data数据&#125;); 通过在 元素上绑定submit事件，开发者可以监听到用户的提交表单的的行为 具体能触发submit事件的行为： 当某些表单元素获取焦点时，敲击Enter（回车键） 上述这些操作下，都可以截获submit事件。 这里需要特别注意： form元素是有默认提交表单的行为，如果通过submit处理的话，需要禁止浏览器的这个默认行为 传统的方式是调用事件对象 e.preventDefault() 来处理， jQuery中可以直接在函数中最后结尾return false即可 jQuery处理如下： 123$("#target").submit(function(data) &#123; return false; //阻止默认行为，提交表单&#125;); 1234567891011&lt;script type="text/javascript"&gt; //回车键或者点击提交表单 $('#target1').submit(function(e) &#123; alert('捕获提交表达动作,不阻止页面跳转') &#125;); //回车键或者点击提交表单,禁止浏览器默认跳转： $('#target2').submit(function() &#123; alert('捕获提交表达动作,阻止页面跳转') return false; &#125;); &lt;/script&gt; jQuery键盘事件之keydown()与keyup()事件鼠标有mousedown,mouseup之类的事件，这是根据人的手势动作分解的2个触发行为。相对应的键盘也有这类事件，将用户行为分解成2个动作，键盘按下与松手，针对这样的2种动作，jQuery分别提供了对应keydown与keyup方法来监听keydown事件：当用户在一个元素上第一次按下键盘上字母键的时候，就会触发它。使用上非常简单，与基本事件参数处理保持一致，这里使用不在重复了，列出使用的方法 123456//直接绑定事件$elem.keydown( handler(eventObject) )//传递参数$elem.keydown( [eventData ], handler(eventObject) )//手动触发已绑定的事件$elem.keydown() keyup事件：当用户在一个元素上第一次松手键盘上的键的时候，就会触发它。使用方法与keydown是一致的只是触发的条件是方法的 注意：• keydown是在键盘按下就会触发• keyup是在键盘松手就会触发• 理论上它可以绑定到任何元素，但keydown/keyup事件只是发送到具有焦点的元素上，不同的浏览器中，可获得焦点的元素略有不同，但是表单元素总是能获取焦点，所以对于此事件类型表单元素是最合适的。 jQuery键盘事件之keypress()事件在input元素上绑定keydown事件会发现一个问题：每次获取的内容都是之前输入的，当前输入的获取不到keydown事件触发在文字还没敲进文本框，这时如果在keydown事件中输出文本框中的文本，得到的是触发键盘事件前的文本，而keyup事件触发时整个键盘事件的操作已经完成，获得的是触发键盘事件后的文本当浏览器捕获键盘输入时，还提供了一个keypress的响应，这个跟keydown是非常相似，这里使用请参考keydown这一节，具体说说不同点keypress事件与keydown和keyup的主要区别• 只能捕获单个字符，不能捕获组合键• 无法响应系统功能键（如delete，backspace）• 不区分小键盘和主键盘的数字字符总而言之，KeyPress主要用来接收字母、数字等ANSI字符，而 KeyDown 和 KeyUP 事件过程可以处理任何不被 KeyPress 识别的击键。诸如：功能键（F1-F12）、编辑键、定位键以及任何这些键和键盘换档键的组合等。 on()的多事件绑定之前学的鼠标事件，表单事件与键盘事件都有个特点，就是直接给元素绑定一个处理函数，所有这类事件都是属于快捷处理。翻开源码其实可以看到，所有的快捷事件在底层的处理都是通过一个”on”方法来实现的。jQuery on()方法是官方推荐的绑定事件的一个方法。基本用法：.on( events ,[ selector ] ,[ data ] )最常见的给元素绑定一个点击事件，对比一下快捷方式与on方式的不同$(“#elem”).click(function(){}) //快捷方式$(“#elem”).on(‘click’,function(){}) //on方式最大的不同点就是on是可以自定义事件名，当然不仅仅只是如何，继续往下看多个事件绑定同一个函数$(“#elem”).on(“mouseover mouseout”,function(){ });通过空格分离，传递不同的事件名，可以同时绑定多个事件多个事件绑定不同函数$(“#elem”).on({mouseover:function(){},mouseout:function(){}});通过空格分离，传递不同的事件名，可以同时绑定多个事件，每一个事件执行自己的回调方法将数据传递到处理程序function greet( event ) {alert( “Hello “ + event.data.name ); //Hello 慕课网}$( “button” ).on( “click”, {name: “慕课网”}, greet );可以通过第二参数（对象），当一个事件被触发时，要传递给事件处理函数的 on()的高级用法针对自己处理机制中，不仅有on方法，还有根据on演变出来的live方法(1.7后去掉了)，delegate方法等等。这些方法的底层实现部分 还是on方法，这是利用了on的另一个事件机制委托的机制衍变而来的委托机制.on( events ,[ selector ] ,[ data ], handler(eventObject) )在on的第二参数中提供了一个selector选择器，简单的来描述下参考下面3层结构 12345678&lt;div class="left"&gt; &lt;p class="aaron"&gt; &lt;a&gt;目标节点&lt;/a&gt; //点击在这个元素上 &lt;/p&gt;&lt;/div&gt;给出如下代码：$("div").on("click","p",fn) 事件绑定在最上层div元素上，当用户触发在a元素上，事件将往上冒泡，一直会冒泡在div元素上。如果提供了第二参数，那么事件在往上冒泡的过程中遇到了选择器匹配的元素，将会触发事件回调函数 1234567891011121314151617&lt;body&gt; &lt;h2&gt;on事件委托&lt;/h2&gt; &lt;div class="left"&gt; &lt;div class="aaron"&gt; &lt;a&gt;点击这里&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; //给body绑定一个click事件 //没有直接a元素绑定点击事件 //通过委托机制，点击a元素的时候，事件触发 $('body').on('click', 'a', function(e) &#123; alert(e.target.textContent) &#125;) &lt;/script&gt;&lt;/body&gt;结果：弹出“点击这里”对话框 卸载事件off()方法• 通过.on()绑定的事件处理程序• 通过off() 方法移除该绑定根据on绑定事件的一些特性，off方法也可以通过相应的传递组合的事件名，名字空间，选择器或处理函数来移除绑定在元素上指定的事件处理函数。当有多个过滤参数时，只有与这些参数完全匹配的事件处理函数才会被移除 12345678绑定2个事件$("elem").on("mousedown mouseup",fn)删除一个事件$("elem").off("mousedown")删除所有事件$("elem").off("mousedown mouseup")快捷方式删除所有事件，这里不需要传递事件名了，节点上绑定的所有事件讲全部销毁$("elem").off() jQuery事件对象的作用事件中的Event对象容易被初学者忽略掉，可能大多时候初学者不知道怎么去用它，但有些时候它还是非常有用的一个标准的”click”点击事件 123$(elem).on("click",function(event)&#123; event //事件对象&#125;) 在不同浏览器之间事件对象的获取, 以及事件对象的属性都有差异。jQuery根据 W3C 标准规范了事件对象，所以在jQuery事件回调方法中获取到的事件对象是经过兼容后处理过的一个标准的跨浏览器对象这里不在千篇一律的说方法的使用，通过实际的一个小案例，从而来了解事件对象的作用 123456&lt;ul&gt; &lt;li class="even1"&gt;&lt;/li&gt; &lt;li class="even2"&gt;&lt;/li&gt; &lt;li class="even2"&gt;&lt;/li&gt; .........&lt;/ul&gt; ul有N个子元素li(这里只写了3个)，如果我要响应每一个li的事件，那么常规的方法就是需要给所有的li都单独绑定一个事件监听，这样写法很符合逻辑，但是同时有显得繁琐因为li都有一个共同的父元素，而且所有的事件都是一致的，这里我们可以采用要一个技巧来处理，也是常说的”事件委托”事件没直接和li元素发生关系，而且绑定父元素了。由于浏览器有事件冒泡的这个特性，我们可以在触发li的时候把这个事件往上冒泡到ul上，因为ul上绑定事件响应所以就能够触发这个动作了。唯一的问题怎么才知道触发的li元素是哪个一个？这里就引出了事件对象了事件对象是用来记录一些事件发生时的相关信息的对象。事件对象只有事件发生时才会产生，并且只能是事件处理函数内部访问，在所有事件处理函数运行结束后，事件对象就被销毁回到上面的问题，既然事件对象是跟当前触发元素息息相关的，所以我们就能从里面相关的信息，从事件对象中找到 event.targetevent.targettarget 属性可以是注册事件时的元素，或者它的子元素。通常用于比较 event.target 和 this 来确定事件是不是由于冒泡而触发的。经常用于事件冒泡时处理事件委托简单来说：event.target代表当前触发事件的元素，可以通过当前元素对象的一系列属性来判断是不是我们想要的元素经过简单的实验，觉得event是实际的触发事件的元素，而this是给哪个元素绑定了事件 jQuery事件对象的属性和方法事件对象的属于与方法有很多，但是我们经常用的只有那么几个，这里我主要说下作用与区别 event.type：获取事件的类型触发元素的事件类型 123$("a").click(function(event) &#123; alert(event.type); // "click"事件&#125;); event.pageX 和 event.pageY：获取鼠标当前相对于页面的坐标通过这2个属性，可以确定元素在当前页面的坐标值，鼠标相对于文档的左边缘的位置（左边）与 （顶边）的距离，简单来说是从页面左上角开始,即是以页面为参考点,不随滑动条移动而变化 event.preventDefault() 方法：阻止默认行为这个用的特别多，在执行这个方法后，如果点击一个链接（a标签），浏览器不会跳转到新的 URL 去了。我们可以用 ######event.isDefaultPrevented() 来确定这个方法是否(在那个事件对象上)被调用过了 event.stopPropagation() 方法：阻止事件冒泡事件是可以冒泡的，为防止事件冒泡到DOM树上，也就是不触发的任何前辈元素上的事件处理函数 event.which：获取在鼠标单击时，单击的是鼠标的哪个键event.which 将 event.keyCode 和 event.charCode 标准化了。event.which也将正常化的按钮按下(mousedown 和 mouseupevents)，左键报告1，中间键报告2，右键报告3event.currentTarget : 在事件冒泡过程中的当前DOM元素冒泡前的当前触发事件的DOM对象, 等同于this. this和event.target的区别：js中事件是会冒泡的，所以this是可以变化的，但event.target不会变化，它永远是直接接受事件的目标DOM元素；.this和event.target都是dom对象如果要使用jquey中的方法可以将他们转换为jquery对象。比如this和$(this)的使用、event.target和$(event.target)的使用； jQuery自定义事件之trigger事件众所周知类似于mousedown、click、keydown等等这类型的事件都是浏览器提供的，通俗叫原生事件，这类型的事件是需要有交互行为才能被触发。在jQuery通过on方法绑定一个原生事件 123$('#elem').on('click', function() &#123; alert("触发系统事件") &#125;); alert需要执行的条件：必须有用户点击才可以。如果不同用户交互是否能在某一时刻自动触发该事件呢？ 正常来说是不可以的，但是jQuery解决了这个问题，提供了一个trigger方法来触发浏览器事件所以我们可以这样：$(‘#elem’).trigger(‘click’);在绑定on的事件元素上，通过trigger方法就可以调用到alert了，挺简单！再来看看.trigger是什么？简单来讲就是：根据绑定到匹配元素的给定的事件类型执行所有的处理程序和行为trigger除了能够触发浏览器事件，同时还支持自定义事件，并且自定义时间还支持传递参数 1234$('#elem').on('Aaron', function(event,arg1,arg2) &#123; alert("自触自定义时间") &#125;);$('#elem').trigger('Aaron',['参数1','参数2']) trigger触发浏览器事件与自定义事件区别？• 自定义事件对象，是jQuery模拟原生实现的• 自定义事件可以传递参数 jQuery自定义事件之triggerHandler事件trigger事件还有一个特性：会在DOM树上冒泡，所以如果要阻止冒泡就需要在事件处理程序中返回false或调用事件对象中的.stopPropagation() 方法可以使事件停止冒泡trigger事件是具有触发原生与自定义能力的，但是存在一个不可避免的问题： 事件对象event无法完美的实现，毕竟一个是浏览器给的，一个是自己模拟的。尽管 .trigger() 模拟事件对象，但是它并没有完美的复制自然发生的事件，若要触发通过 jQuery 绑定的事件处理函数，而不触发原生的事件，使用.triggerHandler() 来代替triggerHandler与trigger的用法是一样的，重点看不同之处：• triggerHandler不会触发浏览器的默认行为，.triggerHandler( “submit” )将不会调用表单上的.submit()• .trigger() 会影响所有与 jQuery 对象相匹配的元素，而 .triggerHandler() 仅影响第一个匹配到的元素• 使用 .triggerHandler() 触发的事件，并不会在 DOM 树中向上冒泡。 如果它们不是由目标元素直接触发的，那么它就不会进行任何处理• 与普通的方法返回 jQuery 对象(这样就能够使用链式用法)相反，.triggerHandler() 返回最后一个处理的事件的返回值。如果没有触发任何事件，会返回 undefined]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F15%2Fhttp%2F</url>
    <content type="text"><![CDATA[http全过程输入域名(url)–&gt;DNS映射为IP–&gt;TCP三次握手–&gt;HTTP请求–&gt;HTTP响应–&gt;(浏览器跟踪重定向地址)–&gt;服务器处理请求–&gt;服务器返回一个html响应–&gt;(视情况决定释放TCP连接)–&gt;客户端解析HTML–&gt;获取嵌入在HTML中的对象重新发起http请求 输入域名(url)在域名这里有很多可以聊的：域名级数判别域名服务器及域名这里有详细解释，即“计算机网络技术”的第九章Domain Name System一个点分隔一级（域名由分量组成，一级为一个分量），通俗易懂如下： 1234...三级域名.二级域名.顶级域名WWW.baidu.com com为顶级域名(通常依据组织和地理分为两类)，baidu为二级域名，WWW网站www.pic.baidu.com pic为三级域名所谓降域，如pic.baidu.com/a.txt baidu.com/b.txt中a和b在不同的域下面，都降域为baidu.com..如下详细解释 同源策略同源需满足的条件： 协议相同 域名相同:a.b.c.com a.b.d.com域名相同吗 端口相同 非同源受限制的行为： cookie localStorage indexDB无法获取 DOM无法获得 ajax请求不能发送跨域方法： 双向跨域1.降域(二级和以上有共同部分) 1234所谓降域就是寻找到最后面的域名相同的部分留下a.b.c.comd.b.c.com降域后统统改为b.c.com或者c.com 存在的问题： 安全性，当一个站点被攻击，相同域名的站点也会被攻击 重复性，所有需要跨域的都要修改document.domain=”” ajax不受降域影响，还是需要iframe在一个页面引入另一页面的形式 不可更改性，一旦降域就无法回去 2.location.hash(FIM—fragment itentitier messaging) 1234a向b传送数据 baidu.com/a.html中的iframe的src=&quot;google.com/b.html#paco&quot;,b.html监听到 url发生变化触发相应操作b向a传送数据 google.com/b.html中隐藏一个iframe,设置src=&quot;baidu.com/proxy.html#data&quot; data为要传输的数据,proxy.html是和a.html同域名下的，是a b之间的代理，负责监听utl变化就修改a的url，a监听到url变化了就做出相应操作 b.html: 123456789try &#123; parent.location.hash = &apos;data&apos;; &#125; catch (e) &#123; // ie、chrome的安全机制无法修改parent.location.hash， var ifrproxy = document.createElement(&apos;iframe&apos;); ifrproxy.style.display = &apos;none&apos;; ifrproxy.src = &quot;http://www.baidu.com/proxy.html#data&quot;; document.body.appendChild(ifrproxy); &#125; proxy.html: 123//因为parent.parent（即baidu.com/a.html）和baidu.com/proxy.html属于同一个域，所以可以改变其location.hash的值 parent.parent.location.hash = self.location.hash.substring(1); 问题：数据暴露在URL中，数据大小格式受限 3.HTML5的postMessage方法 1a向b发送数据 baidu.com/a.html 12345window.onload = function() &#123; var ifr = document.getElementById(&apos;ifr&apos;); var targetOrigin = &quot;http://www.google.com&quot;; ifr.contentWindow.postMessage(&apos;hello world!&apos;, targetOrigin); &#125;; google.com/b.html 123456789101112131415var onmessage = function (event) &#123; var data = event.data;//消息 var origin = event.origin;//消息来源地址 var source = event.source;//源Window对象 if(origin==&quot;http://www.baidu.com&quot;)&#123; console.log(data);//hello world! &#125; &#125;; if (typeof window.addEventListener != &apos;undefined&apos;) &#123; window.addEventListener(&apos;message&apos;, onmessage, false); &#125; else if (typeof window.attachEvent != &apos;undefined&apos;) &#123; //for ie window.attachEvent(&apos;onmessage&apos;, onmessage); &#125; 同理可以b向a postMessage 单向跨域 1.jsonp 1234567891011先看两种用法&lt;script&gt; function foo(data)&#123; console.log(data); &#125;&lt;/script&gt;&lt;script type=&quot;http://www.google.com/getUsers.js?callback=foo&quot;&gt;&lt;/script&gt;回调函数&lt;script src=&quot;http://www.google.com/getUsers.php?flag=do&amp;time=1&quot;&gt;&lt;/script&gt;参数问题：只支持get请求 2.服务器代理 12服务器没有同源策略，在数据提供方没有jsonp,window.name协议的支持下，使用服务器代理。在baidu.com下配置一个代理proxy即baidu.com/proxy/将ajax绑定到代理下发送http请求，此时http请求是在服务端进行的，无同源限制 3.CORS 12345678910var url = &apos;http://api.alice.com/cors&apos;; var xhr = createCORSRequest(&apos;GET&apos;, url); xhr.send();//非简单请求var url = &apos;http://api.alice.com/cors&apos;; var xhr = createCORSRequest(&apos;PUT&apos;, url); xhr.setRequestHeader( &apos;X-Custom-Header&apos;, &apos;value&apos;);xhr.send(); 另外：对于CORS的支持需要服务器和客户端之间的协调 4.window.name 5.webSocket 1需要服务器的支持，源在白名单 6.Access-Controll-Allow-Origin http和https协议有什么区别，重点解释https 1http+加密+认证+完整性保护=https http:应用层的无状态，超文本传输协议。端口为80 HTTPS：只是http通信接口部分用SSL和TLS协议替代。http直接和TCP通信，而HTTPS使用SSL所以是先和SSL通信，再由SSL和TCP通信。端口为443 cookie sessionStorage localStorage有什么不同 cookie存储在客户端，可以发送给服务器，数据大小限制为4K sessionStorage,localStorage存储在本地，不可以发送给服务器，数据大小为5M localStorage只能手动清除数据 sessionStorage关闭会话窗，数据就被清除了 HTML5本地存储分为 webStorage(localStorage,sessionStorage) indexDB DNS解析域名为IP 浏览器缓存中找 系统缓存中找 路由器缓存中找 ISP DNS缓存中找 TCP三次握手 client—–&gt;server:SYN(发起一个TCP连接，同步报文) server—–&gt;client:SYN+ACK(应答报文，表示已创建连接) client—–&gt;server:ACK(应答报文，表示收到已连接) 123456789四次挥手： 由客户端发起的关闭连接 * client-----&gt;server:FIN(请求关闭连接) * server-----&gt;client:ACK(收到了连接，但不会立即关闭，等到报文都发送完再回复一个FIN) * server-----&gt;client:FIN * client-----&gt;server:ACK(收到关闭) 由服务端发起的关闭连接 * 当http设置了keepalive定时关闭，服务端会在结束数据传送后关闭TCP连接 http请求 请求行 请求头 空行 请求包体(只有POST请求有包体) get/post区别 请求参数：get参数附在URL后面?隔开，POST参数放在包体中 大小限制：GET限制为2048字符，post无限制 安全问题：GET参数暴露在URL中，不如POST安全 浏览器历史记录：GET可以记录，POST无记录 缓存：GET可被缓存，post无 书签：GET可被收藏为书签，post不可 数据类型：GET只能ASCII码，post无限制 http响应 状态行 响应头 响应包体 http状态码1XX：表示可续发请求2XX：表示成功 123* 202成功* 204成功 不返回实体主体* 206成功 执行了一个范围请求 3XX：表示重定向 12345* 301永久重定向，增加SEO排名* 302临时重定向 禁止POST变为GET* 303另外一个URI* 304判断是否要更新缓存 请求头部携带if-modified-since自从上次更新距这次多久* 307临时重定向 4XX：表示客户端错误 1234* 400客户端语法错误* 401请求未经授权* 403服务器拒绝服务* 404请求资源不存在 5XX：服务端错误 12* 500不可预期的错误* 503此时不能提供服务 稍后恢复正常 释放TCP连接 header中的connecton:close 1服务器主动关闭TCP连接，客户端被动关闭连接 header中的connecton:keepalive 1连接保持一段时间，可以连续发送http请求 客户端解析HTMLonload ready区别： ready表示文档加载完毕，不包括图片 onload表示都加载完毕]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见命名]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F15%2F%E5%B8%B8%E8%A7%81%E5%91%BD%E5%90%8D%2F</url>
    <content type="text"><![CDATA[常见命名1 .wrap或.wrapper – 用于外侧包裹 .container或 .ct – 包裹容器 .header – 用于头部 .body – 页面 body .footer – 页面尾部 aside、sidebar – 用于侧边栏 .content – 和header footer 对应，用于主要内容 .navigation – 导航元素 .pagination – 分页 常见命名2 .tabs &gt; .tab – tab 切换 .breadcrumbs – 导航列表、面包屑 .dropdown – 下拉菜单 .article – 文章 .main – 用于主体 .thumbnail – 头像，小图像 .media – 媒体资源 .panel – 面板 .tooltip – 鼠标放置上去的提示 .popup – 鼠标点击弹出的提示 常见命名3 .button、.btn – 按钮 .ad – 广告 .subnav – 二级导航 .menu – 菜单 .tag – 标签 .message或者.notice – 提示消息 .summary – 摘要 .logo – logo .search – 搜索框 .login – 登录 常见命名4 .register – 注册 .username – 用户名 .password – 密码 .banner – 广告条 .copyright – 版权 .modal或者 .dialog – 弹窗 轮播命名 carousel –轮播 pre-arrow –后退箭头 next -arrow – 前进箭头 bullet –弹出导航条 常见命名61234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980var 名字 = &#123; 状态: [ 'inverse', 'toggled', 'switched', 'original', 'initial', 'identified', 'disabled', 'loading', 'pending', 'syncing', 'default' ], 修饰: [ 'dark', 'light', 'shaded', 'flat', 'ghost', 'maroon', 'pale', 'intense', 'twisted', 'narrow', 'wide', 'smooth', 'separate', 'clean', 'sharp', 'aligned' ], 元素: [ 'pagination', 'modal', 'popup', 'article', 'story', 'flash', 'status', 'state', 'media', 'block', 'card', 'teaser', 'badge', 'label', 'sheet', 'poster', 'notice', 'record', 'entry', 'item', 'figure', 'square', 'module', 'bar', 'button', 'action', 'knob' ], 布局: [ 'navigation', 'wrapper', 'inner', 'header', 'footer', 'aside', 'section', 'divider', 'content', 'container', 'panel', 'pane', 'construct', 'composition', 'spacing', 'frame' ]&#125;]]></content>
      <categories>
        <category>HTML</category>
        <category>CSS</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>JavaScript</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是BOM]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F15%2F%E4%BB%80%E4%B9%88%E6%98%AFBOM%2F</url>
    <content type="text"><![CDATA[什么是BOMBOM:Browser Object Model 浏览器对象模型BOM是JavaScript组成之一，它是浏览器窗口的API；BOM的核心对象是window，所以BOM是全局对象，window是浏览器提供给JS的API。 BOM的常用APIwindow.name = xxx 会将当前网页的名字声明为‘xxx’字符串，所以在JS中不要声明name，因为var name = true等同于window.name = true那么name === &#39;true&#39;;typeof name === &#39;string&#39;不能全局变量的字符串有哪些可以在控制台输入window回车查看。 window.open语句： let windowObjectReference = window.open(strUrl, strWindowName, [strWindowFeatures]); 示例：window.open(&#39;http://www.baidu.com&#39;,&#39;_blank&#39;,&#39;left=100,top=100,width=100,height=100&#39;//打开网页window.close() //关闭网页window.opener.close() //被打开的网页关闭window.history.back() || window.history.forward() || window.history.go(-1||2) //后退 前进 跳转window.location.reload(false/true) //重新加载当前页面window.location = ‘xxx’ === window.location.href = ‘xxx’//会在当前路径下的’xxx’路径window.location.protocol //获取网页协议window.location.host //获取域名window.location.port //获取端口window.location.pathname //获取路径window.location.search //获取查询字符串window.location.hash //获取锚点window.navigator.(language 语言||userAgent 当前是什么浏览器) //获取浏览器的相关信息window.pageX/YOffset //网页滚动位置window.confirm(‘xxx’) //弹出确认和取消window.scrollTo(500,500) //网页滚动到（500，50）window.outerWidth/outerHeight //获取完整窗口大小innerWidth/innerHeight //获取文档显示区大小resizeTo(width,height) //新窗口大小location.replace(“url”) //当前页面打开不可后退clearInterval(timer);time=null //定时器一次性cleartimeout(timer);time=null //定时器周期性clearInterval(timer); timer=null //停止定时器周期性clearTimeout(timer); timer=null //停止定时器一次性btn.addEventListener(“事件名”，函数对象) //添加事件监听btn.remove //删除事件监听EventListener(“事件名”，函数对象) e.stopPropagation() //阻止冒泡e.preventDefault //取消事件（阻止默认行为） BOM概述BOM是browser object model的缩写，简称浏览器对象模型 BOM提供了独立于内容而与浏览器窗口进行交互的对象，主要处理浏览器窗口和框架，不过通常浏览器特定的 JavaScript 扩展都被看做 BOM 的一部分。这些扩展包括： 1.弹出新的浏览器窗口 2.移动、关闭浏览器窗口以及调整窗口大小 3.提供 Web 浏览器详细信息的定位对象 4.提供用户屏幕分辨率详细信息的屏幕对象 5.对 cookie 的支持 6.IE 扩展了BOM，加入了ActiveXObject 类，可以通过 JavaScript 实例化 ActiveX 对象 由于BOM主要用于管理窗口与窗口之间的通讯，因此其核心对象是window BOM由一系列相关的对象构成，并且每个对象都提供了很多方法与属性 BOM缺乏标准, 是各个浏览器厂商根据DOM在各自浏览器上的实现（表现为不同浏览器定义有差别,实现方式不同）；JavaScript语法的标准化组织是ECMA，DOM的标准化组织是W3C BOM最初是Netscape浏览器标准的一部分 window对象是BOM的顶层(核心)对象，不是JS对象，所有对象都是通过它延伸出来的，也可以称为window的子对象。JavaScript是通过访问BOM（Browser Object Model）对象来访问、控制、修改客户端(浏览器)，由于BOM的window包含了document，window对象的属性和方法是直接可以使用而且被感知的，因此可以直接使用window对象的document属性，通过document属性就可以访问、检索、修改XHTML文档内容与结构。因为document对象又是DOM（Document Object Model）模型的根节点。可以说，BOM包含了DOM(文档对象模型)，浏览器提供出来给予访问的是BOM对象，从BOM对象再访问到DOM对象，从而js可以操作浏览器以及浏览器读取到的文档。 BOM的组成一、window对象window对象是BOM的核心。它具有双重角色，既是通过js访问浏览器窗口的一个接口，又是一个Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都以window作为其global对象。 全局的window对象 JavaScript中的任何一个全局函数或变量都是window的属性 window与self对象 self对象与window对象完全相同，self通常用于确认就是在当前的窗体内 window的子对象 1.document 对象 2.frames 对象 3.history 对象 4.location 对象 5.navigator 对象 6.screen 对象 window对象的函数和属性索引 窗体控制moveBy() 函数可相对窗口的当前坐标把它移动指定的像素 moveTo() 函数可把窗口的左上角移动到一个指定的坐标 resizeBy() 函数用于根据指定的像素来调整窗口的大小 resizeTo() 函数用于把窗口大小调整为指定的宽度和高度 screenLeft 和 screenTop属性返回窗口相对于屏幕的X和Y坐标 screenX 和 screenY 属性返回窗口相对于屏幕的X和Y坐标 pageXOffset 和 pageYOffset 属性设置或返回当前页面相对于窗口显示区左上角的 X 位置。pageYOffset 设置或返回当前页面相对于窗口显示区左上角的 Y 位置 outerWidth 和 outerHeight 属性设置或返回一个窗口的外部宽度(高度)，包括所有界面元素（如工具栏/滚动条） 窗体滚动轴控制scrollBy() 函数可把内容滚动指定的像素数 scrollTo() 函数可把内容滚动到指定的坐标 提示：上面几个函数的名字最后都带有To或By，to是绝对的意思(从整体而言)，by是相对的意思(从原先的位置而言) 窗体焦点控制focus() 函数可把键盘焦点给予一个窗口 blur() 函数可把键盘焦点从顶层窗口移开 新建窗体open() 函数用于打开一个新的浏览器窗口或查找一个已命名的窗口 close() 函数用于关闭浏览器窗口 createPopup() 函数用来创建一个弹出窗口 opener 属性是一个可读可写的属性，可返回对创建该窗口的 Window 对象的引用 closed 属性可返回一个布尔值，该值声明了窗口是否已经关闭 对话框alert() 函数用于显示带有一条指定消息和一个 确认 按钮的警告框 confirm() 函数用于显示一个带有指定消息和确认及取消按钮的对话框 prompt() 函数用于显示可提示用户进行输入的对话框 状态栏window.defaultStatus 属性可设置或返回窗口状态栏中的默认文本。该属性可读可写 window.status 属性可设置或返回窗口状态栏中的文本 print() 函数用于打印当前窗口的内容 时间等待与间隔setTimeout() 函数用于在指定的毫秒数后调用函数或计算表达式 clearTimeout() 函数可取消由 setTimeout() 方法设置的 timeout setInterval() 函数可按照指定的周期（以毫秒计）来调用函数或计算表达式 clearInterval() 函数可取消由 setInterval() 设置的 timeout 二、document对象document对象用于表现HTML页面当前窗体的内容，是window对象的属性，包含了一个节点对象（该对象包含每个单独页面的所有HTML元素，这就是W3C的DOM对象，由于document对象内容比较我，我们将在后面专门撰写文章进行讲解）。 三、frames对象frames对象用于表现HTML页面当前窗体的中的框架集合，是window对象的属性。如果页面使用框架，将产生一个框架集合frames，在集合中可用数字(从0开始，从左到右，逐行索引)或名字索引框架。 window：当前框架 self 属性可返回对窗口自身的只读引用 Top 属性返回当前窗口的最顶层浏览器窗口 parent 属性返回当前窗口的父窗口 四、history对象history对象用于窗体中的导航，是window对象的属性，浏览者通常可以使用浏览器的前进与后退按钮访问曾经浏览过的页面。JavaScript的history对象记录了用户曾经浏览过的页面，并可以实现浏览器前进与后退相似的导航功能；可以通过back函数后退一个页面，forward函数前进一个页面，或者使用go函数任意后退或前进页面，还可以通过length属性查看history对象中存储的页面数。 go() 函数可加载历史列表中的某个具体的页面 back() 函数可加载历史列表中的前一个 URL（如果存在） forward() 函数可加载历史列表中的下一个 URL length 属性声明了浏览器历史列表中的元素数量 五、location**对象**location对象用于获取或设置窗体的URL并可以用于解析URL。它既是window对象的属性又是document对象的属性，包含8个属性，其中7个都是当前窗体的URL的一部分，剩下的也是最重要的一个是href属性，代表当前窗体的URL。8个属性都是可读写的，但是只有href与hash的写才有意义。 assign() 函数加载一个新的文档 replace() 函数可用一个新文档取代当前文档 reload() 函数用于刷新当前文档 hash 属性是一个可读可写的字符串，该字符串是 URL 的锚部分（从 # 号开始的部分） host 属性是一个可读可写的字符串，可设置或返回当前 URL 的主机名称和端口号 hostname 属性是一个可读可写的字符串，可设置或返回当前 URL 的主机名 href 属性是一个可读可写的字符串，可设置或返回当前显示的文档的完整 URL pathname 属性是一个可读可写的字符串，可设置或返回当前 URL 的路径部分 port 属性是一个可读可写的字符串，可设置或返回当前 URL 的端口部分 protocol 属性是一个可读可写的字符串，可设置或返回当前 URL 的协议 search 属性是一个可读可写的字符串，可设置或返回当前 URL 的查询部分（问号 ? 之后的部分） navigator对象navigator对象通常用于检测浏览器与操作系统的版本，是window对象的属性。由于navigator没有统一的标准，因此各个浏览器都有自己不同的navigator版本。常用的navigator函数和属性有： taintEnabled() 函数可返回一个布尔值，该值声明了当前浏览器是否启用了 data tainting appCodeName 属性是一个只读字符串，声明了浏览器的代码名 appName 属性可返回浏览器的名称 appVersion 属性可返回浏览器的平台和版本信息。该属性是一个只读的字符串 cookieEnabled 属性可返回一个布尔值，如果浏览器启用了 cookie，该属性值为 true。如果禁用了 cookie，则值为 false platform 属性是一个只读的字符串，声明了运行浏览器的操作系统和（或）硬件平台 userAgent 属性是一个只读的字符串，声明了浏览器用于 HTTP 请求的用户代理头的值 javaEnabled() 函数可返回一个布尔值，该值指示浏览器是否支持并启用了 Java。如果是，则返回 true，否则返回 false screen对象screen对象用于获取用户的屏幕信息，是window对象的属性。 width 属性声明了显示浏览器的屏幕的宽度，以像素计 height 属性声明了显示浏览器的屏幕的高度，以像素计 availWidth 属性声明了显示浏览器的屏幕的可用宽度，以像素计。在 Windows 这样的操作系统中，这个可用高度不包括分配给半永久特性（如屏幕底部的任务栏）的垂直空间 availHeight 属性声明了显示浏览器的屏幕的可用高度，以像素计。在 Windows 这样的操作系统中，这个可用高度不包括分配给半永久特性（如屏幕底部的任务栏）的垂直空间 colorDepth 属性返回目标设备或缓冲器上的调色板的比特深度 pixelDepth 属性返回显示屏幕的颜色分辨率（比特每像素）]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>BOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML基础知识]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F15%2FHTML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[HTML、XML、XHTML 有什么区别这三者都是标记语言（Markup Language），区别在于： HTML：超文本标记语言，比较松散不严格的Web语言，其标签不区分大小写。 XML：可扩展标记语言，存储数据，结构参考，标签可以自定义、可扩展、区分大小写。 XTHML: 可扩展超文本标记语言，基于XML，但较于HMTL更严格的语法，更好的跨平台能力，标签必须使用小写字母、被正确地嵌套、正确地被关闭，文档必须拥有根元素。 怎样理解 HTML 语义化 使用H5新增的具有语义化的标签，便于构建更加合理的结构，利于开发者阅读代码，团队开发和维护，减少差异化 为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构； 用户体验：例如title、alt用于解释名词或解释图片信息、label标签的活用； 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重； 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页； 便于团队开发和维护，语义化更具可读性，减少差异化。 怎样理解内容与样式分离的原则 内容（HTML）与样式（CSS）分离可以便于修改控制不同的样式，让后期维护变得简单。HTML专注于内容结构，CSS控制不同的样式，让其各司其职，互不干扰。简单来说，就是HTML文档和css样式不要混着写在一起，尽量不要写行内样式,不利于修改和阅读，要从外部引入CSS文件。 有哪些常见的meta标签 meta charset=”UTF-8” 万国码 meta http-equiv=”keywords” content=””关键字，搜所引擎SEO meta http-equiv=”description” content=”内容” 网页描述 meta http-equiv=”X-UA-Compatible” content=”IE=Edge,chrome=1” 如果安装了GCF，则使用GCF来渲染页面，如果没有安装GCF，则使用最高版本的IE内核进行渲染。 meta name=”viewport” content=”width=device-width,initial-scale=1.0”&gt; 适应手机屏幕大小 meta http-equiv=”Pragma” content=”no-cache”&gt;禁止浏览器从本地计算机的缓存中访问页面内容 meta name=”author” content=”姓名”&gt;定义网页作者 meta content=”telephone=no” name=”format-detection” 忽略数字自动识别为电话号码 meta name=”renderer” content=”webkit|ie-comp|ie-stand”浏览器内核控制，一般浏览器为双核，添加meta标签的网站可以控制浏览器选择何种内核渲染。 meta http-equiv=”Cache-Control” content=”no-siteapp” /&gt; 转码申明 文档声明的作用?严格模式和混杂模式指什么?&lt;!doctype html&gt; 的作用? 文档声明的作用?文档声明是为了告诉浏览器，你的 HTML 文档是用的什么版本的 HTML 来写的，这样浏览器才能按照你声明的版本来正确的解析你的 HTML 文档。 严格模式和混杂模式指什么? 严格模式（推荐）现在也称为标准模式，在该模式下，浏览器会严格按照 HTML 和 CSS 标准来解析、渲染你的文档。 混杂模式（不推荐）的由来是一个历史问题。在互联网早期，网页一般写成两个版本：一个写给网景公司的 Navigator浏览器，一个写给微软公司的IE浏览器。当W3C制定了 Web 标准后，这两个浏览器不能马上开始按标准来解析渲染页面，因为这样会破坏当时大部分页面的显示效果。所以各浏览器就引入了混杂模式，在该模式下，浏览器会模拟Navigator 4和IE5的非标准行为来解析渲染页面，这样做就是为了兼容在W3C标准出现之前就存在的那些“不标准”的页面。 &lt;!doctype html&gt; 的作用?&lt;!doctype html&gt; 的作用就是让浏览器进入标准模式，使用最新的 HTML5标准来解析渲染页面；如果不写，浏览器就会进入混杂模式，而这是我们要避免的。 浏览器乱码的原因是什么？如何解决 乱码产生的根源就在我们保存文件时会把我们写入的文字使用编辑器默认的编码方式进行保存，而浏览器解析时并没有按照我们保存的编码格式进行解析，导致编码格式不匹配，从而产生乱码。一般只对于除英文外的语言会产生乱码，因为大部分编码格式 例如utf-8、gbk对英文都是采用1个字节的编码方式，并且使用了相同的码字，展现也就一样了。 首页，在文件保存的时候要清楚是用哪种编码方式保存的。如果你的文件是保存为utf-8格式，那么一定要在HTML 的 &lt;head&gt;里添加&lt;meta charset=&quot;utf-8&quot;&gt;，这句话的意思是告诉浏览器在打开这个页面的时候不要去猜了，而是直接选用utf-8去解码。 同理，如果你的文件保存为gbk格式，一定在文件里添加&lt;meta charset=&quot;gbk&quot;&gt;。 常见的浏览器有哪些，什么内核 常见浏览器 内核 Internet Explorer IE内核 Firefox Gecko Opear Presto Safari Webkit Chrome Blink 常见的标签&lt;html&gt;&lt;/html&gt;根标签，所有的网页标签都在中。 &lt;head&gt;&lt;/head&gt;标签用于定义文档的头部，它是所有头部元素的容器。 &lt;body&gt;和&lt;/body&gt;标签之间的内容是网页的主要内容 &lt;h1&gt;&lt;/h1&gt;~&lt;h6&gt;&lt;/h6&gt;一级标题到六级标题 &lt;p&gt;用于文字的段落，占一行 &lt;span&gt;&lt;/span&gt;标签是没有语义的，它的作用就是为了文字设置单独的样式用的。 &lt;br&gt;换行标签，自闭合标签 &lt;em&gt;&lt;/em&gt;标签内的文字会变成斜体 1234&lt;ul&gt; &lt;li&gt; &lt;li&gt;&lt;/ul&gt; 无序列表 1234&lt;ol&gt; &lt;li&gt; &lt;li&gt;&lt;/ol&gt; 有序列表 &lt;div&gt;&lt;/div&gt;标签是没有语义的，将元素包裹的一个容器，常用于对一个模块设置样式用。 &lt;table&gt;&lt;/table&gt;表格标签，用于制作表格 &lt;form&gt;&lt;/form&gt;用于打包form内的表单数据。 &lt;img&gt;用于插入图片，自闭合标签。 &lt;a&gt;超链接标签，用于跳转网页，自闭合标签]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>XML</tag>
        <tag>XHTML</tag>
        <tag>语义化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML表单(form)]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F15%2FHTML%E8%A1%A8%E5%8D%95%2F</url>
    <content type="text"><![CDATA[form表单有什么作用？有哪些常用的input 标签，分别有什么作用？表单在网页中主要负责数据采集功能。HTML &lt;form&gt;元素 表示了文档中的一个区域，这个区域包含有交互控制元件，用来向web服务器提交信息，拥有以下属性。 action 一个处理这个form信息的程序所在的URL。 autocomplete 用于指示 input 元素是否能够拥有一个默认值，这个默认值是由浏览器自动补全的。 enctype 当 method 属性值为 post 时, enctype 是提交form给服务器的内容的 MIME 类型，可能的取值有三个，application/x-www-form-urlencoded: 如果属性未指定时的默认值。multipart/form-data: 这个值用于一个 type 属性设置为 “file” 的&lt;input&gt; 元素。text/plain (HTML5)。 method 浏览器使用这种 HTTP 方式来提交 form。 可能的值有get和post。 target 一个名字或者说关键字，用来指示在提交表单之后，在哪里显示收到的回复. 常见的input标签主要由type属性控制。(input为自闭合标签) type: 控件类型的显示。如果这个属性没有指定，默认的类型是 text。 type可用的值包括： button：无缺省行为按钮。 checkbox： 复选框。必须使用 value 属性定义此控件被提交时的值。使用 checked 属性指示控件是否被选择。也可以使用 indeterminate 指示复选框在一种不确定状态（大多数平台上，显示为一条穿过复选框的水平线）。 color：HTML5 用于指定颜色的控件。 date：HTML5 用于输入日期的控件（年，月，日，不包括时间）。 datetime：HTML5 基于 UTC 时区的日期时间输入控件（时，分，秒及几分之一秒）。 datetime-local：HTML5 用于输入日期时间控件，不包含时区。 email：HTML5 用于编辑 e-mail 的字段。 合适的时候可以使用 :valid 和 :invalid CSS 伪类。 file：此控件可以让用户选择文件。使用 accept 属性可以定义控件可以选择的文件类型。 hidden：不显示在页面上的控件，但它的值会被提交到服务器。 image：图片提交按钮。必须使用 src 属性定义图片的来源及使用 alt 定义替代文本。还可以使用 height 和 width 属性以像素为单位定义图片的大小。 month：HTML5 用于输入年月的控件，不带时区。 number: HTML5 用于输入浮点数的控件。 password：一个值被遮盖的单行文本字段。使用 maxlength 指定可以输入的值的最大长度 。 radio：单选按钮。必须使用 value 属性定义此控件被提交时的值。使用checked 必须指示控件是否缺省被选择。在同一个”单选按钮组“中，所有单选按钮的 name 属性使用同一个值； 一个单选按钮组中是，同一时间只有一个单选按钮可以被选择。 range：HTML5 用于输入不精确值控件。 reset：用于将表单所内容设置为缺省值的按钮。 search：HTML5用于输入搜索字符串的单行文本字段。换行会被从输入的值中自动移除。 submit：用于提交表单的按钮。 tel：HTML5 用于输入电话号码的控件；换行会被自动从输入的值中移除A,，but no other syntax is enforced。可以使用属性，比如 pattern 和 maxlength 来约束控件输入的值。恰当的时候，可以应用 :valid 和 :invalid CSS 伪类。 text：单行字段；换行会将自动从输入的值中移除。 time：HTML5 用于输入不含时区的时间控件。 url：HTML5 用于编辑URL的字段。 The user may enter a blank or invalid address. 换行会被自动从输入值中移队。可以使用如：pattern 和 maxlength 样的属性来约束输入的值。 恰当的时候使可以应用 :valid 和 :invalid CSS 伪类。 week：HTML5 用于输入一个由星期-年组成的日期，日期不包括时区。 一些不用&lt;input type=&quot;&quot;&gt;属性创建的表单标签 label：为input元素定义标注（label 元素不会向用户呈现任何特殊效果。不过，它为鼠标用户改进了可用性。如果您在 label 元素内点击文本，就会触发此控件。就是说，当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。标签的 for 属性应当与相关input元素的 id 属性相同） textarea：创建一个文本域（多行文本输入控制）。用户可以在文本域中写入文本。在文本域中，可写入的字符字数不受限制。 hidden：隐藏域，暂存一些值；和后台交互的时候确认身份的作用，防止xss攻击；通常是需要提交到后台又不想在页面上展现的数据。 其中button，form，select，textarea，label为闭合标签。不用input来写 属性 name ，value对应的是Key——值 表单中readonly和disabled属性的区别设置了readonly的input[text]在提交表单的时候还是会提交input上声明的数据。设置了disabled的则不会提交input上声明的数据。 表单提交文件的正确方式 添加input[type=file]的input标签 设置表单的method为post 设置表单的enctype为multipart/form-data 如何无刷新提交表单在页面设置一个iframe，设置好它的name属性值，用css控制他是’消失’的。设置form的target属性为iframe的name属性即可。 默认情况下，form中的button按钮不声明type属性，则一律视为submit。 表单中readonly和disabled属性的区别设置了readonly的input[text]在提交表单的时候还是会提交input上声明的数据。设置了disabled的则不会提交input上声明的数据。 表单提交文件的正确方式 添加input[type=file]的input标签 设置表单的method为post 设置表单的enctype为multipart/form-data 如何无刷新提交表单在页面设置一个iframe，设置好它的name属性值，用css控制他是’消失’的。设置form的target属性为iframe的name属性即可。 默认情况下，form中的button按钮不声明type属性，则一律视为submit。 post 和 get 方式的区别？ GET后退按钮/刷新无害，POST数据会被重新提交（浏览器应该告知用户数据会被重新提交）。 GET书签可收藏，POST为书签不可收藏。 GET能被缓存，POST不能缓存 。 GET编码类型application/x-www-form-url，POST编码类型application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。 GET历史参数保留在浏览器历史中。POST参数不会保存在浏览器历史中。 GET对数据长度有限制，当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。POST无限制。 GET只允许 ASCII 字符。POST没有限制。也允许二进制数据。 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。GET的数据在 URL 中对所有人都是可见的。POST的数据不会显示在 URL 中。 GET请求的数据会附在URL之后(就是把数据放置在HTTP协议头中)，以?分割URL和传输数据，参数之间以&amp;相连。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中%XX中的XX为该符号以16进制表示的ASCII。POST把提交的数据则放置在是HTTP包的包体中。Get一般用于提交少量数据，Post用于提交大量数据Get最多提交1k数据，浏览器的限制。Post理论上无限制，受服务器限制Get提交的数据在浏览器历史记录中，安全性不好这里所说的安全性和上面GET提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存，(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码。 在input里，name 有什么作用？ 作为可与服务器交互数据的HTML元素的服务器端的标示，比如input、select、textarea、和button等。 由于表单提交的数据一般都是以key:value的方式提交，所以input中的name属性主要用来标识提交的数据的key值，好让服务器处理程序分辨。例如： 12&lt;input name=name value=adam&gt;&lt;input name=age value=18&gt; 则服务器在后台收到的数据格式可能是这样的： 1234&#123; name:adam, age:18&#125; radio 如何 分组? 根据name值进行分组，相同的那么值为一组单选按钮； placeholder 属性有什么作用? placeholder属性一般会在输入框有一个提示，该提示会在输入字段为空时显示，并会在字段获得焦点时消失。 注意： placeholder 属性适用于以下的 &lt;input&gt;类型：text, search, url, telephone, email 以及 password。placeholder为HTML5的新属性 type=hidden隐藏域有什么作用? 举例说明 type属性值定义为hidden可定义隐藏字段。隐藏字段对于用户是不可见的。隐藏字段通常会存储一个默认值，它们的值也可以由 JavaScript 进行修改。 有些时候我们要给用户一信息，让他在提交表单时提交上来以确定用户身份，如sessionkey等。当然这些东西也能用cookie实现，但使用隐藏域就简单的多了．而且不会有浏览器不支持，用户禁用cookie的烦恼。 有些时候一个form里有多个提交按钮，怎样使程序能够分清楚到底用户是按那一个按钮提交上来的呢？我们就可以写一个隐藏域，然后在每一个按钮处加上onclick=”document.form.command.value=”xx””然后我们接到数据后先检查command的值就会知道用户是按的那个按钮提交上来的。 有时候一个网页中有多个form，我们知道多个form是不能同时提交的，但有时这些form确实相互作用，我们就可以在form中添加隐藏域来使它们联系起来。 JavaScript不支持全局变量，但有时我们必须用全局变量，我们就可以把值先存在隐藏域里，它的值就不会丢失了。 还有个例子，比如按一个按钮弹出四个小窗口，当点击其中的一个小窗口时其他三个自动关闭．可是IE不支持小窗口相互调用，所以只有在父窗口写个隐藏域，当小窗口看到那个隐藏域的值是close时就自己关掉。 一方面隐藏数据可以暂存数据，例如用户不需要见到，但操作网页时可能用到的数据；另一方面可以提高安全性，例如，页面提交表单时可通过type=hidden设置一段隐藏的按照预先算法约定好的随机字段，服务器在受到表单数据时对这个隐藏字段进行校验，来识别该表单数据来源是否可靠，从而避免服务器数据被假页面提交的数据攻击篡改。 123账号:&lt;input type="text"&gt;密码:&lt;input type="password"&gt;&lt;input type="hidden" value="fa89f12819"&gt; CSRF 详解与攻防实战 常用方法form的属性action：指定表单数据提交到哪个地址进行处理method：指明提交表单的HTTP方法，取值为get或posttarget：在何处打开action，与标签的target属性用法类似。enctype（编码方式）：application/x-www-form-urlencoded：在发送前编码所有字符（默认）text/plain：空格转换为 “+” 加号，但不对特殊字符编码multipart/form-data：使用包含文件上传控件的表单时，必须使用该值 常用标签input标签 作用文本输入框，单行，默认宽度为20个字符密码输入框，输入内容自动转变成圆点单选框，用name分组要一致，一定要加value值复选框，用name分组要一致，一定要加value值文件上传，accept属性值可限制上传文件类型隐藏字段，后台可根据name、value值判断用户提交的表单数据是否安全定义按钮定义提交表单数据至表单处理程序的按钮定义重置按钮定义图像形式的提交按钮]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>form</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML中常用的meta元素]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F15%2FHTML%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84meta%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[meta标签提供了 HTML 文档的元数据。元数据不会显示在客户端，但是会被浏览器解析。META元素通常用于指定网页的描述，关键词，文件的最后修改时间，作者及其他元数据。元数据可以被使用浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 Web 服务调用。 meta 的属性有：name属性、http-equiv属性 、content属性和charset属性 。 name属性：name 属性规定元数据的名称。 name 属性规定content属性的信息/值的名称。 注意：如果设置了 http-equiv 属性，则不应该设置 name 属性。 语法1&lt;meta name="value"&gt; 属性值application-name 规定页面所代表的 Web 应用程序的名称。 author 规定文档的作者的名字。 1&lt;meta name = "author" content = "作者的姓名"&gt; description 规定页面的描述。搜索引擎会把这个描述显示在搜索结果中。 1&lt;meta name = "description" content = "对页面的描述语言”&gt; generator 规定用于生成文档的一个软件包（不用于手写页面）。 1&lt;meta name = "generator" content = "编辑软件的名称"&gt; keywords 规定一个逗号分隔的关键词列表 - 相关的网页（告诉搜索引擎页面是与什么相关的）。 提示：总是规定关键词（对于搜索引擎进行页面分类是必要的）。 1&lt;meta name = "keywords" content = "具体的关键字"&gt; referrer 控制所述HTTP的内容Referer附加到从本文件发送的任何请求的HTTP标头。 1&lt;meta name="referrer"&gt; no-referrer 不要发送一个HTTP Referer标头。 origin 发送起源的文件。 no-referrer-when-downgrade 发送原点作为引荐先验的，多的安全目的地（https-&gt; HTTPS），但不发送引荐一个不太安全的目的地（https-&gt; HTTP）。这是默认的行为。 origin-when-crossorigin 执行相同来源的请求时，发送一个完整的URL（从参数剥离），但只送起源的其他情况下的文件。 unsafe-URL perfoming来源相同的请求时，发送一个完整的URL（从参数剥离）。 creator 限定，在自由格式中，文件的创建者的名称。请注意，它可以是机构的名称。如果有不止一个，有几个要素都应该使用。 googlebot 这是一个代名词robots，但只有其是googlebot，索引爬虫对谷歌搜索。 publisher 在一个自由的格式，文件的发布者的名称。请注意，它可以是该机构的名称。 robots（定义搜索 引擎爬虫的索引方式）：content的参数有all（默认 ）,none,index,follow,nofollow。 1&lt;meta name="robots" content="none"&gt; slurp 这是一个代名词robots，但只有其是slurp，索引爬虫对雅虎搜索。 viewport 这给出了关于的初始大小的大小提示视口。 1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; 值 可能值 描述 width 一个正整数或者字符串 device-width 限定了宽度，以像素为单位，视口的 height 一个正整数或者字符串 device-height 定义了高度，以像素，视口的 initial-scale 一个0.0 到10.0之间的正数 定义设备宽度（之间的比率device-width以纵向模式或device-height横向模式）和视口的大小。 maximum-scale 一个0.0 到10.0之间的正数 定义了变焦的最大值; 它必须大于或等于minimum-scale或行为是不确定的。 minimum-scale 一个0.0 到10.0之间的正数 定义了变焦的最低值; 它必须小于或等于maximum-scale或行为是不确定的。 user-scalable 一个布尔值（yes 或者no） 如果设置为no，用户无法在网页中放大。默认值是yes。 scheme 该属性定义了描述元数据的方案。scheme是一种上下文，它可以对内容值进行正确的解释，就像一种格式。 http-equiv属性：http-equiv 属性提供了content属性的信息/值的 HTTP 头。 http-equiv 属性可用于模拟一个 HTTP 响应头。 语法1&lt;meta http-equiv="content-type|default-style|refresh"&gt; 属性值content-type 规定文档的字符编码。 1&lt;meta http-equiv="content-type" content="text/html; charset=utf-8"&gt; default-style 规定要使用的预定义的样式表。 1&lt;meta http-equiv="default-style" content="the document's preferred stylesheet"&gt; 注释：上面 content 属性的值必须匹配同一文档中的一个 link 元素上的 title 属性的值，或者必须匹配同一文档中的一个 style 元素上的 title 属性的值。 refresh 定义文档自动刷新的时间间隔。 1&lt;meta http-equiv="refresh" content="300"&gt; set-cookie 设置cookie，如果网页过期，那么旧cookie将被删除。 1&lt;meta http-equiv="set-cookie" content="cookievalue=xxx;expires=Monday,12 Jan 2020 20:20:20 GMT;path=/"&gt; content 属性:定义与 http-equiv 或 name 属性相关的元信息。 content 属性给出了与 http-equiv 或 name 属性相关的值。 语法1&lt;meta content="text"&gt; 属性值text ：meta 信息的内容。 charset属性：charset 属性规定 HTML 文档的字符编码。 提示：charset 属性可以通过任意元素上的 lang 属性来重写。 语法1&lt;meta charset="character_set"&gt; 属性值character_set ：规定 HTML 文档的字符编码。 常用的值： UTF-8 - Unicode 字符编码 ISO-8859-1 - 拉丁字母表的字符编码 1&lt;meta charset ="UTF-8"&gt; 在理论上，可以使用任何字符编码，但并不是所有浏览器都能够理解它们。某种字符编码使用的范围越广，浏览器就越有可能理解它。 本篇博客转载地址]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>meta</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[标签模版过滤防止恶意代码嵌入]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F14%2F%E6%A0%87%E7%AD%BE%E6%A8%A1%E7%89%88%E8%BF%87%E6%BB%A4%E9%98%B2%E6%AD%A2%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%B5%8C%E5%85%A5%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920function SaferHTML(templateData) &#123; let s = templateData[0]; for (let i = 1; i &lt; arguments.length; i++) &#123; let arg = String(arguments[i]); // Escape special characters in the substitution. s += arg.replace(/&amp;/g, "&amp;amp;") .replace(/&lt;/g, "&amp;lt;") .replace(/&gt;/g, "&amp;gt;"); // Don't escape special characters in the template. s += templateData[i]; &#125; return s;&#125;let sender = '&lt;script&gt;alert("abc")&lt;/script&gt;'; // 恶意代码let message = SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;message"&lt;p&gt;&amp;lt;script&amp;gt;alert("abc")&amp;lt;/script&amp;gt; has sent you a message.&lt;/p&gt;"]]></content>
      <categories>
        <category>JavaScript</category>
        <category>安全</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[let和const命令]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F14%2Flet%E5%92%8Cconst%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[ECMAScript 6.0ECMAScript 6.0（以下简称 ES6）是 JavaScript语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。 ECMAScript 和 JavaScript 的关系ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 Jscript 和 ActionScript）。日常场合，这两个词是可以互换的。 ES6 既是一个历史名词，也是一个泛指，含义是5.1版以后的 JavaScript 的下一代标准，涵盖了ES2015、ES2016、ES2017等等，而ES2015 则是正式名称，特指该年发布的正式版本的语言标准。以下提到的 ES6 一般是指 ES2015 标准，但有时也是泛指“下一代 JavaScript 语言”。 一、let 和 const 命令1. letES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。 不存在变量提升请参阅 #73var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。 为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。 暂时性死区只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 “暂时性死区”也意味着typeof不再是一个百分之百安全的操作。 ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。 总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。 ES6 的块级作用域let实际上为 JavaScript 新增了块级作用域。(ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。第一种场景，内层变量可能会覆盖外层变量。第二种场景，用来计数的循环变量泄露为全局变量。) 块级作用域与函数声明鉴于内部各种复杂的机制，考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。 do 表达式本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。现在有一个提案，使得块级作用域可以变为表达式，也就是说可以返回值，办法就是在块级作用域之前加上do，使它变为do表达式。 1234let x = do &#123; let t = f(); t * t + 1;&#125;; 上面代码中，变量x会得到整个块级作用域的返回值。 2. constconst声明一个只读的常量。一旦声明，常量的值就不能改变。 const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。（只声明不赋值，就会报错） const的作用域与let命令相同：只在声明所在的块级作用域内有效。const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。const声明的常量，也与let一样不可重复声明。 本质const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动 对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。 如果真的想将对象冻结，应该使用Object.freeze方法。 ES6 声明变量的六种方法ES5 只有两种声明变量的方法：var命令和function命令。ES6 除了添加let和const命令，后面章节还会提到。另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有6种声明变量的方法。 3. 顶层对象的属性顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的。 这样的设计带来了很大的问题。 ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。 （ES5 的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。） 二、变量的解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 1. 数组的解构赋值曾经，为变量赋值，只能直接指定值。 123let a = 1;let b = 2;let c = 3; ES6 允许写成下面这样。 1let [a, b, c] = [1, 2, 3]; 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。 解构不成功，foo的值都会等于undefined。 12345678let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4 上面属于不完全解构，但是可以成功。 事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。 默认值解构赋值允许指定默认值。 12345let [foo = true] = [];foo // truelet [x, y = 'b'] = ['a']; // x='a', y='b'let [x, y = 'b'] = ['a', undefined]; // x='a', y='b' 注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。 2. 对象的解构赋值解构不仅可以用于数组，还可以用于对象。 123let &#123; foo, bar &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb" 对象的解构与数组有一个重要的不同。 数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 等号左边两个变量的次序，与等号右边两个同名属性的次序不一致，对取值完全没有影响 如果变量没有对应的同名属性，导致取不到值，最后等于undefined。 如果变量名与属性名不一致，必须写成下面这样。 1234567var &#123; foo: baz &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;baz // "aaa"let obj = &#123; first: 'hello', last: 'world' &#125;;let &#123; first: f, last: l &#125; = obj;f // 'hello'l // 'world' 这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。 1let &#123; foo: foo, bar: bar &#125; = &#123; foo: "aaa", bar: "bbb" &#125;; 也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。 123let &#123; foo: baz &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;baz // "aaa"foo // error: foo is not defined 上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。 与数组一样，解构也可以用于嵌套结构的对象。 12345678910let obj = &#123; p: [ 'Hello', &#123; y: 'World' &#125; ]&#125;;let &#123; p: [x, &#123; y &#125;] &#125; = obj;x // "Hello"y // "World" 注意，这时p是模式，不是变量，因此不会被赋值。如果p也要作为变量赋值，可以写成下面这样。 1234567891011let obj = &#123; p: [ 'Hello', &#123; y: 'World' &#125; ]&#125;;let &#123; p, p: [x, &#123; y &#125;] &#125; = obj;x // "Hello"y // "World"p // ["Hello", &#123;y: "World"&#125;] 对象的解构也可以指定默认值。如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。 对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。 1let &#123; log, sin, cos &#125; = Math; 上面代码将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。 1234let arr = [1, 2, 3];let &#123;0 : first, [arr.length - 1] : last&#125; = arr;first // 1last // 3 上面代码对数组进行对象解构。数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3。方括号这种写法，属于“属性名表达式”，参见《对象的扩展》 3. 字符串的解构赋值字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。 123456const [a, b, c, d, e] = 'hello';a // "h"b // "e"c // "l"d // "l"e // "o" 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。 12let &#123;length : len&#125; = 'hello';len // 5 4. 数值和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。 12345let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true 上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。 12let &#123; prop: x &#125; = undefined; // TypeErrorlet &#123; prop: y &#125; = null; // TypeError 5. 函数参数的解构赋值函数的参数也可以使用解构赋值。 12345function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3 上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。 下面是另一个例子。 12[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);// [ 3, 7 ] 函数参数的解构也可以使用默认值。 12345678function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0] 上面代码中，函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值 注意，下面的写法会得到不一样的结果。 12345678function move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, undefined]move(&#123;&#125;); // [undefined, undefined]move(); // [0, 0] 上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。 可以使用圆括号的情况可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。 123[(b)] = [3]; // 正确(&#123; p: (d) &#125; = &#123;&#125;); // 正确[(parseInt.prop)] = [3]; // 正确 上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。 用途变量的解构赋值用途很多。 （1）交换变量的值1234let x = 1;let y = 2;[x, y] = [y, x]; 上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。 （2）从函数返回多个值函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。 12345678910111213141516// 返回一个数组function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; = example(); （3）函数参数的定义解构赋值可以方便地将一组参数与变量名对应起来。 1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); （4）提取JSON数据解构赋值对提取JSON对象中的数据，尤其有用。 12345678910let jsonData = &#123; id: 42, status: "OK", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, "OK", [867, 5309] （5）函数参数的默认值1234567891011jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125;) &#123; // ... do stuff&#125;; 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || &#39;default foo&#39;;这样的语句。 （6）遍历Map结构任何部署了Iterator接口的对象，都可以用for...of循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。 1234567891011121314151617181920var map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) &#123; console.log(key + " is " + value);&#125;// first is hello// second is world如果只想获取键名，或者只想获取键值，可以写成下面这样。// 获取键名for (let [key] of map) &#123; // ...&#125;// 获取键值for (let [,value] of map) &#123; // ...&#125; （7）输入模块的指定方法加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。 1const &#123; SourceMapConsumer, SourceNode &#125; = require("source-map");]]></content>
      <categories>
        <category>JavaScript</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>let</tag>
        <tag>const</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6中对JS的扩展]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F14%2FES6%E4%B8%AD%E5%AF%B9JS%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[目录： 字符串的扩展 正则的扩展 数值的扩展 函数的扩展 数组的扩展 对象的扩展 字符串的扩展ES6 加强了对 Unicode 的支持，并且扩展了字符串对象。 目录： 字符的 Unicode 表示法 codePointAt() String.fromCodePoint() 字符串的遍历器接口 at() normalize() includes(), startsWith(), endsWith() repeat() padStart()，padEnd() 模板字符串 实例：模板编译 标签模板 String.raw() 模板字符串的限制 字符的 Unicode 表示法JavaScript 允许采用\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点。 12"\u0061"// "a" 但是，这种表示法只限于码点在\u0000~\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。 12345"\uD842\uDFB7"// "𠮷""\u20BB7"// " 7" 上面代码表示，如果直接在\u后面跟上超过0xFFFF的数值（比如\u20BB7），JavaScript会理解成\u20BB+7。由于\u20BB是一个不可打印字符，所以只会显示一个空格，后面跟着一个7。 ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。 1234567891011"\u&#123;20BB7&#125;"// "𠮷""\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;"// "ABC"let hello = 123;hell\u&#123;6F&#125; // 123'\u&#123;1F680&#125;' === '\uD83D\uDE80'// true 上面代码中，最后一个例子表明，大括号表示法与四字节的 UTF-16 编码是等价的。 有了这种表示法之后，JavaScript 共有6种方法可以表示一个字符。 12345'\z' === 'z' // true'\172' === 'z' // true'\x7A' === 'z' // true'\u007A' === 'z' // true'\u&#123;7A&#125;' === 'z' // true codePointAt()JavaScript内部，字符以UTF-16的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode码点大于0xFFFF的字符），JavaScript会认为它们是两个字符。 1234567var s = "𠮷";s.length // 2s.charAt(0) // ''s.charAt(1) // ''s.charCodeAt(0) // 55362s.charCodeAt(1) // 57271 上面代码中，汉字“𠮷”（注意，这个字不是“吉祥”的“吉”）的码点是0x20BB7，UTF-16编码为0xD842 0xDFB7（十进制为55362 57271），需要4个字节储存。对于这种4个字节的字符，JavaScript不能正确处理，字符串长度会误判为2，而且charAt方法无法读取整个字符，charCodeAt方法只能分别返回前两个字节和后两个字节的值。 ES6提供了codePointAt方法，能够正确处理4个字节储存的字符，返回一个字符的码点。 123456var s = '𠮷a';s.codePointAt(0) // 134071s.codePointAt(1) // 57271s.codePointAt(2) // 97 codePointAt方法的参数，是字符在字符串中的位置（从0开始）。上面代码中，JavaScript将“𠮷a”视为三个字符，codePointAt方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点134071（即十六进制的20BB7）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，codePointAt方法的结果与charCodeAt方法相同。 总之，codePointAt方法会正确返回32位的UTF-16字符的码点。对于那些两个字节储存的常规字符，它的返回结果与charCodeAt方法相同。 codePointAt方法返回的是码点的十进制值，如果想要十六进制的值，可以使用toString方法转换一下。 1234var s = '𠮷a';s.codePointAt(0).toString(16) // "20bb7"s.codePointAt(2).toString(16) // "61" 你可能注意到了，codePointAt方法的参数，仍然是不正确的。比如，上面代码中，字符a在字符串s的正确位置序号应该是1，但是必须向codePointAt方法传入2。解决这个问题的一个办法是使用for…of循环，因为它会正确识别32位的UTF-16字符。 123456var s = '𠮷a';for (let ch of s) &#123; console.log(ch.codePointAt(0).toString(16));&#125;// 20bb7// 61 codePointAt方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。 123456function is32Bit(c) &#123; return c.codePointAt(0) &gt; 0xFFFF;&#125;is32Bit("𠮷") // trueis32Bit("a") // false String.fromCodePoint()ES5提供String.fromCharCode方法，用于从码点返回对应字符，但是这个方法不能识别32位的UTF-16字符（Unicode编号大于0xFFFF）。 12String.fromCharCode(0x20BB7)// "ஷ" 上面代码中，String.fromCharCode不能识别大于0xFFFF的码点，所以0x20BB7就发生了溢出，最高位2被舍弃了，最后返回码点U+0BB7对应的字符，而不是码点U+20BB7对应的字符。 ES6提供了String.fromCodePoint方法，可以识别大于0xFFFF的字符，弥补了String.fromCharCode方法的不足。在作用上，正好与codePointAt方法相反。 1234String.fromCodePoint(0x20BB7)// "𠮷"String.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\uD83D\uDE80y'// true 上面代码中，如果String.fromCodePoint方法有多个参数，则它们会被合并成一个字符串返回。 注意，fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上。 字符串的遍历器接口ES6为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被for…of循环遍历。 123456for (let codePoint of 'foo') &#123; console.log(codePoint)&#125;// "f"// "o"// "o" 除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。 at()ES5 对字符串对象提供charAt方法，返回字符串给定位置的字符。该方法不能识别码点大于0xFFFF的字符。 目前，有一个提案，提出字符串实例的at方法，可以识别 Unicode 编号大于0xFFFF的字符，返回正确的字符。 12'abc'.at(0) // "a"'𠮷'.at(0) // "𠮷" 这个方法可以通过垫片库实现。 normalize()ES6 提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。 includes(), startsWith(), endsWith()传统上，JavaScript只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。 includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 12345678910111213var s = 'Hello world!';s.startsWith('Hello') // trues.endsWith('!') // trues.includes('o') // true// 这三个方法都支持第二个参数，表示开始搜索的位置。s.startsWith('world', 6) // trues.endsWith('Hello', 5) // trues.includes('Hello', 6) // false// 使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，// 而其他两个方法针对从第n个位置直到字符串结束。 repeat()repeat方法返回一个新字符串，表示将原字符串重复n次。 参数如果是小数，会被取整。 1'na'.repeat(2.9) // "nana" 如果repeat的参数是负数或者Infinity，会报错。 1234'na'.repeat(Infinity)// RangeError'na'.repeat(-1)// RangeError 但是，如果参数是0到-1之间的小数，则等同于0，这是因为会先进行取整运算。0到-1之间的小数，取整以后等于-0，repeat视同为0。 1'na'.repeat(-0.9) // "" 参数NaN等同于0。 1'na'.repeat(NaN) // "" 如果repeat的参数是字符串，则会先转换成数字。 12'na'.repeat('na') // ""'na'.repeat('3') // "nanana" padStart()，padEnd()ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。 12345'x'.padStart(5, 'ab') // 'ababx''x'.padStart(4, 'ab') // 'abax''x'.padEnd(5, 'ab') // 'xabab''x'.padEnd(4, 'ab') // 'xaba' 上面代码中，padStart和padEnd一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。 如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。 如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。 如果省略第二个参数，默认使用空格补全长度。 padStart的常见用途是为数值补全指定位数。下面代码生成10位的数值字符串。 123'1'.padStart(10, '0') // "0000000001"'12'.padStart(10, '0') // "0000000012"'123456'.padStart(10, '0') // "0000123456" 另一个用途是提示字符串格式。 12'12'.padStart(10, 'YYYY-MM-DD') // "YYYY-MM-12"'09-12'.padStart(10, 'YYYY-MM-DD') // "YYYY-09-12" 模板字符串ES6 中引进的一种新型的字符串字面量语法 模板字符串(Template String)是增强版的字符串，用反引号(`)标识，它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。 12345678910// 普通字符串`In JavaScript '\n' is a line-feed.`// 多行字符串`In JavaScript this isnot legal.`// 字符串中嵌入变量var name = "Bob", time = "today";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` // Hello Bob, how are you today? 如果使用模板字符串表示多行字符串，则所有的空格、缩进和换行都会被保留在输出中。 123456$('#list').html(`&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;`); 上面代码中，所有模板字符串的空格和换行都是被保留的，比如&lt;ul&gt;标签前面会有一个换行。如果想把行首和行尾的换行、空格等去掉，则使用trim方法即可。 123456$('#list').html(`&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;`.trim()); 模板字符串中嵌入变量，要将变量名写在${}之中。大括号内可以放入任意的JavaScript表达式，可以进行运算，以及引入对象属性。 模板字符串之中还可以调用函数。 如果大括号中的值不是字符串，则将按照一般的规则转换为字符串。如，若大括号中是一个对象，则将默认调用对象的toString方法，把对象转换为字符串。 如果模板字符串中的变量没有声明，则会报错。 模板字符串之间还可以进行嵌套。 而单纯的模板字符串还存在着很多的局限性。如： 不能自动转义特殊的字符串。（这样很容易引起注入攻击） 不能很好的和国际化库配合（即不会格式化特定语言的数字，日期，文字等） 没有内建循环语法，（甚至连条件语句都不支持， 只可以使用模板套构的方法） 实例：模板编译下面，我们来看一个通过模板字符串，生成正式模板的实例。 1234567var template = `&lt;ul&gt; &lt;% for(var i=0; i &lt; data.supplies.length; i++) &#123; %&gt; &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt; &lt;% &#125; %&gt;&lt;/ul&gt;`; 上面代码在模板字符串之中，放置了一个常规模板。该模板使用&lt;%…%&gt;放置JavaScript代码，使用&lt;%= … %&gt;输出JavaScript表达式。 怎么编译这个模板字符串呢？ 一种思路是将其转换为JavaScript表达式字符串。 1234567echo('&lt;ul&gt;');for(var i=0; i &lt; data.supplies.length; i++) &#123; echo('&lt;li&gt;'); echo(data.supplies[i]); echo('&lt;/li&gt;');&#125;;echo('&lt;/ul&gt;'); 这个转换使用正则表达式就行了。 12345678var evalExpr = /&lt;%=(.+?)%&gt;/g;var expr = /&lt;%([\s\S]+?)%&gt;/g;template = template .replace(evalExpr, '`); \n echo( $1 ); \n echo(`') .replace(expr, '`); \n $1 \n echo(`');template = 'echo(`' + template + '`);'; 然后，将template封装在一个函数里面返回，就可以了。 1234567891011121314var script =`(function parse(data)&#123; var output = ""; function echo(html)&#123; output += html; &#125; $&#123; template &#125; return output;&#125;)`;return script; 将上面的内容拼装成一个模板编译函数compile。 12345678910111213141516171819202122232425function compile(template)&#123; var evalExpr = /&lt;%=(.+?)%&gt;/g; var expr = /&lt;%([\s\S]+?)%&gt;/g; template = template .replace(evalExpr, '`); \n echo( $1 ); \n echo(`') .replace(expr, '`); \n $1 \n echo(`'); template = 'echo(`' + template + '`);'; var script = `(function parse(data)&#123; var output = ""; function echo(html)&#123; output += html; &#125; $&#123; template &#125; return output; &#125;)`; return script;&#125; compile函数的用法如下。 1234567var parse = eval(compile(template));div.innerHTML = parse(&#123; supplies: [ "broom", "mop", "cleaner" ] &#125;);// &lt;ul&gt;// &lt;li&gt;broom&lt;/li&gt;// &lt;li&gt;mop&lt;/li&gt;// &lt;li&gt;cleaner&lt;/li&gt;// &lt;/ul&gt; 标签模板(tagged template)为此，引出了标签模板的概念。标签模板则是在反引号前面引入一个标签（tag）。该标签是一个函数，用于处于定制化模板字符串后返回值。就拿上面对特殊字符串举例。 模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。 123alert`123`// 等同于alert(123) 标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。 1234567var a = 5;var b = 10;tag`Hello $&#123; a + b &#125; world $&#123; a * b &#125;`;// 等同于tag(['Hello ', ' world ', ''], 15, 50); 上面代码中，模板字符串前面有一个标识名tag，它是一个函数。整个表达式的返回值，就是tag函数处理模板字符串后的返回值。 函数tag依次会接收到多个参数。 123456789function tag(stringArr, value1, value2)&#123; // ...&#125;// 等同于function tag(stringArr, ...values)&#123; // ...&#125; tag函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。 tag函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此tag会接受到value1和value2两个参数。 tag函数所有参数的实际值如下。 第一个参数：[‘Hello ‘, ‘ world ‘, ‘’] 第二个参数: 15 第三个参数：50 也就是说，tag函数实际上以下面的形式调用。 1tag(['Hello ', ' world ', ''], 15, 50) passthru函数采用rest参数的写法如下。这个例子展示了，如何将各个参数按照原来的位置拼合回去。 123456789101112131415function passthru(literals, ...values) &#123; var output = ""; for (var index = 0; index &lt; values.length; index++) &#123; output += literals[index] + values[index]; &#125; output += literals[index] return output;&#125;var total = 30;var msg = passthru`The total is $&#123;total&#125; ($&#123;total*1.05&#125; with tax)`;msg// "The total is 30 (31.5 with tax)" “标签模板”的一个重要应用，就是过滤HTML字符串，防止用户输入恶意内容。123456789101112131415161718var message = SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;function SaferHTML(templateData) &#123; var s = templateData[0]; for (var i = 1; i &lt; arguments.length; i++) &#123; var arg = String(arguments[i]); // Escape special characters in the substitution. s += arg.replace(/&amp;/g, "&amp;amp;") .replace(/&lt;/g, "&amp;lt;") .replace(/&gt;/g, "&amp;gt;"); // Don't escape special characters in the template. s += templateData[i]; &#125; return s;&#125; 上面代码中，sender变量往往是用户提供的，经过SaferHTML函数处理，里面的特殊字符都会被转义。 12345var sender = '&lt;script&gt;alert("abc")&lt;/script&gt;'; // 恶意代码var message = SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;message// &lt;p&gt;&amp;lt;script&amp;gt;alert("abc")&amp;lt;/script&amp;gt; has sent you a message.&lt;/p&gt; String.raw()ES6还为原生的String对象，提供了一个raw方法。 String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。 12345String.raw`Hi\n$&#123;2+3&#125;!`;// "Hi\\n5!"String.raw`Hi\u000A!`;// 'Hi\\u000A!' 如果原字符串的斜杠已经转义，那么String.raw不会做任何处理。 12String.raw`Hi\\n`// "Hi\\n" String.raw方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。 String.raw方法也可以作为正常的函数使用。这时，它的第一个参数，应该是一个具有raw属性的对象，且raw属性的值应该是一个数组。 12345String.raw(&#123; raw: 'test' &#125;, 0, 1, 2);// 't0e1s2t'// 等同于String.raw(&#123; raw: ['t','e','s','t'] &#125;, 0, 1, 2); 模板字符串的限制前面提到标签模板里面，可以内嵌其他语言。但是，模板字符串默认会将字符串转义，导致无法嵌入其他语言。 正则的扩展 RegExp 构造函数 字符串的正则方法 u 修饰符 y 修饰符 sticky 属性 flags 属性 s 修饰符：dotAll 模式 后行断言 Unicode 属性类 具名组匹配 RegExp 构造函数在 ES5 中，RegExp构造函数的参数有两种情况。 第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。 第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。 但 当第二种情况，参数是正则表达式的时候，ES5 不允许此时使用第二个参数添加修饰符，否则会报错。 12var regex = new RegExp(/xyz/, 'i');// Uncaught TypeError: Cannot supply flags when constructing one RegExp from another ES6 改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。 12new RegExp(/abc/ig, 'i').flags// "i" 字符串的正则方法字符串对象共有4个方法，可以使用正则表达式：match()、replace()、search()和split()。 ES6 将这4个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。 String.prototype.match 调用 RegExp.prototype[Symbol.match] String.prototype.replace 调用 RegExp.prototype[Symbol.replace] String.prototype.search 调用 RegExp.prototype[Symbol.search] String.prototype.split 调用 RegExp.prototype[Symbol.split] u 修饰符ES6 对正则表达式添加了u修饰符，含义为“Unicode模式”，用来正确处理大于\uFFFF的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。 12/^\uD83D/u.test('\uD83D\uDC2A') // false/^\uD83D/.test('\uD83D\uDC2A') // true 一旦加上u修饰符号，就会修改下面这些正则表达式的行为。1. 点字符点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于0xFFFF的 Unicode 字符，点字符不能识别，必须加上u修饰符。 1234var s = '𠮷';/^.$/.test(s) // false/^.$/u.test(s) // true 上面代码表示，如果不添加u修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。 2. Unicode 字符表示法ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上u修饰符，才能识别当中的大括号，否则会被解读为量词。 12/\u&#123;61&#125;/.test('a') // false/\u&#123;61&#125;/u.test('a') // true 上面代码表示，如果不加u修饰符，正则表达式无法识别\u{61}这种表示法，只会认为这匹配61个连续的u。 3. 量词使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的 Unicode 字符。 12/𠮷&#123;2&#125;/.test('𠮷𠮷') // false/𠮷&#123;2&#125;/u.test('𠮷𠮷') // true 4. 预定义模式u修饰符也影响到预定义模式，能否正确识别码点大于0xFFFF的 Unicode 字符。 12/^\S$/.test('𠮷') // false/^\S$/u.test('𠮷') // true 上面代码的\S是预定义模式，匹配所有不是空格的字符。只有加了u修饰符，它才能正确匹配码点大于0xFFFF的 Unicode 字符。 5. i 修饰符有些 Unicode 字符的编码不同，但是字型很相近，比如，\u004B与\u212A都是大写的K。 12/[a-z]/i.test('\u212A') // false/[a-z]/iu.test('\u212A') // true 上面代码中，不加u修饰符，就无法识别非规范的K字符 y 修饰符除了u修饰符，ES6 还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。 y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。 不同之处在于，g修饰符只要剩余位置中存在匹配就可， 而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。（第一次也是必须从第一个位置匹配） 123456789var s = 'aaa_aa_a';var r1 = /a+/g;var r2 = /a+/y;r1.exec(s) // ["aaa"]r2.exec(s) // ["aaa"]r1.exec(s) // ["aa"]r2.exec(s) // null lastIndex属性指定每次搜索的开始位置 g修饰符从这个位置开始向后搜索，直到发现匹配为止。 y修饰符同样遵守lastIndex属性，但是要求必须在lastIndex指定的位置发现匹配。 sticky 属性与y修饰符相匹配，ES6 的正则对象多了sticky属性，表示是否设置了y修饰符。 12var r = /hello\d/y;r.sticky // true flags 属性ES6 为正则表达式新增了flags属性，会返回正则表达式的修饰符。 123456789// ES5 的 source 属性// 返回正则表达式的正文/abc/ig.source// "abc"// ES6 的 flags 属性// 返回正则表达式的修饰符/abc/ig.flags// 'gi' s 修饰符：dotAll 模式正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是行终止符（line terminator character）除外。 以下四个字符属于”行终止符“。 U+000A 换行符（\n） U+000D 回车符（\r） U+2028 行分隔符（line separator） U+2029 段分隔符（paragraph separator） 但是，很多时候我们希望 。匹配的是任意单个字符，这时有一种变通的写法。 12/foo[^]bar/.test('foo\nbar')// true 这种解决方案毕竟不太符合直觉，所以现在有一个提案，引入/s修饰符，使得.可以匹配任意单个字符。 1/foo.bar/s.test('foo\nbar') // true 这被称为dotAll模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个dotAll属性，返回一个布尔值，表示该正则表达式是否处在dotAll模式。 后行断言JavaScript 语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative lookahead），不支持后行断言（lookbehind）和后行否定断言（negative lookbehind）。目前，有一个提案，引入后行断言，V8 引擎4.9版已经支持。 ”先行断言“指的是，x只有在y前面才匹配，必须写成/x(?=y)/。比如，只匹配百分号之前的数字，要写成/\d+(?=%)/。”先行否定断言“指的是，x只有不在y前面才匹配，必须写成/x(?!y)/。比如，只匹配不在百分号之前的数字，要写成/\d+(?!%)/。 12/\d+(?=%)/.exec('100% of US presidents have been male') // ["100"]/\d+(?!%)/.exec('that’s all 44 of them') // ["44"] 上面两个字符串，如果互换正则表达式，就不会得到相同结果。另外，还可以看到，”先行断言“括号之中的部分（(?=%)），是不计入返回结果的。 “后行断言”正好与“先行断言”相反，x只有在y后面才匹配，必须写成/(?&lt;=y)x/。比如，只匹配美元符号之后的数字，要写成/(?&lt;=$)\d+/。”后行否定断言“则与”先行否定断言“相反，x只有不在y后面才匹配，必须写成/(?&lt;!y)x/。比如，只匹配不在美元符号后面的数字，要写成/(?&lt;!$)\d+/。 12/(?&lt;=\$)\d+/.exec('Benjamin Franklin is on the $100 bill') // ["100"]/(?&lt;!\$)\d+/.exec('it’s is worth about €90') // ["90"] 上面的例子中，“后行断言”的括号之中的部分（(?&lt;=$)），也是不计入返回结果。 Unicode 属性类目前，有一个提案，引入了一种新的类的写法\p{…}和\P{…}，允许正则表达式匹配符合 Unicode 某种属性的所有字符。 12const regexGreekSymbol = /\p&#123;Script=Greek&#125;/u;regexGreekSymbol.test('π') // true 上面代码中，\p{Script=Greek}指定匹配一个希腊文字母，所以匹配π成功。 Unicode 属性类要指定属性名和属性值。 1\p&#123;UnicodePropertyName=UnicodePropertyValue&#125; 对于某些属性，可以只写属性名。 1\p&#123;UnicodePropertyName&#125; \P{…}是\p{…}的反向匹配，即匹配不满足条件的字符。 注意，这两种类只对 Unicode 有效，所以使用的时候一定要加上u修饰符。如果不加u修饰符，正则表达式使用\p和\P会报错，ECMAScript 预留了这两个类。 具名组匹配简介正则表达式使用圆括号进行组匹配。 1const RE_DATE = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/; 上面代码中，正则表达式里面有三组圆括号。使用exec方法，就可以将这三组匹配结果提取出来。 1234const matchObj = RE_DATE.exec('1999-12-31');const year = matchObj[1]; // 1999const month = matchObj[2]; // 12const day = matchObj[3]; // 31 组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号引用，要是组的顺序变了，引用的时候就必须修改序号。 现在有一个“具名组匹配”（Named Capture Groups）的提案，允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。 123456const RE_DATE = /(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/;const matchObj = RE_DATE.exec('1999-12-31');const year = matchObj.groups.year; // 1999const month = matchObj.groups.month; // 12const day = matchObj.groups.day; // 31 上面代码中，“具名组匹配”在圆括号内部，模式的头部添加“问号 + 尖括号 + 组名”（?&lt;year&gt;），然后就可以在exec方法返回结果的groups属性上引用该组名。同时，数字序号（matchObj[1]）依然有效。 具名组匹配等于为每一组匹配加上了 ID，便于描述匹配的目的。如果组的顺序变了，也不用改变匹配后的处理代码。 如果具名组没有匹配，那么对应的groups对象属性会是undefined。 12345const RE_OPT_A = /^(?&lt;as&gt;a+)?$/;const matchObj = RE_OPT_A.exec('');matchObj.groups.as // undefined'as' in matchObj.groups // true 上面代码中，具名组as没有找到匹配，那么matchObj.groups.as属性值就是undefined，并且as这个键名在groups是始终存在的。 解构赋值和替换有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。 123let &#123;groups: &#123;one, two&#125;&#125; = /^(?&lt;one&gt;.*):(?&lt;two&gt;.*)$/u.exec('foo:bar');one // footwo // bar 字符串替换时，使用$&lt;组名&gt;引用具名组。 1234let re = /(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/u;'2015-01-02'.replace(re, '$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;')// '02/01/2015' 上面代码中，replace方法的第二个参数是一个字符串，而不是正则表达式。 replace方法的第二个参数也可以是函数，该函数的参数序列如下。 123456789101112'2015-01-02'.replace(re, ( matched, // 整个匹配结果 2015-01-02 capture1, // 第一个组匹配 2015 capture2, // 第二个组匹配 01 capture3, // 第三个组匹配 02 position, // 匹配开始的位置 0 S, // 原字符串 2015-01-02 groups // 具名组构成的一个对象 &#123;year, month, day&#125; ) =&gt; &#123; let &#123;day, month, year&#125; = args[args.length - 1]; return `$&#123;day&#125;/$&#123;month&#125;/$&#123;year&#125;`;&#125;); 具名组匹配在原来的基础上，新增了最后一个函数参数：具名组构成的一个对象。函数内部可以直接对这个对象进行解构赋值。 引用如果要在正则表达式内部引用某个“具名组匹配”，可以使用\k&lt;组名&gt;的写法。 123const RE_TWICE = /^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;$/;RE_TWICE.test('abc!abc') // trueRE_TWICE.test('abc!ab') // false 数字引用（\1）依然有效。 123const RE_TWICE = /^(?&lt;word&gt;[a-z]+)!\1$/;RE_TWICE.test('abc!abc') // trueRE_TWICE.test('abc!ab') // false 这两种引用语法还可以同时使用。 123const RE_TWICE = /^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;!\1$/;RE_TWICE.test('abc!abc!abc') // trueRE_TWICE.test('abc!abc!ab') // false 数值的扩展 二进制和八进制表示法 Number.isFinite(), Number.isNaN() Number.parseInt(), Number.parseFloat() Number.isInteger() Number.EPSILON 安全整数和Number.isSafeInteger() Math对象的扩展 Math.signbit() 指数运算符 Integer 数据类型 二进制和八进制表示法ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。 120b111110111 === 503 // true0o767 === 503 // true 从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀0表示，ES6 进一步明确，要使用前缀0o表示。 如果要将0b和0o前缀的字符串数值转为十进制，要使用Number方法。 12Number('0b111') // 7Number('0o10') // 8 Number.isFinite(), Number.isNaN()ES6 在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法。 Number.isFinite()用来检查一个数值是否为有限的（finite） 12Number.isFinite(15); // trueNumber.isFinite(0.8); // true ES5 可以通过下面的代码，部署Number.isFinite方法。(原在global对象上) 123456789101112(function (global) &#123; var global_isFinite = global.isFinite; Object.defineProperty(Number, 'isFinite', &#123; value: function isFinite(value) &#123; return typeof value === 'number' &amp;&amp; global_isFinite(value); &#125;, configurable: true, enumerable: false, writable: true &#125;);&#125;)(this); Number.isNaN()用来检查一个值是否为NaN。 12Number.isNaN(NaN) // trueNumber.isNaN(15) // false ES5 通过下面的代码，部署Number.isNaN()。(也原在全局对象上) 123456789101112(function (global) &#123; var global_isNaN = global.isNaN; Object.defineProperty(Number, 'isNaN', &#123; value: function isNaN(value) &#123; return typeof value === 'number' &amp;&amp; global_isNaN(value); &#125;, configurable: true, enumerable: false, writable: true &#125;);&#125;)(this); ES6这两个新方法 与 传统的全局方法 isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false。 12345678910isFinite(25) // trueisFinite("25") // trueNumber.isFinite(25) // trueNumber.isFinite("25") // falseisNaN(NaN) // trueisNaN("NaN") // trueNumber.isNaN(NaN) // trueNumber.isNaN("NaN") // falseNumber.isNaN(1) // false Number.parseInt(), Number.parseFloat()ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。 1234567// ES5的写法parseInt('12.34') // 12parseFloat('123.45#') // 123.45// ES6的写法Number.parseInt('12.34') // 12Number.parseFloat('123.45#') // 123.45 这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。 12Number.parseInt === parseInt // trueNumber.parseFloat === parseFloat // true Number.isInteger()Number.isInteger()用来判断一个值是否为整数。需要注意的是，在 JavaScript 内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。 12345Number.isInteger(25) // trueNumber.isInteger(25.0) // trueNumber.isInteger(25.1) // falseNumber.isInteger("15") // falseNumber.isInteger(true) // false ES5 可以通过下面的代码，部署Number.isInteger()。 123456789101112131415(function (global) &#123; var floor = Math.floor, isFinite = global.isFinite; Object.defineProperty(Number, 'isInteger', &#123; value: function isInteger(value) &#123; return typeof value === 'number' &amp;&amp; isFinite(value) &amp;&amp; floor(value) === value; &#125;, configurable: true, enumerable: false, writable: true &#125;);&#125;)(this); Number.EPSILONES6在Number对象上面，新增一个极小的常量Number.EPSILON。 1234Number.EPSILON// 2.220446049250313e-16Number.EPSILON.toFixed(20)// '0.00000000000000022204' 引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。 123456780.1 + 0.2// 0.300000000000000040.1 + 0.2 - 0.3// 5.551115123125783e-175.551115123125783e-17.toFixed(20)// '0.00000000000000005551' 但是如果这个误差能够小于Number.EPSILON，我们就可以认为得到了正确结果。 125.551115123125783e-17 &lt; Number.EPSILON// true 因此，Number.EPSILON的实质是一个可以接受的误差范围。 1234567function withinErrorMargin (left, right) &#123; return Math.abs(left - right) &lt; Number.EPSILON;&#125;withinErrorMargin(0.1 + 0.2, 0.3)// truewithinErrorMargin(0.2 + 0.2, 0.3)// false 上面的代码为浮点数运算，部署了一个误差检查函数。 安全整数和Number.isSafeInteger()JavaScript能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。 1234567Math.pow(2, 53) // 90071992547409929007199254740992 // 90071992547409929007199254740993 // 9007199254740992Math.pow(2, 53) === Math.pow(2, 53) + 1// true 上面代码中，超出2的53次方之后，一个数就不精确了。 ES6引入了Number.MAX_SAFE_INTEGER、Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。 Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。 Math对象的扩展ES6在Math对象上新增了17个与数学相关的方法。所有这些方法都是静态方法，只能在Math对象上调用。 指数运算符ES2016 新增了一个指数运算符（**）。 122 ** 2 // 42 ** 3 // 8 指数运算符可以与等号结合，形成一个新的赋值运算符（**=）。 1234567let a = 1.5;a **= 2;// 等同于 a = a * a;let b = 4;b **= 3;// 等同于 b = b * b * b; 注意，在 V8 引擎中，指数运算符与Math.pow的实现不相同，对于特别大的运算结果，两者会有细微的差异。 12345Math.pow(99, 99)// 3.697296376497263e+19799 ** 99// 3.697296376497268e+197 上面代码中，两个运算结果的最后一位有效数字是有差异的。 函数的扩展 函数参数的默认值 rest 参数 严格模式 name 属性 箭头函数 绑定 this 尾调用优化 函数参数的尾逗号 catch 语句的参数 函数参数的默认值基本用法ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。 12345678function log(x, y) &#123; y = y || 'World'; console.log(x, y);&#125;log('Hello') // Hello Worldlog('Hello', 'China') // Hello Chinalog('Hello', '') // Hello World 这种写法的缺点在于，如果参数y赋值了，但是对应的布尔值为false，则该赋值不起作用 为了避免这个问题，通常需要先判断一下参数y是否被赋值，如果没有，再等于默认值。 123if (typeof y === 'undefined') &#123; y = 'World';&#125; ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。1234567function log(x, y = 'World') &#123; console.log(x, y);&#125;log('Hello') // Hello Worldlog('Hello', 'China') // Hello Chinalog('Hello', '') // Hello 除了简洁，ES6 的写法还有两个好处： 首先，阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档； 其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。 几个注意点 参数变量是默认声明的，所以不能用let或const再次声明。 使用参数默认值时，函数不能有同名参数。 参数默认值是惰性求值的。（每次都重新计算默认值表达式的值） 与解构赋值默认值结合使用参数默认值可以与解构赋值的默认值，结合起来使用。 12345678function foo(&#123;x, y = 5&#125;) &#123; console.log(x, y);&#125;foo(&#123;&#125;) // undefined 5foo(&#123;x: 1&#125;) // 1 5foo(&#123;x: 1, y: 2&#125;) // 1 2foo() // TypeError: Cannot read property 'x' of undefined 上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。 只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值生成。如果函数foo调用时没提供参数，变量x和y就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。 12345function foo(&#123;x, y = 5&#125; = &#123;&#125;) &#123; console.log(x, y);&#125;foo() // undefined 5 上面代码指定，如果没有提供参数，函数foo的参数默认为一个空对象。 参数默认值的位置通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。 12345678910111213141516171819// 例一function f(x = 1, y) &#123; return [x, y];&#125;f() // [1, undefined]f(2) // [2, undefined])f(, 1) // 报错f(undefined, 1) // [1, 1]// 例二function f(x, y = 5, z) &#123; return [x, y, z];&#125;f() // [undefined, 5, undefined]f(1) // [1, 5, undefined]f(1, ,2) // 报错f(1, undefined, 2) // [1, 5, 2] 上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入undefined。传入undefined，将触发该参数等于默认值，null则没有这个效果。 函数的 length 属性指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。 这是因为length属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，后文的 rest 参数也不会计入length属性。 1(function(...args) &#123;&#125;).length // 0 另外如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。 12(function (a = 0, b, c) &#123;&#125;).length // 0(function (a, b = 1, c) &#123;&#125;).length // 1 作用域一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。 1234567var x = 1;function f(x, y = x) &#123; console.log(y);&#125;f(2) // 2 上面代码中，参数y的默认值等于变量x。调用函数f时，参数形成一个单独的作用域。在这个作用域里面，默认值变量x指向第一个参数x，而不是全局变量x，所以输出是2。 再看下面的例子。 12345678let x = 1;function f(y = x) &#123; let x = 2; console.log(y);&#125;f() // 1 上面代码中，函数f调用时，参数y = x形成一个单独的作用域。这个作用域里面，变量x本身没有定义，所以指向外层的全局变量x。函数调用时，函数体内部的局部变量x影响不到默认值变量x。 如果此时，全局变量x不存在，就会报错。 123456function f(y = x) &#123; let x = 2; console.log(y);&#125;f() // ReferenceError: x is not defined 下面这样写，也会报错。 1234567var x = 1;function foo(x = x) &#123; // ...&#125;foo() // ReferenceError: x is not defined 上面代码中，参数x = x形成一个单独作用域。实际执行的是let x = x，由于暂时性死区的原因，这行代码会报错”x 未定义“。 如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。请看下面的例子。 12345678let foo = 'outer';function bar(func = () =&gt; foo) &#123; let foo = 'inner'; console.log(func());&#125;bar(); // outer 上面代码中，函数bar的参数func的默认值是一个匿名函数，返回值为变量foo。函数参数形成的单独作用域里面，并没有定义变量foo，所以foo指向外层的全局变量foo，因此输出outer。 如果写成下面这样，就会报错。 123456function bar(func = () =&gt; foo) &#123; let foo = 'inner'; console.log(func());&#125;bar() // ReferenceError: foo is not defined 上面代码中，匿名函数里面的foo指向函数外层，但是函数外层并没有声明变量foo，所以就报错了。 下面是一个更复杂的例子。 123456789var x = 1;function foo(x, y = function() &#123; x = 2; &#125;) &#123; var x = 3; y(); console.log(x);&#125;foo() // 3x // 1 上面代码中，函数foo的参数形成一个单独作用域。这个作用域里面，首先声明了变量x，然后声明了变量y，y的默认值是一个匿名函数。这个匿名函数内部的变量x，指向同一个作用域的第一个参数x。函数foo内部又声明了一个内部变量x，该变量与第一个参数x由于不是同一个作用域，所以不是同一个变量，因此执行y后，内部变量x和外部全局变量x的值都没变。 如果将var x = 3的var去除，函数foo的内部变量x就指向第一个参数x，与匿名函数内部的x是一致的，所以最后输出的就是2，而外层的全局变量x依然不受影响。 123456789var x = 1;function foo(x, y = function() &#123; x = 2; &#125;) &#123; x = 3; y(); console.log(x);&#125;foo() // 2x // 1 应用利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。 12345678910function throwIfMissing() &#123; throw new Error('Missing parameter');&#125;function foo(mustBeProvided = throwIfMissing()) &#123; return mustBeProvided;&#125;foo()// Error: Missing parameter 上面代码的foo函数，如果调用的时候没有参数，就会调用默认值throwIfMissing函数，从而抛出一个错误。 从上面代码还可以看到，参数mustBeProvided的默认值等于throwIfMissing函数的运行结果（注意函数名throwIfMissing之后有一对圆括号），这表明参数的默认值不是在定义时执行，而是在运行时执行。如果参数已经赋值，默认值中的函数就不会运行。 另外，可以将参数默认值设为undefined，表明这个参数是可以省略的。 1function foo(optional = undefined) &#123; ··· &#125; rest 参数ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。 下面是一个 rest 参数代替arguments变量的例子。 1234567// arguments变量的写法function sortNumbers() &#123; return Array.prototype.slice.call(arguments).sort();&#125;// rest参数的写法const sortNumbers = (...numbers) =&gt; numbers.sort(); arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。 注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。还有上面说过的 函数的length属性，不包括 rest 参数。 严格模式从 ES5 开始，函数内部可以设定为严格模式。 1234function doSomething(a, b) &#123; 'use strict'; // code&#125; ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。 这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。 12345// 报错function doSomething(value = 070) &#123; 'use strict'; return value;&#125; 上面代码中，参数value的默认值是八进制数070，但是严格模式下不能用前缀0表示八进制，所以应该报错。但是实际上，JavaScript 引擎会先成功执行value = 070，然后进入函数体内部，发现需要用严格模式执行，这时才会报错。 虽然可以先解析函数体代码，再执行参数代码，但是这样无疑就增加了复杂性。因此，标准索性禁止了这种用法，只要参数使用了默认值、解构赋值、或者扩展运算符，就不能显式指定严格模式。 两种方法可以规避这种限制。第一种是设定全局性的严格模式，这是合法的。第一种是设定全局性的严格模式，这是合法的。 12345'use strict';function doSomething(a, b = a) &#123; // code&#125; 第二种是把函数包在一个无参数的立即执行函数里面。 123456const doSomething = (function () &#123; 'use strict'; return function(value = 42) &#123; return value; &#125;;&#125;()); name 属性函数的name属性，返回该函数的函数名。 这个属性早就被浏览器广泛支持，但是直到 ES6，才将其写入了标准。 需要注意的是，ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的name属性，会返回空字符串，而 ES6 的name属性会返回实际的函数名。 1234567var f = function () &#123;&#125;;// ES5f.name // ""// ES6f.name // "f" 如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的name属性都返回这个具名函数原本的名字。 1234567const bar = function baz() &#123;&#125;;// ES5bar.name // "baz"// ES6bar.name // "baz" Function构造函数返回的函数实例，name属性的值为anonymous。 1(new Function).name // "anonymous" bind返回的函数，name属性值会加上bound前缀。 1234function foo() &#123;&#125;;foo.bind(&#123;&#125;).name // "bound foo"(function()&#123;&#125;).bind(&#123;&#125;).name // "bound " 箭头函数基本用法ES6 允许使用“箭头”（=&gt;）定义函数。 123456var f = v =&gt; v;//上面的箭头函数等同于：var f = function(v) &#123; return v;&#125;; 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。 箭头函数可以与变量解构结合使用。 箭头函数的一个用处是简化回调函数。 使用注意点箭头函数有几个使用注意点。 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。（因为没有this） 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。 箭头函数导致this总是指向函数定义生效时所在的对象，绑定定义时所在的作用域，而不是指向运行时所在的作用域。 this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。 所以，箭头函数转成 ES5 的代码如下。 123456789101112131415// ES6function foo() &#123; setTimeout(() =&gt; &#123; console.log('id:', this.id); &#125;, 100);&#125;// ES5function foo() &#123; var _this = this; setTimeout(function () &#123; console.log('id:', _this.id); &#125;, 100);&#125; 除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。 另外，由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。 绑定 this箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法（call、apply、bind）。但是，箭头函数并不适用于所有场合，所以ES7提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。虽然该语法还是ES7的一个提案，但是Babel转码器已经支持。 函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。 123456789101112foo::bar;// 等同于bar.bind(foo);foo::bar(...arguments);// 等同于bar.apply(foo, arguments);const hasOwnProperty = Object.prototype.hasOwnProperty;function hasOwn(obj, key) &#123; return obj::hasOwnProperty(key);&#125; 如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。 1234567var method = obj::obj.foo;// 等同于var method = ::obj.foo;let log = ::console.log;// 等同于var log = console.log.bind(console); 由于双冒号运算符返回的还是原对象，因此可以采用链式写法。 1234567891011121314// 例一import &#123; map, takeWhile, forEach &#125; from "iterlib";getPlayers()::map(x =&gt; x.character())::takeWhile(x =&gt; x.strength &gt; 100)::forEach(x =&gt; console.log(x));// 例二let &#123; find, html &#125; = jake;document.querySelectorAll("div.myClass")::find("p")::html("hahaha"); 尾调用优化什么是尾调用？尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。 尾调用不一定出现在函数尾部，只要是最后一步操作即可。 尾调用优化尾调用之所以与其他调用不同，就在于它的特殊的调用位置。 我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。 123456789101112131415function f() &#123; let m = 1; let n = 2; return g(m + n);&#125;f();// 等同于function f() &#123; return g(3);&#125;f();// 等同于g(3); 上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除f(x)的调用帧，只保留g(3)的调用帧。 这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。 注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。 1234567function addOne(a)&#123; var one = 1; function inner(b)&#123; return b + one; &#125; return inner(a);&#125; 上面的函数不会进行尾调用优化，因为内层函数inner用到了外层函数addOne的内部变量one。 尾递归函数调用自身，称为递归。如果尾调用自身，就称为尾递归。 递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。 123456function factorial(n) &#123; if (n === 1) return 1; return n * factorial(n - 1);&#125;factorial(5) // 120 上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。 如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。 123456function factorial(n, total) &#123; if (n === 1) return total; return factorial(n - 1, n * total);&#125;factorial(5, 1) // 120 还有一个比较著名的例子，就是计算 Fibonacci 数列，也能充分说明尾递归优化的重要性。 非尾递归的 Fibonacci 数列实现如下。 123456789function Fibonacci (n) &#123; if ( n &lt;= 1 ) &#123;return 1&#125;; return Fibonacci(n - 1) + Fibonacci(n - 2);&#125;Fibonacci(10) // 89Fibonacci(100) // 堆栈溢出Fibonacci(500) // 堆栈溢出 尾递归优化过的 Fibonacci 数列实现如下。 123456789function Fibonacci2 (n , ac1 = 1 , ac2 = 1) &#123; if( n &lt;= 1 ) &#123;return ac2&#125;; return Fibonacci2 (n - 1, ac2, ac1 + ac2);&#125;Fibonacci2(100) // 573147844013817200000Fibonacci2(1000) // 7.0330367711422765e+208Fibonacci2(10000) // Infinity 由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出，相对节省内存。 递归函数的改写尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。 比如上面的例子，阶乘函数 factorial 需要用到一个中间变量total，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？ 两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。 12345678910function tailFactorial(n, total) &#123; if (n === 1) return total; return tailFactorial(n - 1, n * total);&#125;function factorial(n) &#123; return tailFactorial(n, 1);&#125;factorial(5) // 120 上面代码通过一个正常形式的阶乘函数factorial，调用尾递归函数tailFactorial，看起来就正常多了。 而且函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。 1234567891011121314function currying(fn, n) &#123; return function (m) &#123; return fn.call(this, m, n); &#125;;&#125;function tailFactorial(n, total) &#123; if (n === 1) return total; return tailFactorial(n - 1, n * total);&#125;const factorial = currying(tailFactorial, 1);factorial(5) // 120 上面代码通过柯里化，将尾递归函数tailFactorial变为只接受一个参数的factorial。 第二种方法就简单多了，就是采用 ES6 的函数默认值。 123456function factorial(n, total = 1) &#123; if (n === 1) return total; return factorial(n - 1, n * total);&#125;factorial(5) // 120 上面代码中，参数total有默认值1，所以调用时不用提供这个值。 总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。 严格模式ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。 这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。 func.arguments：返回调用时函数的参数。 func.caller：返回调用当前函数的那个函数。 尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。 123456function restricted() &#123; 'use strict'; restricted.caller; // 报错 restricted.arguments; // 报错&#125;restricted(); 尾递归优化的实现尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。 它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。 下面是一个正常的递归函数。 12345678910function sum(x, y) &#123; if (y &gt; 0) &#123; return sum(x + 1, y - 1); &#125; else &#123; return x; &#125;&#125;sum(1, 100000)// Uncaught RangeError: Maximum call stack size exceeded(…) 上面代码中，sum是一个递归函数，参数x是需要累加的值，参数y控制递归次数。一旦指定sum递归100000次，就会报错，提示超出调用栈的最大次数。 蹦床函数（trampoline）可以将递归执行转为循环执行。 123456function trampoline(f) &#123; while (f &amp;&amp; f instanceof Function) &#123; f = f(); &#125; return f;&#125; 上面就是蹦床函数的一个实现，它接受一个函数f作为参数。只要f执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。 然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。 1234567function sum(x, y) &#123; if (y &gt; 0) &#123; return sum.bind(null, x + 1, y - 1); &#125; else &#123; return x; &#125;&#125; 上面代码中，sum函数的每次执行，都会返回自身的另一个版本。 现在，使用蹦床函数执行sum，就不会发生调用栈溢出。 12trampoline(sum(1, 100000))// 100001 蹦床函数并不是真正的尾递归优化，下面的实现才是。 1234567891011121314151617181920212223242526272829function tco(f) &#123; var value; var active = false; var accumulated = []; return function accumulator() &#123; accumulated.push(arguments); if (!active) &#123; active = true; while (accumulated.length) &#123; value = f.apply(this, accumulated.shift()); &#125; active = false; return value; &#125; &#125;;&#125;var sum = tco(function(x, y) &#123; if (y &gt; 0) &#123; return sum(x + 1, y - 1) &#125; else &#123; return x &#125;&#125;);sum(1, 100000)// 100001 上面代码中，tco函数是尾递归优化的实现，它的奥妙就在于状态变量active。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归sum返回的都是undefined，所以就避免了递归执行；而accumulated数组存放每一轮sum执行的参数，总是有值的，这就保证了accumulator函数内部的while循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。 函数参数的尾逗号ES2017 允许函数的最后一个参数有尾逗号（trailing comma）。 此前，函数定义和调用时，都不允许最后一个参数后面出现逗号。 catch 语句的参数目前，有一个提案，允许try…catch结构中的catch语句调用时不带有参数。这个提案跟参数有关，也放在这一章介绍。 传统的写法是catch语句必须带有参数，用来接收try代码块抛出的错误。 数组的扩展 扩展运算符 Array.from() Array.of() 数组实例的 copyWithin() 数组实例的 find() 和 findIndex() 数组实例的fill() 数组实例的 entries()，keys() 和 values() 数组实例的 includes() 数组的空位 扩展运算符含义扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。 替代数组的 apply 方法由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。 12345678910111213// ES5 的写法function f(x, y, z) &#123; // ...&#125;var args = [0, 1, 2];f.apply(null, args);// ES6的写法function f(x, y, z) &#123; // ...&#125;var args = [0, 1, 2];f(...args); 下面是扩展运算符取代apply方法的一个实际的例子，应用Math.max方法，简化求出一个数组最大元素的写法。 12345678// ES5 的写法Math.max.apply(null, [14, 3, 77])// ES6 的写法Math.max(...[14, 3, 77])// 等同于Math.max(14, 3, 77); 另一个例子是通过push函数，将一个数组添加到另一个数组的尾部。 123456789// ES5的 写法var arr1 = [0, 1, 2];var arr2 = [3, 4, 5];Array.prototype.push.apply(arr1, arr2);// ES6 的写法var arr1 = [0, 1, 2];var arr2 = [3, 4, 5];arr1.push(...arr2); 上面代码的 ES5 写法中，push方法的参数不能是数组，所以只好通过apply方法变通使用push方法。有了扩展运算符，就可以直接将数组传入push方法。 扩展运算符的应用1. 合并数组扩展运算符提供了数组合并的新写法。 12345678910111213141516// ES5[1, 2].concat(more)// ES6[1, 2, ...more]var arr1 = ['a', 'b'];var arr2 = ['c'];var arr3 = ['d', 'e'];// ES5的合并数组arr1.concat(arr2, arr3);// [ 'a', 'b', 'c', 'd', 'e' ]// ES6的合并数组[...arr1, ...arr2, ...arr3]// [ 'a', 'b', 'c', 'd', 'e' ] 2. 与解构赋值结合扩展运算符可以与解构赋值结合起来，用于生成数组。 1234// ES5a = list[0], rest = list.slice(1)// ES6[a, ...rest] = list 下面是另外一些例子。 1234567891011const [first, ...rest] = [1, 2, 3, 4, 5];first // 1rest // [2, 3, 4, 5]const [first, ...rest] = [];first // undefinedrest // []const [first, ...rest] = ["foo"];first // "foo"rest // [] 如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。 12345const [...butLast, last] = [1, 2, 3, 4, 5];// 报错const [first, ...middle, last] = [1, 2, 3, 4, 5];// 报错 3. 函数的返回值JavaScript 的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象。扩展运算符提供了解决这个问题的一种变通方法。 12var dateFields = readDateFields(database);var d = new Date(...dateFields); 上面代码从数据库取出一行数据，通过扩展运算符，直接将其传入构造函数Date。 4. 字符串扩展运算符还可以将字符串转为真正的数组。 12[...'hello']// [ "h", "e", "l", "l", "o" ] 上面的写法，有一个重要的好处，那就是能够正确识别32位的Unicode字符。 12'x\uD83D\uDE80y'.length // 4[...'x\uD83D\uDE80y'].length // 3 上面代码的第一种写法，JavaScript会将32位Unicode字符，识别为2个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写。 12345function length(str) &#123; return [...str].length;&#125;length('x\uD83D\uDE80y') // 3 凡是涉及到操作32位 Unicode 字符的函数，都有这个问题。因此，最好都用扩展运算符改写。 1234567let str = 'x\uD83D\uDE80y';str.split('').reverse().join('')// 'y\uDE80\uD83Dx'[...str].reverse().join('')// 'y\uD83D\uDE80x' 上面代码中，如果不用扩展运算符，字符串的reverse操作就不正确。 5. 实现了 Iterator 接口的对象任何 Iterator 接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。 12var nodeList = document.querySelectorAll('div');var array = [...nodeList]; 上面代码中，querySelectorAll方法返回的是一个nodeList对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于NodeList对象实现了 Iterator 。 对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。 123456789let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;// TypeError: Cannot spread non-iterable object.let arr = [...arrayLike]; 上面代码中，arrayLike是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这时，可以改为使用Array.from方法将arrayLike转为真正的数组。 6. Map 和 Set 结构，Generator 函数扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。 1234567let map = new Map([ [1, 'one'], [2, 'two'], [3, 'three'],]);let arr = [...map.keys()]; // [1, 2, 3] Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。 1234567var go = function*()&#123; yield 1; yield 2; yield 3;&#125;;[...go()] // [1, 2, 3] 上面代码中，变量go是一个 Generator 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。 如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错。 12var obj = &#123;a: 1, b: 2&#125;;let arr = [...obj]; // TypeError: Cannot spread non-iterable object Array.from()Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。 下面是一个类似数组的对象，Array.from将它转为真正的数组。 123456789101112let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;// ES5的写法var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']// ES6的写法let arr2 = Array.from(arrayLike); // ['a', 'b', 'c'] 实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。 1234567891011// NodeList对象let ps = document.querySelectorAll('p');Array.from(ps).forEach(function (p) &#123; console.log(p);&#125;);// arguments对象function foo() &#123; var args = Array.from(arguments); // ...&#125; 上面代码中，querySelectorAll方法返回的是一个类似数组的对象，可以将这个对象转为真正的数组，再使用forEach方法。 只要是部署了Iterator接口的数据结构，Array.from都能将其转为数组。 12345Array.from('hello')// ['h', 'e', 'l', 'l', 'o']let namesSet = new Set(['a', 'b'])Array.from(namesSet) // ['a', 'b'] 上面代码中，字符串和Set结构都具有Iterator接口，因此可以被Array.from转为真正的数组。 如果参数是一个真正的数组，Array.from会返回一个一模一样的新数组。 12Array.from([1, 2, 3])// [1, 2, 3] 值得提醒的是，扩展运算符（…）也可以将某些数据结构转为数组。 1234567// arguments对象function foo() &#123; var args = [...arguments];&#125;// NodeList对象[...document.querySelectorAll('div')] 扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。 而 Array.from 方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。 12Array.from(&#123; length: 3 &#125;);// [ undefined, undefined, undefined ] 上面代码中，Array.from返回了一个具有三个成员的数组，每个位置的值都是undefined。扩展运算符转换不了这个对象。 对于还没有部署该方法的浏览器，可以用Array.prototype.slice方法替代。 123const toArray = (() =&gt; Array.from ? Array.from : obj =&gt; [].slice.call(obj))(); Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。 123456Array.from(arrayLike, x =&gt; x * x);// 等同于Array.from(arrayLike).map(x =&gt; x * x);Array.from([1, 2, 3], (x) =&gt; x * x)// [1, 4, 9] 另一个例子是返回各种数据的类型。 12345function typesOf () &#123; return Array.from(arguments, value =&gt; typeof value)&#125;typesOf(null, [], NaN)// ['object', 'object', 'number'] 如果map函数里面用到了this关键字，还可以传入Array.from的第三个参数，用来绑定this。 Array.from()可以将各种值转为真正的数组，并且还提供map功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。 12Array.from(&#123; length: 2 &#125;, () =&gt; 'jack')// ['jack', 'jack'] 上面代码中，Array.from的第一个参数指定了第二个参数运行的次数。这种特性可以让该方法的用法变得非常灵活。 Array.from()的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种Unicode字符，可以避免JavaScript将大于\uFFFF的Unicode字符，算作两个字符的bug。(扩展运算符也可以实现) 123function countSymbols(string) &#123; return Array.from(string).length;&#125; Array.of()Array.of方法用于将一组值，转换为数组。 123Array.of(3, 11, 8) // [3,11,8]Array.of(3) // [3]Array.of(3).length // 1 这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。 123Array() // []Array(3) // [, , ,]Array(3, 11, 8) // [3, 11, 8] 上面代码中，Array方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于2个时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。 Array.of基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。 1234Array.of() // []Array.of(undefined) // [undefined]Array.of(1) // [1]Array.of(1, 2) // [1, 2] Array.of总是返回参数值组成的数组。如果没有参数，就返回一个空数组。 Array.of方法可以用下面的代码模拟实现。 123function ArrayOf()&#123; return [].slice.call(arguments);&#125; 数组实例的 copyWithin()数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。 1Array.prototype.copyWithin(target, start = 0, end = this.length) 它接受三个参数。 target（必需）：从该位置开始替换数据。 start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。 这三个参数都应该是数值，如果不是，会自动转为数值。 12[1, 2, 3, 4, 5].copyWithin(0, 3)// [4, 5, 3, 4, 5] 上面代码表示将从3号位直到数组结束的成员（4和5），复制到从0号位开始的位置，结果覆盖了原来的1和2。 数组实例的 find() 和 findIndex()数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 12[1, 4, -5, 10].find((n) =&gt; n &lt; 0)// -5 上面代码找出数组中第一个小于0的成员。 123[1, 5, 10, 15].find(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 10 上面代码中，find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 123[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2 这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。 另外，这两个方法都可以发现NaN，弥补了数组的IndexOf方法的不足。 数组实例的fill()fill方法使用给定值，填充一个数组。 12345['a', 'b', 'c'].fill(7)// [7, 7, 7]new Array(3).fill(7)// [7, 7, 7] 上面代码表明，fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。 fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。 数组实例的 entries()，keys() 和 values()ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。 values在chrome未实现（测试日期2017年9月16日） 1234567891011121314151617181920// 浏览器必须支持 for..of 循环// 以及 let —— 将变量作用域限定在 for 循环中for (let index of ['a', 'b'].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of ['a', 'b'].values()) &#123; console.log(elem);&#125;// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem);&#125;// 0 "a"// 1 "b" 如果不使用for…of循环，可以手动调用遍历器对象的next方法，进行遍历。 12345let letter = ['a', 'b', 'c'];let entries = letter.entries();console.log(entries.next().value); // [0, 'a']console.log(entries.next().value); // [1, 'b']console.log(entries.next().value); // [2, 'c'] 数组实例的 includes()Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。ES2016 引入了该方法。 123[1, 2, 3].includes(2) // true[1, 2, 3].includes(4) // false[1, 2, NaN].includes(NaN) // true 该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。 12[1, 2, 3].includes(3, 3); // false[1, 2, 3].includes(3, -1); // true 没有该方法之前，我们通常使用数组的indexOf方法，检查是否包含某个值。 123if (arr.indexOf(el) !== -1) &#123; // ...&#125; indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。 12[NaN].indexOf(NaN)// -1 includes使用的是不一样的判断算法，就没有这个问题。 12[NaN].includes(NaN)// true 下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。 123456const contains = (() =&gt; Array.prototype.includes ? (arr, value) =&gt; arr.includes(value) : (arr, value) =&gt; arr.some(el =&gt; el === value))();contains(['foo', 'bar'], 'baz'); // =&gt; false 另外，Map 和 Set 数据结构有一个has方法，需要注意与includes区分。 Map 结构的has方法，是用来查找键名的，比如Map.prototype.has(key)、WeakMap.prototype.has(key)、Reflect.has(target, propertyKey)。 Set 结构的has方法，是用来查找值的，比如Set.prototype.has(value)、WeakSet.prototype.has(value)。 数组的空位数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位。 1Array(3) // [, , ,] 上面代码中，Array(3)返回一个具有3个空位的数组。 注意，空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值，in运算符可以说明这一点。 120 in [undefined, undefined, undefined] // true0 in [, , ,] // false 上面代码说明，第一个数组的0号位置是有值的，第二个数组的0号位置没有值。 ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。 forEach(), filter(), every() 和some()都会跳过空位。 map()会跳过空位，但会保留这个值 join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。 1234567891011121314151617181920// forEach方法[,'a'].forEach((x,i) =&gt; console.log(i)); // 1// filter方法['a',,'b'].filter(x =&gt; true) // ['a','b']// every方法[,'a'].every(x =&gt; x==='a') // true// some方法[,'a'].some(x =&gt; x !== 'a') // false// map方法[,'a'].map(x =&gt; 1) // [,1]// join方法[,'a',undefined,null].join('#') // "#a##"// toString方法[,'a',undefined,null].toString() // ",a,," ES6 则是明确将空位转为undefined。Array.from方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位。 12Array.from(['a',,'b'])// [ "a", undefined, "b" ] 扩展运算符（…）也会将空位转为undefined。 12[...['a',,'b']]// [ "a", undefined, "b" ] copyWithin()会连空位一起拷贝。 1[,'a','b',,].copyWithin(2,0) // [,"a",,"a"] fill()会将空位视为正常的数组位置。 1new Array(3).fill('a') // ["a","a","a"] for…of循环也会遍历空位。 123456let arr = [, ,];for (let i of arr) &#123; console.log(1);&#125;// 1// 1 上面代码中，数组arr有两个空位，for…of并没有忽略它们。如果改成map方法遍历，空位是会跳过的。 entries()、keys()、values()、find()和findIndex()会将空位处理成undefined。 1234567891011121314// entries()[...[,'a'].entries()] // [[0,undefined], [1,"a"]]// keys()[...[,'a'].keys()] // [0,1]// values()[...[,'a'].values()] // [undefined,"a"]// find()[,'a'].find(x =&gt; true) // undefined// findIndex()[,'a'].findIndex(x =&gt; true) // 0 由于空位的处理规则非常不统一，所以建议避免出现空位。 对象的扩展 属性的简洁表示法 属性名表达式 方法的 name 属性 Object.is() Object.assign() 属性的可枚举性和遍历 Object.getOwnPropertyDescriptors() [object Object]属性，Object.setPrototypeOf()，Object.getPrototypeOf() Object.keys()，Object.values()，Object.entries() 对象的扩展运算符 Null 传导运算符 属性的简洁表示法ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。 123456var foo = 'bar';var baz = &#123;foo&#125;;baz // &#123;foo: "bar"&#125;// 等同于var baz = &#123;foo: foo&#125;; 上面代码表明，ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。下面是另一个例子。 12345678910111213var birth = '2000/01/01';var Person = &#123; name: '张三', //等同于birth: birth birth, // 等同于hello: function ()... hello() &#123; console.log('我的名字是', this.name); &#125;&#125;; 这种写法用于函数的返回值，将会非常方便。 12345678function getPoint() &#123; var x = 1; var y = 10; return &#123;x, y&#125;;&#125;getPoint()// &#123;x:1, y:10&#125; CommonJS 模块输出一组变量，就非常合适使用简洁写法。 123456789101112131415161718192021var ms = &#123;&#125;;function getItem (key) &#123; return key in ms ? ms[key] : null;&#125;function setItem (key, value) &#123; ms[key] = value;&#125;function clear () &#123; ms = &#123;&#125;;&#125;module.exports = &#123; getItem, setItem, clear &#125;;// 等同于module.exports = &#123; getItem: getItem, setItem: setItem, clear: clear&#125;; 属性的赋值器（setter）和取值器（getter）(ES5)，事实上也是采用这种写法。 1234567891011121314var cart = &#123; _wheels: 4, get wheels () &#123; return this._wheels; &#125;, set wheels (value) &#123; if (value &lt; this._wheels) &#123; throw new Error('数值太小了！'); &#125; this._wheels = value; &#125;&#125; 注意，简洁写法的属性名总是字符串，这会导致一些看上去比较奇怪的结果。 123456789var obj = &#123; class () &#123;&#125;&#125;;// 等同于var obj = &#123; 'class': function() &#123;&#125;&#125;; 上面代码中，class是字符串，所以不会因为它属于关键字，而导致语法解析报错。 如果某个方法的值是一个 Generator 函数，前面需要加上星号。 12345var obj = &#123; * m() &#123; yield &apos;hello world&apos;; &#125;&#125;; 属性名表达式JavaScript 定义对象的属性，有两种方法。 12345// 方法一obj.foo = true;// 方法二obj['a' + 'bc'] = 123; 上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。 但是，如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用方法一（标识符）定义属性。 1234var obj = &#123; foo: true, abc: 123&#125;; ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。 123456let propKey = 'foo';let obj = &#123; [propKey]: true, ['a' + 'bc']: 123&#125;; 注意，属性名表达式与简洁表示法，不能同时使用，会报错。 注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]，这一点要特别小心。 方法的 name 属性函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。 如果对象的方法使用了取值函数（getter）和存值函数（setter），则name属性不是在该方法上面，而是该方法的属性的描述对象的get和set属性上面，返回值是方法名前加上get和set。 有两种特殊情况：bind方法创造的函数，name属性返回bound加上原函数的名字；Function构造函数创造的函数，name属性返回anonymous。 如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。 Object.is()ES5 比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。 ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。 1234Object.is('foo', 'foo')// trueObject.is(&#123;&#125;, &#123;&#125;)// false 不同之处只有两个：一是+0不等于-0，二是NaN等于自身。 12345+0 === -0 //trueNaN === NaN // falseObject.is(+0, -0) // falseObject.is(NaN, NaN) // true ES5 可以通过下面的代码，部署Object.is。 12345678910111213Object.defineProperty(Object, 'is', &#123; value: function(x, y) &#123; if (x === y) &#123; // 针对+0 不等于 -0的情况 return x !== 0 || 1 / x === 1 / y; &#125; // 针对NaN的情况 return x !== x &amp;&amp; y !== y; &#125;, configurable: true, enumerable: false, writable: true&#125;); Object.assign()基本用法Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。 1234567var target = &#123; a: 1 &#125;;var source1 = &#123; b: 2 &#125;;var source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。 注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。 如果只有一个参数，Object.assign会直接返回该参数。 12var obj = &#123;a: 1&#125;;Object.assign(obj) === obj // true 如果该参数不是对象，则会先转成对象，然后返回。 1typeof Object.assign(2) // "object" 由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。 12Object.assign(undefined) // 报错Object.assign(null) // 报错 如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果undefined和null不在首参数，就不会报错。 123let obj = &#123;a: 1&#125;;Object.assign(obj, undefined) === obj // trueObject.assign(obj, null) === obj // true 其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。 123456var v1 = 'abc';var v2 = true;var v3 = 10;var obj = Object.assign(&#123;&#125;, v1, v2, v3);console.log(obj); // &#123; "0": "a", "1": "b", "2": "c" &#125; 上面代码中，v1、v2、v3分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。 123Object(true) // &#123;[[PrimitiveValue]]: true&#125;Object(10) // &#123;[[PrimitiveValue]]: 10&#125;Object('abc') // &#123;0: "a", 1: "b", 2: "c", length: 3, [[PrimitiveValue]]: "abc"&#125; 上面代码中，布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性[[PrimitiveValue]]上面，这个属性是不会被Object.assign拷贝的。只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。 Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。 1234567Object.assign(&#123;b: 'c'&#125;, Object.defineProperty(&#123;&#125;, 'invisible', &#123; enumerable: false, value: 'hello' &#125;))// &#123; b: 'c' &#125; 上面代码中，Object.assign要拷贝的对象只有一个不可枚举属性invisible，这个属性并没有被拷贝进去。 属性名为 Symbol 值的属性，也会被Object.assign拷贝。 12Object.assign(&#123; a: 'b' &#125;, &#123; [Symbol('c')]: 'd' &#125;)// &#123; a: 'b', Symbol(c): 'd' &#125; 注意点Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。 12345var obj1 = &#123;a: &#123;b: 1&#125;&#125;;var obj2 = Object.assign(&#123;&#125;, obj1);obj1.a.b = 2;obj2.a.b // 2 上面代码中，源对象obj1的a属性的值是一个对象，Object.assign拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。 对于这种嵌套的对象，一旦遇到同名属性，Object.assign的处理方法是替换，而不是添加。 1234var target = &#123; a: &#123; b: 'c', d: 'e' &#125; &#125;var source = &#123; a: &#123; b: 'hello' &#125; &#125;Object.assign(target, source)// &#123; a: &#123; b: 'hello' &#125; &#125; 上面代码中，target对象的a属性被source对象的a属性整个替换掉了，而不会得到{ a: { b: ‘hello’, d: ‘e’ } }的结果。这通常不是开发者想要的，需要特别小心。 有一些函数库提供Object.assign的定制版本（比如 Lodash 的_.defaultsDeep方法），可以解决浅拷贝的问题，得到深拷贝的合并。 注意，Object.assign可以用来处理数组，但是会把数组视为对象。 Object.assign([1, 2, 3], [4, 5])// [4, 5, 3]上面代码中，Object.assign把数组视为属性名为0、1、2的对象，因此源数组的0号属性4覆盖了目标数组的0号属性1。 常见用途Object.assign方法有很多用处。 1. 为对象添加属性12345class Point &#123; constructor(x, y) &#123; Object.assign(this, &#123;x, y&#125;); &#125;&#125; 上面方法通过Object.assign方法，将x属性和y属性添加到Point类的对象实例。 2. 为对象添加方法12345678910111213141516Object.assign(SomeClass.prototype, &#123; someMethod(arg1, arg2) &#123; ··· &#125;, anotherMethod() &#123; ··· &#125;&#125;);// 等同于下面的写法SomeClass.prototype.someMethod = function (arg1, arg2) &#123; ···&#125;;SomeClass.prototype.anotherMethod = function () &#123; ···&#125;; 上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用assign方法添加到SomeClass.prototype之中。 3. 克隆对象123function clone(origin) &#123; return Object.assign(&#123;&#125;, origin);&#125; 上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。 不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。 1234function clone(origin) &#123; let originProto = Object.getPrototypeOf(origin); return Object.assign(Object.create(originProto), origin);&#125; 4. 合并多个对象将多个对象合并到某个对象。 12const merge = (target, ...sources) =&gt; Object.assign(target, ...sources); 如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。 12const merge = (...sources) =&gt; Object.assign(&#123;&#125;, ...sources); 5. 为属性指定默认值12345678910const DEFAULTS = &#123; logLevel: 0, outputFormat: 'html'&#125;;function processContent(options) &#123; options = Object.assign(&#123;&#125;, DEFAULTS, options); console.log(options); // ...&#125; 上面代码中，DEFAULTS对象是默认值，options对象是用户提供的参数。Object.assign方法将DEFAULTS和options合并成一个新对象，如果两者有同名属性，则option的属性值会覆盖DEFAULTS的属性值。 注意，由于存在浅拷贝的问题，DEFAULTS对象和options对象的所有属性的值，最好都是简单类型，不要指向另一个对象。否则，DEFAULTS对象的该属性很可能不起作用。 属性的可枚举性和遍历可枚举性对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。 12345678let obj = &#123; foo: 123 &#125;;Object.getOwnPropertyDescriptor(obj, 'foo')// &#123;// value: 123,// writable: true,// enumerable: true,// configurable: true// &#125; 描述对象的enumerable属性，称为”可枚举性“，如果该属性为false，就表示某些操作会忽略当前属性。 目前，有四个操作会忽略enumerable为false的属性。 for…in循环：只遍历对象自身的和继承的可枚举的属性。 Object.keys()：返回对象自身的所有可枚举的属性的键名。 JSON.stringify()：只串行化对象自身的可枚举的属性。 Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。 这四个操作之中，前三个是 ES5 就有的，最后一个Object.assign()是 ES6 新增的。其中，只有for…in会返回继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性。实际上，引入“可枚举”（enumerable）这个概念的最初目的，就是让某些属性可以规避掉for…in操作，不然所有内部属性和方法都会被遍历到。比如，对象原型的toString方法，以及数组的length属性，就通过“可枚举性”，从而避免被for…in遍历到。 另外，ES6 规定，所有 Class 的原型的方法都是不可枚举的。 12Object.getOwnPropertyDescriptor(class &#123;foo() &#123;&#125;&#125;.prototype, 'foo').enumerable// false 总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用for…in循环，而用Object.keys()代替。 属性的遍历ES6 一共有5种方法可以遍历对象的属性。 1. for…infor…in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。 2. Object.keys(obj)Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）。 3. Object.getOwnPropertyNames(obj)Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）。 4. Object.getOwnPropertySymbols(obj)Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性。 5. Reflect.ownKeys(obj)Reflect.ownKeys返回一个数组，包含对象自身的所有属性，不管属性名是 Symbol 或字符串，也不管是否可枚举。 以上的5种方法遍历对象的属性，都遵守同样的属性遍历的次序规则。 首先遍历所有属性名为数值的属性，按照数字排序。 其次遍历所有属性名为字符串的属性，按照生成时间排序。 最后遍历所有属性名为 Symbol 值的属性，按照生成时间排序。 12Reflect.ownKeys(&#123; [Symbol()]:0, b:0, 10:0, 2:0, a:0 &#125;)// ['2', '10', 'b', 'a', Symbol()] 上面代码中，Reflect.ownKeys方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性2和10，其次是字符串属性b和a，最后是 Symbol 属性。 Object.getOwnPropertyDescriptors()前面说过，Object.getOwnPropertyDescriptor方法会返回某个对象属性的描述对象（descriptor）。ES2017 引入了Object.getOwnPropertyDescriptors方法，返回指定对象所有自身属性（非继承属性）的描述对象。 12345678910111213141516const obj = &#123; foo: 123, get bar() &#123; return 'abc' &#125;&#125;;Object.getOwnPropertyDescriptors(obj)// &#123; foo:// &#123; value: 123,// writable: true,// enumerable: true,// configurable: true &#125;,// bar:// &#123; get: [Function: bar],// set: undefined,// enumerable: true,// configurable: true &#125; &#125; 上面代码中，Object.getOwnPropertyDescriptors方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。 该方法的实现非常容易。 1234567function getOwnPropertyDescriptors(obj) &#123; const result = &#123;&#125;; for (let key of Reflect.ownKeys(obj)) &#123; result[key] = Object.getOwnPropertyDescriptor(obj, key); &#125; return result;&#125; 该方法的引入目的，主要是为了解决Object.assign()无法正确拷贝get属性和set属性的问题。 1234567891011121314const source = &#123; set foo(value) &#123; console.log(value); &#125;&#125;;const target1 = &#123;&#125;;Object.assign(target1, source);Object.getOwnPropertyDescriptor(target1, 'foo')// &#123; value: undefined,// writable: true,// enumerable: true,// configurable: true &#125; 上面代码中，source对象的foo属性的值是一个赋值函数，Object.assign方法将这个属性拷贝给target1对象，结果该属性的值变成了undefined。这是因为Object.assign方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。 这时，Object.getOwnPropertyDescriptors方法配合Object.defineProperties方法，就可以实现正确拷贝。 12345678910111213const source = &#123; set foo(value) &#123; console.log(value); &#125;&#125;;const target2 = &#123;&#125;;Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));Object.getOwnPropertyDescriptor(target2, 'foo')// &#123; get: undefined,// set: [Function: foo],// enumerable: true,// configurable: true &#125; 上面代码中，两个对象合并的逻辑可以写成一个函数。 1234const shallowMerge = (target, source) =&gt; Object.defineProperties( target, Object.getOwnPropertyDescriptors(source)); Object.getOwnPropertyDescriptors方法的另一个用处，是配合Object.create方法，将对象属性克隆到一个新对象。这属于浅拷贝。 123456789const clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));// 或者const shallowClone = (obj) =&gt; Object.create( Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj)); 上面代码会克隆对象obj。 另外，Object.getOwnPropertyDescriptors方法可以实现一个对象继承另一个对象。以前，继承另一个对象，常常写成下面这样。 1234const obj = &#123; __proto__: prot, foo: 123,&#125;; ES6 规定[object Object]只有浏览器要部署，其他环境不用部署。如果去除[object Object]，上面代码就要改成下面这样。 1234567891011const obj = Object.create(prot);obj.foo = 123;// 或者const obj = Object.assign( Object.create(prot), &#123; foo: 123, &#125;); 有了Object.getOwnPropertyDescriptors，我们就有了另一种写法。 123456const obj = Object.create( prot, Object.getOwnPropertyDescriptors(&#123; foo: 123, &#125;)); Object.getOwnPropertyDescriptors也可以用来实现 Mixin（混入）模式。 12345678910111213141516let mix = (object) =&gt; (&#123; with: (...mixins) =&gt; mixins.reduce( (c, mixin) =&gt; Object.create( c, Object.getOwnPropertyDescriptors(mixin) ), object)&#125;);// multiple mixins examplelet a = &#123;a: 'a'&#125;;let b = &#123;b: 'b'&#125;;let c = &#123;c: 'c'&#125;;let d = mix(c).with(a, b);d.c // "c"d.b // "b"d.a // "a" 上面代码返回一个新的对象d，代表了对象a和b被混入了对象c的操作。 出于完整性的考虑，Object.getOwnPropertyDescriptors进入标准以后，还会有Reflect.getOwnPropertyDescriptors方法。 [object Object]属性，Object.setPrototypeOf()，Object.getPrototypeOf()[object Object]属性[object Object]属性（前后各两个下划线），用来读取或设置当前对象的prototype对象。目前，所有浏览器（包括 IE11）都部署了这个属性。 123456789// es6的写法var obj = &#123; method: function() &#123; ... &#125;&#125;;obj.__proto__ = someOtherObj;// es5的写法var obj = Object.create(someOtherObj); obj.method = function() { … };该属性没有写入 ES6 的正文，而是写入了附录，原因是__proto__前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替。 实现上，[object Object]调用的是Object.prototype.__proto__，具如果一个对象本身部署了[object Object]属性，则该属性的值就是对象的原型。 12Object.getPrototypeOf(&#123; __proto__: null &#125;)// null Object.setPrototypeOf()Object.setPrototypeOf方法的作用与[object Object]相同，用来设置一个对象的prototype对象，返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。 12345// 格式Object.setPrototypeOf(object, prototype)// 用法var o = Object.setPrototypeOf(&#123;&#125;, null); 该方法等同于下面的函数。 1234function (obj, proto) &#123; obj.__proto__ = proto; return obj;&#125; 下面是一个例子。 12345678910let proto = &#123;&#125;;let obj = &#123; x: 10 &#125;;Object.setPrototypeOf(obj, proto);proto.y = 20;proto.z = 40;obj.x // 10obj.y // 20obj.z // 40 上面代码将proto对象设为obj对象的原型，所以从obj对象可以读取proto对象的属性。 如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。 123Object.setPrototypeOf(1, &#123;&#125;) === 1 // trueObject.setPrototypeOf('foo', &#123;&#125;) === 'foo' // trueObject.setPrototypeOf(true, &#123;&#125;) === true // true 由于undefined和null无法转为对象，所以如果第一个参数是undefined或null，就会报错。 12345Object.setPrototypeOf(undefined, &#123;&#125;)// TypeError: Object.setPrototypeOf called on null or undefinedObject.setPrototypeOf(null, &#123;&#125;)// TypeError: Object.setPrototypeOf called on null or undefined Object.getPrototypeOf()该方法与Object.setPrototypeOf方法配套，用于读取一个对象的原型对象。 1Object.getPrototypeOf(obj); 下面是一个例子。 123456789101112function Rectangle() &#123; // ...&#125;var rec = new Rectangle();Object.getPrototypeOf(rec) === Rectangle.prototype// trueObject.setPrototypeOf(rec, Object.prototype);Object.getPrototypeOf(rec) === Rectangle.prototype// false 如果参数不是对象，会被自动转为对象。 123456789101112131415// 等同于 Object.getPrototypeOf(Number(1))Object.getPrototypeOf(1)// Number &#123;[[PrimitiveValue]]: 0&#125;// 等同于 Object.getPrototypeOf(String('foo'))Object.getPrototypeOf('foo')// String &#123;length: 0, [[PrimitiveValue]]: ""&#125;// 等同于 Object.getPrototypeOf(Boolean(true))Object.getPrototypeOf(true)// Boolean &#123;[[PrimitiveValue]]: false&#125;Object.getPrototypeOf(1) === Number.prototype // trueObject.getPrototypeOf('foo') === String.prototype // trueObject.getPrototypeOf(true) === Boolean.prototype // true 如果参数是undefined或null，它们无法转为对象，所以会报错。 12345Object.getPrototypeOf(null)// TypeError: Cannot convert undefined or null to objectObject.getPrototypeOf(undefined)// TypeError: Cannot convert undefined or null to object Object.keys()，Object.values()，Object.entries()Object.keys()ES5 引入了Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。 123var obj = &#123; foo: 'bar', baz: 42 &#125;;Object.keys(obj)// ["foo", "baz"] ES2017 引入了跟Object.keys配套的Object.values和Object.entries，作为遍历一个对象的补充手段，供for…of循环使用。 1234567891011121314let &#123;keys, values, entries&#125; = Object;let obj = &#123; a: 1, b: 2, c: 3 &#125;;for (let key of keys(obj)) &#123; console.log(key); // 'a', 'b', 'c'&#125;for (let value of values(obj)) &#123; console.log(value); // 1, 2, 3&#125;for (let [key, value] of entries(obj)) &#123; console.log([key, value]); // ['a', 1], ['b', 2], ['c', 3]&#125; Object.values()Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。 123var obj = &#123; foo: 'bar', baz: 42 &#125;;Object.values(obj)// ["bar", 42] 返回数组的成员顺序，与本章的《属性的遍历》部分介绍的排列规则一致。 123var obj = &#123; 100: 'a', 2: 'b', 7: 'c' &#125;;Object.values(obj)// ["b", "c", "a"] Object.values只返回对象自身的可遍历属性。Object.values会过滤属性名为 Symbol 值的属性。如果Object.values方法的参数是一个字符串，会返回各个字符组成的一个数组。如果参数不是对象，Object.values会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，Object.values会返回空数组。 12Object.values(42) // []Object.values(true) // [] Object.entriesObject.entries方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。 123var obj = &#123; foo: 'bar', baz: 42 &#125;;Object.entries(obj)// [ ["foo", "bar"], ["baz", 42] ] 除了返回值不一样，该方法的行为与Object.values基本一致。如果原对象的属性名是一个 Symbol 值，该属性会被忽略 Object.entries的基本用途是遍历对象的属性。 12345678let obj = &#123; one: 1, two: 2 &#125;;for (let [k, v] of Object.entries(obj)) &#123; console.log( `$&#123;JSON.stringify(k)&#125;: $&#123;JSON.stringify(v)&#125;` );&#125;// "one": 1// "two": 2 Object.entries方法的另一个用处是，将对象转为真正的Map结构。 123var obj = &#123; foo: 'bar', baz: 42 &#125;;var map = new Map(Object.entries(obj));map // Map &#123; foo: "bar", baz: 42 &#125; 自己实现Object.entries方法，非常简单。 123456789101112131415// Generator函数的版本function* entries(obj) &#123; for (let key of Object.keys(obj)) &#123; yield [key, obj[key]]; &#125;&#125;// 非Generator函数的版本function entries(obj) &#123; let arr = []; for (let key of Object.keys(obj)) &#123; arr.push([key, obj[key]]); &#125; return arr;&#125; 对象的扩展运算符《数组的扩展》一章中，已经介绍过扩展运算符（…）。 123const [a, ...b] = [1, 2, 3];a // 1b // [2, 3] ES2017 将这个运算符引入了对象。 1. 解构赋值对象的解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。 1234let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;x // 1y // 2z // &#123; a: 3, b: 4 &#125; 上面代码中，变量z是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（a和b），将它们连同值一起拷贝过来。 由于解构赋值要求等号右边是一个对象，所以如果等号右边是undefined或null，就会报错，因为它们无法转为对象。 12let &#123; x, y, ...z &#125; = null; // 运行时错误let &#123; x, y, ...z &#125; = undefined; // 运行时错误 解构赋值必须是最后一个参数，否则会报错。 12let &#123; ...x, y, z &#125; = obj; // 句法错误let &#123; x, ...y, ...z &#125; = obj; // 句法错误 上面代码中，解构赋值不是最后一个参数，所以会报错。 注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。 1234let obj = &#123; a: &#123; b: 1 &#125; &#125;;let &#123; ...x &#125; = obj;obj.a.b = 2;x.a.b // 2 上面代码中，x是解构赋值所在的对象，拷贝了对象obj的a属性。a属性引用了一个对象，修改这个对象的值，会影响到解构赋值对它的引用。 另外，解构赋值不会拷贝继承自原型对象的属性。 123456let o1 = &#123; a: 1 &#125;;let o2 = &#123; b: 2 &#125;;o2.__proto__ = o1;let &#123; ...o3 &#125; = o2;o3 // &#123; b: 2 &#125;o3.a // undefined 上面代码中，对象o3复制了o2，但是只复制了o2自身的属性，没有复制它的原型对象o1的属性。 下面是另一个例子。 1234567var o = Object.create(&#123; x: 1, y: 2 &#125;);o.z = 3;let &#123; x, ...&#123; y, z &#125; &#125; = o;x // 1y // undefinedz // 3 上面代码中，变量x是单纯的解构赋值，所以可以读取对象o继承的属性；变量y和z是双重解构赋值，只能读取对象o自身的属性，所以只有变量z可以赋值成功。 解构赋值的一个用处，是扩展某个函数的参数，引入其他操作。 12345678function baseFunction(&#123; a, b &#125;) &#123; // ...&#125;function wrapperFunction(&#123; x, y, ...restConfig &#125;) &#123; // 使用x和y参数进行操作 // 其余参数传给原始函数 return baseFunction(restConfig);&#125; 上面代码中，原始函数baseFunction接受a和b作为参数，函数wrapperFunction在baseFunction的基础上进行了扩展，能够接受多余的参数，并且保留原始函数的行为。 2. 扩展运算符扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。 123let z = &#123; a: 3, b: 4 &#125;;let n = &#123; ...z &#125;;n // &#123; a: 3, b: 4 &#125; 这等同于使用Object.assign方法。 123let aClone = &#123; ...a &#125;;// 等同于let aClone = Object.assign(&#123;&#125;, a); 上面的例子只是拷贝了对象实例的属性，如果想完整克隆一个对象，还拷贝对象原型的属性，可以采用下面的写法。 1234567891011// 写法一const clone1 = &#123; __proto__: Object.getPrototypeOf(obj), ...obj&#125;;// 写法二const clone2 = Object.assign( Object.create(Object.getPrototypeOf(obj)), obj); 上面代码中，写法一的[object Object]属性在非浏览器的环境不一定部署，因此推荐使用写法二。 扩展运算符可以用于合并两个对象。123let ab = &#123; ...a, ...b &#125;;// 等同于let ab = Object.assign(&#123;&#125;, a, b); 如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。 1234567let aWithOverrides = &#123; ...a, x: 1, y: 2 &#125;;// 等同于let aWithOverrides = &#123; ...a, ...&#123; x: 1, y: 2 &#125; &#125;;// 等同于let x = 1, y = 2, aWithOverrides = &#123; ...a, x, y &#125;;// 等同于let aWithOverrides = Object.assign(&#123;&#125;, a, &#123; x: 1, y: 2 &#125;); 上面代码中，a对象的x属性和y属性，拷贝到新对象后会被覆盖掉。 这用来修改现有对象部分的属性就很方便了。 1234let newVersion = &#123; ...previousVersion, name: 'New Name' // Override the name property&#125;; 上面代码中，newVersion对象自定义了name属性，其他属性全部复制自previousVersion对象。 如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。 12345let aWithDefaults = &#123; x: 1, y: 2, ...a &#125;;// 等同于let aWithDefaults = Object.assign(&#123;&#125;, &#123; x: 1, y: 2 &#125;, a);// 等同于let aWithDefaults = Object.assign(&#123; x: 1, y: 2 &#125;, a); 与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式。 1234const obj = &#123; ...(x &gt; 1 ? &#123;a: 1&#125; : &#123;&#125;), b: 2,&#125;; 如果扩展运算符后面是一个空对象，则没有任何效果。 12&#123;...&#123;&#125;, a: 1&#125;// &#123; a: 1 &#125; 如果扩展运算符的参数是null或undefined，这两个值会被忽略，不会报错。 1let emptyObject = &#123; ...null, ...undefined &#125;; // 不报错 扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行的。 1234567891011121314151617// 并不会抛出错误，因为 x 属性只是被定义，但没执行let aWithXGetter = &#123; ...a, get x() &#123; throw new Error('not throw yet'); &#125;&#125;;// 会抛出错误，因为 x 属性被执行了let runtimeError = &#123; ...a, ...&#123; get x() &#123; throw new Error('throw now'); &#125; &#125;&#125;; Null 传导运算符编程实务中，如果读取对象内部的某个属性，往往需要判断一下该对象是否存在。比如，要读取message.body.user.firstName，安全的写法是写成下面这样。 1234const firstName = (message &amp;&amp; message.body &amp;&amp; message.body.user &amp;&amp; message.body.user.firstName) || 'default'; 这样的层层判断非常麻烦，因此现在有一个提案，引入了“Null 传导运算符”（null propagation operator）?.，简化上面的写法。 1const firstName = message?.body?.user?.firstName || 'default'; 上面代码有三个?.运算符，只要其中一个返回null或undefined，就不再往下运算，而是返回undefined。 “Null 传导运算符”有四种用法。 obj?.prop // 读取对象属性 obj?.[expr] // 同上 func?.(…args) // 函数或对象方法的调用 new C?.(…args) // 构造函数的调用 传导运算符之所以写成obj?.prop，而不是obj?prop，是为了方便编译器能够区分三元运算符?:（比如obj?prop:123）。 下面是更多的例子。 12345678910// 如果 a 是 null 或 undefined, 返回 undefined// 否则返回 a.b.c().da?.b.c().d// 如果 a 是 null 或 undefined，下面的语句不产生任何效果// 否则执行 a.b = 42a?.b = 42// 如果 a 是 null 或 undefined，下面的语句不产生任何效果delete a?.b]]></content>
      <categories>
        <category>JavaScript</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>基础类型扩展</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6-异步]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F14%2FES6-%E5%BC%82%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[异步编程对 JavaScript 语言太重要。Javascript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。主要介绍 Generator 函数如何完成异步操作。 传统方法 基本概念 Generator 函数 Thunk 函数 co 模块 传统方法ES6 诞生以前，异步编程的方法，大概有下面四种。 回调函数 事件监听 发布/订阅 Promise 对象 Generator 函数将 JavaScript 异步编程带入了一个全新的阶段。 基本概念异步所谓”异步”，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。 比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。 相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。 回调函数JavaScript 语言对异步编程的实现，就是回调函数。 所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。回调函数的英语名字callback，直译过来就是”重新调用”。读取文件进行处理，是这样写的。 1234fs.readFile('/etc/passwd', 'utf-8', function (err, data) &#123; if (err) throw err; console.log(data);&#125;); 上面代码中，readFile函数的第三个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了/etc/passwd这个文件以后，回调函数才会执行。 ( 一个有趣的问题是，为什么 Node 约定，回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是null）？ 原因是执行分成两段，第一段执行完以后，任务所在的上下文环境就已经结束了。在这以后抛出的错误，原来的上下文环境已经无法捕捉，只能当作参数，传入第二段。 ) Promise回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取A文件之后，再读取B文件，代码如下。 12345fs.readFile(fileA, 'utf-8', function (err, data) &#123; fs.readFile(fileB, 'utf-8', function (err, data) &#123; // ... &#125;);&#125;); 不难想象，如果依次读取两个以上的文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。因为多个异步操作形成了强耦合，只要有一个操作需要修改，它的上层回调函数和下层回调函数，可能都要跟着修改。这种情况就称为”回调函数地狱”（callback hell）。 Promise 对象就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。采用 Promise，连续读取多个文件，写法如下。 123456789101112131415var readFile = require('fs-readfile-promise');readFile(fileA).then(function (data) &#123; console.log(data.toString());&#125;).then(function () &#123; return readFile(fileB);&#125;).then(function (data) &#123; console.log(data.toString());&#125;).catch(function (err) &#123; console.log(err);&#125;); 上面代码中，使用了fs-readfile-promise模块，它的作用就是返回一个 Promise 版本的readFile函数。Promise 提供then方法加载回调函数，catch方法捕捉执行过程中抛出的错误。 Generator 函数协程传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做”协程”（coroutine），意思是多个线程互相协作，完成异步任务。 协程有点像函数，又有点像线程。它的运行流程大致如下。 第一步，协程A开始执行。 第二步，协程A执行到一半，进入暂停，执行权转移到协程B。 第三步，（一段时间后）协程B交还执行权。 第四步，协程A恢复执行。 上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。 举例来说，读取文件的协程写法如下。 12345function* asyncJob() &#123; // ...其他代码 var f = yield readFile(fileA); // ...其他代码&#125; 上面代码的函数asyncJob是一个协程，它的奥妙就在其中的yield命令。它表示执行到此处，执行权将交给其他协程。也就是说，yield命令是异步两个阶段的分界线。 协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。协程的 Generator 函数实现Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。 整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明。Generator 函数的执行方法如下。 12345678function* gen(x) &#123; var y = yield x + 2; return y;&#125;var g = gen(1);g.next() // &#123; value: 3, done: false &#125;g.next() // &#123; value: undefined, done: true &#125; 上面代码中，调用 Generator 函数，会返回一个内部指针（即遍历器）g。这是 Generator 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针g的next方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的yield语句，上例是执行到x + 2为止。 换言之，next方法的作用是分阶段执行Generator函数。每次调用next方法，会返回一个对象，表示当前阶段的信息（value属性和done属性）。value属性是yield语句后面表达式的值，表示当前阶段的值；done属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。 Generator 函数的数据交换和错误处理Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。 next返回值的value属性，是 Generator 函数向外输出数据；next方法还可以接受参数，向 Generator 函数体内输入数据。 12345678function* gen(x)&#123; var y = yield x + 2; return y;&#125;var g = gen(1);g.next() // &#123; value: 3, done: false &#125;g.next(2) // &#123; value: 2, done: true &#125; 上面代码中，第一next方法的value属性，返回表达式x + 2的值3。第二个next方法带有参数2，这个参数可以传入 Generator 函数，作为上个阶段异步任务的返回结果，被函数体内的变量y接收。因此，这一步的value属性，返回的就是2（变量y的值）。 Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。 12345678910111213function* gen(x)&#123; try &#123; var y = yield x + 2; &#125; catch (e)&#123; console.log(e); &#125; return y;&#125;var g = gen(1);g.next();g.throw('出错了');// 出错了 上面代码的最后一行，Generator 函数体外，使用指针对象的throw方法抛出的错误，可以被函数体内的try…catch代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。 异步任务的封装下面看看如何使用 Generator 函数，执行一个真实的异步任务。 1234567var fetch = require('node-fetch');function* gen()&#123; var url = 'https://api.github.com/users/github'; var result = yield fetch(url); console.log(result.bio);&#125; 上面代码中，Generator 函数封装了一个异步操作，该操作先读取一个远程接口，然后从 JSON 格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了yield命令。 执行这段代码的方法如下。 12345678var g = gen();var result = g.next();result.value.then(function(data)&#123; return data.json();&#125;).then(function(data)&#123; g.next(data);&#125;); 上面代码中，首先执行 Generator 函数，获取遍历器对象，然后使用next方法（第二行），执行异步任务的第一阶段。由于Fetch模块返回的是一个 Promise 对象，因此要用then方法调用下一个next方法。 可以看到，虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。]]></content>
      <categories>
        <category>JavaScript</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6-Symbol]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F14%2FES6-Symbol%2F</url>
    <content type="text"><![CDATA[目录： 概述 作为属性名的 Symbol 实例：消除魔术字符串 属性名的遍历 Symbol.for()，Symbol.keyFor() 实例：模块的 Singleton 模式 内置的Symbol值 概述ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入Symbol的原因。 ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。 Symbol其实解决了两个问题： 唯一性 通过Symbol的属性来操作JavaScript内部的逻辑 Symbol 值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。 1234let s = Symbol();typeof s// &quot;symbol&quot; 上面代码中，变量s就是一个独一无二的值。typeof运算符的结果，表明变量s是 Symbol 数据类型，而不是字符串之类的其他类型。 注意，Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。 Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。 12345678var s1 = Symbol(&apos;foo&apos;);var s2 = Symbol(&apos;bar&apos;);s1 // Symbol(foo)s2 // Symbol(bar)s1.toString() // &quot;Symbol(foo)&quot;s2.toString() // &quot;Symbol(bar)&quot; 如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值。 1234567const obj = &#123; toString() &#123; return &apos;abc&apos;; &#125;&#125;;const sym = Symbol(obj);sym // Symbol(abc) 注意，Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。 1234567891011// 没有参数的情况var s1 = Symbol();var s2 = Symbol();s1 === s2 // false// 有参数的情况var s1 = Symbol(&apos;foo&apos;);var s2 = Symbol(&apos;foo&apos;);s1 === s2 // false Symbol 值不能与其他类型的值进行运算，会报错。 但是，Symbol 值可以显式转为字符串。 另外，Symbol 值也可以转为布尔值，但是不能转为数值。 作为属性名的 Symbol由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。 1234567891011121314151617var mySymbol = Symbol();// 第一种写法var a = &#123;&#125;;a[mySymbol] = &apos;Hello!&apos;;// 第二种写法var a = &#123; [mySymbol]: &apos;Hello!&apos;&#125;;// 第三种写法var a = &#123;&#125;;Object.defineProperty(a, mySymbol, &#123; value: &apos;Hello!&apos; &#125;);// 以上写法都得到同样结果a[mySymbol] // &quot;Hello!&quot; 上面代码通过方括号结构和Object.defineProperty，将对象的属性名指定为一个 Symbol 值。 注意，Symbol 值作为对象属性名时，不能用点运算符。 123456var mySymbol = Symbol();var a = &#123;&#125;;a.mySymbol = &apos;Hello!&apos;;a[mySymbol] // undefineda[&apos;mySymbol&apos;] // &quot;Hello!&quot; 上面代码中，因为点运算符后面总是字符串，所以不会读取mySymbol作为标识名所指代的那个值，导致a的属性名实际上是一个字符串，而不是一个 Symbol 值。 同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。 1234567let s = Symbol();let obj = &#123; [s]: function (arg) &#123; ... &#125;&#125;;obj[s](123); 上面代码中，如果s不放在方括号中，该属性的键名就是字符串s，而不是s所代表的那个 Symbol 值。 采用增强的对象写法，上面代码的obj对象可以写得更简洁一些。 123let obj = &#123; [s](arg) &#123; ... &#125;&#125;; 还有一点需要注意，Symbol 值作为属性名时，该属性还是公开属性，不是私有属性。 实例：消除魔术字符串魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。 1234567891011121314function getArea(shape, options) &#123; var area = 0; switch (shape) &#123; case &apos;Triangle&apos;: // 魔术字符串 area = .5 * options.width * options.height; break; /* ... more code ... */ &#125; return area;&#125;getArea(&apos;Triangle&apos;, &#123; width: 100, height: 100 &#125;); // 魔术字符串 上面代码中，字符串Triangle就是一个魔术字符串。它多次出现，与代码形成“强耦合”，不利于将来的修改和维护。 常用的消除魔术字符串的方法，就是把它写成一个变量。 123456789101112131415var shapeType = &#123; triangle: &apos;Triangle&apos;&#125;;function getArea(shape, options) &#123; var area = 0; switch (shape) &#123; case shapeType.triangle: area = .5 * options.width * options.height; break; &#125; return area;&#125;getArea(shapeType.triangle, &#123; width: 100, height: 100 &#125;); 上面代码中，我们把Triangle写成shapeType对象的triangle属性，这样就消除了强耦合。 如果仔细分析，可以发现shapeType.triangle等于哪个值并不重要，只要确保不会跟其他shapeType属性的值冲突即可。因此，这里就很适合改用 Symbol 值。 123const shapeType = &#123; triangle: Symbol()&#125;; 上面代码中，除了将shapeType.triangle的值设为一个Symbol，其他地方都不用修改 属性名的遍历Symbol 作为属性名，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。 Object.getOwnPropertySymbols方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。 1234567891011var obj = &#123;&#125;;var a = Symbol(&apos;a&apos;);var b = Symbol(&apos;b&apos;);obj[a] = &apos;Hello&apos;;obj[b] = &apos;World&apos;;var objectSymbols = Object.getOwnPropertySymbols(obj);objectSymbols// [Symbol(a), Symbol(b)] 另一个新的API，Reflect.ownKeys方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。 12345678let obj = &#123; [Symbol(&apos;my_key&apos;)]: 1, enum: 2, nonEnum: 3&#125;;Reflect.ownKeys(obj)// [&quot;enum&quot;, &quot;nonEnum&quot;, Symbol(my_key)] 由于以 Symbol 值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。 Symbol.for()，Symbol.keyFor()有时，我们希望重新使用同一个Symbol值，Symbol.for方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。 1234var s1 = Symbol.for(&apos;foo&apos;);var s2 = Symbol.for(&apos;foo&apos;);s1 === s2 // true 上面代码中，s1和s2都是 Symbol 值，但是它们都是同样参数的Symbol.for方法生成的，所以实际上是同一个值。 Symbol.for()与Symbol()这两种写法，都会生成新的Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。比如，如果你调用Symbol.for(“cat”)30次，每次都会返回同一个 Symbol 值，但是调用Symbol(“cat”)30次，会返回30个不同的Symbol值。 Symbol.keyFor方法返回一个已登记的 Symbol 类型值的key。 12345var s1 = Symbol.for(&quot;foo&quot;);Symbol.keyFor(s1) // &quot;foo&quot;var s2 = Symbol(&quot;foo&quot;);Symbol.keyFor(s2) // undefined 上面代码中，变量s2属于未登记的Symbol值，所以返回undefined。 需要注意的是，Symbol.for为Symbol值登记的名字，是全局环境的，可以在不同的 iframe 或 service worker 中取到同一个值。 实例：模块的 Singleton 模式Singleton模式指的是调用一个类，任何时候返回的都是同一个实例。 对于Node来说，模块文件可以看成是一个类。怎么保证每次执行这个模块文件，返回的都是同一个实例呢？ 很容易想到，可以把实例放到顶层对象global。 1234567891011121314// mod.jsfunction A() &#123; this.foo = &apos;hello&apos;;&#125;if (!global._foo) &#123; global._foo = new A();&#125;module.exports = global._foo;然后，加载上面的mod.js。var a = require(&apos;./mod.js&apos;);console.log(a.foo); 上面代码中，变量a任何时候加载的都是A的同一个实例。 但是，这里有一个问题，全局变量global._foo是可写的，任何文件都可以修改。 12var a = require(&apos;./mod.js&apos;);global._foo = 123; 上面的代码，会使得别的脚本加载mod.js都失真。 为了防止这种情况出现，我们就可以使用Symbol。 123456789101112// mod.jsconst FOO_KEY = Symbol.for(&apos;foo&apos;);function A() &#123; this.foo = &apos;hello&apos;;&#125;if (!global[FOO_KEY]) &#123; global[FOO_KEY] = new A();&#125;module.exports = global[FOO_KEY]; 上面代码中，可以保证global[FOO_KEY]不会被无意间覆盖，但还是可以被改写。 12var a = require(&apos;./mod.js&apos;);global[Symbol.for(&apos;foo&apos;)] = 123; 如果键名使用Symbol方法生成，那么外部将无法引用这个值，当然也就无法改写。 1234// mod.jsconst FOO_KEY = Symbol(&apos;foo&apos;);// 后面代码相同 …… 1上面代码将导致其他脚本都无法引用FOO_KEY。但这样也有一个问题，就是如果多次执行这个脚本，每次得到的FOO_KEY都是不一样的。虽然Node会将脚本的执行结果缓存，一般情况下，不会多次执行同一个脚本，但是用户可以手动清除缓存，所以也不是完全可靠。 内置的Symbol值除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。目录： 概述 作为属性名的 Symbol 实例：消除魔术字符串 属性名的遍历 Symbol.for()，Symbol.keyFor() 实例：模块的 Singleton 模式 内置的Symbol值 概述ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入Symbol的原因。 ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。 Symbol其实解决了两个问题： 唯一性 通过Symbol的属性来操作JavaScript内部的逻辑 Symbol 值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。 1234let s = Symbol();typeof s// &quot;symbol&quot; 上面代码中，变量s就是一个独一无二的值。typeof运算符的结果，表明变量s是 Symbol 数据类型，而不是字符串之类的其他类型。 注意，Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。 Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。 12345678var s1 = Symbol(&apos;foo&apos;);var s2 = Symbol(&apos;bar&apos;);s1 // Symbol(foo)s2 // Symbol(bar)s1.toString() // &quot;Symbol(foo)&quot;s2.toString() // &quot;Symbol(bar)&quot; 如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值。 1234567const obj = &#123; toString() &#123; return &apos;abc&apos;; &#125;&#125;;const sym = Symbol(obj);sym // Symbol(abc) 注意，Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。 1234567891011// 没有参数的情况var s1 = Symbol();var s2 = Symbol();s1 === s2 // false// 有参数的情况var s1 = Symbol(&apos;foo&apos;);var s2 = Symbol(&apos;foo&apos;);s1 === s2 // false Symbol 值不能与其他类型的值进行运算，会报错。 但是，Symbol 值可以显式转为字符串。 另外，Symbol 值也可以转为布尔值，但是不能转为数值。 作为属性名的 Symbol由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。 1234567891011121314151617var mySymbol = Symbol();// 第一种写法var a = &#123;&#125;;a[mySymbol] = &apos;Hello!&apos;;// 第二种写法var a = &#123; [mySymbol]: &apos;Hello!&apos;&#125;;// 第三种写法var a = &#123;&#125;;Object.defineProperty(a, mySymbol, &#123; value: &apos;Hello!&apos; &#125;);// 以上写法都得到同样结果a[mySymbol] // &quot;Hello!&quot; 上面代码通过方括号结构和Object.defineProperty，将对象的属性名指定为一个 Symbol 值。 注意，Symbol 值作为对象属性名时，不能用点运算符。 123456var mySymbol = Symbol();var a = &#123;&#125;;a.mySymbol = &apos;Hello!&apos;;a[mySymbol] // undefineda[&apos;mySymbol&apos;] // &quot;Hello!&quot; 上面代码中，因为点运算符后面总是字符串，所以不会读取mySymbol作为标识名所指代的那个值，导致a的属性名实际上是一个字符串，而不是一个 Symbol 值。 同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。 1234567let s = Symbol();let obj = &#123; [s]: function (arg) &#123; ... &#125;&#125;;obj[s](123); 上面代码中，如果s不放在方括号中，该属性的键名就是字符串s，而不是s所代表的那个 Symbol 值。 采用增强的对象写法，上面代码的obj对象可以写得更简洁一些。 123let obj = &#123; [s](arg) &#123; ... &#125;&#125;; 还有一点需要注意，Symbol 值作为属性名时，该属性还是公开属性，不是私有属性。 实例：消除魔术字符串魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。 1234567891011121314function getArea(shape, options) &#123; var area = 0; switch (shape) &#123; case &apos;Triangle&apos;: // 魔术字符串 area = .5 * options.width * options.height; break; /* ... more code ... */ &#125; return area;&#125;getArea(&apos;Triangle&apos;, &#123; width: 100, height: 100 &#125;); // 魔术字符串 上面代码中，字符串Triangle就是一个魔术字符串。它多次出现，与代码形成“强耦合”，不利于将来的修改和维护。 常用的消除魔术字符串的方法，就是把它写成一个变量。 123456789101112131415var shapeType = &#123; triangle: &apos;Triangle&apos;&#125;;function getArea(shape, options) &#123; var area = 0; switch (shape) &#123; case shapeType.triangle: area = .5 * options.width * options.height; break; &#125; return area;&#125;getArea(shapeType.triangle, &#123; width: 100, height: 100 &#125;); 上面代码中，我们把Triangle写成shapeType对象的triangle属性，这样就消除了强耦合。 如果仔细分析，可以发现shapeType.triangle等于哪个值并不重要，只要确保不会跟其他shapeType属性的值冲突即可。因此，这里就很适合改用 Symbol 值。 123const shapeType = &#123; triangle: Symbol()&#125;; 上面代码中，除了将shapeType.triangle的值设为一个Symbol，其他地方都不用修改 属性名的遍历Symbol 作为属性名，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。 Object.getOwnPropertySymbols方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。 1234567891011var obj = &#123;&#125;;var a = Symbol(&apos;a&apos;);var b = Symbol(&apos;b&apos;);obj[a] = &apos;Hello&apos;;obj[b] = &apos;World&apos;;var objectSymbols = Object.getOwnPropertySymbols(obj);objectSymbols// [Symbol(a), Symbol(b)] 另一个新的API，Reflect.ownKeys方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。 12345678let obj = &#123; [Symbol(&apos;my_key&apos;)]: 1, enum: 2, nonEnum: 3&#125;;Reflect.ownKeys(obj)// [&quot;enum&quot;, &quot;nonEnum&quot;, Symbol(my_key)] 由于以 Symbol 值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。 Symbol.for()，Symbol.keyFor()有时，我们希望重新使用同一个Symbol值，Symbol.for方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。 1234var s1 = Symbol.for(&apos;foo&apos;);var s2 = Symbol.for(&apos;foo&apos;);s1 === s2 // true 上面代码中，s1和s2都是 Symbol 值，但是它们都是同样参数的Symbol.for方法生成的，所以实际上是同一个值。 Symbol.for()与Symbol()这两种写法，都会生成新的Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。比如，如果你调用Symbol.for(“cat”)30次，每次都会返回同一个 Symbol 值，但是调用Symbol(“cat”)30次，会返回30个不同的Symbol值。 Symbol.keyFor方法返回一个已登记的 Symbol 类型值的key。 12345var s1 = Symbol.for(&quot;foo&quot;);Symbol.keyFor(s1) // &quot;foo&quot;var s2 = Symbol(&quot;foo&quot;);Symbol.keyFor(s2) // undefined 上面代码中，变量s2属于未登记的Symbol值，所以返回undefined。 需要注意的是，Symbol.for为Symbol值登记的名字，是全局环境的，可以在不同的 iframe 或 service worker 中取到同一个值。 实例：模块的 Singleton 模式Singleton模式指的是调用一个类，任何时候返回的都是同一个实例。 对于Node来说，模块文件可以看成是一个类。怎么保证每次执行这个模块文件，返回的都是同一个实例呢？ 很容易想到，可以把实例放到顶层对象global。 1234567891011121314// mod.jsfunction A() &#123; this.foo = &apos;hello&apos;;&#125;if (!global._foo) &#123; global._foo = new A();&#125;module.exports = global._foo;然后，加载上面的mod.js。var a = require(&apos;./mod.js&apos;);console.log(a.foo); 上面代码中，变量a任何时候加载的都是A的同一个实例。 但是，这里有一个问题，全局变量global._foo是可写的，任何文件都可以修改。 12var a = require(&apos;./mod.js&apos;);global._foo = 123; 上面的代码，会使得别的脚本加载mod.js都失真。 为了防止这种情况出现，我们就可以使用Symbol。 123456789101112// mod.jsconst FOO_KEY = Symbol.for(&apos;foo&apos;);function A() &#123; this.foo = &apos;hello&apos;;&#125;if (!global[FOO_KEY]) &#123; global[FOO_KEY] = new A();&#125;module.exports = global[FOO_KEY]; 上面代码中，可以保证global[FOO_KEY]不会被无意间覆盖，但还是可以被改写。 12var a = require(&apos;./mod.js&apos;);global[Symbol.for(&apos;foo&apos;)] = 123; 如果键名使用Symbol方法生成，那么外部将无法引用这个值，当然也就无法改写。 1234// mod.jsconst FOO_KEY = Symbol(&apos;foo&apos;);// 后面代码相同 …… 1上面代码将导致其他脚本都无法引用FOO_KEY。但这样也有一个问题，就是如果多次执行这个脚本，每次得到的FOO_KEY都是不一样的。虽然Node会将脚本的执行结果缓存，一般情况下，不会多次执行同一个脚本，但是用户可以手动清除缓存，所以也不是完全可靠。 内置的Symbol值除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。]]></content>
      <categories>
        <category>JavaScript</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>Symbol</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6-Set-Map]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F14%2FES6-Set-Map%2F</url>
    <content type="text"><![CDATA[Set基本用法ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 Set 本身是一个构造函数，用来生成 Set 数据结构。 12345678const s = new Set();[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));for (let i of s) &#123; console.log(i);&#125;// 2 3 5 4 上面代码通过add方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。 Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。 1234567891011121314151617181920// 例一const set = new Set([1, 2, 3, 4, 4]);[...set]// [1, 2, 3, 4]// 例二const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);items.size // 5// 例三function divs () &#123; return [...document.querySelectorAll('div')];&#125;const set = new Set(divs());set.size // 56// 类似于divs().forEach(div =&gt; set.add(div));set.size // 56 上面代码中，例一和例二都是Set函数接受数组作为参数，例三是接受类似数组的对象作为参数。 上面代码中，也展示了一种去除数组重复成员的方法。 12// 去除数组的重复成员[...new Set(array)] 向Set加入值的时候，不会发生类型转换，所以5和”5”是两个不同的值。Set内部判断两个值是否不同，使用的算法叫做“Same-value equality”，它类似于精确相等运算符（===），主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身。 另外，两个对象总是不相等的。 1234567let set = new Set();set.add(&#123;&#125;);set.size // 1set.add(&#123;&#125;);set.size // 2 Set 实例的属性和方法Set 结构的实例有以下属性。 Set.prototype.constructor：构造函数，默认就是Set函数。 Set.prototype.size：返回Set实例的成员总数。 Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。 add(value)：添加某个值，返回Set结构本身。 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 has(value)：返回一个布尔值，表示该值是否为Set的成员。 clear()：清除所有成员，没有返回值。 上面这些属性和方法的实例如下。 1234567891011s.add(1).add(2).add(2);// 注意2被加入了两次s.size // 2s.has(1) // trues.has(2) // trues.has(3) // falses.delete(2);s.has(2) // false Array.from方法可以将 Set 结构转为数组。 12const items = new Set([1, 2, 3, 4, 5]);const array = Array.from(items); 这就提供了去除数组重复成员的另一种方法。 遍历操作Set 结构的实例有四个遍历方法，可以用于遍历成员。 keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 需要特别指出的是，Set的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用Set保存一个回调函数列表，调用时就能保证按照添加顺序调用。 1. keys()，values()，entries()keys方法、values方法、entries方法返回的都是遍历器对象（详见《Iterator 对象》一章）。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。 12345678910111213141516171819202122let set = new Set(['red', 'green', 'blue']);for (let item of set.keys()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.values()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.entries()) &#123; console.log(item);&#125;// ["red", "red"]// ["green", "green"]// ["blue", "blue"] 上面代码中，entries方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。 Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。 12Set.prototype[Symbol.iterator] === Set.prototype.values// true 这意味着，可以省略values方法，直接用for…of循环遍历 Set。 12345678let set = new Set(['red', 'green', 'blue']);for (let x of set) &#123; console.log(x);&#125;// red// green// blue 2. forEach()Set结构的实例的forEach方法，用于对每个成员执行某种操作，没有返回值。 12345let set = new Set([1, 2, 3]);set.forEach((value, key) =&gt; console.log(value * 2) )// 2// 4// 6 上面代码说明，forEach方法的参数就是一个处理函数。该函数的参数依次为键值、键名、集合本身（上例省略了该参数）。另外，forEach方法还可以有第二个参数，表示绑定的this对象。 3. 遍历的应用扩展运算符（…）内部使用for…of循环，所以也可以用于 Set 结构。 123let set = new Set(['red', 'green', 'blue']);let arr = [...set];// ['red', 'green', 'blue'] 扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。 123let arr = [3, 5, 2, 2, 5, 5];let unique = [...new Set(arr)];// [3, 5, 2] 而且，数组的map和filter方法也可以用于 Set 了。 1234567let set = new Set([1, 2, 3]);set = new Set([...set].map(x =&gt; x * 2));// 返回Set结构：&#123;2, 4, 6&#125;let set = new Set([1, 2, 3, 4, 5]);set = new Set([...set].filter(x =&gt; (x % 2) == 0));// 返回Set结构：&#123;2, 4&#125; 因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。 1234567891011121314let a = new Set([1, 2, 3]);let b = new Set([4, 3, 2]);// 并集let union = new Set([...a, ...b]);// Set &#123;1, 2, 3, 4&#125;// 交集let intersect = new Set([...a].filter(x =&gt; b.has(x)));// set &#123;2, 3&#125;// 差集let difference = new Set([...a].filter(x =&gt; !b.has(x)));// Set &#123;1&#125; 如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用Array.from方法。 123456789// 方法一let set = new Set([1, 2, 3]);set = new Set([...set].map(val =&gt; val * 2));// set的值是2, 4, 6// 方法二let set = new Set([1, 2, 3]);set = new Set(Array.from(set, val =&gt; val * 2));// set的值是2, 4, 6 WeakSet类似于Set，也是不重复的值的集合。但是它只能用于存储对象。而不能是其他类型的值。WeakSet是一个个构造函数。可以接受数组和类似数组的对象作为参数。（实际上，任何具作为iterable接口的对象都可以作为WeakSet的参数）。该数组的所有成员都会自动成为WeakSet的实例对象的成员。 123var ws = new WeakSet();ws.add(1);//TypeError:Invalid value used in weak set ws.add(Symbol);//TypeError:Invalid value used in weak set 添如一个数值和一个Symbol，结果同时报错。 WeakSet结构有以下的上方法 WeakSet.protoptype.add(value)：向WeakSet实例添加一个新成员。 WeakSet.protoptype.delete(value)：删除WeakSet实例指定成员。 WeakSet.protoptype.has(value)：返回一个布尔值，表示某个值是否在WeakSet实例中。 123456789var ws = new WeakSet();var obj = &#123;&#125;;var foo = &#123;&#125;;ws.add(window);ws.add(obj);ws.has(window);//truews.has(foo);falsews.delete(window);//truews.has(window);//false WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历不能保证成员的存在。可能刚刚遍历结束，成员就取不到了。WeakSet的一个用处是存储DOM节点，而不用担心这些节点从文档移除时，会引起内存的泄露。 Map含义和基本用法JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。 12345const data = &#123;&#125;;const element = document.getElementById('myDiv');data[element] = 'metadata';data['[object HTMLDivElement]'] // "metadata" 上面代码原意是将一个 DOM 节点作为对象data的键，但是由于对象只接受字符串作为键名，所以element被自动转为字符串[object HTMLDivElement]。 为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。 123456789const m = new Map();const o = &#123;p: 'Hello World'&#125;;m.set(o, 'content')m.get(o) // "content"m.has(o) // truem.delete(o) // truem.has(o) // false 上面代码使用 Map 结构的set方法，将对象o当作m的一个键，然后又使用get方法读取这个键，接着使用delete方法删除了这个键。 上面的例子展示了如何向 Map 添加成员。作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。 12345678910const map = new Map([ ['name', '张三'], ['title', 'Author']]);map.size // 2map.has('name') // truemap.get('name') // "张三"map.has('title') // truemap.get('title') // "Author" 上面代码在新建 Map 实例时，就指定了两个键name和title。 Map构造函数接受数组作为参数，实际上执行的是下面的算法。 12345678910const items = [ ['name', '张三'], ['title', 'Author']];const map = new Map();items.forEach( ([key, value]) =&gt; map.set(key, value)); 事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作Map构造函数的参数。这就是说，Set和Map都可以用来生成新的 Map。 12345678910const set = new Set([ ['foo', 1], ['bar', 2]]);const m1 = new Map(set);m1.get('foo') // 1const m2 = new Map([['baz', 3]]);const m3 = new Map(m2);m3.get('baz') // 3 上面代码中，我们分别使用 Set 对象和 Map 对象，当作Map构造函数的参数，结果都生成了新的 Map 对象。 如果对同一个键多次赋值，后面的值将覆盖前面的值。 注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。 由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。 如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如0和-0就是一个键，布尔值true和字符串true则是两个不同的键。另外，undefined和null也是两个不同的键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键。 123456789101112131415let map = new Map();map.set(-0, 123);map.get(+0) // 123map.set(true, 1);map.set('true', 2);map.get(true) // 1map.set(undefined, 3);map.set(null, 4);map.get(undefined) // 3map.set(NaN, 123);map.get(NaN) // 123 实例的属性和操作方法Map 结构的实例有以下属性和操作方法。 1. size属性size属性返回 Map 结构的成员总数。 12345const map = new Map();map.set('foo', true);map.set('bar', false);map.size // 2 2. set(key, value)set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。 12345const m = new Map();m.set('edition', 6) // 键是字符串m.set(262, 'standard') // 键是数值m.set(undefined, 'nah') // 键是 undefined set方法返回的是当前的Map对象，因此可以采用链式写法。 1234let map = new Map() .set(1, 'a') .set(2, 'b') .set(3, 'c'); 3. get(key)get方法读取key对应的键值，如果找不到key，返回undefined。 123456const m = new Map();const hello = function() &#123;console.log('hello');&#125;;m.set(hello, 'Hello ES6!') // 键是函数m.get(hello) // Hello ES6! 4. has(key)has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。 12345678910const m = new Map();m.set('edition', 6);m.set(262, 'standard');m.set(undefined, 'nah');m.has('edition') // truem.has('years') // falsem.has(262) // truem.has(undefined) // true 5. delete(key)delete方法删除某个键，返回true。如果删除失败，返回false。 123456const m = new Map();m.set(undefined, 'nah');m.has(undefined) // truem.delete(undefined)m.has(undefined) // false 6. clear()clear方法清除所有成员，没有返回值。 1234567let map = new Map();map.set('foo', true);map.set('bar', false);map.size // 2map.clear()map.size // 0 遍历方法Map 结构原生提供三个遍历器生成函数和一个遍历方法。 keys()：返回键名的遍历器。 values()：返回键值的遍历器。 entries()：返回所有成员的遍历器。 forEach()：遍历 Map 的所有成员。 需要特别注意的是，Map 的遍历顺序就是插入顺序。 123456789101112131415161718192021222324252627282930313233343536const map = new Map([ ['F', 'no'], ['T', 'yes'],]);for (let key of map.keys()) &#123; console.log(key);&#125;// "F"// "T"for (let value of map.values()) &#123; console.log(value);&#125;// "no"// "yes"for (let item of map.entries()) &#123; console.log(item[0], item[1]);&#125;// "F" "no"// "T" "yes"// 或者for (let [key, value] of map.entries()) &#123; console.log(key, value);&#125;// "F" "no"// "T" "yes"// 等同于使用map.entries()for (let [key, value] of map) &#123; console.log(key, value);&#125;// "F" "no"// "T" "yes" 上面代码最后的那个例子，表示 Map 结构的默认遍历器接口（Symbol.iterator属性），就是entries方法。 12map[Symbol.iterator] === map.entries// true Map 结构转为数组结构，比较快速的方法是使用扩展运算符（…）。 1234567891011121314151617const map = new Map([ [1, 'one'], [2, 'two'], [3, 'three'],]);[...map.keys()]// [1, 2, 3][...map.values()]// ['one', 'two', 'three'][...map.entries()]// [[1,'one'], [2, 'two'], [3, 'three']][...map]// [[1,'one'], [2, 'two'], [3, 'three']] 结合数组的map方法、filter方法，可以实现 Map 的遍历和过滤（Map 本身没有map和filter方法）。 1234567891011121314const map0 = new Map() .set(1, 'a') .set(2, 'b') .set(3, 'c');const map1 = new Map( [...map0].filter(([k, v]) =&gt; k &lt; 3));// 产生 Map 结构 &#123;1 =&gt; 'a', 2 =&gt; 'b'&#125;const map2 = new Map( [...map0].map(([k, v]) =&gt; [k * 2, '_' + v]) );// 产生 Map 结构 &#123;2 =&gt; '_a', 4 =&gt; '_b', 6 =&gt; '_c'&#125; 此外，Map 还有一个forEach方法，与数组的forEach方法类似，也可以实现遍历。 123map.forEach(function(value, key, map) &#123; console.log("Key: %s, Value: %s", key, value);&#125;); forEach方法还可以接受第二个参数，用来绑定this。 123456789const reporter = &#123; report: function(key, value) &#123; console.log("Key: %s, Value: %s", key, value); &#125;&#125;;map.forEach(function(value, key, map) &#123; this.report(key, value);&#125;, reporter); 上面代码中，forEach方法的回调函数的this，就指向reporter。 与其他数据结构的互相转换1. Map 转为数组前面已经提过，Map 转为数组最方便的方法，就是使用扩展运算符（…）。 12345const myMap = new Map() .set(true, 7) .set(&#123;foo: 3&#125;, ['abc']);[...myMap]// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ 'abc' ] ] ] 2. 数组 转为 Map将数组传入 Map 构造函数，就可以转为 Map。 12345678new Map([ [true, 7], [&#123;foo: 3&#125;, ['abc']]])// Map &#123;// true =&gt; 7,// Object &#123;foo: 3&#125; =&gt; ['abc']// &#125; 3. Map 转为对象如果所有 Map 的键都是字符串，它可以转为对象。 12345678910111213function strMapToObj(strMap) &#123; let obj = Object.create(null); for (let [k,v] of strMap) &#123; obj[k] = v; &#125; return obj;&#125;const myMap = new Map() .set('yes', true) .set('no', false);strMapToObj(myMap)// &#123; yes: true, no: false &#125; 4. 对象转为 Map12345678910function objToStrMap(obj) &#123; let strMap = new Map(); for (let k of Object.keys(obj)) &#123; strMap.set(k, obj[k]); &#125; return strMap;&#125;objToStrMap(&#123;yes: true, no: false&#125;)// Map &#123;"yes" =&gt; true, "no" =&gt; false&#125; 5. Map 转为 JSONMap 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。 1234567function strMapToJson(strMap) &#123; return JSON.stringify(strMapToObj(strMap));&#125;let myMap = new Map().set('yes', true).set('no', false);strMapToJson(myMap)// '&#123;"yes":true,"no":false&#125;' 另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。 1234567function mapToArrayJson(map) &#123; return JSON.stringify([...map]);&#125;let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, ['abc']);mapToArrayJson(myMap)// '[[true,7],[&#123;"foo":3&#125;,["abc"]]]' 6. JSON 转为 MapJSON 转为 Map，正常情况下，所有键名都是字符串。 123456function jsonToStrMap(jsonStr) &#123; return objToStrMap(JSON.parse(jsonStr));&#125;jsonToStrMap('&#123;"yes": true, "no": false&#125;')// Map &#123;'yes' =&gt; true, 'no' =&gt; false&#125; 但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为Map。这往往是数组转为 JSON 的逆操作。 123456function jsonToMap(jsonStr) &#123; return new Map(JSON.parse(jsonStr));&#125;jsonToMap('[[true,7],[&#123;"foo":3&#125;,["abc"]]]')// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; ['abc']&#125; WeakMap含义WeakMap结构与Map结构类似，也是用于生成键值对的集合。 123456789101112// WeakMap 可以使用 set 方法添加成员const wm1 = new WeakMap();const key = &#123;foo: 1&#125;;wm1.set(key, 2);wm1.get(key) // 2// WeakMap 也可以接受一个数组，// 作为构造函数的参数const k1 = [1, 2, 3];const k2 = [4, 5, 6];const wm2 = new WeakMap([[k1, 'foo'], [k2, 'bar']]);wm2.get(k2) // "bar" WeakMap与Map的区别有两点。首先，WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。 1234567const map = new WeakMap();map.set(1, 2)// TypeError: 1 is not an object!map.set(Symbol(), 2)// TypeError: Invalid value used as weak map keymap.set(null, 2)// TypeError: Invalid value used as weak map key 上面代码中，如果将数值1和Symbol值作为 WeakMap 的键名，都会报错。 其次，WeakMap的键名所指向的对象，不计入垃圾回收机制。 WeakMap的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。请看下面的例子。 123456const e1 = document.getElementById('foo');const e2 = document.getElementById('bar');const arr = [ [e1, 'foo 元素'], [e2, 'bar 元素'],]; 上面代码中，e1和e2是两个对象，我们通过arr数组对这两个对象添加一些文字说明。这就形成了arr对e1和e2的引用。 一旦不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放e1和e2占用的内存。 1234// 不需要 e1 和 e2 的时候// 必须手动删除引用arr [0] = null;arr [1] = null; 上面这样的写法显然很不方便。一旦忘了写，就会造成内存泄露。 WeakMap 就是为了解决这个问题而诞生的，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。 基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用WeakMap结构。当该 DOM 元素被清除，其所对应的WeakMap记录就会自动被移除。 123456const wm = new WeakMap();const element = document.getElementById('example');wm.set(element, 'some information');wm.get(element) // "some information" 上面代码中，先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对element的引用就是弱引用，不会被计入垃圾回收机制。 也就是说，上面的 DOM 节点对象的引用计数是1，而不是2。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。 总之，WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。 注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。 12345678const wm = new WeakMap();let key = &#123;&#125;;let obj = &#123;foo: 1&#125;;wm.set(key, obj);obj = null;wm.get(key)// Object &#123;foo: 1&#125; 上面代码中，键值obj是正常引用。所以，即使在 WeakMap 外部消除了obj的引用，WeakMap 内部的引用依然存在。 WeakMap 的语法WeakMap 与 Map 在 API 上的区别主要是两个，一是没有遍历操作（即没有key()、values()和entries()方法），也没有size属性。因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为了防止出现不确定性，就统一规定不能取到键名。二是无法清空，即不支持clear方法。因此，WeakMap只有四个方法可用：get()、set()、has()、delete()。 123456const wm = new WeakMap();// size、forEach、clear 方法都不存在wm.size // undefinedwm.forEach // undefinedwm.clear // undefined Set 和 WeakSet 的特点： 它是一个不可重复的无序列表 值与值之间的比较是通过Object.is方法来进行的，这也意味着5和“5”会占据两个空间 Set和WeakSet区别在于，WeakSet只提供了基础的方法，并且是一个弱引用。 Map 和 WeakMap 的特点： 它是一个由多个无序键值对组成的集合 键名可以是任意的数据类型 WeakMap的键名只能是对象，与WeakSet类似，它也是一个弱引用 Map比WeakMap多了几个方法，但是基础的set get 都是相同的目前，已知的Map的用途，可能就是来存储私有数据，存储对象引用（可以自动释放），大部分情况下，你基本不会用到Map。]]></content>
      <categories>
        <category>JavaScript</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>Set</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 Proxy&Reflect]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F14%2FES6-Proxy-Reflect%2F</url>
    <content type="text"><![CDATA[Proxy概述Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。 Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。 Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。 ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。 1var proxy = new Proxy(target, handler); Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。 1234567891011下面是另一个拦截读取属性行为的例子。var proxy = new Proxy(&#123;&#125;, &#123; get: function(target, property) &#123; return 35; &#125;&#125;);proxy.time // 35proxy.name // 35proxy.title // 35 上面代码中，作为构造函数，Proxy接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有Proxy的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个get方法，用来拦截对目标对象属性的访问请求。get方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回35，所以访问任何属性都得到35。 注意，要使得Proxy起作用，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。 如果handler没有设置任何拦截，那就等同于直接通向原对象。 一个技巧是将 Proxy 对象，设置到object.proxy属性，从而可以在object对象上调用。 1var object = &#123; proxy: new Proxy(target, handler) &#125;; Proxy 实例也可以作为其他对象的原型对象。 12345678var proxy = new Proxy(&#123;&#125;, &#123; get: function(target, property) &#123; return 35; &#125;&#125;);let obj = Object.create(proxy);obj.time // 35 同一个拦截器函数，可以设置拦截多个操作。 Proxy 支持的拦截操作一览。对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。 （1）get(target, propKey, receiver) 拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]。 最后一个参数receiver是一个对象，可选，参见下面Reflect.get的部分。 （2）set(target, propKey, value, receiver) 拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值。 （3）has(target, propKey) 拦截propKey in proxy的操作，返回一个布尔值。 （4）deleteProperty(target, propKey) 拦截delete proxy[propKey]的操作，返回一个布尔值。 （5）ownKeys(target) 拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。 （6）getOwnPropertyDescriptor(target, propKey) 拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。 （7）defineProperty(target, propKey, propDesc) 拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。 （8）preventExtensions(target) 拦截Object.preventExtensions(proxy)，返回一个布尔值。 （9）getPrototypeOf(target) 拦截Object.getPrototypeOf(proxy)，返回一个对象。 （10）isExtensible(target) 拦截Object.isExtensible(proxy)，返回一个布尔值。 （11）setPrototypeOf(target, proto) 拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。 如果目标对象是函数，那么还有两种额外操作可以拦截。 （12）apply(target, object, args) 拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。 （13）construct(target, args) 拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。 Proxy 实例的方法下面是上面这些拦截方法的详细介绍。 get()get方法用于拦截某个属性的读取操作。上文已经有一个例子，下面是另一个拦截读取操作的例子。 12345678910111213141516var person = &#123; name: "张三"&#125;;var proxy = new Proxy(person, &#123; get: function(target, property) &#123; if (property in target) &#123; return target[property]; &#125; else &#123; throw new ReferenceError("Property \"" + property + "\" does not exist."); &#125; &#125;&#125;);proxy.name // "张三"proxy.age // 抛出一个错误 上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回undefined。 get方法可以继承。 123456789let proto = new Proxy(&#123;&#125;, &#123; get(target, propertyKey, receiver) &#123; console.log('GET '+propertyKey); return target[propertyKey]; &#125;&#125;);let obj = Object.create(proto);obj.xxx // "GET xxx" 上面代码中，拦截操作定义在Prototype对象上面，所以如果读取obj对象继承的属性时，拦截会生效。 如果一个属性不可配置（configurable）和不可写（writable），则该属性不能被代理，通过 Proxy 对象访问该属性会报错。 set()set方法用来拦截某个属性的赋值操作。 假定Person对象有一个age属性，该属性应该是一个不大于200的整数，那么可以使用Proxy保证age的属性值符合要求。 1234567891011121314151617181920212223let validator = &#123; set: function(obj, prop, value) &#123; if (prop === 'age') &#123; if (!Number.isInteger(value)) &#123; throw new TypeError('The age is not an integer'); &#125; if (value &gt; 200) &#123; throw new RangeError('The age seems invalid'); &#125; &#125; // 对于age以外的属性，直接保存 obj[prop] = value; &#125;&#125;;let person = new Proxy(&#123;&#125;, validator);person.age = 100;person.age // 100person.age = 'young' // 报错person.age = 300 // 报错 上面代码中，由于设置了存值函数set，任何不符合要求的age属性赋值，都会抛出一个错误，这是数据验证的一种实现方法。利用set方法，还可以数据绑定，即每当对象发生变化时，会自动更新 DOM。 有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合get和set方法，就可以做到防止这些内部属性被外部读写。 12345678910111213141516171819202122var handler = &#123; get (target, key) &#123; invariant(key, 'get'); return target[key]; &#125;, set (target, key, value) &#123; invariant(key, 'set'); target[key] = value; return true; &#125;&#125;;function invariant (key, action) &#123; if (key[0] === '_') &#123; throw new Error(`Invalid attempt to $&#123;action&#125; private "$&#123;key&#125;" property`); &#125;&#125;var target = &#123;&#125;;var proxy = new Proxy(target, handler);proxy._prop// Error: Invalid attempt to get private "_prop" propertyproxy._prop = 'c'// Error: Invalid attempt to set private "_prop" property 上面代码中，只要读写的属性名的第一个字符是下划线，一律抛错，从而达到禁止读写内部属性的目的。 注意，如果目标对象自身的某个属性，不可写也不可配置，那么set不得改变这个属性的值，只能返回同样的值，否则报错。 apply()apply方法拦截函数的调用、call和apply操作。 apply方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组。 12345var handler = &#123; apply (target, ctx, args) &#123; return Reflect.apply(...arguments); &#125;&#125;; 另外，直接调用Reflect.apply方法，也会被拦截。 1Reflect.apply(proxy, null, [9, 10]) // 38 has()has方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符。 下面的例子使用has方法隐藏某些属性，不被in运算符发现。 1234567891011var handler = &#123; has (target, key) &#123; if (key[0] === '_') &#123; return false; &#125; return key in target; &#125;&#125;;var target = &#123; _prop: 'foo', prop: 'foo' &#125;;var proxy = new Proxy(target, handler);'_prop' in proxy // false 如果原对象不可配置或者禁止扩展，这时has拦截会报错。 值得注意的是，has方法拦截的是HasProperty操作，而不是HasOwnProperty操作，即has方法不判断一个属性是对象自身的属性，还是继承的属性。 另外，虽然for…in循环也用到了in运算符，但是has拦截对for…in循环不生效。 construct()construct方法用于拦截new命令，下面是拦截对象的写法。 12345var handler = &#123; construct (target, args, newTarget) &#123; return new target(...args); &#125;&#125;; construct方法可以接受两个参数。 target: 目标对象 args：构建函数的参数对象 construct方法返回的必须是一个对象，否则会报错。 deleteProperty()deleteProperty方法用于拦截delete操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除。 注意，目标对象自身的不可配置（configurable）的属性，不能被deleteProperty方法删除，否则报错 defineProperty()defineProperty方法拦截了Object.defineProperty操作。 getOwnPropertyDescriptor()getOwnPropertyDescriptor方法拦截Object.getOwnPropertyDescriptor()，返回一个属性描述对象或者undefined。 getPrototypeOf()getPrototypeOf方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作。 Object.prototype.[object Object] Object.prototype.isPrototypeOf() Object.getPrototypeOf() Reflect.getPrototypeOf() instanceof 注意，getPrototypeOf方法的返回值必须是对象或者null，否则报错。另外，如果目标对象不可扩展（extensible）， getPrototypeOf方法必须返回目标对象的原型对象。 isExtensible()isExtensible方法拦截Object.isExtensible操作。 12345678910var p = new Proxy(&#123;&#125;, &#123; isExtensible: function(target) &#123; console.log("called"); return true; &#125;&#125;);Object.isExtensible(p)// "called"// true 上面代码设置了isExtensible方法，在调用Object.isExtensible时会输出called。 注意，该方法只能返回布尔值，否则返回值会被自动转为布尔值。 这个方法有一个强限制，它的返回值必须与目标对象的isExtensible属性保持一致，否则就会抛出错误。 ownKeys()ownKeys方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。 Object.getOwnPropertyNames() Object.getOwnPropertySymbols() Object.keys() 注意，使用Object.keys方法时，有三类属性会被ownKeys方法自动过滤，不会返回。 目标对象上不存在的属性 属性名为 Symbol 值 不可遍历（enumerable）的属性 preventExtensions()preventExtensions方法拦截Object.preventExtensions()。该方法必须返回一个布尔值，否则会被自动转为布尔值。 这个方法有一个限制，只有目标对象不可扩展时（即Object.isExtensible(proxy)为false），proxy.preventExtensions才能返回true，否则会报错。 1234567var p = new Proxy(&#123;&#125;, &#123; preventExtensions: function(target) &#123; return true; &#125;&#125;);Object.preventExtensions(p) // 报错 上面代码中，proxy.preventExtensions方法返回true，但这时Object.isExtensible(proxy)会返回true，因此报错。 为了防止出现这个问题，通常要在proxy.preventExtensions方法里面，调用一次Object.preventExtensions。 setPrototypeOf()setPrototypeOf方法主要用来拦截Object.setPrototypeOf方法。 注意，该方法只能返回布尔值，否则会被自动转为布尔值。另外，如果目标对象不可扩展（extensible），setPrototypeOf方法不得改变目标对象的原型。 Proxy.revocable()Proxy.revocable方法返回一个可取消的 Proxy 实例。 12345678910let target = &#123;&#125;;let handler = &#123;&#125;;let &#123;proxy, revoke&#125; = Proxy.revocable(target, handler);proxy.foo = 123;proxy.foo // 123revoke();proxy.foo // TypeError: Revoked Proxy.revocable方法返回一个对象，该对象的proxy属性是Proxy实例，revoke属性是一个函数，可以取消Proxy实例。上面代码中，当执行revoke函数之后，再访问Proxy实例，就会抛出一个错误。 Proxy.revocable的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。 this 问题虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理。 1234567891011const target = &#123; m: function () &#123; console.log(this === proxy); &#125;&#125;;const handler = &#123;&#125;;const proxy = new Proxy(target, handler);target.m() // falseproxy.m() // true 上面代码中，一旦proxy代理target.m，后者内部的this就是指向proxy，而不是target。 由于this指向的变化，有些情况会导致 Proxy 无法代理目标对象。 此外，有些原生对象的内部属性，只有通过正确的this才能拿到，所以 Proxy 也无法代理这些原生对象的属性。 实例：Web 服务的客户端Proxy 对象可以拦截目标对象的任意属性，这使得它很合适用来写 Web 服务的客户端。 123456const service = createWebService('http://example.com/data');service.employees().then(json =&gt; &#123; const employees = JSON.parse(json); // ···&#125;); 上面代码新建了一个 Web 服务的接口，这个接口返回各种数据。Proxy 可以拦截这个对象的任意属性，所以不用为每一种数据写一个适配方法，只要写一个 Proxy 拦截就可以了。 1234567function createWebService(baseUrl) &#123; return new Proxy(&#123;&#125;, &#123; get(target, propKey, receiver) &#123; return () =&gt; httpGet(baseUrl+'/' + propKey); &#125; &#125;);&#125; 同理，Proxy 也可以用来实现数据库的 ORM 层。 Reflect概述Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect对象的设计目的有这样几个。 （1） 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。 （2） 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。 1234567891011121314// 老写法try &#123; Object.defineProperty(target, property, attributes); // success&#125; catch (e) &#123; // failure&#125;// 新写法if (Reflect.defineProperty(target, property, attributes)) &#123; // success&#125; else &#123; // failure&#125; （3） 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。 12345// 老写法'assign' in Object // true// 新写法Reflect.has(Object, 'assign') // true （4）Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。 123456789Proxy(target, &#123; set: function(target, name, value, receiver) &#123; var success = Reflect.set(target,name, value, receiver); if (success) &#123; log('property ' + name + ' on ' + target + ' set to ' + value); &#125; return success; &#125;&#125;); 上面代码中，Proxy方法拦截target对象的属性赋值行为。它采用Reflect.set方法将值赋值给对象的属性，确保完成原有的行为，然后再部署额外的功能。 下面是另一个例子。 1234567891011121314var loggedObj = new Proxy(obj, &#123; get(target, name) &#123; console.log('get', target, name); return Reflect.get(target, name); &#125;, deleteProperty(target, name) &#123; console.log('delete' + name); return Reflect.deleteProperty(target, name); &#125;, has(target, name) &#123; console.log('has' + name); return Reflect.has(target, name); &#125;&#125;); 上面代码中，每一个Proxy对象的拦截操作（get、delete、has），内部都调用对应的Reflect方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。 有了Reflect对象以后，很多操作会更易读。 12345// 老写法Function.prototype.apply.call(Math.floor, undefined, [1.75]) // 1// 新写法Reflect.apply(Math.floor, undefined, [1.75]) // 1 静态方法Reflect对象一共有13个静态方法。 Reflect.apply(target,thisArg,args) Reflect.construct(target,args) Reflect.get(target,name,receiver) Reflect.set(target,name,value,receiver) Reflect.defineProperty(target,name,desc) Reflect.deleteProperty(target,name) Reflect.has(target,name) Reflect.ownKeys(target) Reflect.isExtensible(target) Reflect.preventExtensions(target) Reflect.getOwnPropertyDescriptor(target, name) Reflect.getPrototypeOf(target) Reflect.setPrototypeOf(target, prototype) 上面这些方法的作用，大部分与Object对象的同名方法的作用都是相同的，而且它与Proxy对象的方法是一一对应的。下面是对它们的解释。 Reflect.get(target, name, receiver)Reflect.get方法查找并返回target对象的name属性，如果没有该属性，则返回undefined。 1234567891011var myObject = &#123; foo: 1, bar: 2, get baz() &#123; return this.foo + this.bar; &#125;,&#125;Reflect.get(myObject, 'foo') // 1Reflect.get(myObject, 'bar') // 2Reflect.get(myObject, 'baz') // 3 如果name属性部署了读取函数（getter），则读取函数的this绑定receiver。 1234567891011121314var myObject = &#123; foo: 1, bar: 2, get baz() &#123; return this.foo + this.bar; &#125;,&#125;;var myReceiverObject = &#123; foo: 4, bar: 4,&#125;;Reflect.get(myObject, 'baz', myReceiverObject) // 8 如果第一个参数不是对象，Reflect.get方法会报错。 12Reflect.get(1, 'foo') // 报错Reflect.get(false, 'foo') // 报错 Reflect.set(target, name, value, receiver)Reflect.set方法设置target对象的name属性等于value。 如果name属性设置了赋值函数，则赋值函数的this绑定receiver。 1234567891011121314var myObject = &#123; foo: 4, set bar(value) &#123; return this.foo = value; &#125;,&#125;;var myReceiverObject = &#123; foo: 0,&#125;;Reflect.set(myObject, 'bar', 1, myReceiverObject);myObject.foo // 4myReceiverObject.foo // 1 如果第一个参数不是对象，Reflect.set会报错。 注意，Reflect.set会触发Proxy.defineProperty拦截 Reflect.has(obj, name)Reflect.has方法对应name in obj里面的in运算符。 123456789var myObject = &#123; foo: 1,&#125;;// 旧写法'foo' in myObject // true// 新写法Reflect.has(myObject, 'foo') // true 如果第一个参数不是对象，Reflect.has和in运算符都会报错。 Reflect.deleteProperty(obj, name)Reflect.deleteProperty方法等同于delete obj[name]，用于删除对象的属性。 1234567const myObj = &#123; foo: 'bar' &#125;;// 旧写法delete myObj.foo;// 新写法Reflect.deleteProperty(myObj, 'foo'); 该方法返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回true；删除失败，被删除的属性依然存在，返回false。 Reflect.construct(target, args)Reflect.construct方法等同于new target(…args)，这提供了一种不使用new，来调用构造函数的方法。 123456789function Greeting(name) &#123; this.name = name;&#125;// new 的写法const instance = new Greeting('张三');// Reflect.construct 的写法const instance = Reflect.construct(Greeting, ['张三']); Reflect.getPrototypeOf(obj)Reflect.getPrototypeOf方法用于读取对象的[object Object]属性，对应Object.getPrototypeOf(obj)。 1234567const myObj = new FancyThing();// 旧写法Object.getPrototypeOf(myObj) === FancyThing.prototype;// 新写法Reflect.getPrototypeOf(myObj) === FancyThing.prototype; Reflect.getPrototypeOf和Object.getPrototypeOf的一个区别是： 如果参数不是对象，Object.getPrototypeOf会将这个参数转为对象，然后再运行，而Reflect.getPrototypeOf会报错。 Reflect.setPrototypeOf(obj, newProto)Reflect.setPrototypeOf方法用于设置对象的[object Object]属性，返回第一个参数对象，对应Object.setPrototypeOf(obj, newProto)。 Reflect.apply(func, thisArg, args)Reflect.apply方法等同于Function.prototype.apply.call(func, thisArg, args)，用于绑定this对象后执行给定函数。 一般来说，如果要绑定一个函数的this对象，可以这样写fn.apply(obj, args)，但是如果函数定义了自己的apply方法，就只能写成Function.prototype.apply.call(fn, obj, args)，采用Reflect对象可以简化这种操作。 1234567891011const ages = [11, 33, 12, 54, 18, 96];// 旧写法const youngest = Math.min.apply(Math, ages);const oldest = Math.max.apply(Math, ages);const type = Object.prototype.toString.call(youngest);// 新写法const youngest = Reflect.apply(Math.min, Math, ages);const oldest = Reflect.apply(Math.max, Math, ages);const type = Reflect.apply(Object.prototype.toString, youngest, []); Reflect.defineProperty(target, propertyKey, attributes)Reflect.defineProperty方法基本等同于Object.defineProperty，用来为对象定义属性。未来，后者会被逐渐废除，请从现在开始就使用Reflect.defineProperty代替它。 12345678910111213function MyDate() &#123; /*…*/&#125;// 旧写法Object.defineProperty(MyDate, 'now', &#123; value: () =&gt; Date.now()&#125;);// 新写法Reflect.defineProperty(MyDate, 'now', &#123; value: () =&gt; Date.now()&#125;); 如果Reflect.defineProperty的第一个参数不是对象，就会抛出错误，比如Reflect.defineProperty(1, ‘foo’)。 Reflect.getOwnPropertyDescriptor(target, propertyKey)Reflect.getOwnPropertyDescriptor基本等同于Object.getOwnPropertyDescriptor，用于得到指定属性的描述对象，将来会替代掉后者。 Reflect.isExtensible (target)Reflect.isExtensible方法对应Object.isExtensible，返回一个布尔值，表示当前对象是否可扩展。 1234567const myObject = &#123;&#125;;// 旧写法Object.isExtensible(myObject) // true// 新写法Reflect.isExtensible(myObject) // true Reflect.preventExtensions(target)Reflect.preventExtensions对应Object.preventExtensions方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。 1234567var myObject = &#123;&#125;;// 旧写法Object.preventExtensions(myObject) // Object &#123;&#125;// 新写法Reflect.preventExtensions(myObject) // true 如果参数不是对象，Object.preventExtensions在 ES5 环境报错，在 ES6 环境返回传入的参数，而Reflect.preventExtensions会报错。 12345678// ES5 环境Object.preventExtensions(1) // 报错// ES6 环境Object.preventExtensions(1) // 1// 新写法Reflect.preventExtensions(1) // 报错 Reflect.ownKeys (target)Reflect.ownKeys方法用于返回对象的所有属性，基本等同于Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和。 1234567891011121314151617var myObject = &#123; foo: 1, bar: 2, [Symbol.for('baz')]: 3, [Symbol.for('bing')]: 4,&#125;;// 旧写法Object.getOwnPropertyNames(myObject)// ['foo', 'bar']Object.getOwnPropertySymbols(myObject)//[Symbol(baz), Symbol(bing)]// 新写法Reflect.ownKeys(myObject)// ['foo', 'bar', Symbol(baz), Symbol(bing)] 实例：使用 Proxy 实现观察者模式观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。 12345678910111213const person = observable(&#123; name: '张三', age: 20&#125;);function print() &#123; console.log(`$&#123;person.name&#125;, $&#123;person.age&#125;`)&#125;observe(print);person.name = '李四';// 输出// 李四, 20 上面代码中，数据对象person是观察目标，函数print是观察者。一旦数据对象发生变化，print就会自动执行。 下面，使用 Proxy 写一个观察者模式的最简单实现，即实现observable和observe这两个函数。思路是observable函数返回一个原始对象的 Proxy 代理，拦截赋值操作，触发充当观察者的各个函数。 12345678910const queuedObservers = new Set();const observe = fn =&gt; queuedObservers.add(fn);const observable = obj =&gt; new Proxy(obj, &#123;set&#125;);function set(target, key, value, receiver) &#123; const result = Reflect.set(target, key, value, receiver); queuedObservers.forEach(observer =&gt; observer()); return result;&#125; 上面代码中，先定义了一个Set集合，所有观察者函数都放进这个集合。然后，observable函数返回原始对象的代理，拦截赋值操作。拦截函数set之中，会自动执行所有观察者。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>Proxy</tag>
        <tag>Reflect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6-Promise]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F14%2FES6-Promise%2F</url>
    <content type="text"><![CDATA[Promise 的含义Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 Promise对象有以下两个特点。One：对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态： pending（进行中） fulfilled（已成功） rejected（已失败） 只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 Two：一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 注意，为了行文方便，本章后面的resolved统一只指fulfilled状态，不包含rejected状态。 有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。 Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 如果某些事件不断地反复发生，一般来说，使用 Stream 模式是比部署Promise更好的选择。 基本用法ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。 下面代码创造了一个Promise实例。 123456789var promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。 resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去； reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。 12345promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;); then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。 Promise 新建后就会立即执行。1234567891011121314let promise = new Promise(function(resolve, reject) &#123; console.log('Promise'); resolve();&#125;);promise.then(function() &#123; console.log('resolved.');&#125;);console.log('Hi!');// Promise// Hi!// resolved 上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。 如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例 12345678var p1 = new Promise(function (resolve, reject) &#123; // ...&#125;);var p2 = new Promise(function (resolve, reject) &#123; // ... resolve(p1);&#125;) 上面代码中，p1和p2都是 Promise 的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。 注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。 注意，调用resolve或reject并不会终结 Promise 的参数函数的执行。 12345678new Promise((resolve, reject) =&gt; &#123; resolve(1); console.log(2);&#125;).then(r =&gt; &#123; console.log(r);&#125;);// 2// 1 上面代码中，调用resolve(1)以后，后面的console.log(2)还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。 一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。 12345new Promise((resolve, reject) =&gt; &#123; return resolve(1); // 后面的语句不会执行 console.log(2);&#125;) Promise.prototype.then()Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。 then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。 采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。 1234567getJSON("/post/1.json").then(function (post) &#123; return getJSON(post.commentURL);&#125;).then(function funcA(comments) &#123; console.log("resolved: ", comments);&#125;, function funcB(err) &#123; console.log("rejected: ", err);&#125;); 上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为resolved，就调用funcA，如果状态变为rejected，就调用funcB。 也可以使用箭头函数，上面的代码将更简洁。 Promise.prototype.catch()Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。 123456p.then((val) =&gt; console.log('fulfilled:', val)) .catch((err) =&gt; console.log('rejected', err));// 等同于p.then((val) =&gt; console.log('fulfilled:', val)) .then(null, (err) =&gt; console.log("rejected:", err)); 如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。 如果Promise状态已经变成resolved，再抛出错误是无效的。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。 Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。 一般来说，不要在then方法里面定义Reject状态的回调函数（即then的第二个参数），总是使用catch方法。 12345678910111213141516// badpromise .then(function(data) &#123; // success &#125;, function(err) &#123; // error &#125;);// goodpromise .then(function(data) &#123; //cb // success &#125;) .catch(function(err) &#123; // error &#125;); 上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch）。因此，建议总是使用catch方法，而不使用then方法的第二个参数。 跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。 一般总是建议，Promise 对象后面要跟catch方法，这样可以处理 Promise 内部发生的错误。catch方法返回的还是一个 Promise 对象，因此后面还可以接着调用then方法。 Promise.all()Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。 1var p = Promise.all([p1, p2, p3]); Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。） p的状态由p1、p2、p3决定，分成两种情况。 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。 12345678910111213141516const p1 = new Promise((resolve, reject) =&gt; &#123; resolve('hello');&#125;).then(result =&gt; result).catch(e =&gt; e);const p2 = new Promise((resolve, reject) =&gt; &#123; throw new Error('报错了');&#125;).then(result =&gt; result).catch(e =&gt; e);Promise.all([p1, p2]).then(result =&gt; console.log(result)).catch(e =&gt; console.log(e));// ["hello", Error: 报错了] 上面代码中，p1会resolved，p2首先会rejected，但是p2有自己的catch方法，该方法返回的是一个新的 Promise 实例，p2指向的实际上是这个实例。该实例执行完catch方法后，也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved，因此会调用then方法指定的回调函数，而不会调用catch方法指定的回调函数。 如果p2没有自己的catch方法，就会调用Promise.all()的catch方法。 1234567891011121314const p1 = new Promise((resolve, reject) =&gt; &#123; resolve('hello');&#125;).then(result =&gt; result);const p2 = new Promise((resolve, reject) =&gt; &#123; throw new Error('报错了');&#125;).then(result =&gt; result);Promise.all([p1, p2]).then(result =&gt; console.log(result)).catch(e =&gt; console.log(e));// Error: 报错了 Promise.race()Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。 1var p = Promise.race([p1, p2, p3]); 只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。 Promise.race方法的参数与Promise.all方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。 Promise.resolve()有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。 1var jsPromise = Promise.resolve($.ajax('/whatever.json')); 上面代码将jQuery生成的deferred对象，转为一个新的Promise对象。 Promise.resolve方法的参数分成四种情况。 参数是一个Promise实例 如果参数是Promise实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。 参数是一个thenable对象thenable对象指的是具有then方法的对象，比如下面这个对象。 12345let thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;; Promise.resolve方法会将这个对象转为Promise对象，然后就立即执行thenable对象的then方法。 12345678910let thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;;let p1 = Promise.resolve(thenable);p1.then(function(value) &#123; console.log(value); // 42&#125;); 上面代码中，thenable对象的then方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then方法指定的回调函数，输出42。 参数不是具有then方法的对象，或根本就不是对象 如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为resolved。 123456var p = Promise.resolve('Hello');p.then(function (s)&#123; console.log(s)&#125;);// Hello 上面代码生成一个新的Promise对象的实例p。由于字符串Hello不属于异步操作（判断方法是字符串对象不具有then方法），返回Promise实例的状态从一生成就是resolved，所以回调函数会立即执行。Promise.resolve方法的参数，会同时传给回调函数。 不带有任何参数Promise.resolve方法允许调用时不带参数，直接返回一个resolved状态的Promise对象。所以，如果希望得到一个Promise对象，比较方便的方法就是直接调用Promise.resolve方法。 需要注意的是，立即resolve的Promise对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时。 12345678910111213setTimeout(function () &#123; console.log('three');&#125;, 0);Promise.resolve().then(function () &#123; console.log('two');&#125;);console.log('one');// one// two// three 上面代码中，setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.resolve()在本轮“事件循环”结束时执行，console.log(‘one’)则是立即执行，因此最先输出。 Promise.reject()Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。 12345678var p = Promise.reject('出错了');// 等同于var p = new Promise((resolve, reject) =&gt; reject('出错了'))p.then(null, function (s) &#123; console.log(s)&#125;);// 出错了 上面代码生成一个Promise对象的实例p，状态为rejected，回调函数会立即执行。 注意，Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。这一点与Promise.resolve方法不一致。 1234567891011const thenable = &#123; then(resolve, reject) &#123; reject('出错了'); &#125;&#125;;Promise.reject(thenable).catch(e =&gt; &#123; console.log(e === thenable)&#125;)// true 上面代码中，Promise.reject方法的参数是一个thenable对象，执行以后，后面catch方法的参数不是reject抛出的“出错了”这个字符串，而是thenable对象。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6-Iterator遍历器的概念]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F14%2FES6-Iterator%E9%81%8D%E5%8E%86%E5%99%A8%E7%9A%84%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[Iterator（遍历器）的概念JavaScript 原有的表示“集合”的数据结构，主要是数组（Array）和对象（Object），ES6 又添加了Map和Set。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是Map，Map的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。 遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。 Iterator 的作用有三个： 为各种数据结构，提供一个统一的、简便的访问接口； 使得数据结构的成员能够按某种次序排列； ES6创造了一种新的遍历命令for…of循环，Iterator接口主要供for…of使用。 Iterator 的遍历过程是这样的。 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。 第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。 第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。 不断调用指针对象的next方法，直到它指向数据结构的结束位置。 每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。 下面是一个模拟next方法返回值的例子。 12345678910111213141516var it = makeIterator(['a', 'b']);it.next() // &#123; value: "a", done: false &#125;it.next() // &#123; value: "b", done: false &#125;it.next() // &#123; value: undefined, done: true &#125;function makeIterator(array) &#123; var nextIndex = 0; return &#123; next: function() &#123; return nextIndex &lt; array.length ? &#123;value: array[nextIndex++], done: false&#125; : &#123;value: undefined, done: true&#125;; &#125; &#125;;&#125; 上面代码定义了一个makeIterator函数，它是一个遍历器生成函数，作用就是返回一个遍历器对象。对数组[‘a’, ‘b’]执行这个函数，就会返回该数组的遍历器对象（即指针对象）it。 指针对象的next方法，用来移动指针。开始时，指针指向数组的开始位置。然后，每次调用next方法，指针就会指向数组的下一个成员。第一次调用，指向a；第二次调用，指向b。 next方法返回一个对象，表示当前数据成员的信息。这个对象具有value和done两个属性，value属性返回当前位置的成员，done属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用next方法。 总之，调用指针对象的next方法，就可以遍历事先给定的数据结构。 对于遍历器对象来说，done: false和value: undefined属性都是可以省略的，因此上面的makeIterator函数可以简写成下面的形式。 12345678910function makeIterator(array) &#123; var nextIndex = 0; return &#123; next: function() &#123; return nextIndex &lt; array.length ? &#123;value: array[nextIndex++]&#125; : &#123;done: true&#125;; &#125; &#125;;&#125; 由于 Iterator 只是把接口规格加到数据结构之上，所以，遍历器与它所遍历的那个数据结构，实际上是分开的，完全可以写出没有对应数据结构的遍历器对象，或者说用遍历器对象模拟出数据结构。下面是一个无限运行的遍历器对象的例子。 12345678910111213141516var it = idMaker();it.next().value // '0'it.next().value // '1'it.next().value // '2'// ...function idMaker() &#123; var index = 0; return &#123; next: function() &#123; return &#123;value: index++, done: false&#125;; &#125; &#125;;&#125; 上面的例子中，遍历器生成函数idMaker，返回一个遍历器对象（即指针对象）。但是并没有对应的数据结构，或者说，遍历器对象自己描述了一个数据结构出来。 如果使用 TypeScript 的写法，遍历器接口（Iterable）、指针对象（Iterator）和next方法返回值的规格可以描述如下。 123456789101112interface Iterable &#123; [Symbol.iterator]() : Iterator,&#125;interface Iterator &#123; next(value?: any) : IterationResult,&#125;interface IterationResult &#123; value: any, done: boolean,&#125; 默认 Iterator 接口一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是”可遍历的“（iterable）。 ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。至于属性名Symbol.iterator，它是一个表达式，返回Symbol对象的iterator属性，这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内（参见 Symbol 一章）。 123456789101112const obj = &#123; [Symbol.iterator] : function () &#123; return &#123; next: function () &#123; return &#123; value: 1, done: true &#125;; &#125; &#125;; &#125;&#125;; 上面代码中，对象obj是可遍历的（iterable），因为具有Symbol.iterator属性。执行这个属性，会返回一个遍历器对象。该对象的根本特征就是具有next方法。每次调用next方法，都会返回一个代表当前成员的信息对象，具有value和done两个属性。 ES6 的有些数据结构原生具备 Iterator 接口（比如数组），即不用任何处理，就可以被for…of循环遍历。原因在于，这些数据结构原生部署了Symbol.iterator属性（详见下文），另外一些数据结构没有（比如对象）。凡是部署了Symbol.iterator属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。 原生具备 Iterator 接口的数据结构如下。 Array Map Set String TypedArray 函数的 arguments 对象 NodeList 对象 对于原生部署 Iterator 接口的数据结构，不用自己写遍历器生成函数，for…of循环会自动遍历它们。除此之外，其他数据结构（主要是对象）的 Iterator 接口，都需要自己在Symbol.iterator属性上面部署，这样才会被for…of循环遍历。 对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作 Map 结构使用，ES5 没有 Map 结构，而 ES6 原生提供了。 下面的例子是数组的Symbol.iterator属性。 1234567let arr = ['a', 'b', 'c'];let iter = arr[Symbol.iterator]();iter.next() // &#123; value: 'a', done: false &#125;iter.next() // &#123; value: 'b', done: false &#125;iter.next() // &#123; value: 'c', done: false &#125;iter.next() // &#123; value: undefined, done: true &#125; 上面代码中，变量arr是一个数组，原生就具有遍历器接口，部署在arr的Symbol.iterator属性上面。所以，调用这个属性，就得到遍历器对象。 调用 Iterator 接口的场合有一些场合会默认调用 Iterator 接口（即Symbol.iterator方法），除了下文会介绍的for…of循环，还有几个别的场合。 1. 解构赋值对数组和 Set 结构进行解构赋值时，会默认调用Symbol.iterator方法。 1234567let set = new Set().add('a').add('b').add('c');let [x,y] = set;// x='a'; y='b'let [first, ...rest] = set;// first='a'; rest=['b','c']; 2. 扩展运算符扩展运算符（…）也会调用默认的 Iterator 接口。 12345678// 例一var str = 'hello';[...str] // ['h','e','l','l','o']// 例二let arr = ['b', 'c'];['a', ...arr, 'd']// ['a', 'b', 'c', 'd'] 上面代码的扩展运算符内部就调用 Iterator 接口。 实际上，这提供了一种简便机制，可以将任何部署了 Iterator 接口的数据结构，转为数组。也就是说，只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。 3. yield*yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。 1234567891011121314let generator = function* () &#123; yield 1; yield* [2,3,4]; yield 5;&#125;;var iterator = generator();iterator.next() // &#123; value: 1, done: false &#125;iterator.next() // &#123; value: 2, done: false &#125;iterator.next() // &#123; value: 3, done: false &#125;iterator.next() // &#123; value: 4, done: false &#125;iterator.next() // &#123; value: 5, done: false &#125;iterator.next() // &#123; value: undefined, done: true &#125; 4. 其他场合由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。 下面是一些例子。 for…of Array.from() Map(), Set(), WeakMap(), WeakSet()（比如new Map([[‘a’,1],[‘b’,2]])） Promise.all() Promise.race() Iterator接口与Generator函数Symbol.iterator方法的最简单实现，还是使用下一章要介绍的Generator函数。1234567891011121314151617181920212223var myIterable = &#123;&#125;;myIterable[Symbol.iterator] = function* () &#123; yield 1; yield 2; yield 3;&#125;;[...myIterable] // [1, 2, 3]// 或者采用下面的简洁写法let obj = &#123; * [Symbol.iterator]() &#123; yield 'hello'; yield 'world'; &#125;&#125;;for (let x of obj) &#123; console.log(x);&#125;// hello// world 上面代码中，Symbol.iterator方法几乎不用部署任何代码，只要用yield命令给出每一步的返回值即可。 遍历器对象的return()，throw()遍历器对象除了具有next方法，还可以具有return方法和throw方法。（如果你自己写遍历器对象生成函数，那么next方法是必须部署的，return方法和throw方法是否部署是可选的。） return方法的使用场合是，如果for…of循环提前退出（通常是因为出错，或者有break语句或continue语句），就会调用return方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署return方法。 1234567891011function readLinesSync(file) &#123; return &#123; next() &#123; return &#123; done: false &#125;; &#125;, return() &#123; file.close(); return &#123; done: true &#125;; &#125;, &#125;;&#125; 上面代码中，函数readLinesSync接受一个文件对象作为参数，返回一个遍历器对象，其中除了next方法，还部署了return方法。 下面的三种情况，都会触发执行return方法。 1234567891011121314151617// 情况一for (let line of readLinesSync(fileName)) &#123; console.log(line); break;&#125;// 情况二for (let line of readLinesSync(fileName)) &#123; console.log(line); continue;&#125;// 情况三for (let line of readLinesSync(fileName)) &#123; console.log(line); throw new Error();&#125; 上面代码中，情况一输出文件的第一行以后，就会执行return方法，关闭这个文件；情况二输出所有行以后，执行return方法，关闭该文件；情况三会在执行return方法关闭文件之后，再抛出错误。 注意，return方法必须返回一个对象，这是 Generator 规格决定的。 throw方法主要是配合 Generator 函数使用，一般的遍历器对象用不到这个方法。请参阅《Generator函数》一章。 for…of循环ES6 借鉴 C++、Java、C# 和 Python 语言，引入了for…of循环，作为遍历所有数据结构的统一的方法。 一个数据结构只要部署了Symbol.iterator属性，就被视为具有iterator接口，就可以用for…of循环遍历它的成员。也就是说，for…of循环内部调用的是数据结构的Symbol.iterator方法。 for…of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。 数组数组原生具备iterator接口（即默认部署了Symbol.iterator属性），for…of循环本质上就是调用这个接口产生的遍历器 JavaScript 原有的for…in循环，只能获得对象的键名，不能直接获取键值。ES6 提供for…of循环，允许遍历获得键值。 for…in循环读取键名，for…of循环读取键值。如果要通过for…of循环，获取数组的索引，可以借助数组实例的entries方法和keys方法，参见《数组的扩展》章节。 for…of循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟for…in循环也不一样。 Set 和 Map 结构Set 和 Map 结构也原生具有 Iterator 接口，可以直接使用for…of循环。 值得注意的地方有两个 首先，遍历的顺序是按照各个成员被添加进数据结构的顺序。 其次，Set 结构遍历时，返回的是一个值，而 Map 结构遍历时，返回的是一个数组，该数组的两个成员分别为当前 Map 成员的键名和键值。 123456789101112131415161718var engines = new Set(["Gecko", "Trident", "Webkit", "Webkit"]);for (var e of engines) &#123; console.log(e);&#125;// Gecko// Trident// Webkitvar es6 = new Map();es6.set("edition", 6);es6.set("committee", "TC39");es6.set("standard", "ECMA-262");for (var [name, value] of es6) &#123; console.log(name + ": " + value);&#125;// edition: 6// committee: TC39// standard: ECMA-262 123456789101112let map = new Map().set('a', 1).set('b', 2);for (let pair of map) &#123; console.log(pair);&#125;// ['a', 1]// ['b', 2]for (let [key, value] of map) &#123; console.log(key + ' : ' + value);&#125;// a : 1// b : 2 计算生成的数据结构有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6的数组、Set、Map 都部署了以下三个方法，调用后都返回遍历器对象。 entries() 返回一个遍历器对象，用来遍历[键名, 键值]组成的数组。对于数组，键名就是索引值；对于 Set，键名与键值相同。Map 结构的 Iterator 接口，默认就是调用entries方法。keys() 返回一个遍历器对象，用来遍历所有的键名。values() 返回一个遍历器对象，用来遍历所有的键值。这三个方法调用后生成的遍历器对象，所遍历的都是计算生成的数据结构。 1234567let arr = ['a', 'b', 'c'];for (let pair of arr.entries()) &#123; console.log(pair);&#125;// [0, 'a']// [1, 'b']// [2, 'c'] 类似数组的对象类似数组的对象包括好几类。下面是for…of循环用于字符串、DOM NodeList 对象、arguments对象的例子。 1234567891011121314151617181920212223// 字符串let str = "hello";for (let s of str) &#123; console.log(s); // h e l l o&#125;// DOM NodeList对象let paras = document.querySelectorAll("p");for (let p of paras) &#123; p.classList.add("test");&#125;// arguments对象function printArgs() &#123; for (let x of arguments) &#123; console.log(x); &#125;&#125;printArgs('a', 'b');// 'a'// 'b' 对于字符串来说，for…of循环还有一个特点，就是会正确识别32位 UTF-16 字符。 12345for (let x of 'a\uD83D\uDC0A') &#123; console.log(x);&#125;// 'a'// '\uD83D\uDC0A' 并不是所有类似数组的对象都具有 Iterator 接口，一个简便的解决方法，就是使用Array.from方法将其转为数组。 1234567891011let arrayLike = &#123; length: 2, 0: 'a', 1: 'b' &#125;;// 报错for (let x of arrayLike) &#123; console.log(x);&#125;// 正确for (let x of Array.from(arrayLike)) &#123; console.log(x);&#125; 对象对于普通的对象，for…of结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。但是，这样情况下，for…in循环依然可以用来遍历键名。 一种解决方法是，使用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组。 123for (var key of Object.keys(someObject)) &#123; console.log(key + ': ' + someObject[key]);&#125; 另一个方法是使用 Generator 函数将对象重新包装一下。 123456789101112function* entries(obj) &#123; for (let key of Object.keys(obj)) &#123; yield [key, obj[key]]; &#125;&#125;for (let [key, value] of entries(obj)) &#123; console.log(key, '-&gt;', value);&#125;// a -&gt; 1// b -&gt; 2// c -&gt; 3 与其他遍历语法的比较以数组为例，JavaScript 提供多种遍历语法。最原始的写法就是for循环。 123for (var index = 0; index &lt; myArray.length; index++) &#123; console.log(myArray[index]);&#125; 这种写法比较麻烦，因此数组提供内置的forEach方法。 123myArray.forEach(function (value) &#123; console.log(value);&#125;); 这种写法的问题在于，无法中途跳出forEach循环，break命令或return命令都不能奏效。 for…in循环可以遍历数组的键名。 123for (var index in myArray) &#123; console.log(myArray[index]);&#125; for…in循环有几个缺点。 数组的键名是数字，但是for…in循环是以字符串作为键名“0”、“1”、“2”等等。 for…in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。 某些情况下，for…in循环会以任意顺序遍历键名。 总之，for…in循环主要是为遍历对象而设计的，不适用于遍历数组。for…of循环相比上面几种做法，有一些显著的优点。 123for (let value of myArray) &#123; console.log(value);&#125; 有着同for…in一样的简洁语法，但是没有for…in那些缺点。 不同于forEach方法，它可以与break、continue和return配合使用。 提供了遍历所有数据结构的统一操作接口。 下面是一个使用break语句，跳出for…of循环的例子。 12345for (var n of fibonacci) &#123; if (n &gt; 1000) break; console.log(n);&#125; 上面的例子，会输出斐波纳契数列小于等于1000的项。如果当前项大于1000，就会使用break语句跳出for…of循环。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>Iterator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6-Generator]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F14%2FES6-Generator%2F</url>
    <content type="text"><![CDATA[简介基本概念Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。 Generator 函数有多种理解角度。从语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。 执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。 形式上，Generator 函数是一个普通函数，但是有两个特征。 function关键字与函数名之间有一个星号 函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。 1234567function* helloWorldGenerator() &#123; yield 'hello'; yield 'world'; return 'ending';&#125;var hw = helloWorldGenerator(); 上面代码定义了一个 Generator 函数helloWorldGenerator，它内部有两个yield表达式（hello和world），即该函数有三个状态：hello，world 和 return 语句（结束执行）。 Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。 然后接着，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。 总结调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。 ES6 没有规定，function关键字与函数名之间的星号，写在哪个位置。这导致下面的写法都能通过。 1234function * foo(x, y) &#123; ··· &#125;function *foo(x, y) &#123; ··· &#125;function* foo(x, y) &#123; ··· &#125;function*foo(x, y) &#123; ··· &#125; 由于 Generator 函数仍然是普通函数，所以一般的写法是上面的第三种，即星号紧跟在function关键字后面。 yield 表达式由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。 遍历器对象的next方法的运行逻辑如下。 遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。 下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。 如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。 如果该函数没有return语句，则返回的对象的value属性值为undefined。 需要注意的是，yield表达式后面的表达式，只有当调用next方法、并且内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。 123function* gen() &#123; yield 123 + 456;&#125; 上面代码中，yield后面的表达式123 + 456，不会立即求值，只会在next方法将指针移到这一句时，才会求值。 yield表达式与return语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield表达式。正常函数只能返回一个值，因为只能执行一次return；Generator 函数可以返回一系列的值，因为可以有任意多个yield。从另一个角度看，也可以说 Generator 生成了一系列的值，这也就是它的名称的来历（英语中，generator 这个词是“生成器”的意思）。 Generator 函数可以不用yield表达式，这时就变成了一个单纯的暂缓执行函数。 另外需要注意，yield表达式只能用在 Generator 函数里面，用在其他地方都会报错。 另外，yield表达式如果用在另一个表达式之中，必须放在圆括号里面。 与 Iterator 接口的关系上一章说过，任意一个对象的Symbol.iterator方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。 由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口。 12345678var myIterable = &#123;&#125;;myIterable[Symbol.iterator] = function* () &#123; yield 1; yield 2; yield 3;&#125;;[...myIterable] // [1, 2, 3] 上面代码中，Generator 函数赋值给Symbol.iterator属性，从而使得myIterable对象具有了 Iterator 接口，可以被…运算符遍历了。 Generator 函数执行后，返回一个遍历器对象。该对象本身也具有Symbol.iterator属性，执行后返回自身。 12345678function* gen()&#123; // some code&#125;var g = gen();g[Symbol.iterator]() === g// true next 方法的参数yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。 123456789101112function* f() &#123; for(var i = 0; true; i++) &#123; var reset = yield i; if(reset) &#123; i = -1; &#125; &#125;&#125;var g = f();g.next() // &#123; value: 0, done: false &#125;g.next() // &#123; value: 1, done: false &#125;g.next(true) // &#123; value: 0, done: false &#125; 上面代码先定义了一个可以无限运行的 Generator 函数f，如果next方法没有参数，每次运行到yield表达式，变量reset的值总是undefined。当next方法带一个参数true时，变量reset就被重置为这个参数（即true），因此i会等于-1，下一轮循环就会从-1开始递增。 这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过next方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。 注意，由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的。V8 引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数。 for…of 循环for…of循环可以自动遍历 Generator 函数时生成的Iterator对象，且此时不再需要调用next方法。 12345678910111213function *foo() &#123; yield 1; yield 2; yield 3; yield 4; yield 5; return 6;&#125;for (let v of foo()) &#123; console.log(v);&#125;// 1 2 3 4 5 上面代码使用for…of循环，依次显示5个yield表达式的值。这里需要注意，一旦next方法的返回对象的done属性为true，for…of循环就会中止，且不包含该返回对象，所以上面代码的return语句返回的6，不包括在for…of循环之中。 利用for…of循环，可以写出遍历任意对象（object）的方法。原生的 JavaScript 对象没有遍历接口，无法使用for…of循环，通过 Generator 函数为它加上这个接口，就可以用了。 123456789101112131415function* objectEntries(obj) &#123; let propKeys = Reflect.ownKeys(obj); for (let propKey of propKeys) &#123; yield [propKey, obj[propKey]]; &#125;&#125;let jane = &#123; first: 'Jane', last: 'Doe' &#125;;for (let [key, value] of objectEntries(jane)) &#123; console.log(`$&#123;key&#125;: $&#123;value&#125;`);&#125;// first: Jane// last: Doe 上面代码中，对象jane原生不具备 Iterator 接口，无法用for…of遍历。这时，我们通过 Generator 函数objectEntries为它加上遍历器接口，就可以用for…of遍历了。 加上遍历器接口的另一种写法是，将 Generator 函数加到对象的Symbol.iterator属性上面。 1234567891011121314151617function* objectEntries() &#123; let propKeys = Object.keys(this); for (let propKey of propKeys) &#123; yield [propKey, this[propKey]]; &#125;&#125;let jane = &#123; first: 'Jane', last: 'Doe' &#125;;jane[Symbol.iterator] = objectEntries;for (let [key, value] of jane) &#123; console.log(`$&#123;key&#125;: $&#123;value&#125;`);&#125;// first: Jane// last: Doe 除了for…of循环以外，扩展运算符（…）、解构赋值和Array.from方法内部调用的都是遍历器接口。这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。 123456789101112131415161718192021222324function* numbers () &#123; yield 1 yield 2 return 3 yield 4&#125;// 扩展运算符[...numbers()] // [1, 2]// Array.from 方法Array.from(numbers()) // [1, 2]// 解构赋值let [x, y] = numbers();x // 1y // 2// for...of 循环for (let n of numbers()) &#123; console.log(n)&#125;// 1// 2 Generator.prototype.throw()Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。 12345678910111213141516171819var g = function* () &#123; try &#123; yield; &#125; catch (e) &#123; console.log('内部捕获', e); &#125;&#125;;var i = g();i.next();try &#123; i.throw('a'); i.throw('b');&#125; catch (e) &#123; console.log('外部捕获', e);&#125;// 内部捕获 a// 外部捕获 b 上面代码中，遍历器对象i连续抛出两个错误。第一个错误被 Generator 函数体内的catch语句捕获。i第二次抛出错误，由于 Generator 函数内部的catch语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的catch语句捕获。 throw方法可以接受一个参数，该参数会被catch语句接收，建议抛出Error对象的实例。 123456789101112var g = function* () &#123; try &#123; yield; &#125; catch (e) &#123; console.log(e); &#125;&#125;;var i = g();i.next();i.throw(new Error('出错了！'));// Error: 出错了！(…) 注意，不要混淆遍历器对象的throw方法和全局的throw命令。上面代码的错误，是用遍历器对象的throw方法抛出的，而不是用throw命令抛出的。后者只能被函数体外的catch语句捕获。 123456789101112131415161718192021var g = function* () &#123; while (true) &#123; try &#123; yield; &#125; catch (e) &#123; if (e != 'a') throw e; console.log('内部捕获', e); &#125; &#125;&#125;;var i = g();i.next();try &#123; throw new Error('a'); throw new Error('b');&#125; catch (e) &#123; console.log('外部捕获', e);&#125;// 外部捕获 [Error: a] 上面代码之所以只捕获了a，是因为函数体外的catch语句块，捕获了抛出的a错误以后，就不会再继续try代码块里面剩余的语句了。 如果 Generator 函数内部没有部署try…catch代码块，那么throw方法抛出的错误，将被外部try…catch代码块捕获。 1234567891011121314151617var g = function* () &#123; while (true) &#123; yield; console.log('内部捕获', e); &#125;&#125;;var i = g();i.next();try &#123; i.throw('a'); i.throw('b');&#125; catch (e) &#123; console.log('外部捕获', e);&#125;// 外部捕获 a 上面代码中，Generator 函数g内部没有部署try…catch代码块，所以抛出的错误直接被外部catch代码块捕获。 如果 Generator 函数内部和外部，都没有部署try…catch代码块，那么程序将报错，直接中断执行。 throw方法被捕获以后，会附带执行下一条yield表达式。也就是说，会附带执行一次next方法。1234567891011121314var gen = function* gen()&#123; try &#123; yield console.log('a'); &#125; catch (e) &#123; // ... &#125; yield console.log('b'); yield console.log('c');&#125;var g = gen();g.next() // ag.throw() // bg.next() // c 上面代码中，g.throw方法被捕获以后，自动执行了一次next方法，所以会打印b。另外，也可以看到，只要 Generator 函数内部部署了try…catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历。 另外，throw命令与g.throw方法是无关的，两者互不影响。 这种函数体内捕获错误的机制，大大方便了对错误的处理。多个yield表达式，可以只用一个try…catch代码块来捕获错误。如果使用回调函数的写法，想要捕获多个错误，就不得不为每个函数内部写一个错误处理语句，现在只在 Generator 函数内部写一次catch语句就可以了。 Generator 函数体外抛出的错误，可以在函数体内捕获；反过来，Generator 函数体内抛出的错误，也可以被函数体外的catch捕获。 一旦 Generator 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用next方法，将返回一个value属性等于undefined、done属性等于true的对象，即 JavaScript 引擎认为这个 Generator 已经运行结束了。 Generator.prototype.return()Generator 函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历 Generator 函数。 1234567891011function* gen() &#123; yield 1; yield 2; yield 3;&#125;var g = gen();g.next() // &#123; value: 1, done: false &#125;g.return('foo') // &#123; value: "foo", done: true &#125;g.next() // &#123; value: undefined, done: true &#125; 上面代码中，遍历器对象g调用return方法后，返回值的value属性就是return方法的参数foo。并且，Generator函数的遍历就终止了，返回值的done属性为true，以后再调用next方法，done属性总是返回true。 如果return方法调用时，不提供参数，则返回值的value属性为undefined。 next()、throw()、return() 的共同点next()、throw()、return()这三个方法本质上是同一件事，可以放在一起理解。它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换yield表达式。next()是将yield表达式替换成一个值。 1234567891011const g = function* (x, y) &#123; let result = yield x + y; return result;&#125;;const gen = g(1, 2);gen.next(); // Object &#123;value: 3, done: false&#125;gen.next(1); // Object &#123;value: 1, done: true&#125;// 相当于将 let result = yield x + y// 替换成 let result = 1; 上面代码中，第二个next(1)方法就相当于将yield表达式替换成一个值1。如果next方法没有参数，就相当于替换成undefined。 throw()是将yield表达式替换成一个throw语句。 123gen.throw(new Error('出错了')); // Uncaught Error: 出错了// 相当于将 let result = yield x + y// 替换成 let result = throw(new Error('出错了')); return()是将yield表达式替换成一个return语句。 123gen.return(2); // Object &#123;value: 2, done: true&#125;// 相当于将 let result = yield x + y// 替换成 let result = return 2; yield* 表达式如果在 Generator 函数内部，调用另一个 Generator 函数，默认情况下是没有效果的。 12345678910111213141516function* foo() &#123; yield 'a'; yield 'b';&#125;function* bar() &#123; yield 'x'; foo(); yield 'y';&#125;for (let v of bar())&#123; console.log(v);&#125;// "x"// "y" 上面代码中，foo和bar都是 Generator 函数，在bar里面调用foo，是不会有效果的。 这个就需要用到yield*表达式，用来在一个 Generator 函数里面执行另一个 Generator 函数。 123456789101112131415161718192021222324252627282930function* bar() &#123; yield 'x'; yield* foo(); yield 'y';&#125;// 等同于function* bar() &#123; yield 'x'; yield 'a'; yield 'b'; yield 'y';&#125;// 等同于function* bar() &#123; yield 'x'; for (let v of foo()) &#123; yield v; &#125; yield 'y';&#125;for (let v of bar())&#123; console.log(v);&#125;// "x"// "a"// "b"// "y" 再来看一个对比的例子。 12345678910111213141516171819202122232425function* inner() &#123; yield 'hello!';&#125;function* outer1() &#123; yield 'open'; yield inner(); yield 'close';&#125;var gen = outer1()gen.next().value // "open"gen.next().value // 返回一个遍历器对象gen.next().value // "close"function* outer2() &#123; yield 'open' yield* inner() yield 'close'&#125;var gen = outer2()gen.next().value // "open"gen.next().value // "hello!"gen.next().value // "close" 从语法角度看，如果yield表达式后面跟的是一个遍历器对象，需要在yield表达式后面加上星号，表明它返回的是一个遍历器对象。这被称为yield*表达式。 yield*后面的 Generator 函数（没有return语句时），等同于在 Generator 函数内部，部署一个for…of循环。 实际上，任何数据结构只要有 Iterator 接口，就可以被yield*遍历。 如果被代理的 Generator 函数有return语句，那么就可以向代理它的 Generator 函数返回数据。 作为对象属性的Generator函数如果一个对象的属性是 Generator 函数，可以简写成下面的形式。 12345let obj = &#123; * myGeneratorMethod() &#123; ··· &#125;&#125;; 上面代码中，myGeneratorMethod属性前面有一个星号，表示这个属性是一个 Generator 函数。 它的完整形式如下，与上面的写法是等价的。 12345let obj = &#123; myGeneratorMethod: function* () &#123; // ··· &#125;&#125;; Generator 函数的thisGenerator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的prototype对象上的方法。 12345678910function* g() &#123;&#125;g.prototype.hello = function () &#123; return 'hi!';&#125;;let obj = g();obj instanceof g // trueobj.hello() // 'hi!' 但是，如果把g当作普通的构造函数，并不会生效，因为g返回的总是遍历器对象，而不是this对象。 123456function* g() &#123; this.a = 11;&#125;let obj = g();obj.a // undefined 上面代码中，Generator函数g在this对象上面添加了一个属性a，但是obj对象拿不到这个属性。 Generator函数也不能跟new命令一起用，会报错。 含义Generator 与状态机Generator 是实现状态机的最佳结构。比如，下面的clock函数就是一个状态机。 12345678var ticking = true;var clock = function() &#123; if (ticking) console.log('Tick!'); else console.log('Tock!'); ticking = !ticking;&#125; 上面代码的clock函数一共有两种状态（Tick和Tock），每运行一次，就改变一次状态。这个函数如果用 Generator 实现，就是下面这样。 12345678var clock = function* () &#123; while (true) &#123; console.log('Tick!'); yield; console.log('Tock!'); yield; &#125;&#125;; 上面的 Generator 实现与 ES5 实现对比，可以看到少了用来保存状态的外部变量ticking，这样就更简洁，更安全（状态不会被非法篡改）、更符合函数式编程的思想，在写法上也更优雅。Generator 之所以可以不用外部变量保存状态，是因为它本身就包含了一个状态信息，即目前是否处于暂停态。 Generator与协程协程（coroutine）是一种程序运行的方式，可以理解成“协作的线程”或“协作的函数”。协程既可以用单线程实现，也可以用多线程实现。前者是一种特殊的子例程，后者是一种特殊的线程。 1. 协程与子例程的差异传统的“子例程”（subroutine）采用堆栈式“后进先出”的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数。协程与其不同，多个线程（单线程情况下，即多个函数）可以并行执行，但是只有一个线程（或函数）处于正在运行的状态，其他线程（或函数）都处于暂停态（suspended），线程（或函数）之间可以交换执行权。也就是说，一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。 从实现上看，在内存中，子例程只使用一个栈（stack），而协程是同时存在多个栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行。 2. 协程与普通线程的差异不难看出，协程适合用于多任务运行的环境。在这个意义上，它与普通的线程很相似，都有自己的执行上下文、可以分享全局变量。它们的不同之处在于，同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都处于暂停状态。此外，普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。 由于 JavaScript 是单线程语言，只能保持一个调用栈。引入协程以后，每个任务可以保持自己的调用栈。这样做的最大好处，就是抛出错误的时候，可以找到原始的调用栈。不至于像异步操作的回调函数那样，一旦出错，原始的调用栈早就结束。 Generator 函数是 ES6 对协程的实现，但属于不完全实现。Generator 函数被称为“半协程”（semi-coroutine），意思是只有 Generator 函数的调用者，才能将程序的执行权还给 Generator 函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。 如果将 Generator 函数当作协程，完全可以将多个需要互相协作的任务写成 Generator 函数，它们之间使用yield表示式交换控制权。 应用Generator 可以暂停函数执行，返回任意表达式的值。这种特点使得 Generator 有多种应用场景。 1. 异步操作的同步化表达Generator 函数的暂停执行的效果，意味着可以把异步操作写在yield表达式里面，等到调用next方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在yield表达式下面，反正要等到调用next方法时再执行。所以，Generator 函数的一个重要实际意义就是用来处理异步操作，改写回调函数。 1234567891011function* loadUI() &#123; showLoadingScreen(); yield loadUIDataAsynchronously(); hideLoadingScreen();&#125;var loader = loadUI();// 加载UIloader.next()// 卸载UIloader.next() 上面代码中，第一次调用loadUI函数时，该函数不会执行，仅返回一个遍历器。下一次对该遍历器调用next方法，则会显示Loading界面（showLoadingScreen），并且异步加载数据（loadUIDataAsynchronously）。等到数据加载完成，再一次使用next方法，则会隐藏Loading界面。可以看到，这种写法的好处是所有Loading界面的逻辑，都被封装在一个函数，按部就班非常清晰。 Ajax 是典型的异步操作，通过 Generator 函数部署 Ajax 操作，可以用同步的方式表达。 1234567891011121314function* main() &#123; var result = yield request("http://some.url"); var resp = JSON.parse(result); console.log(resp.value);&#125;function request(url) &#123; makeAjaxCall(url, function(response)&#123; it.next(response); &#125;);&#125;var it = main();it.next(); 上面代码的main函数，就是通过 Ajax 操作获取数据。可以看到，除了多了一个yield，它几乎与同步操作的写法完全一样。注意，makeAjaxCall函数中的next方法，必须加上response参数，因为yield表达式，本身是没有值的，总是等于undefined。 2. 控制流管理如果有一个多步操作非常耗时，采用回调函数，可能会写成下面这样。 123456789step1(function (value1) &#123; step2(value1, function(value2) &#123; step3(value2, function(value3) &#123; step4(value3, function(value4) &#123; // Do something with value4 &#125;); &#125;); &#125;);&#125;); 采用 Promise 改写上面的代码。 12345678910Promise.resolve(step1) .then(step2) .then(step3) .then(step4) .then(function (value4) &#123; // Do something with value4 &#125;, function (error) &#123; // Handle any error from step1 through step4 &#125;) .done(); 上面代码已经把回调函数，改成了直线执行的形式，但是加入了大量 Promise 的语法。Generator 函数可以进一步改善代码运行流程。 1234567891011function* longRunningTask(value1) &#123; try &#123; var value2 = yield step1(value1); var value3 = yield step2(value2); var value4 = yield step3(value3); var value5 = yield step4(value4); // Do something with value4 &#125; catch (e) &#123; // Handle any error from step1 through step4 &#125;&#125; 然后，使用一个函数，按次序自动执行所有步骤。 12345678910scheduler(longRunningTask(initialValue));function scheduler(task) &#123; var taskObj = task.next(task.value); // 如果Generator函数未结束，就继续调用 if (!taskObj.done) &#123; task.value = taskObj.value scheduler(task); &#125;&#125; 注意，上面这种做法，只适合同步操作，即所有的task都必须是同步的，不能有异步操作。因为这里的代码一得到返回值，就继续往下执行，没有判断异步操作何时完成。如果要控制异步的操作流程，详见后面的《异步操作》一章。 下面，利用for…of循环会自动依次执行yield命令的特性，提供一种更一般的控制流管理的方法。 12345678let steps = [step1Func, step2Func, step3Func];function *iterateSteps(steps)&#123; for (var i=0; i&lt; steps.length; i++)&#123; var step = steps[i]; yield step(); &#125;&#125; 上面代码中，数组steps封装了一个任务的多个步骤，Generator 函数iterateSteps则是依次为这些步骤加上yield命令。 将任务分解成步骤之后，还可以将项目分解成多个依次执行的任务。 12345678let jobs = [job1, job2, job3];function* iterateJobs(jobs)&#123; for (var i=0; i&lt; jobs.length; i++)&#123; var job = jobs[i]; yield* iterateSteps(job.steps); &#125;&#125; 上面代码中，数组jobs封装了一个项目的多个任务，Generator 函数iterateJobs则是依次为这些任务加上yield*命令。 最后，就可以用for…of循环一次性依次执行所有任务的所有步骤。 123for (var step of iterateJobs(jobs))&#123; console.log(step.id);&#125; 再次提醒，上面的做法只能用于所有步骤都是同步操作的情况，不能有异步操作的步骤。如果想要依次执行异步的步骤，必须使用后面的《异步操作》一章介绍的方法。 for…of的本质是一个while循环，所以上面的代码实质上执行的是下面的逻辑。 12345678var it = iterateJobs(jobs);var res = it.next();while (!res.done)&#123; var result = res.value; // ... res = it.next();&#125; 3. 部署 Iterator 接口利用 Generator 函数，可以在任意对象上部署 Iterator 接口。 12345678910111213141516function* iterEntries(obj) &#123; let keys = Object.keys(obj); for (let i=0; i &lt; keys.length; i++) &#123; let key = keys[i]; yield [key, obj[key]]; &#125;&#125;let myObj = &#123; foo: 3, bar: 7 &#125;;for (let [key, value] of iterEntries(myObj)) &#123; console.log(key, value);&#125;// foo 3// bar 7 上述代码中，myObj是一个普通对象，通过iterEntries函数，就有了 Iterator 接口。也就是说，可以在任意对象上部署next方法。 4. 作为数据结构Generator 可以看作是数据结构，更确切地说，可以看作是一个数组结构，因为 Generator 函数可以返回一系列的值，这意味着它可以对任意表达式，提供类似数组的接口。 12345function *doStuff() &#123; yield fs.readFile.bind(null, 'hello.txt'); yield fs.readFile.bind(null, 'world.txt'); yield fs.readFile.bind(null, 'and-such.txt');&#125; 上面代码就是依次返回三个函数，但是由于使用了 Generator 函数，导致可以像处理数组那样，处理这三个返回的函数。 123for (task of doStuff()) &#123; // task是一个函数，可以像回调函数那样使用它&#125; 实际上，如果用 ES5 表达，完全可以用数组模拟 Generator 的这种用法。 1234567function doStuff() &#123; return [ fs.readFile.bind(null, 'hello.txt'), fs.readFile.bind(null, 'world.txt'), fs.readFile.bind(null, 'and-such.txt') ];&#125; 上面的函数，可以用一模一样的for…of循环处理！两相一比较，就不难看出 Generator 使得数据或者操作，具备了类似数组的接口。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>Generator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 async]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F14%2FES6-async%2F</url>
    <content type="text"><![CDATA[含义ES2017 标准引入了 async 函数，使得异步操作变得更加方便。async 函数是什么？一句话，它就是 Generator 函数的语法糖。前文有一个 Generator 函数，依次读取两个文件。 1234567891011121314151617const fs = require('fs');const readFile = function (fileName) &#123; return new Promise(function (resolve, reject) &#123; fs.readFile(fileName, function(error, data) &#123; if (error) return reject(error); resolve(data); &#125;); &#125;);&#125;;const gen = function* () &#123; const f1 = yield readFile('/etc/fstab'); const f2 = yield readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;; 写成async函数，就是下面这样。 123456const asyncReadFile = async function () &#123; const f1 = await readFile('/etc/fstab'); const f2 = await readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;; 一比较就会发现，async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。 async函数对 Generator 函数的改进，体现在以下四点。1. 内置执行器。Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。 asyncReadFile();上面的代码调用了asyncReadFile函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用next方法，或者用co模块，才能真正执行，得到最后结果。 2. 更好的语义。async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。 3. 更广的适用性。co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。 4. 返回值是 Promise。async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。 进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。基本用法async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。下面是一个例子。 123456789async function getStockPriceByName(name) &#123; const symbol = await getStockSymbol(name); const stockPrice = await getStockPrice(symbol); return stockPrice;&#125;getStockPriceByName('goog').then(function (result) &#123; console.log(result);&#125;); 上面代码是一个获取股票报价的函数，函数前面的async关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个Promise对象。 下面是另一个例子，指定多少毫秒后输出一个值。 123456789101112function timeout(ms) &#123; return new Promise((resolve) =&gt; &#123; setTimeout(resolve, ms); &#125;);&#125;async function asyncPrint(value, ms) &#123; await timeout(ms); console.log(value);&#125;asyncPrint('hello world', 50); 上面代码指定50毫秒以后，输出hello world。 由于async函数返回的是 Promise 对象，可以作为await命令的参数。所以，上面的例子也可以写成下面的形式。 123456789101112async function timeout(ms) &#123; await new Promise((resolve) =&gt; &#123; setTimeout(resolve, ms); &#125;);&#125;async function asyncPrint(value, ms) &#123; await timeout(ms); console.log(value);&#125;asyncPrint('hello world', 50); async 函数有多种使用形式。123456789101112131415161718192021222324252627// 函数声明async function foo() &#123;&#125;// 函数表达式const foo = async function () &#123;&#125;;// 对象的方法let obj = &#123; async foo() &#123;&#125; &#125;;obj.foo().then(...)// Class 的方法class Storage &#123; constructor() &#123; this.cachePromise = caches.open('avatars'); &#125; async getAvatar(name) &#123; const cache = await this.cachePromise; return cache.match(`/avatars/$&#123;name&#125;.jpg`); &#125;&#125;const storage = new Storage();storage.getAvatar('jake').then(…);// 箭头函数const foo = async () =&gt; &#123;&#125;; 语法async函数的语法规则总体上比较简单，难点是错误处理机制。 返回 Promise 对象async函数返回一个 Promise 对象。async函数内部return语句返回的值，会成为then方法回调函数的参数。123456async function f() &#123; return 'hello world';&#125;f().then(v =&gt; console.log(v))// "hello world" 上面代码中，函数f内部return命令返回的值，会被then方法回调函数接收到。 async函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。123456789async function f() &#123; throw new Error('出错了');&#125;f().then( v =&gt; console.log(v), e =&gt; console.log(e))// Error: 出错了 Promise 对象的状态变化async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。 下面是一个例子。 1234567async function getTitle(url) &#123; let response = await fetch(url); let html = await response.text(); return html.match(/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i)[1];&#125;getTitle('https://tc39.github.io/ecma262/').then(console.log)// "ECMAScript 2017 Language Specification" 上面代码中，函数getTitle内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行then方法里面的console.log。 await 命令正常情况下，await命令后面是一个 Promise 对象。如果不是，会被转成一个立即resolve的 Promise 对象。123456async function f() &#123; return await 123;&#125;f().then(v =&gt; console.log(v))// 123 上面代码中，await命令的参数是数值123，它被转成 Promise 对象，并立即resolve。 await命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。12345678async function f() &#123; await Promise.reject('出错了');&#125;f().then(v =&gt; console.log(v)).catch(e =&gt; console.log(e))// 出错了 注意，上面代码中，await语句前面没有return，但是reject方法的参数依然传入了catch方法的回调函数。这里如果在await前面加上return，效果是一样的。 只要一个await语句后面的 Promise 变为reject，那么整个async函数都会中断执行。1234async function f() &#123; await Promise.reject('出错了'); await Promise.resolve('hello world'); // 不会执行&#125; 上面代码中，第二个await语句是不会执行的，因为第一个await语句状态变成了reject。 有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个await放在try…catch结构里面，这样不管这个异步操作是否成功，第二个await都会执行。 1234567891011async function f() &#123; try &#123; await Promise.reject('出错了'); &#125; catch(e) &#123; &#125; return await Promise.resolve('hello world');&#125;f().then(v =&gt; console.log(v))// hello world 另一种方法是await后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误。12345678910async function f() &#123; await Promise.reject('出错了') .catch(e =&gt; console.log(e)); return await Promise.resolve('hello world');&#125;f().then(v =&gt; console.log(v))// 出错了// hello world 错误处理如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject。12345678910async function f() &#123; await new Promise(function (resolve, reject) &#123; throw new Error('出错了'); &#125;);&#125;f().then(v =&gt; console.log(v)).catch(e =&gt; console.log(e))// Error：出错了 上面代码中，async函数f执行后，await后面的 Promise 对象会抛出一个错误对象，导致catch方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制，可以参考后文的“async 函数的实现原理”。 防止出错的方法，也是将其放在try…catch代码块之中。123456789async function f() &#123; try &#123; await new Promise(function (resolve, reject) &#123; throw new Error('出错了'); &#125;); &#125; catch(e) &#123; &#125; return await('hello world');&#125; 如果有多个await命令，可以统一放在try…catch结构中。 123456789101112async function main() &#123; try &#123; const val1 = await firstStep(); const val2 = await secondStep(val1); const val3 = await thirdStep(val1, val2); console.log('Final: ', val3); &#125; catch (err) &#123; console.error(err); &#125;&#125; 下面的例子使用try…catch结构，实现多次重复尝试。 123456789101112131415const superagent = require('superagent');const NUM_RETRIES = 3;async function test() &#123; let i; for (i = 0; i &lt; NUM_RETRIES; ++i) &#123; try &#123; await superagent.get('http://google.com/this-throws-an-error'); break; &#125; catch(err) &#123;&#125; &#125; console.log(i); // 3&#125;test(); 上面代码中，如果await操作成功，就会使用break语句退出循环；如果失败，会被catch语句捕捉，然后进入下一轮循环。 使用注意点第一点，前面已经说过，await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try…catch代码块中。12345678910111213141516async function myFunction() &#123; try &#123; await somethingThatReturnsAPromise(); &#125; catch (err) &#123; console.log(err); &#125;&#125;// 另一种写法async function myFunction() &#123; await somethingThatReturnsAPromise() .catch(function (err) &#123; console.log(err); &#125;);&#125; 第二点，多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。12let foo = await getFoo();let bar = await getBar(); 上面代码中，getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发。 12345678// 写法一let [foo, bar] = await Promise.all([getFoo(), getBar()]);// 写法二let fooPromise = getFoo();let barPromise = getBar();let foo = await fooPromise;let bar = await barPromise; 上面两种写法，getFoo和getBar都是同时触发，这样就会缩短程序的执行时间。 第三点，await命令只能用在async函数之中，如果用在普通函数，就会报错。12345678async function dbFuc(db) &#123; let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; // 报错 docs.forEach(function (doc) &#123; await db.post(doc); &#125;);&#125; 上面代码会报错，因为await用在普通函数之中了。但是，如果将forEach方法的参数改成async函数，也有问题。 12345678function dbFuc(db) &#123; //这里不需要 async let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; // 可能得到错误结果 docs.forEach(async function (doc) &#123; await db.post(doc); &#125;);&#125; 上面代码可能不会正常工作，原因是这时三个db.post操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用for循环。 1234567async function dbFuc(db) &#123; let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; for (let doc of docs) &#123; await db.post(doc); &#125;&#125; 如果确实希望多个请求并发执行，可以使用Promise.all方法。当三个请求都会resolved时，下面两种写法效果相同。 1234567891011121314151617181920async function dbFuc(db) &#123; let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; let promises = docs.map((doc) =&gt; db.post(doc)); let results = await Promise.all(promises); console.log(results);&#125;// 或者使用下面的写法async function dbFuc(db) &#123; let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; let promises = docs.map((doc) =&gt; db.post(doc)); let results = []; for (let promise of promises) &#123; results.push(await promise); &#125; console.log(results);&#125; 目前，@std/esm模块加载器支持顶层await，即await命令可以不放在 async 函数里面，直接使用。 1234567891011// async 函数的写法const start = async () =&gt; &#123; const res = await fetch('google.com'); return res.text();&#125;;start().then(console.log);// 顶层 await 的写法const res = await fetch('google.com');console.log(await res.text()); 上面代码中，第二种写法的脚本必须使用@std/esm加载器，才会生效。 async 函数的实现原理async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。1234567891011async function fn(args) &#123; // ...&#125;// 等同于function fn(args) &#123; return spawn(function* () &#123; // ... &#125;);&#125; 所有的async函数都可以写成上面的第二种形式，其中的spawn函数就是自动执行器。 下面给出spawn函数的实现，基本就是前文自动执行器的翻版。 12345678910111213141516171819202122function spawn(genF) &#123; return new Promise(function(resolve, reject) &#123; const gen = genF(); function step(nextF) &#123; let next; try &#123; next = nextF(); &#125; catch(e) &#123; return reject(e); &#125; if(next.done) &#123; return resolve(next.value); &#125; Promise.resolve(next.value).then(function(v) &#123; step(function() &#123; return gen.next(v); &#125;); &#125;, function(e) &#123; step(function() &#123; return gen.throw(e); &#125;); &#125;); &#125; step(function() &#123; return gen.next(undefined); &#125;); &#125;);&#125; 与其他异步处理方法的比较我们通过一个例子，来看 async 函数与 Promise、Generator 函数的比较。 假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。 首先是 Promise 的写法。123456789101112131415161718192021222324function chainAnimationsPromise(elem, animations) &#123; // 变量ret用来保存上一个动画的返回值 let ret = null; // 新建一个空的Promise let p = Promise.resolve(); // 使用then方法，添加所有动画 for(let anim of animations) &#123; p = p.then(function(val) &#123; ret = val; return anim(elem); &#125;); &#125; // 返回一个部署了错误捕捉机制的Promise return p.catch(function(e) &#123; /* 忽略错误，继续执行 */ &#125;).then(function() &#123; return ret; &#125;);&#125; 虽然 Promise 的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是 Promise 的 API（then、catch等等），操作本身的语义反而不容易看出来。 接着是 Generator 函数的写法。123456789101112131415function chainAnimationsGenerator(elem, animations) &#123; return spawn(function*() &#123; let ret = null; try &#123; for(let anim of animations) &#123; ret = yield anim(elem); &#125; &#125; catch(e) &#123; /* 忽略错误，继续执行 */ &#125; return ret; &#125;);&#125; 上面代码使用 Generator 函数遍历了每个动画，语义比 Promise 写法更清晰，用户定义的操作全部都出现在spawn函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行 Generator 函数，上面代码的spawn函数就是自动执行器，它返回一个 Promise 对象，而且必须保证yield语句后面的表达式，必须返回一个 Promise。 最后是 async 函数的写法。1234567891011async function chainAnimationsAsync(elem, animations) &#123; let ret = null; try &#123; for(let anim of animations) &#123; ret = await anim(elem); &#125; &#125; catch(e) &#123; /* 忽略错误，继续执行 */ &#125; return ret;&#125; 可以看到Async函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将Generator写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用Generator写法，自动执行器需要用户自己提供。 实例：按顺序完成异步操作实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组 URL，然后按照读取的顺序输出结果。 Promise 的写法如下。 123456789101112function logInOrder(urls) &#123; // 远程读取所有URL const textPromises = urls.map(url =&gt; &#123; return fetch(url).then(response =&gt; response.text()); &#125;); // 按次序输出 textPromises.reduce((chain, textPromise) =&gt; &#123; return chain.then(() =&gt; textPromise) .then(text =&gt; console.log(text)); &#125;, Promise.resolve());&#125; 上面代码使用fetch方法，同时远程读取一组 URL。每个fetch操作都返回一个 Promise 对象，放入textPromises数组。然后，reduce方法依次处理每个 Promise 对象，然后使用then，将所有 Promise 对象连起来，因此就可以依次输出结果。 这种写法不太直观，可读性比较差。下面是 async 函数实现。 123456async function logInOrder(urls) &#123; for (const url of urls) &#123; const response = await fetch(url); console.log(await response.text()); &#125;&#125; 上面代码确实大大简化，问题是所有远程操作都是继发。只有前一个URL返回结果，才会去读取下一个URL，这样做效率很差，非常浪费时间。我们需要的是并发发出远程请求。 123456789101112async function logInOrder(urls) &#123; // 并发读取远程URL const textPromises = urls.map(async url =&gt; &#123; const response = await fetch(url); return response.text(); &#125;); // 按次序输出 for (const textPromise of textPromises) &#123; console.log(await textPromise); &#125;&#125; 上面代码中，虽然map方法的参数是async函数，但它是并发执行的，因为只有async函数内部是继发执行，外部不受影响。后面的for..of循环内部使用了await，因此实现了按顺序输出。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>async</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现一个回到顶部按钮]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F14%2F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%9B%9E%E5%88%B0%E9%A1%B6%E9%83%A8%E6%8C%89%E9%92%AE%2F</url>
    <content type="text"><![CDATA[前言在实际应用中，经常用到滚动到页面顶部或某个位置，一般简单用锚点处理或用js将document.body.scrollTop设置为0，结果是页面一闪而过滚到指定位置，不是特别友好。我们想要的效果是要有点缓冲效果。 现代浏览器陆续意识到了这种需求，scrollIntoView意思是滚动到可视，css中提供了scroll-behavior属性，js有Element.scrollIntoView()方法。 scroll-behavior1scroll-behavior`属性可取值`auto`|`smooth`|`inherit`|`unset scroll-behavior: smooth;是我们想要的缓冲效果。在PC浏览器中，页面默认滚动是在&lt;html&gt;标签上，移动端大多数在&lt;body&gt;标签上，在我们想要实现平滑“回到顶部”，只需在这两个标签上都加上： 123html, body &#123; scroll-behavior: smooth;&#125; 准确的说，写在容器元素上，可以让容器（非鼠标手势触发）的滚动变得平滑，而不局限于&lt;html&gt;，&lt;body&gt;标签。 利用这个css属性可以一步将原来纯css标签直接切换，变成平滑过渡切换效果。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859.tab label &#123; padding: 10px; border: 1px solid #ccc; margin-right: -1px; text-align: center; float: left; overflow: hidden;&#125;.tab::after &#123; content: ""; display: table; clear: both;&#125;.box &#123; height: 200px; border: 1px solid #ccc; scroll-behavior: smooth; overflow: hidden; margin-top: 10px;&#125;.item &#123; height: 100%; position: relative; overflow: hidden;&#125;.item input &#123; position: absolute; top: 0; height: 100%; width: 1px; border: 0; padding: 0; margin: 0; clip: rect(0 0 0 0);&#125;&lt;h1&gt;纯CSS选项卡&lt;/h1&gt;&lt;div class="tab"&gt; &lt;label for="tab1"&gt;选项卡1&lt;/label&gt; &lt;label for="tab2"&gt;选项卡2&lt;/label&gt; &lt;label for="tab3"&gt;选项卡3&lt;/label&gt;&lt;/div&gt;&lt;div class="box"&gt; &lt;div class="item"&gt; &lt;input type="text" id="tab1"&gt; &lt;p&gt;选项卡1内容&lt;/p&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;input type="text" id="tab2"&gt; &lt;p&gt;选项卡2内容&lt;/p&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;input type="text" id="tab3"&gt; &lt;p&gt;选项卡3内容&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 实现效果 也可以戳这里 再来看一下这个css属性scroll-behavior在各大浏览器中的支持情况 呃~支持度不是很好，这样一行css代码能应用上当然是最好的，不行就退化成一闪而过的效果咯。下面再看下js提供的api。 Element.scrollIntoView()Element.scrollIntoView() 方法让当前的元素滚动到浏览器窗口的可视区域内。 element.scrollIntoView(); // 等同于element.scrollIntoView(true)element.scrollIntoView(alignToTop); // Boolean型参数element.scrollIntoView(scrollIntoViewOptions); // Object型参数 参数alignToTop一个Boolean值： 如果为true，元素的顶端将和其所在滚动区的可视区域的顶端对齐。相应的scrollIntoViewOptions: {block: &quot;start&quot;, inline: &quot;nearest&quot;}。这是这个参数的默认值。 如果为false，元素的底端将和其所在滚动区的可视区域的底端对齐。相应的scrollIntoViewOptions: {block: &quot;end&quot;, inline: &quot;nearest&quot;}。 参数scrollIntoViewOptions一个带有选项的 object： 1234&#123; behavior: "auto" | "instant" | "smooth", block: "start" | "end",&#125; behavior 可选定义缓动动画， “auto”, “instant”, 或 “smooth” 之一。默认为 “auto”。 block 可选&quot;start&quot;, &quot;center&quot;, &quot;end&quot;, 或 &quot;nearest&quot;之一。默认为 &quot;center&quot;。 inline 可选&quot;start&quot;, &quot;center&quot;, &quot;end&quot;, 或 &quot;nearest&quot;之一。默认为 &quot;nearest&quot;。 浏览器支持 可以看到对于无参数的情况支持还是很好的，有参数的该API在浏览器中支持不是很好，我们可以同时结合CSS设置scroll-behavior: smooth;滚动效果，在执行滚动使用target.scrollIntoView()，即可达到“完美滚动”（不太完美）效果。 向下兼容要达到所有浏览器都有相同（类似）效果，那就要把剩余不支持scroll-behavior属性的浏览器揪出来，用js去完成使命了。 判断是否支持scroll-behavior属性很简单，用以下这一行代码 123456if(typeof window.getComputedStyle(document.body).scrollBehavior === 'undefined') &#123; // 兼容js代码&#125; else &#123; // 原生滚动api // Element.scrollIntoView()&#125; 判断是否支持scroll-behavior属性，直接利用原生Element.scrollIntoView()滚动，否则向下兼容处理。 缓冲算法缓冲的直观效果是越来越慢，直到停止，也就是在相同时间内运动的距离越来越短。这样可以设置一个定时器，移动到当前点到目标点距离的缓冲率（比如1/2，1/3，…）处，比如，缓冲率设为2，当前距离目标点64px，下一秒就是32px，然后16px，8px…，到达某个阈值结束，也就是： 1var position = position + (destination - position) / n; 下面来简单实现一个点击右下方的”回到顶部“按钮，页面缓动滚动到顶部的demo。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;div class="content"&gt; &lt;p&gt;很多内容。。。&lt;/p&gt; ... &lt;/div&gt; &lt;section class="back-to-top"&gt; 回到顶部 &lt;/section&gt;.content &#123; height: 3000px; border: 1px solid #ccc; box-shadow: 0 0 2px solid;&#125;.back-to-top &#123; width: 18px; padding: 10px; border: 1px solid #ccc; box-shadow: 0 0 2px #333; position: fixed; right: 20px; bottom: 40px;&#125;.back-to-top:hover &#123; cursor: pointer;&#125;var scrollTopSmooth = function (position) &#123; // 不存在原生`requestAnimationFrame`，用`setTimeout`模拟替代 if (!window.requestAnimationFrame) &#123; window.requestAnimationFrame = function (cb) &#123; return setTimeout(cb, 17); &#125;; &#125; // 当前滚动高度 var scrollTop = document.documentElement.scrollTop || document.body.scrollTop; // step var step = function () &#123; var distance = position - scrollTop; scrollTop = scrollTop + distance / 5; if (Math.abs(distance) &lt; 1) &#123; window.scrollTo(0, position); &#125; else &#123; window.scrollTo(0, scrollTop); requestAnimationFrame(step); &#125; &#125;; step();&#125;$backToTop = document.querySelector('.back-to-top')$backToTop.addEventListener('click', function () &#123; scrollTopSmooth(0);&#125;, false);&lt;/script&gt; 效果图 或者戳这里 简单封装上面的小demo中，缓冲算法和当前滚动业务代码耦合在一起了，下面单独拆解出单独一个函数。 1234567891011121314151617181920212223242526272829303132/*** 缓冲函数* @param &#123;Number&#125; position 当前滚动位置* @param &#123;Number&#125; destination 目标位置* @param &#123;Number&#125; rate 缓动率* @param &#123;Function&#125; callback 缓动结束回调函数 两个参数分别是当前位置和是否结束*/var easeout = function (position, destination, rate, callback) &#123; if (position === destination || typeof destination !== 'number') &#123; return false; &#125; destination = destination || 0; rate = rate || 2; // 不存在原生`requestAnimationFrame`，用`setTimeout`模拟替代 if (!window.requestAnimationFrame) &#123; window.requestAnimationFrame = function (fn) &#123; return setTimeout(fn, 17); &#125; &#125; var step = function () &#123; position = position + (destination - position) / rate; if (Math.abs(destination - position) &lt; 1) &#123; callback(destination, true); return; &#125; callback(position, false); requestAnimationFrame(step); &#125;; step();&#125; 拆分后，这个小缓冲算法就可以被重复调用啦，而且，适用于滚动到指定位置（不仅仅是到顶部）和缓冲率（控制滚动快慢），当前小demo调用： 123456789101112var scrollTopSmooth = function (position) &#123; // 当前滚动高度 var scrollTop = document.documentElement.scrollTop || document.body.scrollTop; easeout(scrollTop, position, 5, function (val) &#123; window.scrollTo(0, val); &#125;);&#125;$backToTop = document.querySelector('.back-to-top')$backToTop.addEventListener('click', function () &#123; scrollTopSmooth(200);&#125;, false); 总结综合来看，简单实现一个完美滚动注意以下即可 &lt;html&gt;，&lt;body&gt;标签加上scroll-behavior: smooth;属性； 判断当前浏览器是否支持scrollBehavior属性； 如果支持直接用原生滚动apiElement.scrollIntoView()； 如果不支持则用js小缓冲算法兼容处理。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>JavaScript</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现点击button滚动返回顶部动画]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2F%E5%AE%9E%E7%8E%B0%E7%82%B9%E5%87%BBbutton%E6%BB%9A%E5%8A%A8%E8%BF%94%E5%9B%9E%E9%A1%B6%E9%83%A8%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[实现点击button滚动返回顶部动画1234567891011121314//ES6写法 returnTop() &#123; let distance = document.documentElement.scrollTop || document.body.scrollTop; //获得当前高度 let step = distance / 20; //每步的距离 (function jump() &#123; console.log(1); if (distance &gt; 0) &#123; distance -= step; window.scrollTo(0, distance); setTimeout(jump, 10); &#125; &#125;)(); &#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[绘制虚线并且能够设置虚线宽度方法]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2F%E7%BB%98%E5%88%B6%E8%99%9A%E7%BA%BF%E5%B9%B6%E4%B8%94%E8%83%BD%E5%A4%9F%E8%AE%BE%E7%BD%AE%E8%99%9A%E7%BA%BF%E5%AE%BD%E5%BA%A6%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[绘制虚线并且能够设置虚线宽度方法:12345width: 100%;height: 2px;background-image: linear-gradient(to right, #ccc 0%, #ccc 50%, transparent 50%);background-size: 17px 2px;background-repeat: repeat-x;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5CSS3]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2FHTML5CSS3%2F</url>
    <content type="text"><![CDATA[CSS3CSS3是在CSS的接触上增加了很多新的特性，与低版本的CSS并不冲突介绍一些常用的特性 文本text-overflow clip剪切超出文本 ellipsis显示省略号 （需要与 overflow: hiddien ; white-space: nowrap 合用） 换行word-wrap允许长单词或 URL 地址换行到下一行 normal 只在允许的断字点换行 break-word 在长单词或 URL 地址内部进行换行 word-break自动换行的处理方法 normal 使用浏览器默认的换行规则 break-all 允许在单词内换行 keep-all 只能在半角空格或连字符处换行 white-space设置如何处理元素内的空白 normal 连续空白会被浏览器忽略 pre 空白会被浏览器保留 nowrap 文本不会换行，文本会在在同一行上继续，直到遇到标签为止 pre-wrap 保留空白符序列，但是正常地进行换行 pre-line 合并空白符序列，但是保留换行符 text-shadow文字阴影 ， 可以写多个，隔开(x, y, blur, color) 边框 borderborder-radius圆角半径 border-radius是缩写格式，可以把各个角单独拆分第一个值是圆角水平半径，第二个值是垂直半径,如果第二个值省略，那么其等于第一个值 border-image可以用图片作为边框的修饰 source 指定图片来源 width repeat stretch 压缩或伸展border-image的背景图片以其刚好适应border-width的宽度 repeat 简单的重复 round 压缩或伸展border-image的背景图片以图片最小单元刚好适应border-width的宽度，在此基础上重复 outset 边框图像区域超出边框的量 slice box-shadow盒子阴影效果: [inset] x-offset y-offset blur-radius spread-radius color阴影类型，X-offset，Y-offset，阴影模糊半径，阴影扩展半径，阴影颜色可以使用一个或多个投影，如果使用多个投影时必须需要用逗号,分开 box-sizing 框大小可以设置 width 和 height 属性中包含了 padding(内边距) 和 border(边框)。如果使用，推荐在所有元素使用 box-sizing background 背景background-size规定背景图片的尺寸 length: 设置背景图像的高度和宽度，第一个值设置宽度，第二个值设置高度，如果只设置一个值，则第二个值会被设置为auto percentage: 以父元素的百分比来设置背景图像的宽度和高度，第一个值设置宽度，第二个值设置高度，如果只设置一个值，则第二个值会被设置为auto cover: 把背景图像扩展至足够大，以使背景图像完全覆盖背景区域，背景图像的某些部分也许无法显示在背景定位区域中 contain: 把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域 background-origin相对于什么位置来定位 如果背景图像的 background-attachment 属性为fixed，则该属性没有效果 padding-box: 背景图像相对于内边距框来定位 border-box: 背景图像相对于边框盒来定位 content-box: 背景图像相对于内容框来定位 background-clip规定背景的绘制区域 padding-box: 背景被裁剪到边框盒 border-box: 背景被裁剪到内边距框 content-box: 背景被裁剪到内容框 多背景在之前的CSS中只能使用一张背景图片，CSS3可以使用多张背景图片 渐变 gradient（在background里设置） 线性渐变 linear-gradient在线性渐变过程中，颜色沿着一条直线过渡：从左侧到右侧、从右侧到左侧、从顶部到底部、从底部到顶部或着沿任何任意轴（[[&lt;angle&gt; | to &lt;side-or-corner&gt; ],]?&lt;color-stop&gt;[,&lt;color-stop&gt;]+） 径向渐变 radial-gradient径向渐变是圆形或椭圆形渐变。颜色不再沿着一条直线轴变化，而是从一个起点朝所有方向混合。但相对线性渐变要比径向渐变复杂的多。（[[&lt;shape&gt; || &lt;size&gt;] [at &lt;position&gt;]?,| at &lt;position&gt;,]?&lt;color-stop&gt;[,&lt;color-stop&gt;]+） 过渡 transition是元素从一种样式逐渐改变为另一种的效果: property, duration, timing-func, delay 这其实是一个简写形式，可以单独定义成各个属性 一般加在原始元素上 注意事项 目前，各大浏览器（包括IE 10）都已经支持无前缀的transition，所以transition已经可以很安全地不加浏览器前缀 transition需要明确知道，开始状态和结束状态的具体数值，才能计算出中间状态，什么none到block之类的是不行的 transition是一次性的，不能重复发生，除非一再触发 动画 animation先定义动画@keyframes ， 再绑定动画缩写: name, duration, timing-func, delay, fill-mode, direction, iteration-count animation-fill-mode动画结束以后，会立即从结束状态跳回到起始状态，此属性可以改变默认行为 none：默认值，回到动画没开始时的状态 forwards：让动画停留在结束状态 backwards：让动画回到第一帧的状态 both: 根据animation-direction（见后）轮流应用forwards和backwards规则 animation-direction动画循环播放时，每次都是从结束状态跳回到起始状态，再开始播放。animation-direction属性，可以改变这种行为 还可以取alternate、reverse、alternate-reverse等值 最常用的值是normal和reverse。浏览器对其他值的支持情况不佳，应该慎用 animation-play-state有时，动画播放过程中，会突然停止。这时，默认行为是跳回到动画的开始状态，如果想让动画保持突然终止时的状态，就要使用animation-play-state属性。 paused running 不可写进缩写 变形 transform修改元素的变形、旋转、缩放、倾斜特性，在CSS3中transform主要包括以下几种：旋转rotate、扭曲skew、缩放scale和移动translate以及矩阵变形matrix transform中使用多个属性时却需要有空格隔开，可用于内联(inline)元素和块级(block)元素 rotate 旋转可以通过rotate使元素旋转一定的度数 旋转是顺时针的 旋转之后元素仍占据原来位置，实际上所有的transform都是这样，缩放、位移等都不会改变元素占据的位置 元素旋转的的基点默认是中心，可以通过transform-origin属性改变 transform-origin的取值可以是 top, bottom, left, right, center 百分数 transform-origin属性对下面介绍的transform都有作用 translate 位移使元素平移 scale 缩放可以通过scale使元素缩放一定的比例，和translate类似，也有三个方法 scale(x,y)：使元素水平方向和垂直方向同时缩放 scaleX(x)：元素仅水平方向缩放 scaleY(y)：元素仅垂直方向缩放 对于scale只设置一个参数，一相同的比例缩放两个方向 skew 扭曲可以通过skew使元素扭曲一定的度数，和上面一样也有三中类似的用法 transform:skew(10deg, 20deg);transform:skewX(10deg);transform:skewY(10deg);transform:skew(10deg); matrix 矩阵matrix(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;) 以一个含六值的(a,b,c,d,e,f)变换矩阵的形式指定一个2D变换，相当于直接应用一个[a b c d e f]变换矩阵。 就是基于水平方向（X轴）和垂直方向（Y轴）重新定位元素,此属性值使用涉及到数学中的矩阵，感兴趣大家可以自己了解一下 3D效果CSS3带来了DOM的3D效果，元素需要设置需要设置perspective来激活3D效果，可以通过两种方式实现 在transform属性中使用perspective方法transform: perspective( 600px ); 直接使用perspective属性perspective: 600px; perspective属性的值决定了3D效果的强烈程度，可以认为是观察者到页面的距离。值越大距离越远，视觉上的3D效果就会相应的减弱。 这两种方式都会触发3D效果，但是有一点不同： 第一种方式直接在一个元素上触发3D变形，但是当多个元素的时候变形效果和预期会有所不同，如果使用同样的方法作用于不同位置的元素的时候，每个元素会有自己的轴心 为了解决这个问题，需要在父元素使用perspective属性，这样每个子元素都共享相同的3D空间 12345rotateX( angle )rotateY( angle )rotateZ( angle )translateZ( tz )scaleZ( sz ) 有几个变形方法的缩写，这些方法需要把三个参数写全 123translate3d( tx, ty, tz )scale3d( sx, sy, sz )rotate3d( rx, ry, rz, angle ) 任意3D操作会触发硬件加速，甚至可能变形只用到了2D的，或者没有做任何事情（比如translate3d(0,0,0)）。需要注意的是这只是当前的表现，未来可能变化（这也是为什么我们没有写文档或者鼓励这么做），但是这在很多场景下非常有用，可以显著的提高渲染性能 HTML5介绍，特性 见下题目一、二 Cookie, LocalStorage 与 SessionStorage 的异同基本概念CookieCookie 是小甜饼的意思。顾名思义，cookie 确实非常小，它的大小限制为4KB左右，是网景公司的前雇员 Lou Montulli 在1993年3月的发明。它的主要用途有保存登录信息，比如你登录某个网站市场可以看到“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。 localStoragelocalStorage 是 HTML5 标准中新加入的技术，它并不是什么划时代的新东西。早在 IE 6 时代，就有一个叫 userData 的东西用于本地存储，而当时考虑到浏览器兼容性，更通用的方案是使用 Flash。而如今，localStorage 被大多数浏览器所支持，如果你的网站需要支持 IE6+，那以 userData 作为你的 polyfill 的方案是种不错的选择。 sessionStoragesessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。做过后端开发的同学应该知道 Session 这个词的意思，直译过来是“会话”。而 sessionStorage 是一个前端的概念，它只是可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但当页面关闭后，sessionStorage 中的数据就会被清空。 特性 Cookie localStorage sessionStorage 数据的生命期 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效 除非被清除，否则永久保存 仅在当前会话下有效，关闭页面或浏览器后被清除 存放数据大小 4K左右 一般为5MB 与服务器端通信 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 仅在客户端（即浏览器）中保存，不参与和服务器的通信 易用性 需要程序员自己封装，源生的Cookie接口不友好 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 一般情况下浏览器端不会修改 cookie，但会频繁操作两个storage cookie有path概念，子路径可以访问父路径 cookie，父路径不能访问子路径 cookie 共享：sessionStorage不能共享，localStorage在同源文档之间共享， cookie在同源且符合path规则的文档之间共享 如果保存了 cookie的话，http请求中一定会带上；而两个storage可以由脚本选择性的提交 安全性方面， cookie中最好不要放置任何明文的东西。两个storage的数据提交后在服务端一定要校验 localStorage和sessionStorage的主要区别在于存储的有效期和作用域不同。localStorage存储的数据是永久性的，其作用域限定在文档源级别（只要URL的协议、端口、主机名三者中有一个不同，就属于不同的文档源）。除此之外，localStorage也受浏览器供应商限制，如果使用chrome访问一个网站，下次用firefox再次访问是获取不到上次存储的数据的。 而sessionStorage的有效期仅存在于浏览器的标签页。也就是说如果关闭标签页后，通过sessionStorage存储的数据就都被删除了。sessionStorage的作用域不仅被限制在文档源，还被限定在窗口中，也就是同一标签页中。注意，这里说的窗口是指顶级窗口，若果同一标签页中包含多个&lt;iframe&gt;元素，这两者之间也是可以共享sessionStorage的。 使用 local storage和session storage主要通过在js中操作这两个对象来实现，分别为window.localStorage和window.sessionStorage. 这两个对象均是Storage类的两个实例，自然也具有Storage类的属性和方法。 但是cookie需要前端开发者自己封装setCookie，getCookie。但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。 相同 三者都是键值对的集合 都会在浏览器端保存，有大小限制，同源限制 应用场景有了对上面这些差别的直观理解，我们就可以讨论三者的应用场景了。 因为考虑到每个 HTTP 请求都会带着 Cookie 的信息，所以 Cookie 要非常精简，比较常用的一个应用场景就是判断用户是否登录。针对登录过的用户，服务器端会在他登录时往 Cookie 中插入一段加密过的唯一辨识单一用户的辨识码，下次只要读取这个值就可以判断当前用户是否登录啦。曾经还使用 Cookie 来保存用户在电商网站的购物车信息，如今有了 localStorage，在这个方面就不需要cookie了。 而另一方面 localStorage 接替了 Cookie 管理购物车的工作，同时也能胜任其他一些工作。比如HTML5游戏通常会产生一些本地数据，localStorage 也是非常适用的。如果遇到一些内容特别多的表单，为了优化用户体验，我们可能要把表单页面拆分成多个子页面，然后按步骤引导用户填写。这时候 sessionStorage 的作用就发挥出来了。 cookie与session的区别于联系（1）cookie与session的区别：cookie数据保存在客户端，session数据保存在服务器端 如果web服务器端使用的是session，那么所有的数据都保存在服务器上，客户端每次请求服务器的时候会发送当前会话的sessionid，服务器根据当前sessionid判断相应的用户数据标志，以确定用户是否登录或具有某种权限。由于数据是存储在服务器上面，所以你不能伪造，但是如果你能够获取某个登录用户的 sessionid，用特殊的浏览器伪造该用户的请求也是能够成功的。sessionid是服务器和客户端链接时候随机分配的，一般来说是不会有重复，但如果有大量的并发请求，也不是没有重复的可能性。 如果浏览器使用的是cookie，那么所有的数据都保存在浏览器端，比如你登录以后，服务器设置了cookie用户名，那么当你再次请求服务器的时候，浏览器会将用户名一块发送给服务器，这些变量有一定的特殊标记。服务器会解释为cookie变量，所以只要不关闭浏览器，那么cookie变量一直是有效的，所以能够保证长时间不掉线。如果你能够截获某个用户的 cookie变量，然后伪造一个数据包发送过去，那么服务器还是认为你是合法的。所以，使用 cookie被攻击的可能性比较大。如果设置了的有效时间，那么它会将 cookie保存在客户端的硬盘上，下次再访问该网站的时候，浏览器先检查有没有 cookie，如果有的话，就读取该 cookie，然后发送给服务器。如果你在机器上面保存了某个论坛 cookie，有效期是一年，如果有人入侵你的机器，将你的 cookie拷走，然后放在他的浏览器的目录下面，那么他登录该网站的时候就是用你的的身份登录的。所以 cookie是可以伪造的。当然，伪造的时候需要主意，直接copy cookie文件到 cookie目录，浏览器是不认的，他有一个index.dat文件，存储了 cookie文件的建立时间，以及是否有修改，所以你必须先要有该网站的 cookie文件，并且要从保证时间上骗过浏览器。 （2）cookie和session的共同之处：cookie和session都是用来跟踪浏览器用户身份的会话方式。 题目1： HTML5是什么？有哪些新特性？有哪些新增标签？如何让低版本的 IE 支持 HTML5新标签HTML5是什么:HTML5是超文本标记语言的第五次重大修改，2014年10月29日标准规范制定完成。 新特性： 语义特性HTML5赋予网页更好的意义和结构。更加丰富的标签将随着对RDFa的，微数据与微格式等方面的支持，构建对程序、对用户都更有价值的数据驱动的Web。 本地存储特性基于HTML5开发的网页APP拥有更短的启动时间，更快的联网速度，这些全得益于HTML5 APP Cache，以及本地存储功能。Indexed DB（html5本地存储最重要的技术之一）和API说明文档。 设备兼容特性从Geolocation功能的API文档公开以来，HTML5为网页应用开发者们提供了更多功能上的优化选择，带来了更多体验功能的优势。HTML5提供了前所未有的数据与应用接入开放接口。使外部应用可以直接与浏览器内部的数据直接相连，例如视频影音可直接与microphones及摄像头相联。 连接特性更有效的连接工作效率，使得基于页面的实时聊天，更快速的网页游戏体验，更优化的在线交流得到了实现。HTML5拥有更有效的服务器推送技术，Server-Sent Event和WebSockets就是其中的两个特性，这两个特性能够帮助我们实现服务器将数据“推送”到客户端的功能。 网页多媒体特性支持网页端的Audio、Video等多媒体功能， 与网站自带的APPS，摄像头，影音功能相得益彰。三维、图形及特效特性（Class: 3D, Graphics &amp; Effects）基于SVG、Canvas、WebGL及CSS3的3D功能，用户会惊叹于在浏览器中，所呈现的惊人视觉效果。 性能与集成特性没有用户会永远等待你的Loading——HTML5会通过XMLHttpRequest2等技术，解决以前的跨域等问题，帮助您的Web应用和网站在多样化的环境中更快速的工作。 CSS3特性在不牺牲性能和语义结构的前提下，CSS3中提供了更多的风格和更强的效果。此外，较之以前的Web排版，Web的开放字体格式（WOFF）也提供了更高的灵活性和控制性 新增标签 元素 描述 canvas 标签定义图形，比如图表和其他图像。该标签基于 JavaScript 的绘图 API audio 定义音频内容 video 定义视频（video 或者 movie） source 定义多媒体资源 &lt;video&gt; 和&lt;audio&gt; embed 定义嵌入的内容，比如插件 track 为诸如 &lt;video&gt; 和 &lt;audio&gt; 元素之类的媒介规定外部文本轨道 datalist 定义选项列表。与 input 元素配合使用该元素，来定义 input 可能的值 keygen 规定用于表单的密钥对生成器字段 output 定义不同类型的输出，比如脚本的输出 article 定义页面正文内容 aside 定义页面内容之外的内容 bdi 设置一段文本，使其脱离其父元素的文本方向设置 command 定义命令按钮，比如单选按钮、复选框或按钮 details 用于描述文档或文档某个部分的细节 dialog 定义对话框，比如提示框 summary 标签包含 details 元素的标题 figure 规定独立的流内容（图像、图表、照片、代码等等） figcaption 定义 &lt;figure&gt; 元素的标题 footer 定义 section 或 document 的页脚 header 定义了文档的头部区域 mark 定义带有记号的文本 meter 定义度量衡。仅用于已知最大和最小值的度量 nav 导航 progress 定义任何类型的任务的进度 ruby 定义 ruby 注释（中文注音或字符） rt 定义字符（中文注音或字符）的解释或发音 rp 在 ruby 注释中使用，定义不支持 ruby 元素的浏览器所显示的内容 section 定义文档中的节（section、区段） time 定义日期或时间 wbr 规定在文本中的何处适合添加换行符 让低版本的 IE 支持 HTML5新标签使用html5shiv.js 123&lt;!--[if lt IE 9]&gt; &lt;script type="text/javascript" src="scripts/html5shiv.js"&gt;&lt;/script&gt;&lt;![endif]--&gt; 注意 如果版本小于IE9就引入html5shiv.js，IE9以前的浏览器就能使用h5标签，并使用定义好的样式了。这个标签必须放在head标签内，因为浏览器要在解析之前知道这个元素。 也可以直接声明 123&lt;!--[if lt IE 9]&gt; (function()&#123;if(!/*@cc_on!@*/0)return;var e = "abbr,article,aside,audio,canvas,datalist,details,dialog,eventsource,figure,footer,header,hgroup,mark,menu,meter,nav,output,progress,section,time,video".split(','),i=e.length;while(i--)&#123;document.createElement(e[i])&#125;&#125;)()&lt;![endif]--&gt; 题目2： input 有哪些新增类型？ color date datetime-local email 个月 number range search tel time url week 题目3： 浏览器本地存储中 cookie 和 localStorage 有什么区别？ localStorage 如何存储删除数据。 特性 Cookie localStorage 数据的生命期 默认情况下，cookie开始于浏览器启动，结束于浏览器关闭，但是可以手动设置cookie的过期时间，同时，到期后被删除 除非被清除，否则永久保存 存放数据大小 4K左右 一般为5MB 与服务器端通信 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 仅在客户端（即浏览器）中保存，不参与和服务器的通信 易用性 需要程序员自己封装，源生的Cookie接口不友好 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 localStorage存储数据：12localStorage.setItem(key,value);localStorage.key = value; localStorage删除数据：12localStorage.removeItem(key) //删除指定数据localStorage.clear() //删除所有数据 localStorage读取数据：12localStorage.getItem(key,value);localStorage.key = value;]]></content>
      <categories>
        <category>CSS</category>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[media用法总结]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2Fmedia%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[CSS3 @media 用法总结1234//语法：@media mediatype and | not | only (media feature) &#123; css-code; &#125;//也可以针对不同的媒体使用不同的stylesheets: &lt;link rel="stylesheet" media="mediatype and|not|only (media feature)" href="mystylesheet.css"&gt; 一、首先是&lt;meta&gt;标签1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"&gt; 这段代码的几个参数解释： width = device-width：宽度等于当前设备的宽度 initial-scale：初始的缩放比例（默认设置为1.0） minimum-scale：允许用户缩放到的最小比例（默认设置为1.0） maximum-scale：允许用户缩放到的最大比例（默认设置为1.0） user-scalable：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面） 二、&lt;head&gt;标签中引入（CSS2 media）其实并不是只有CSS3才支持Media的用法，早在CSS2开始就已经支持Media，具体用法，就是在HTML页面的head标签中插入如下代码： 例如我们想知道现在的移动设备是不是纵向放置的显示屏，可以这样写： 1&lt;link rel="stylesheet" type="text/css" media="screen and (orientation:portrait)" ;href="style.css"&gt; 页面宽度小于960的执行指定的样式文件： 1&lt;link rel="stylesheet" type="text/css" media="screen and (max-width:960px)" href="style.css"&gt; 既然CSS2可以实现CSS的这个效果为什么不用这个方法呢，很多人应该会问，但是上面这个方法，最大的弊端是他会增加页面http的请求次数，增加了页面负担，我们用CSS3把样式都写在一个文件里面才是最佳的方法。 下面来解释一下遇到冲突时的机制： 123&lt;link rel="stylesheet" href="styleA.css" media="screen and (min-width: 800px)"&gt; &lt;link rel="stylesheet" href="styleB.css" media="screen and (min-width: 600px) and (max-width: 800px)"&gt; &lt;link rel="stylesheet" href="styleC.css" media="screen and (max-width: 600px)"&gt; 上面将设备分成3种，分别是宽度大于800px时，应用 styleA ，宽度在600px到800px之间时应用 styleB ，以及宽度小于600px时应用 styleC 。那假如宽度正好等于800px时该应用那个样式？是 styleB，因为前两条表达式都成立，按CSS默认优先级规则后者覆盖了前者。 因此，为了避免冲突，这个例子正常情况应该这样写： 123&lt;link rel="stylesheet" href="styleA.css" media="screen"&gt; &lt;link rel="stylesheet" href="styleB.css" media="screen and (max-width: 800px)"&gt; &lt;link rel="stylesheet" href="styleC.css" media="screen and (max-width: 600px)"&gt; 三、回归CSS3 @media上面我们大概讲了下CSS2的媒体查询用法，现在我们重新回到CSS3的媒体查询，在第一段代码上面我用的是小于960px的尺寸的写法，那现在我们来实现等于960px尺寸的代码，以下代码需要写在style标签或者css文件中： 123@media screen and (max-device-width:960px)&#123; body&#123;background:red;&#125;&#125; 然后就是当浏览器尺寸大于960px时候的代码了： 123@media screen and (min-width:960px)&#123; body&#123;background:orange;&#125;&#125; 我们还可以混合使用上面的用法： 123@media screen and (min-width:960px) and (max-width:1200px)&#123; body&#123;background:yellow;&#125;&#125; 上面的这段代码的意思是当页面宽度大于960px小于1200px的时候执行下面的CSS。 四、Media所有参数汇总以上就是我们最常需要用到的媒体查询器的三个特性，大于，等于，小于的写法。媒体查询器的全部功能肯定不止这三个功能，下面是我总结的它的一些参数用法解释： width:浏览器可视宽度。 height:浏览器可视高度。 device-width:设备屏幕的宽度。 device-height:设备屏幕的高度。 orientation:检测设备目前处于横向还是纵向状态。 aspect-ratio:检测浏览器可视宽度和高度的比例。(例如：aspect-ratio:16/9) device-aspect-ratio:检测设备的宽度和高度的比例。 color:检测颜色的位数。（例如：min-color:32就会检测设备是否拥有32位颜色） color-index:检查设备颜色索引表中的颜色，他的值不能是负数。 monochrome:检测单色楨缓冲区域中的每个像素的位数。（这个太高级，估计咱很少会用的到） resolution:检测屏幕或打印机的分辨率。(例如：min-resolution:300dpi或min-resolution:118dpcm)。 grid:检测输出的设备是网格的还是位图设备。 12345(max-width:599px) (min-width:600px) (orientation:portrait) 竖屏(orientation:landscape) 横屏(-webkit-min-device-pixel-ratio: 2) 像素比 五、媒体类型1.all 所有媒体 2.braille 盲文触觉设备 3.embossed 盲文打印机 4.print 手持设备 5.projection 打印预览 6.screen 彩屏设备 7.speech ‘听觉’类似的媒体类型 8.tty 不适用像素的设备 9.tv 电视 六、关键字1.and 2.not not关键字是用来排除某种制定的媒体类型 3.only only用来定某种特定的媒体类型 -很多时候是用来对那些不支持媒体特性但却支持媒体类型的设备 七、浏览器支持情况IE8- IE9+ Chrome 5+ Opera 10+ Firefox 3.6+&lt; Safari 4+ 八、常用的几种屏幕宽度设定：123456789101112131415@media screen and (min-width: 1200px) &#123; css-code;&#125;@media screen and(min-width: 960px) and (max-width: 1199px) &#123; css-code;&#125;@media screen and(min-width: 768px) and (max-width: 959px) &#123; css-code;&#125;@media screen and(min-width: 480px) and (max-width: 767px) &#123; css-code;&#125;@media screen and (max-width: 479px) &#123; css-code;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS基础知识]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2FCSS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[CSS的全称是什么? Cascading Style Sheets 叠层样式表一种用来表现HTML或XML等文件样式的计算机语言。 CSS有几种引入方式? link 和@import 有什么区别? 内联样式内联方式指的是直接在HTML标签中的style属性中添加CSS。&lt;h1 style=&quot;color:red&quot;&gt; &lt;/h1&gt; 内部样式内部样式指的是在HTML头部中的标签中写CSS代码。 12345&lt;style type="text/css"&gt; h1&#123; color:red;&#125;&lt;/style&gt; 外部样式。分为链接和导入 链接方式链接方式指的是使用HTML头部的标签引入外部的CSS文件。 123&lt;head&gt;&lt;link rel="stylesheet" type="text/css" href="style.css"&gt;&lt;/head&gt; 导入方式导入方式指的是使用CSS规则引入外部CSS文件。 123&lt;style&gt; @import url(style.css);&lt;/style&gt; 比较link和@import区别link 属于 HTML，通过 标签中的 href 属性来引入外部文件，而 @import 属于 CSS，所以导入语句应写在 CSS 中，要注意的是导入语句应写在样式表的开头，否则无法正确导入外部文件；使用链接方式时，会在装置页面主体部分之前装载CSS文件，这样显示出来的网页从一开始就是带有样式的效果，而使用导入式时，会在整个页面装载完成后再装载CSS文件，对于有的浏览器来说，在一些情况下，如果网页文件的体积比较大，则会出现先显示无样式的页面，闪烁一下之后再出现样式设置后的效果。从浏览者的感受来说，这是使用导入式的一个缺陷。兼容性的差别。@import是CSS2.1提出，在IE5上才能识别。link无此问题。link支持使用Javascript控制DOM去改变样式；而@import不支持 以下这几种文件路径分别用在什么地方，代表什么意思? css/a.css：相对路径：代表当前目录下css文件夹中的a.css文件 ./css/a.css相对路径：代表当前目录下css文件夹中的a.css文件（加单个点与不加相同） b.css相对路径：代表当前目录下b.css文件 ../imgs/a.png相对路径：代表上级目录下imgs文件夹中的a.png文件 /Users/hunger/project/css/a.css/static/css/a.css绝对路径：代表本地绝对路径a.css文件 http://cdn.xxxx.com/kejian1/8-1.png网络路径：代表网站的图片路径 /static/css/a.css网站相对路径：代表网站服务器根目录static文件夹中的css文件夹中的a.css文件 如果我想在网页上展示一个图片，需要怎么操作? 将本地图片发到服务器上，或者直接从别的网站复制图片地址。使用&lt;img src=&quot;地址&quot;&gt; 列出5条以上html和 css 的书写规范 在每个 HTML 页面的第一行添加声明 添加标签 属性名 与之后的 :之间不允许包含空格，:与属性值之间必须包含空格。 使用英文小写 +、&gt;、~ 选择器的两边各保留一个空格。 RGB颜色值必须使用十六进制记号形式 #rrggbb。不允许使用 rgb()。 需要在 Windows 平台显示的中文内容，其字号应不小于 12px。 使用 4 个空格做为一个缩进层级，不允许使用 2 个空格 或 tab 字符别忘记结束符 使用外联式css样式 选择器 与 { 之间必须包含空格。 使用注释，方便以后或其他人理解]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS常见样式2]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2FCSS%E5%B8%B8%E8%A7%81%E6%A0%B7%E5%BC%8F2%2F</url>
    <content type="text"><![CDATA[CSS常见样式背景样式 属性 描述 background 简写属性，作用是将背景属性设置在一个声明中 background-attachment 背景图像是否固定或者随着页面的其余部分滚动 background-color 设置元素的背景颜色 background-image 把图像设置为背景 background-position 设置背景图像的起始位置 background-repeat 设置背景图像是否及如何重复 background-size 设置背景的大小(兼容性) background-position：默认左上角x yx% y%[top | center | bottom] [left | center | right] background-repeatno-repeat：背景图片在规定位置repeat-x：图片横向重复repeat-y：图片纵向重复repeat：全部重复 background-size100px 100pxcontaincover 12345background-color: #F00;background-image: url(background.gif);background-repeat: no-repeat;background-attachment: fixed;background-position: 0 0; 可以缩写为一句： background: #f00 url(background.gif) no-repeat fixed 0 0; 提醒： 要显示出background-img:容器需有 窗口，要被撑开。 text-align: center的作用是什么，作用在什么元素上？能让什么元素水平居中作用是让行内元素（包括inline-block）水平居中作用在要水平居中的行内元素的父元素上 IE 盒模型和W3C盒模型有什么区别?区别W3C标准盒模型中padding、border所占的空间不在width、height范围内，大家俗称的IE的盒模型width包括content尺寸＋padding＋border。 ie678怪异模式（不添加 doctype）使用 ie 盒模型，宽度=边框+padding+内容宽度。chrome， ie9+, ie678(添加 doctype) 使用标准盒模型， 宽度= 内容宽度。 { box-sizing: border-box;}的作用是什么？css3新样式box-sizing：允许以特定的方式定义匹配某个区域的特定元素值：box-sizing: content-box：w3c标准盒模型box-sizing: border-box：“IE盒模型” line-height: 2和line-height: 200%有什么区别?计算方法的区别。 数值：继承的时候，浏览器会先将line-height这个属性继承给子元素，再由子元素计算。根据自身元素font-size的2倍计算。 百分数：继承的时候，浏览器会先将行高对应的具体的数值计算出来以后再继承。根据父元素的font-size的200%计算。 另外 height = line-heihgt 可以用来 垂直居中单行文本 inline-block有什么特性？如何去除缝隙？高度不一样的inline-block元素如何顶端对齐? inline-block 内联块级元素，既能放在一行（内联元素特性），又能设置宽高及padding margin（块级元素特性）。 inline-block 元素间的空白/回车换行会产生缝隙，去除缝隙可以使html标签连续（无空白/折行），还可以设置其父元素font-size:0; 然后在inline-block元素内恢复font-size。 在父元素中使用vertical-align:top; 可以让高度不一样的inline-block 元素顶端对齐。（值还有更多） 行内元素和inline-block元素水平方向上默认情况下是按基线对齐 CSS sprite 是什么?CSS精灵图（雪碧图）CSS Sprites在国内很多人叫css精灵是一种网页图片应用处理方式。它允许你将一个页面涉及到的所有零星图片都包含到一张大图中去，这样一来，当访问该页面时，载入的图片就不会像以前那样一幅一幅地慢慢显示出来了。对于当前网络流行的速度而言，不高于200KB的单张图片的所需载入时间基本是差不多的，所以无需顾忌这个问题。加速的关键，不是降低重量，而是减少个数。传统切图讲究精细，图片规格越小越好，重量越小越好，其实规格大小无所谓，计算机统一都按byte计算。客户端每显示一张图片都会向服务器发送请求。所以，图片越多请求次数越多，造成延迟的可能性也就越大。 简单来说：指将不同的图片/图标合并在一张图上。使用CSS Sprite 可以减少网络请求，提高网页加载性能。 让一个元素”看不见”有几种方式？有什么区别?隐藏or透明 opacity: 0 ; 透明度为0，占据文档空间，元素绑定的事件还是会触发事件。 visibility: hidden ; 类似于 opacity:0，但绑定的事件不会触发。 background-color: rgba(0，0，0，0); 只是背景色透明 display:none; 消失，不占用位置，浏览器不会去绘制它，但存在于DOM树，绑定的事件不会触发。 前三种方法仅仅是改变其透明度，让其”假消失”，看不见，但存在。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS常见样式1]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2FCSS%E5%B8%B8%E8%A7%81%E6%A0%B7%E5%BC%8F1%2F</url>
    <content type="text"><![CDATA[CSS常见样式块级元素和行内元素分别有哪些？动手测试并列出4条以上的特性区别块级元素行内元素块级(block-level); 行内(内联、inline-level) 块级元素 VS 行内元素区别1：块级元素宽度占据整行，行内元素占据自身宽度的空间，能多个并列排序，直到一行排列不下，换下一行。区别2：块级元素可以包含块级元素和行内元素；行内元素内只能包含行内元素和文本区别3：块级元素可以设置宽高；行内元素则不能设置宽高（行内元素的高度是由line-height来决定，宽度由具体的内容来决定）区别4：块级元素可以设置上下左右的margin、padding 边距；行内元素只对左右方向的margin、padding生效，上下无效（行内元素对于上下padding，可以看到背景色和边框的影响，但高度还是无法撑开）区别5：块级元素，默认为display: block；行内元素表示为display:inline.区别6：行内元素可以”感受”到浮动元素的存在。 block-leveldiv h1 h2 h3 h4 h5 h6 p hrform ul dl ol pre tableli dd dt tr td th inline-levelem strong span a br imgbutton input label select textareacode script 什么是 CSS 继承? 哪些属性能继承，哪些不能？ css继承：继承就是子标签继承了上级标签的CSS样式的属性。 不可继承的：display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-bread-before和unicode-bidi。 所有元素可继承：visibility和cursor。 内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction。 终端块状元素可继承：text-indent和text-align。 列表元素可继承：list-style、list-style-type、list-style-position、list-style-image。 表格元素可继承：border-collapse。 如何让块级元素水平居中？如何让行内元素水平居中?水平居中 内联元素：在其父元素身上加 text-align:center； 块级元素： 固定宽度的div margin-left: auto margin-right: auto 不固定宽度的 div（有这种无脑需求？） margin: 0 100px; 用 CSS 实现一个三角形1234567 &lt;div class="box"&gt;&lt;/div&gt;.box &#123; width: 0; height: 0; border: 50px solid transparent; border-bottom: 50px solid #ccc;&#125; 设置块级元素的宽高都为0px，上下左右border设置实线solid，留一个设置为有颜色，其他三个为transparent透明，调整4个border的px可实现不同形状三角形(见最后任务4) 单行文本溢出加 …如何实现?首先设置不换行：white-space:nowrap;其次设置超出隐藏：overflow:hidden;再设置文本溢出显示为省略号：text-overflow:ellipsis; px, em, rem vw有什么区别 px 是绝对长度单位。em、rem 是相对长度单位 em如果用于font-size属性本身，则相对于父元素的font-size。若用于其它属性，则相对于元素本身的font-size当没有设置font-size时，chrome浏览器会有一个默认的 em 设置：1em = 16px缺点：容易混乱 remrem 是相对于根元素html的font-size属性的计算值，比较好计算当没有设置 font-size 时，浏览器会有一个默认的 rem 设置：1rem = 16px，这点与 em 是一致的兼容性：IE8-不支持 vw vh: 相对单位，1vw 为屏幕宽度的1% 兼容性 解释下面代码的作用?为什么要加引号? 字体里\5b8b\4f53代表什么?123body&#123; font: 12px/1.5 tahoma,arial,'Hiragino Sans GB','\5b8b\4f53',sans-serif;&#125; 设置body的字样为大小12px，1.5倍行高，字体选择依次为 tahoma,arial,’Hiragino Sans GB’,’\5b8b\4f53’,sans-serif有空格的内容要加引号，才会被认为是一个整体。不然会被认为是两个字体里\5b8b\4f53代表的是黑体的unicode码。文字先转化为相应的unicode码，再通过不同的字体库依据这个编码来转化为相应的字体(直接写成中文，浏览器有可能不能识别，所以要写成Unicode编码。) 去除元素默认 margin padding ：*{margin:0;padding:0} 颜色单词: red, blue, pink, yellow, white, black十六进制: #000000, #fff, #eee, #ccc, #666, #333, #f00, #0f0, #00frgb: rgb(255, 255, 255), rgb(0, 255, 0)rgba: rgba(0,0,0,0.5)更多 隐藏or透明opacity: 0 ; 透明度为0，整体visibility: hidden ; 和opacity:0 类似display:none; 消失，不占用位置background-color: rgba(0，0，0，0.2) 只是背景色透明 inline-block既呈现 inline 特性(不占据一整行，宽度由内容宽度决定)又呈现 block 特性 (可设置宽高，内外边距)缝隙问题 line-heightline-height: 2line-height: 100%height = line-heihgt 来垂直居中单行文本]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS选择器]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2FCSS%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[CSS选择器选择器类型 基础选择器 组合选择器 属性选择器 伪类选择器 伪元素选择器 基础选择器 选择器 含义 * 通用元素选择器，匹配页面任何元素（这也就决定了我们很少使用） #id id选择器，匹配特定id的元素 .class 类选择器，匹配class包含(不是等于)特定类的元素 element 标签选择器 组合选择器 选择器 含义 E,F 多元素选择器，用,分隔，同时匹配元素E或元素F E F 后代选择器，用空格分隔，匹配E元素所有的后代（不只是子元素、子元素向下递归）元素F E&gt;F 子元素选择器，用&gt;分隔，匹配E元素的所有直接子元素 E+F 直接相邻选择器，匹配E元素之后的相邻的同级元素F E~F 普通相邻选择器（弟弟选择器），匹配E元素之后的同级元素F（无论直接相邻与否） .class1.class2 id和class选择器和选择器连写的时候中间没有分隔符，. 和 # 本身充当分隔符的元素 element#id id和class选择器和选择器连写的时候中间没有分隔符，. 和 # 本身充当分隔符的元素 属性选择器 选择器 含义 E[attr] 匹配所有具有属性attr的元素，div[id]就能取到所有有id属性的div E[attr = value] 匹配属性attr值为value的元素，div[id=test],匹配id=test的div E[attr ~= value] 匹配所有属性attr具有多个空格分隔、其中一个值等于value的元素 E[attr ^= value] 匹配属性attr的值以value开头的元素 E[attr $= value] 匹配属性attr的值以value结尾的元素 E[attr *= value] 匹配属性attr的值包含value的元素 伪类选择器 选择器 含义 E:first-child 匹配作为长子（第一个子女）的元素E E:link 匹配所有未被点击的链接 E:visited 匹配所有已被点击的链接 E:active 匹配鼠标已经其上按下、还没有释放的E元素 E:hover 匹配鼠标悬停其上的E元素 E:focus 匹配获得当前焦点的E元素 E:lang(c) 匹配lang属性等于c的E元素 E:enabled 匹配表单中可用的元素 E:disabled 匹配表单中禁用的元素 E:checked 匹配表单中被选中的radio或checkbox元素 E::selection 匹配用户当前选中的元素 所有选择器列表在 MDN 伪类选择器 选择器 含义 E:root 匹配文档的根元素，对于HTML文档，就是HTML元素 E:nth-child(n) 匹配其父元素的第n个子元素，第一个编号为1 E:nth-last-child(n) 匹配其父元素的倒数第n个子元素，第一个编号为1 E:nth-of-type(n) 与:nth-child()作用类似，但是仅匹配使用同种标签的元素 E:nth-last-of-type(n) 与:nth-last-child() 作用类似，但是仅匹配使用同种标签的元素 E:last-child 匹配父元素的最后一个子元素，等同于:nth-last-child(1) E:first-of-type 匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1) E:last-of-type 匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(1) E:only-child 匹配父元素下仅有的一个子元素，等同于:first-child:last-child或 :nth-child(1):nth-last-child(1) E:only-of-type 匹配父元素下使用同种标签的唯一一个子元素，等同于:first-of-type:last-of-type或 :nth-of-type(1):nth-last-of-type(1) E:empty 匹配一个不包含任何子元素的元素，文本节点也被看作子元素 E:not(selector) 匹配不符合当前选择器的任何元素 n的取值1，2，3，4，52n+1, 2n, 4n-1odd, even 伪元素选择器 选择器 含义 E::first-line 匹配E元素内容的第一行 E::first-letter 匹配E元素内容的第一个字母 E::before 在E元素之前插入生成的内容 E::after 在E元素之后插入生成的内容 CSS优先级从高到低分别是 在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式 作为style属性写在元素标签上的内联样式 id选择器 类选择器 伪类选择器 属性选择器 标签选择器 通配符选择器 浏览器自定义 复杂场景12#test p.class1 &#123;...&#125;#test .class1.class2 &#123;...&#125; 行内样式 &lt;div style=&quot;xxx&quot;&gt;&lt;/div&gt;==&gt; a ID 选择器 ==&gt; b 类，属性选择器和伪类选择器 ==&gt; c 标签选择器、伪元素 ==&gt; d示例： 12345678910* &#123;&#125; /* a=0 b=0 c=0 d=0 -&gt; 0,0,0,0 */p &#123;&#125; /* a=0 b=0 c=0 d=1 -&gt; 0,0,0,1 */a:hover &#123;&#125; /* a=0 b=0 c=0 d=2 -&gt; 0,0,0,2 */ul li &#123;&#125; /* a=0 b=0 c=0 d=2 -&gt; 0,0,0,2 */ul ol+li &#123;&#125; /* a=0 b=0 c=0 d=3 -&gt; 0,0,0,3 */h1+input[type=hidden]&#123;&#125; /* a=0 b=0 c=1 d=2 -&gt; 0,0,1,1 */ul ol li.active &#123;&#125; /* a=0 b=0 c=1 d=3 -&gt; 0,0,1,3 */#ct .box p &#123;&#125; /* a=0 b=1 c=1 d=1 -&gt; 0,1,1,1 */div#header:after &#123;&#125; /* a=0 b=1 c=0 d=2 -&gt; 0,1,0,2 */style="" /* a=1 b=0 c=0 d=0 -&gt; 1,0,0,0 */ 样式覆盖123div &#123;color: #333;&#125;....div &#123;color: #666;&#125; 这样div文案的颜色明显会是#666 class 和 id 的使用场景?id是制定标签的唯一标识，格式为：&lt;input type=password id=&quot;userpwd&quot;&gt; ,id属性的值在当前的page页面要是唯一的。应用场景： 根据提供的唯一id号，快速获取标签对象。如：document.getElementById(id) 用于充当label标签for属性的值：示例：&lt;label for=&#39;userid&#39;&gt;用户名：&lt;/label&gt;，表示单击此label标签时，id为userid的标签获得焦点。 Class用来指定标签的类名，格式为&lt;input type=button class=&quot;btnsubmit&quot; /&gt;，可以把多个类，放在一个class属性里，但必须用空格隔开；如：class=&#39;btnsubmit btnopen&#39;应用场景：CSS操作，把一些特定样式放到一个class类中，需要此样式的标签，可以在添加此类。 a:link, a:hover, a:active, a:visited 的顺序是怎样的？ 为什么？正确顺序为：a:link、a:visited、a:hover、a:active原因： 鼠标经过的“未访问链接”同时拥有a:link、a:hover、a:active三种属性，后面的属性会覆盖前面的属性定义，所以a:link必须放在a:hover的前面，a:hover必须放在a:active的前 鼠标经过的“已访问链接”同时拥有a:visited、a:hover、a:link三种属性，后面的属性会覆盖前面的属性定义，此时a:visted和a:link必须放在a:hover的前面 以下选择器分别是什么意思? 选择器 意义 #header{} 选择id为header的元素 .header{} 选择class为header的元素 .header .logo{} 选择class为header元素下的子元素及所有后代元素class名为logo的元素 .header.mobile{} 选择同时有class名header和mobile的元素 .header p, .header h3{} 选择class为header下的所有p标签以及class为header所有h3标签 #header .nav&gt;li{} 选择id为header下的class为nav的直接子元素li #header a:hover{} 选择id为header下的所以a:hover的伪类选择器元素 #header .logo~p{} 选择id为header下的class为logo的元素之后的所有同级p标签 #header input[type=”text”]{} 选择id为header下的所有input标签的属性值type=”text”的元素 div:first-child、div:first-of-type、div :first-child和div :first-of-type的作用和区别 （注意空格的作用）div:first-child：匹配div元素父元素中的第一个div元素div :first-child：匹配div元素下的第一个子元素div:first-of-type：匹配div元素父元素下的同种类型(这里是div元素)的第一个元素div :first-of-type：匹配div元素下同种类型的第一个元素 运行如下代码，解析下输出样式的原因。12345678910111213&lt;style&gt;.item1:first-child&#123; color: red;&#125;.item1:first-of-type&#123; background: blue;&#125;&lt;/style&gt; &lt;div class="ct"&gt; &lt;p class="item1"&gt;aa&lt;/p&gt; &lt;h3 class="item1"&gt;bb&lt;/h3&gt; &lt;h3 class="item1"&gt;ccc&lt;/h3&gt; &lt;/div&gt; 原因： 123.item1:first-child&#123; color: red;&#125; 定义选择了class名为item1的父元素的第一个子元素，即div下的第一个元素p的文字颜色显示为红色 123.item1:first-of-type&#123; background: blue;&#125; 定义选择了class名为item1的父元素下的同种类型（p与h3）的第一个元素，即div下的p标签和第一个h3标签 （包括其嵌套的元素）的背景颜色显示为蓝色]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>选择器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浮动]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2F%E6%B5%AE%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[浮动基本概念浮动模型也是一种可视化格式模型，浮动的框可以左右移动（根据float属性值而定），直到它的外边缘碰到包含框或者另一个浮动元素的框的边缘。浮动元素不在文档的普通流中，文档的普通流中的元素表现的就像浮动元素不存在一样. 普通流：（normal flow)，或者称之为常规流。 浮动：浮动的框可以左右移动，直至它的外边缘遇到包含框或者另一个浮动框的边缘。浮动框不属于文档中的普通流，当一个元素浮动之后，不会影响到块级框的布局而只会影响内联框（通常是文本）的排列，文档中的普通流就会表现得和浮动框不存在一样，当浮动框高度超出包含框的时候，也就会出现包含框不会自动伸高来闭合浮动元素（“高度塌陷”现象）。顾名思义，就是漂浮于普通流之上，像浮云一样，但是只能左右浮动。 而 float 元素脱离了 normal flow 就相当于进入了一个平行空间，不再与其后边及父级块级元素发生反应，这一特性使得 float 元素无法撑起父元素的高度， 导致父元素塌陷。 其他的文本和行内元素环绕 float元素，但是 float 后的块级元素会与其发生重叠。 解决问题因为浮动元素的父元素有高度塌陷的问题。 (顺便可以解决浮动元素与普通流中的块级元素有重叠的问题)两种方案 采用clear属性清除浮动.通过在浮动元素的末尾添加一个空元素，设置 clear：both属性，after伪元素其实也是通过 content 在元素的后面生成了内容为一个块级元素. 让浮动元素的父元素形成BFC，可以包含浮动 实施采用clear属性： 浮动的父元素设置 :after伪元素，clear:both/left/right;，content=&quot;&quot;;， display:block/table;。a. 至于content里面是点还是其他都是可以的,里面内容为空firefox直到7.0 content:”” 仍然会产生额外的空隙(待亲自实验)。b. display:block 使生成的元素以块级元素显示,占满剩余空间。c. content 为点的话可以加 height:0 避免生成内容破坏原有布局的高度； visibility:hidden 使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互。 在浮动元素末尾加一个空div，并设置clear属性。 让浮动元素的父元素形成BFC： float: left / right(除none以外值) display: table-cell / table-caption / inline-block/flex/inline-flex overflow: hidden / auto / scroll (除visible以外) position: absolute / fixedBFC的几种方式都有各自的问题，上面提到使用BFC使用float的时候会使父容器长度缩短，而且还有个重要缺陷——父容器float解决了其塌陷问题，那么父容器的父容器怎么办？overflow属性会影响滚动条和绝对定位的元素；position会改变元素的定位方式，这是我们不希望的，display这几种方式依然没有解决低版本IE问题。 BFCBFC的全称是 Block Format Content 块级格式化上下文三个特性： BFC会阻止垂直外边距（margin-top、margin-bottom）重叠a. 按照BFC的定义，只有同属于一个BFC时，两个元素才有可能发生垂直margin的重叠，这个包括相邻元素，嵌套元素，只要他们之间没有阻挡(例如边框，非空内容，padding等)就会发生margin重叠。b. 因此要解决margin重叠问题，只要让它们不在同一个BFC就行了，但是对于两个相邻元素来说，意义不大，没有必要给它们加个外壳，但是对于嵌套元素来说就很有必要了，只要把父元素设为BFC就可以了。这样子元素的margin就不会和父元素的margin发生重叠 BFC不会重叠浮动元素 BFC可以包含浮动 通俗地来说：创建了 BFC的元素就是一个独立的盒子，里面的子元素不会在布局上影响外面的元素，反之亦然，同时BFC任然属于文档中的普通流。 我们可以利用BFC的第三条特性来“清浮动”，这里其实说清浮动已经不再合适，应该说包含浮动。也就是说只要父容器形成BFC就可以。 局限性上面提到使用BFC使用float的时候会使父容器长度缩短，而且还有个重要缺陷——父容器float解决了其塌陷问题，那么父容器的父容器怎么办？难道要全部使用folat吗（确实有这种布局方式倒是）。BFC的几种方式都有各自的问题，overflow属性会影响滚动条和绝对定位的元素；position会改变元素的定位方式，这是我们不希望的，display这几种方式依然没有解决低版本IE问题。。。 hasLayout我们知道在IE6、7内有个布局Layout的概念，很多bug正是由hasLayout导致的 当元素的hasLayout属性值为false的时候，元素的尺寸和位置由最近拥有布局的祖先元素控制当元素的hasLayout属性值为true的时候会达到和BFC类似的效果，元素负责本身及其子元素的尺寸设置和定位利用这点儿在IE6、7下完成清浮动，先看看怎么使元素hasLayout为true position: absolutefloat: left|rightdisplay: inline-blockwidth: 除 “auto” 外的任意值height: 除 “auto” 外的任意值zoom: 除 “normal” 外的任意值writing-mode: tb-rl在IE7中使用overflow: hidden|scroll|auto 也可以使hasLayout为true 综上所述： 在支持BFC的浏览器（IE8+，firefox，chrome，safari）可以通过创建新的BFC闭合浮动；在不支持 BFC的浏览器 （IE6-7），可以通过触发 hasLayout 闭合浮动。 通用的清理浮动方案一、 12345678910.clearfix:after &#123; content:"."; display:block; height:0; visibility:hidden; clear:both; &#125;.clearfix &#123; *zoom:1; &#125; display:block 使生成的元素以块级元素显示,占满剩余空间; height:0 避免生成内容破坏原有布局的高度。 visibility:hidden 使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互; 通过 content:”.”生成内容作为最后一个元素，至于content里面是点还是其他都是可以的，例如oocss里面就有经典的 content:”XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX”,有些版本可能content 里面内容为空,一丝冰凉不推荐这样做的,firefox直到7.0 content:”” 仍然会产生额外的空隙；(待验证，目前好像都是采用空的比较多) zoom：1 触发IE hasLayout。 二、 1234567891011// 全浏览器通用的clearfix方案// 引入了zoom以支持IE6/7.clearfix&#123; *zoom:1;&#125;.clearfix:after&#123; content:" "; display:table; clear:both;&#125; 如果我们想要与BFC行为保持一致，或者解决上边距折叠问题 三、精益求精方案：由Nicolas Gallagher 提出来的,原文:A new micro clearfix hackNicolas Gallagher，该方法也不存在firefox中空隙的问题。 1234567891011121314/* For modern browsers */// 全浏览器通用的clearfix方案【推荐】// 引入了zoom以支持IE6/7// 同时加入:before以解决现代浏览器上边距折叠的问题.cf:before,.cf:after &#123;content:" ";display:table;&#125;.cf:after &#123; clear:both; &#125;/* For IE 6/7 (trigger hasLayout) */.cf &#123; zoom:1; &#125; 需要注意的是：上面的方法用到了 ：before伪元素，是用来处理margin边距重叠的，由于内部元素 float 创建了BFC，导致内部元素的margin-top和 上一个盒子的margin-bottom 发生叠加。如果这不是你所希望的，那么就可以加上before，如果只是单纯的闭合浮动，after就够了 除了以上方案外，还有一些其他的方案，比如将父元素的 display 样式属性改为display:table或者position:fixed，但是这些方案容易带来更大的副作用，得不偿失，所以实践中一般都会使用clear属性/修改父元素的overflow属性]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFC]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2FBFC%2F</url>
    <content type="text"><![CDATA[BFC 已经是一个耳听熟闻的词语了，网上有许多关于 BFC 的文章，介绍了如何触发 BFC 以及 BFC 的一些用处（如清除浮动，防止 margin 重叠等）。 一、BFC是什么？ 在解释 BFC 是什么之前，需要先介绍 Box、Formatting Context的概念。 Box: CSS布局的基本单位Box 是 CSS 布局的对象和基本单位， 直观点来说，就是一个页面是由很多个 Box 组成的。元素的类型和 display 属性，决定了这个 Box 的类型。 不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染。让我们看看有哪些盒子： block-level box: display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context； inline-level box: display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context； run-in box: css3 中才有， 这儿先不讲了。 Formatting context Formatting context 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)。 CSS2.1 中只有 BFC 和 IFC, CSS3 中还增加了 GFC 和 FFC。 BFC 定义 BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。 BFC布局规则： 内部的Box会在垂直方向，一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算 二、哪些元素会生成BFC? 根元素 float属性不为none position为absolute或fixed display为inline-block, table-cell, table-caption, flex, inline-flex overflow不为visible 三、BFC的作用及原理1. 自适应两栏布局代码： 12345678910111213141516171819202122&lt;style&gt; body &#123; width: 300px; position: relative; &#125; .aside &#123; width: 100px; height: 150px; float: left; background: #f66; &#125; .main &#123; height: 200px; background: #fcc; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="aside"&gt;&lt;/div&gt; &lt;div class="main"&gt;&lt;/div&gt;&lt;/body&gt; 根据BFC布局规则第3条： 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 因此，虽然存在浮动的元素aside，但main的左边依然会与包含块的左边相接触。 根据BFC布局规则第四条： BFC的区域不会与float box重叠。 我们可以通过触发main生成BFC， 来实现自适应两栏布局。 123.main &#123; overflow: hidden;&#125; 当触发main生成BFC后，这个新的BFC为了不与浮动的aside重叠。因此会根据包含块的宽度，和aside的宽度，自动变窄。效果如下：： 2. 清除内部浮动代码： 12345678910111213141516171819 &lt;style&gt; .par &#123; border: 5px solid #fcc; width: 300px; &#125; .child &#123; border: 5px solid #f66; width:100px; height: 100px; float: left; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="par"&gt; &lt;div class="child"&gt;&lt;/div&gt; &lt;div class="child"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 根据BFC布局规则第六条： 计算BFC的高度时，浮动元素也参与计算 解决方案一般有两种1). 利用 clear属性，清除浮动 123对父元素加一个class:floatfix添加如下CSS 12345678.floatfix&#123; *zoom:1;&#125;.floatfix:after&#123; content:""; display:table; clear:both;&#125; 2). 使父容器形成BFC 为达到清除内部浮动，我们可以触发par生成BFC，那么par在计算高度时，par内部的浮动元素child也会参与计算。 代码： 123 .par &#123; overflow: hidden;&#125; 效果如下： 3. 防止垂直 margin 重叠代码： 1234567891011121314 &lt;style&gt; p &#123; color: #f55; background: #fcc; width: 200px; line-height: 100px; text-align:center; margin: 100px; &#125;&lt;/style&gt;&lt;body&gt; &lt;p&gt;Haha&lt;/p&gt; &lt;p&gt;Hehe&lt;/p&gt;&lt;/body&gt; 页面： 两个p之间的距离为100px，发送了margin重叠。 根据BFC布局规则第二条： Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 折叠的结果： 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。 两个外边距一正一负时，折叠结果是两者的相加的和。 我们可以在p外面包裹一层容器，并触发该容器生成一个BFC。那么两个P便不属于同一个BFC，就不会发生margin重叠了。 代码： 12345678910111213141516171819&lt;style&gt; .wrap &#123; overflow: hidden; &#125; p &#123; color: #f55; background: #fcc; width: 200px; line-height: 100px; text-align:center; margin: 100px; &#125;&lt;/style&gt;&lt;body&gt; &lt;p&gt;Haha&lt;/p&gt; &lt;div class="wrap"&gt; &lt;p&gt;Hehe&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 效果如下: 浮动和绝对定位不与任何元素产生 margin 折叠原因： 浮动元素和绝对定位元素不与其他盒子产生外边距折叠是因为元素会脱离当前的文档流，违反了上面所述的两个margin是邻接的条件同时，又因为浮动和绝对定位会使元素为它的内容创建新的BFC，因此该元素和子元素所处的BFC是不相同的，因此也不会产生margin的折叠。 自己经验添加父子元素margin合并可以给父元素添加border或者padding解决 高级解决父子元素margin合并问题: 1.no-collapse::before&#123;content:'';display:table;&#125;,.no-collapse::after&#123;content:'';display:table;&#125; 总结 其实以上的几个例子都体现了BFC布局规则第五条： BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 因为BFC内部的元素和外部的元素绝对不会互相影响，因此， 当BFC外部存在浮动时，它不应该影响BFC内部Box的布局，BFC会通过变窄，而不与浮动有重叠。同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见布局居中]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2F%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E5%8A%A0-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[文本溢出加 … 如何实现单行12345span&#123;overflow:hidden;text-overflow:ellipsis;white-space:nowarp;&#125; 多行1234567span&#123;width:100px,display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:3; //行数overflow:hidden;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>布局</tag>
        <tag>FONT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见布局居中]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2F%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[两栏布局左侧固定宽度右边自适应负margin方法：1234567891011121314151617181920&lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt;.left&#123; width:200px; height:300px; margin-right:10px; background:red; float:left;&#125;.right&#123; width:100%; height:400px; float:right; margin-right:-210px; background:blue;&#125;&lt;/style&gt; overflow方法:123456789101112131415161718&lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt;.left&#123; width:200px; height:300px; margin-right:10px; background:red; float:left;&#125;.right&#123; height:400px; background:blue; overflow:hidden;&#125;&lt;/style&gt; position方法:12345678910111213141516171819202122232425&lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt;.container&#123; position:relative;&#125;.left&#123; position:absolute; top:0; left:0; width:200px; height:300px; background:red;&#125;.right&#123; position:absolute; top:0; left:210px; right:0; height:400px; background:blue;&#125;&lt;/style&gt; flex方法:1234567891011121314151617181920&lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt;.container&#123; display:flex;&#125;.left&#123; width:200px; height:300px; background:red; margin-right:10px;&#125;.right&#123; flex:1; height:400px; background:blue;&#125;&lt;/style&gt; 三栏布局margin方法1234567891011121314151617181920212223242526&lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;div class="center"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt;.left&#123; width:200px; height:300px; background:red; margin:0 10px; float:left;&#125;.center&#123; height:400px; background:pink; overflow:auto;&#125;.right&#123; width:200px; height:300px; background:blue; float:right; margin:0 10px;&#125;&lt;/style&gt; overflow方法1234567891011121314151617181920212223242526&lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;div class="center"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt;.left&#123; width:200px; height:300px; background:red; margin:0 10px; float:left;&#125;.center&#123; height:400px; background:pink; overflow:auto;&#125;.right&#123; width:200px; height:300px; background:blue; float:right; margin:0 10px;&#125;&lt;/style&gt; position方法12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt;&lt;style&gt;*&#123; box-sizing:border-box; margin:0; padding:0;&#125;.container&#123; position:relative;&#125;.left&#123; width:200px; height:300px; background:red; margin:0 10px; position:absolute; top:0; left:0;&#125;.center&#123; width:calc(100% - 440px); height:400px; background:pink; position:absolute; top:0; left:50%; transform:translateX(-50%);&#125;.right&#123; width:200px; height:300px; background:blue; position:absolute; top:0; right:0; margin:0 10px;&#125;&lt;/style&gt; flex方法123456789101112131415161718192021222324252627282930313233&lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt;*&#123; box-sizing:border-box; padding:0; margin:0;&#125;.container&#123; display:flex;&#125;.left&#123; width:200px; height:300px; background:red; margin:0 10px; &#125;.center&#123; height:400px; background:pink; flex:1;&#125;.right&#123; width:200px; height:300px; background:blue; margin:0 10px;&#125;&lt;/style&gt; 块级元素居中margin方法123456789.container&#123; background:grey;&#125;.item&#123; width:300px; height:200px; background:red; margin:0 auto;&#125; position方法12345678910111213.container&#123; background:grey; position:relative;&#125;.item&#123; width:300px; height:200px; background:red; position:absolute; top:0; left:50%; transform:translateX(-50%)&#125; display:flex12345678910.container&#123; background:grey; display:flex; justify-content:center;&#125;.item&#123; width:300px; height:200px; background:red;&#125; text-align:center 12345678910.container&#123; background:grey; text-align:center;&#125;.item&#123; width:300px; height:200px; background:red; display:inline-block;&#125; 多行文字水平垂直居中123456789101112131415161718192021&lt;section&gt; &lt;div class="container"&gt; &lt;h1 class="title"&gt;这是标题&lt;/h1&gt; &lt;p class="content"&gt;这是一大段文字内容这是一大段文字内容这是一大段文字内容这是一大段文字内容这是一大段文字内容这是一大段文字内容&lt;/p&gt; &lt;/div&gt;&lt;/section&gt;&lt;style&gt;section&#123; margin:0 auto; width:600px;&#125;.container&#123; padding:0 100px; width:600px; height:600px; background:grey; text-align:center; display:table-cell; vertical-align:middle;&#125;&lt;/style&gt; image水平垂直居中123456789101112131415161718 &lt;div class="container"&gt; &lt;img src="" alt="图片"&gt; &lt;/div&gt;.container&#123; width:300px; height:300px; border:1px solid red; text-align:center;&#125;.container::after&#123; content:''; height:100%; display:inline-block; vertical-align:middle;&#125;img&#123; vertical-align:middle;&#125; 浏览器固定水平垂直居中12345678.box&#123; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:#ccc; text-align:center;&#125; 水平居中SVG和font/img1234567svg&#123;vertical-align:middle&#125;span&#123;vertical-align:middle&#125;img&#123; vertical-align:middle&#125; 经典文章:https://www.zhangxinxu.com/wordpress/2015/08/css-deep-understand-vertical-align-and-line-height/]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex布局]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2Fflex%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[常见布局 normal flow（正常流） float + clear（浮动+清楚浮动） position relative + absolute （相对定位+绝对定位） display inline-block （改变元素属性） -margin（负外边距） Flex布局特性 块级布局侧重垂直方向、行内布局侧重水平方向，flex布局是与方向无关的 flex布局可以实现空间自动分配、自动对齐（全称:the flexible box Module） flex适用于简单的线性布局，更复杂的布局要交给grid布局（目前还没发布） ​ 语法 display: flex; display: inline-flex; 设为Flex布局后，子元素的loat,clear和vertical-align属性将失效。 Flex基础概念采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。 上图水平是主轴(main axis)垂直是侧轴(cross axis)。主轴的开始位置叫做main start，结束位置叫做main end；侧轴的开始位置叫做cross start，结束位置叫做cross end 。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的侧轴空间叫做cross size。 Flex container容器属性flex-direction: 决定了主轴的方向（即项目的排列方向)1234.box&#123; display:flex; flex-direction:column-revers|column|row-reverse|row; &#125; 属性名 说明 row(默认) 主轴方向为水平，起点在左端 row- reverse 主轴方向为水平，起点在右端 column 主轴方向为垂直，起点在上端 column-reverse 主轴方向为垂直，起点在下端 单独添加flex-direction: row; //默认是不会换行 flex-wrap: 定义如果一条轴线排不下，如何换行12345.box&#123; display:flex; flex-direction:now flex-wrap:wrap; &#125; 属性名 说明 nowrap(默认) 不换行 wrap 换行 wrap-reverse 换行反转 flex-flow（以上两个属性的简写） flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 1234.box&#123; display:flex; flex-flow: row nowrap; &#125; justify-content:定义了项目在主轴上的对齐方式1234.box&#123; display:flex; justify-content:flex-start | flex-end | center | space-between | space-around;&#125; 属性名 说明 flex-start(默认) 项目沿着主轴方向的起始位置靠齐 flex-end 项目沿着主轴方向的结束位置靠齐，和flex-start相反 space-between 项目在主轴方向上两端对齐，其中的间隔相等 space-around 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍 align-items定义项目在交叉轴上如何对齐1234.box&#123; display:flex; align-items:flex-start | flex-end | center | baseline | stretch;&#125; 属性名 说明 flex-start 项目沿着侧轴上的起点对齐 flex-end 项目沿着侧轴上的终点对齐 center 项目在侧轴方向上居中对齐 stretch(默认) 如果项目未设置高度或高度为auto,将占满整个容器的高度。 align-content多行多列内容对齐方式注意如果项目只有一行，属性不起作用 1234.box&#123; display:flex; align-content:flex-start | flex-end | center | space-between | space-around | stretch;&#125; 属性名 说明 flex-start 项目与侧轴的起点对齐 flex-end 项目与侧轴的终点对齐 center 项目与侧轴的中点对齐 space-between 与侧轴两端对齐，轴线之间的间隔平均分布 space-around 每行轴线两侧的间隔都相等。所以轴线之间的间隔比轴线与边框的间隔大一倍 stretch（默认） 轴线占满整个测轴 flex item项目属性 order属性：定义项目的排列顺序。数值越小，排列越靠前，默认为0 .item{order: &lt;integer&gt;;} flex-grow属性:定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大 .item{flex-grow:&lt;number&gt;;} flex-grow为零的话则不变化，不能为負值。如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项的2倍。 flex-shrink属性：定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小 .item{flex-shrink:&lt;number&gt;;} 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。 flex-basis属性:定义了在分配多余空间之前，项目占据的主轴空间（main size） 浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。它可以设为跟width或height属性一样的值，则项目将占据固定空间 .item{flex-basis: &lt;length&gt;| auto; flex属性：flex-grow,flex-shrink和flex-basis的简写 默认值为0 1 auto。后两个属性可选。该属性有两个快捷值：auto(1 1 auto) 和 none (0 0 auto)。 align-self属性：允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性 默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 .item{align-self:auto | flex-start | flex-end | center | baseline | stretch;} 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 最近发现一篇很详细关于flex box 布局的博客链接阮一峰flex实战布局教程]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2FZombieBrand.github.io%2F2019%2F03%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
